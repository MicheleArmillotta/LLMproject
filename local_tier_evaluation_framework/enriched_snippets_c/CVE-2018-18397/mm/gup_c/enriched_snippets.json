[
  {
    "function_name": "get_user_pages_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1857-1900",
    "snippet": "int get_user_pages_fast(unsigned long start, int nr_pages, int write,\n\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr = 0, ret = 0;\n\n\tstart &= PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (nr_pages <= 0)\n\t\treturn 0;\n\n\tif (unlikely(!access_ok(write ? VERIFY_WRITE : VERIFY_READ,\n\t\t\t\t\t(void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\tif (gup_fast_permitted(start, nr_pages, write)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, write, pages, &nr);\n\t\tlocal_irq_enable();\n\t\tret = nr;\n\t}\n\n\tif (nr < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr << PAGE_SHIFT;\n\t\tpages += nr;\n\n\t\tret = get_user_pages_unlocked(start, nr_pages - nr, pages,\n\t\t\t\twrite ? FOLL_WRITE : 0);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr;\n\t\t\telse\n\t\t\t\tret += nr;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user_pages_unlocked",
          "args": [
            "start",
            "nr_pages - nr",
            "pages",
            "write ? FOLL_WRITE : 0"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_pages_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1029-1042",
          "snippet": "long get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,\n\t\t\t     struct page **pages, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint locked = 1;\n\tlong ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = __get_user_pages_locked(current, mm, start, nr_pages, pages, NULL,\n\t\t\t\t      &locked, gup_flags | FOLL_TOUCH);\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,\n\t\t\t     struct page **pages, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint locked = 1;\n\tlong ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = __get_user_pages_locked(current, mm, start, nr_pages, pages, NULL,\n\t\t\t\t      &locked, gup_flags | FOLL_TOUCH);\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gup_pgd_range",
          "args": [
            "addr",
            "end",
            "write",
            "pages",
            "&nr"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "gup_pgd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1758-1782",
          "snippet": "static void gup_pgd_range(unsigned long addr, unsigned long end,\n\t\tint write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpgd_t *pgdp;\n\n\tpgdp = pgd_offset(current->mm, addr);\n\tdo {\n\t\tpgd_t pgd = READ_ONCE(*pgdp);\n\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none(pgd))\n\t\t\treturn;\n\t\tif (unlikely(pgd_huge(pgd))) {\n\t\t\tif (!gup_huge_pgd(pgd, pgdp, addr, next, write,\n\t\t\t\t\t  pages, nr))\n\t\t\t\treturn;\n\t\t} else if (unlikely(is_hugepd(__hugepd(pgd_val(pgd))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(pgd_val(pgd)), addr,\n\t\t\t\t\t PGDIR_SHIFT, next, write, pages, nr))\n\t\t\t\treturn;\n\t\t} else if (!gup_p4d_range(pgd, addr, next, write, pages, nr))\n\t\t\treturn;\n\t} while (pgdp++, addr = next, addr != end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void gup_pgd_range(unsigned long addr, unsigned long end,\n\t\tint write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpgd_t *pgdp;\n\n\tpgdp = pgd_offset(current->mm, addr);\n\tdo {\n\t\tpgd_t pgd = READ_ONCE(*pgdp);\n\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none(pgd))\n\t\t\treturn;\n\t\tif (unlikely(pgd_huge(pgd))) {\n\t\t\tif (!gup_huge_pgd(pgd, pgdp, addr, next, write,\n\t\t\t\t\t  pages, nr))\n\t\t\t\treturn;\n\t\t} else if (unlikely(is_hugepd(__hugepd(pgd_val(pgd))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(pgd_val(pgd)), addr,\n\t\t\t\t\t PGDIR_SHIFT, next, write, pages, nr))\n\t\t\t\treturn;\n\t\t} else if (!gup_p4d_range(pgd, addr, next, write, pages, nr))\n\t\t\treturn;\n\t} while (pgdp++, addr = next, addr != end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gup_fast_permitted",
          "args": [
            "start",
            "nr_pages",
            "write"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "gup_fast_permitted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1789-1796",
          "snippet": "bool gup_fast_permitted(unsigned long start, int nr_pages, int write)\n{\n\tunsigned long len, end;\n\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\treturn end >= start;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nbool gup_fast_permitted(unsigned long start, int nr_pages, int write)\n{\n\tunsigned long len, end;\n\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\treturn end >= start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(write ? VERIFY_WRITE : VERIFY_READ,\n\t\t\t\t\t(void __user *)start, len)"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "write ? VERIFY_WRITE : VERIFY_READ",
            "(void __user *)start",
            "len"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint get_user_pages_fast(unsigned long start, int nr_pages, int write,\n\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr = 0, ret = 0;\n\n\tstart &= PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (nr_pages <= 0)\n\t\treturn 0;\n\n\tif (unlikely(!access_ok(write ? VERIFY_WRITE : VERIFY_READ,\n\t\t\t\t\t(void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\tif (gup_fast_permitted(start, nr_pages, write)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, write, pages, &nr);\n\t\tlocal_irq_enable();\n\t\tret = nr;\n\t}\n\n\tif (nr < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr << PAGE_SHIFT;\n\t\tpages += nr;\n\n\t\tret = get_user_pages_unlocked(start, nr_pages - nr, pages,\n\t\t\t\twrite ? FOLL_WRITE : 0);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr;\n\t\t\telse\n\t\t\t\tret += nr;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__get_user_pages_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1805-1839",
    "snippet": "int __get_user_pages_fast(unsigned long start, int nr_pages, int write,\n\t\t\t  struct page **pages)\n{\n\tunsigned long len, end;\n\tunsigned long flags;\n\tint nr = 0;\n\n\tstart &= PAGE_MASK;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (unlikely(!access_ok(write ? VERIFY_WRITE : VERIFY_READ,\n\t\t\t\t\t(void __user *)start, len)))\n\t\treturn 0;\n\n\t/*\n\t * Disable interrupts.  We use the nested form as we can already have\n\t * interrupts disabled by get_futex_key.\n\t *\n\t * With interrupts disabled, we block page table pages from being\n\t * freed from under us. See struct mmu_table_batch comments in\n\t * include/asm-generic/tlb.h for more details.\n\t *\n\t * We do not adopt an rcu_read_lock(.) here as we also want to\n\t * block IPIs that come from THPs splitting.\n\t */\n\n\tif (gup_fast_permitted(start, nr_pages, write)) {\n\t\tlocal_irq_save(flags);\n\t\tgup_pgd_range(start, end, write, pages, &nr);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\treturn nr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gup_pgd_range",
          "args": [
            "start",
            "end",
            "write",
            "pages",
            "&nr"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "gup_pgd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1758-1782",
          "snippet": "static void gup_pgd_range(unsigned long addr, unsigned long end,\n\t\tint write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpgd_t *pgdp;\n\n\tpgdp = pgd_offset(current->mm, addr);\n\tdo {\n\t\tpgd_t pgd = READ_ONCE(*pgdp);\n\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none(pgd))\n\t\t\treturn;\n\t\tif (unlikely(pgd_huge(pgd))) {\n\t\t\tif (!gup_huge_pgd(pgd, pgdp, addr, next, write,\n\t\t\t\t\t  pages, nr))\n\t\t\t\treturn;\n\t\t} else if (unlikely(is_hugepd(__hugepd(pgd_val(pgd))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(pgd_val(pgd)), addr,\n\t\t\t\t\t PGDIR_SHIFT, next, write, pages, nr))\n\t\t\t\treturn;\n\t\t} else if (!gup_p4d_range(pgd, addr, next, write, pages, nr))\n\t\t\treturn;\n\t} while (pgdp++, addr = next, addr != end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void gup_pgd_range(unsigned long addr, unsigned long end,\n\t\tint write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpgd_t *pgdp;\n\n\tpgdp = pgd_offset(current->mm, addr);\n\tdo {\n\t\tpgd_t pgd = READ_ONCE(*pgdp);\n\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none(pgd))\n\t\t\treturn;\n\t\tif (unlikely(pgd_huge(pgd))) {\n\t\t\tif (!gup_huge_pgd(pgd, pgdp, addr, next, write,\n\t\t\t\t\t  pages, nr))\n\t\t\t\treturn;\n\t\t} else if (unlikely(is_hugepd(__hugepd(pgd_val(pgd))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(pgd_val(pgd)), addr,\n\t\t\t\t\t PGDIR_SHIFT, next, write, pages, nr))\n\t\t\t\treturn;\n\t\t} else if (!gup_p4d_range(pgd, addr, next, write, pages, nr))\n\t\t\treturn;\n\t} while (pgdp++, addr = next, addr != end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gup_fast_permitted",
          "args": [
            "start",
            "nr_pages",
            "write"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "gup_fast_permitted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1789-1796",
          "snippet": "bool gup_fast_permitted(unsigned long start, int nr_pages, int write)\n{\n\tunsigned long len, end;\n\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\treturn end >= start;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nbool gup_fast_permitted(unsigned long start, int nr_pages, int write)\n{\n\tunsigned long len, end;\n\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\treturn end >= start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(write ? VERIFY_WRITE : VERIFY_READ,\n\t\t\t\t\t(void __user *)start, len)"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "write ? VERIFY_WRITE : VERIFY_READ",
            "(void __user *)start",
            "len"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint __get_user_pages_fast(unsigned long start, int nr_pages, int write,\n\t\t\t  struct page **pages)\n{\n\tunsigned long len, end;\n\tunsigned long flags;\n\tint nr = 0;\n\n\tstart &= PAGE_MASK;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (unlikely(!access_ok(write ? VERIFY_WRITE : VERIFY_READ,\n\t\t\t\t\t(void __user *)start, len)))\n\t\treturn 0;\n\n\t/*\n\t * Disable interrupts.  We use the nested form as we can already have\n\t * interrupts disabled by get_futex_key.\n\t *\n\t * With interrupts disabled, we block page table pages from being\n\t * freed from under us. See struct mmu_table_batch comments in\n\t * include/asm-generic/tlb.h for more details.\n\t *\n\t * We do not adopt an rcu_read_lock(.) here as we also want to\n\t * block IPIs that come from THPs splitting.\n\t */\n\n\tif (gup_fast_permitted(start, nr_pages, write)) {\n\t\tlocal_irq_save(flags);\n\t\tgup_pgd_range(start, end, write, pages, &nr);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\treturn nr;\n}"
  },
  {
    "function_name": "gup_fast_permitted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1789-1796",
    "snippet": "bool gup_fast_permitted(unsigned long start, int nr_pages, int write)\n{\n\tunsigned long len, end;\n\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\treturn end >= start;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nbool gup_fast_permitted(unsigned long start, int nr_pages, int write)\n{\n\tunsigned long len, end;\n\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\treturn end >= start;\n}"
  },
  {
    "function_name": "gup_pgd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1758-1782",
    "snippet": "static void gup_pgd_range(unsigned long addr, unsigned long end,\n\t\tint write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpgd_t *pgdp;\n\n\tpgdp = pgd_offset(current->mm, addr);\n\tdo {\n\t\tpgd_t pgd = READ_ONCE(*pgdp);\n\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none(pgd))\n\t\t\treturn;\n\t\tif (unlikely(pgd_huge(pgd))) {\n\t\t\tif (!gup_huge_pgd(pgd, pgdp, addr, next, write,\n\t\t\t\t\t  pages, nr))\n\t\t\t\treturn;\n\t\t} else if (unlikely(is_hugepd(__hugepd(pgd_val(pgd))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(pgd_val(pgd)), addr,\n\t\t\t\t\t PGDIR_SHIFT, next, write, pages, nr))\n\t\t\t\treturn;\n\t\t} else if (!gup_p4d_range(pgd, addr, next, write, pages, nr))\n\t\t\treturn;\n\t} while (pgdp++, addr = next, addr != end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gup_p4d_range",
          "args": [
            "pgd",
            "addr",
            "next",
            "write",
            "pages",
            "nr"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "gup_p4d_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1733-1756",
          "snippet": "static int gup_p4d_range(pgd_t pgd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tp4d_t *p4dp;\n\n\tp4dp = p4d_offset(&pgd, addr);\n\tdo {\n\t\tp4d_t p4d = READ_ONCE(*p4dp);\n\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none(p4d))\n\t\t\treturn 0;\n\t\tBUILD_BUG_ON(p4d_huge(p4d));\n\t\tif (unlikely(is_hugepd(__hugepd(p4d_val(p4d))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(p4d_val(p4d)), addr,\n\t\t\t\t\t P4D_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pud_range(p4d, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (p4dp++, addr = next, addr != end);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_p4d_range(pgd_t pgd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tp4d_t *p4dp;\n\n\tp4dp = p4d_offset(&pgd, addr);\n\tdo {\n\t\tp4d_t p4d = READ_ONCE(*p4dp);\n\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none(p4d))\n\t\t\treturn 0;\n\t\tBUILD_BUG_ON(p4d_huge(p4d));\n\t\tif (unlikely(is_hugepd(__hugepd(p4d_val(p4d))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(p4d_val(p4d)), addr,\n\t\t\t\t\t P4D_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pud_range(p4d, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (p4dp++, addr = next, addr != end);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gup_huge_pd",
          "args": [
            "__hugepd(pgd_val(pgd))",
            "addr",
            "PGDIR_SHIFT",
            "next",
            "write",
            "pages",
            "nr"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pgd_val(pgd)"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_val",
          "args": [
            "pgd"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_hugepd(__hugepd(pgd_val(pgd)))"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugepd",
          "args": [
            "__hugepd(pgd_val(pgd))"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pgd_val(pgd)"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_val",
          "args": [
            "pgd"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gup_huge_pgd",
          "args": [
            "pgd",
            "pgdp",
            "addr",
            "next",
            "write",
            "pages",
            "nr"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "gup_huge_pgd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1626-1661",
          "snippet": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pgd_huge(pgd)"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_huge",
          "args": [
            "pgd"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_none",
          "args": [
            "pgd"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*pgdp"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "current->mm",
            "addr"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void gup_pgd_range(unsigned long addr, unsigned long end,\n\t\tint write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpgd_t *pgdp;\n\n\tpgdp = pgd_offset(current->mm, addr);\n\tdo {\n\t\tpgd_t pgd = READ_ONCE(*pgdp);\n\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none(pgd))\n\t\t\treturn;\n\t\tif (unlikely(pgd_huge(pgd))) {\n\t\t\tif (!gup_huge_pgd(pgd, pgdp, addr, next, write,\n\t\t\t\t\t  pages, nr))\n\t\t\t\treturn;\n\t\t} else if (unlikely(is_hugepd(__hugepd(pgd_val(pgd))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(pgd_val(pgd)), addr,\n\t\t\t\t\t PGDIR_SHIFT, next, write, pages, nr))\n\t\t\t\treturn;\n\t\t} else if (!gup_p4d_range(pgd, addr, next, write, pages, nr))\n\t\t\treturn;\n\t} while (pgdp++, addr = next, addr != end);\n}"
  },
  {
    "function_name": "gup_p4d_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1733-1756",
    "snippet": "static int gup_p4d_range(pgd_t pgd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tp4d_t *p4dp;\n\n\tp4dp = p4d_offset(&pgd, addr);\n\tdo {\n\t\tp4d_t p4d = READ_ONCE(*p4dp);\n\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none(p4d))\n\t\t\treturn 0;\n\t\tBUILD_BUG_ON(p4d_huge(p4d));\n\t\tif (unlikely(is_hugepd(__hugepd(p4d_val(p4d))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(p4d_val(p4d)), addr,\n\t\t\t\t\t P4D_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pud_range(p4d, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (p4dp++, addr = next, addr != end);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gup_pud_range",
          "args": [
            "p4d",
            "addr",
            "next",
            "write",
            "pages",
            "nr"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "gup_pud_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1705-1731",
          "snippet": "static int gup_pud_range(p4d_t p4d, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpud_t *pudp;\n\n\tpudp = pud_offset(&p4d, addr);\n\tdo {\n\t\tpud_t pud = READ_ONCE(*pudp);\n\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none(pud))\n\t\t\treturn 0;\n\t\tif (unlikely(pud_huge(pud))) {\n\t\t\tif (!gup_huge_pud(pud, pudp, addr, next, write,\n\t\t\t\t\t  pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugepd(__hugepd(pud_val(pud))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(pud_val(pud)), addr,\n\t\t\t\t\t PUD_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pmd_range(pud, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (pudp++, addr = next, addr != end);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_pud_range(p4d_t p4d, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpud_t *pudp;\n\n\tpudp = pud_offset(&p4d, addr);\n\tdo {\n\t\tpud_t pud = READ_ONCE(*pudp);\n\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none(pud))\n\t\t\treturn 0;\n\t\tif (unlikely(pud_huge(pud))) {\n\t\t\tif (!gup_huge_pud(pud, pudp, addr, next, write,\n\t\t\t\t\t  pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugepd(__hugepd(pud_val(pud))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(pud_val(pud)), addr,\n\t\t\t\t\t PUD_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pmd_range(pud, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (pudp++, addr = next, addr != end);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gup_huge_pd",
          "args": [
            "__hugepd(p4d_val(p4d))",
            "addr",
            "P4D_SHIFT",
            "next",
            "write",
            "pages",
            "nr"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "p4d_val(p4d)"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_val",
          "args": [
            "p4d"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_hugepd(__hugepd(p4d_val(p4d)))"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugepd",
          "args": [
            "__hugepd(p4d_val(p4d))"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "p4d_val(p4d)"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_val",
          "args": [
            "p4d"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "p4d_huge(p4d)"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_huge",
          "args": [
            "p4d"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_none",
          "args": [
            "p4d"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*p4dp"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "&pgd",
            "addr"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_p4d_range(pgd_t pgd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tp4d_t *p4dp;\n\n\tp4dp = p4d_offset(&pgd, addr);\n\tdo {\n\t\tp4d_t p4d = READ_ONCE(*p4dp);\n\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none(p4d))\n\t\t\treturn 0;\n\t\tBUILD_BUG_ON(p4d_huge(p4d));\n\t\tif (unlikely(is_hugepd(__hugepd(p4d_val(p4d))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(p4d_val(p4d)), addr,\n\t\t\t\t\t P4D_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pud_range(p4d, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (p4dp++, addr = next, addr != end);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "gup_pud_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1705-1731",
    "snippet": "static int gup_pud_range(p4d_t p4d, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpud_t *pudp;\n\n\tpudp = pud_offset(&p4d, addr);\n\tdo {\n\t\tpud_t pud = READ_ONCE(*pudp);\n\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none(pud))\n\t\t\treturn 0;\n\t\tif (unlikely(pud_huge(pud))) {\n\t\t\tif (!gup_huge_pud(pud, pudp, addr, next, write,\n\t\t\t\t\t  pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugepd(__hugepd(pud_val(pud))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(pud_val(pud)), addr,\n\t\t\t\t\t PUD_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pmd_range(pud, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (pudp++, addr = next, addr != end);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gup_pmd_range",
          "args": [
            "pud",
            "addr",
            "next",
            "write",
            "pages",
            "nr"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "gup_pmd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1663-1703",
          "snippet": "static int gup_pmd_range(pud_t pud, unsigned long addr, unsigned long end,\n\t\tint write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpmd_t *pmdp;\n\n\tpmdp = pmd_offset(&pud, addr);\n\tdo {\n\t\tpmd_t pmd = READ_ONCE(*pmdp);\n\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (!pmd_present(pmd))\n\t\t\treturn 0;\n\n\t\tif (unlikely(pmd_trans_huge(pmd) || pmd_huge(pmd))) {\n\t\t\t/*\n\t\t\t * NUMA hinting faults need to be handled in the GUP\n\t\t\t * slowpath for accounting purposes and so that they\n\t\t\t * can be serialised against THP migration.\n\t\t\t */\n\t\t\tif (pmd_protnone(pmd))\n\t\t\t\treturn 0;\n\n\t\t\tif (!gup_huge_pmd(pmd, pmdp, addr, next, write,\n\t\t\t\tpages, nr))\n\t\t\t\treturn 0;\n\n\t\t} else if (unlikely(is_hugepd(__hugepd(pmd_val(pmd))))) {\n\t\t\t/*\n\t\t\t * architecture have different format for hugetlbfs\n\t\t\t * pmd format and THP pmd format\n\t\t\t */\n\t\t\tif (!gup_huge_pd(__hugepd(pmd_val(pmd)), addr,\n\t\t\t\t\t PMD_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pte_range(pmd, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (pmdp++, addr = next, addr != end);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_pmd_range(pud_t pud, unsigned long addr, unsigned long end,\n\t\tint write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpmd_t *pmdp;\n\n\tpmdp = pmd_offset(&pud, addr);\n\tdo {\n\t\tpmd_t pmd = READ_ONCE(*pmdp);\n\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (!pmd_present(pmd))\n\t\t\treturn 0;\n\n\t\tif (unlikely(pmd_trans_huge(pmd) || pmd_huge(pmd))) {\n\t\t\t/*\n\t\t\t * NUMA hinting faults need to be handled in the GUP\n\t\t\t * slowpath for accounting purposes and so that they\n\t\t\t * can be serialised against THP migration.\n\t\t\t */\n\t\t\tif (pmd_protnone(pmd))\n\t\t\t\treturn 0;\n\n\t\t\tif (!gup_huge_pmd(pmd, pmdp, addr, next, write,\n\t\t\t\tpages, nr))\n\t\t\t\treturn 0;\n\n\t\t} else if (unlikely(is_hugepd(__hugepd(pmd_val(pmd))))) {\n\t\t\t/*\n\t\t\t * architecture have different format for hugetlbfs\n\t\t\t * pmd format and THP pmd format\n\t\t\t */\n\t\t\tif (!gup_huge_pd(__hugepd(pmd_val(pmd)), addr,\n\t\t\t\t\t PMD_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pte_range(pmd, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (pmdp++, addr = next, addr != end);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gup_huge_pd",
          "args": [
            "__hugepd(pud_val(pud))",
            "addr",
            "PUD_SHIFT",
            "next",
            "write",
            "pages",
            "nr"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pud_val(pud)"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_val",
          "args": [
            "pud"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_hugepd(__hugepd(pud_val(pud)))"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugepd",
          "args": [
            "__hugepd(pud_val(pud))"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pud_val(pud)"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_val",
          "args": [
            "pud"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gup_huge_pud",
          "args": [
            "pud",
            "pudp",
            "addr",
            "next",
            "write",
            "pages",
            "nr"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "gup_huge_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1588-1624",
          "snippet": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pud_huge(pud)"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_huge",
          "args": [
            "pud"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_none",
          "args": [
            "pud"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*pudp"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "&p4d",
            "addr"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_pud_range(p4d_t p4d, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpud_t *pudp;\n\n\tpudp = pud_offset(&p4d, addr);\n\tdo {\n\t\tpud_t pud = READ_ONCE(*pudp);\n\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none(pud))\n\t\t\treturn 0;\n\t\tif (unlikely(pud_huge(pud))) {\n\t\t\tif (!gup_huge_pud(pud, pudp, addr, next, write,\n\t\t\t\t\t  pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugepd(__hugepd(pud_val(pud))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(pud_val(pud)), addr,\n\t\t\t\t\t PUD_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pmd_range(pud, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (pudp++, addr = next, addr != end);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "gup_pmd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1663-1703",
    "snippet": "static int gup_pmd_range(pud_t pud, unsigned long addr, unsigned long end,\n\t\tint write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpmd_t *pmdp;\n\n\tpmdp = pmd_offset(&pud, addr);\n\tdo {\n\t\tpmd_t pmd = READ_ONCE(*pmdp);\n\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (!pmd_present(pmd))\n\t\t\treturn 0;\n\n\t\tif (unlikely(pmd_trans_huge(pmd) || pmd_huge(pmd))) {\n\t\t\t/*\n\t\t\t * NUMA hinting faults need to be handled in the GUP\n\t\t\t * slowpath for accounting purposes and so that they\n\t\t\t * can be serialised against THP migration.\n\t\t\t */\n\t\t\tif (pmd_protnone(pmd))\n\t\t\t\treturn 0;\n\n\t\t\tif (!gup_huge_pmd(pmd, pmdp, addr, next, write,\n\t\t\t\tpages, nr))\n\t\t\t\treturn 0;\n\n\t\t} else if (unlikely(is_hugepd(__hugepd(pmd_val(pmd))))) {\n\t\t\t/*\n\t\t\t * architecture have different format for hugetlbfs\n\t\t\t * pmd format and THP pmd format\n\t\t\t */\n\t\t\tif (!gup_huge_pd(__hugepd(pmd_val(pmd)), addr,\n\t\t\t\t\t PMD_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pte_range(pmd, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (pmdp++, addr = next, addr != end);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gup_pte_range",
          "args": [
            "pmd",
            "addr",
            "next",
            "write",
            "pages",
            "nr"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "gup_pte_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1467-1471",
          "snippet": "static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gup_huge_pd",
          "args": [
            "__hugepd(pmd_val(pmd))",
            "addr",
            "PMD_SHIFT",
            "next",
            "write",
            "pages",
            "nr"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pmd_val(pmd)"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_val",
          "args": [
            "pmd"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_hugepd(__hugepd(pmd_val(pmd)))"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugepd",
          "args": [
            "__hugepd(pmd_val(pmd))"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pmd_val(pmd)"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_val",
          "args": [
            "pmd"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gup_huge_pmd",
          "args": [
            "pmd",
            "pmdp",
            "addr",
            "next",
            "write",
            "pages",
            "nr"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "gup_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1550-1586",
          "snippet": "static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pmd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pmd_devmap(orig))\n\t\treturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pmd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pmd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pmd_devmap(orig))\n\t\treturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pmd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_protnone",
          "args": [
            "pmd"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pmd_trans_huge(pmd) || pmd_huge(pmd)"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_huge",
          "args": [
            "pmd"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "pmd"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "pmd"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*pmdp"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "&pud",
            "addr"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_pmd_range(pud_t pud, unsigned long addr, unsigned long end,\n\t\tint write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpmd_t *pmdp;\n\n\tpmdp = pmd_offset(&pud, addr);\n\tdo {\n\t\tpmd_t pmd = READ_ONCE(*pmdp);\n\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (!pmd_present(pmd))\n\t\t\treturn 0;\n\n\t\tif (unlikely(pmd_trans_huge(pmd) || pmd_huge(pmd))) {\n\t\t\t/*\n\t\t\t * NUMA hinting faults need to be handled in the GUP\n\t\t\t * slowpath for accounting purposes and so that they\n\t\t\t * can be serialised against THP migration.\n\t\t\t */\n\t\t\tif (pmd_protnone(pmd))\n\t\t\t\treturn 0;\n\n\t\t\tif (!gup_huge_pmd(pmd, pmdp, addr, next, write,\n\t\t\t\tpages, nr))\n\t\t\t\treturn 0;\n\n\t\t} else if (unlikely(is_hugepd(__hugepd(pmd_val(pmd))))) {\n\t\t\t/*\n\t\t\t * architecture have different format for hugetlbfs\n\t\t\t * pmd format and THP pmd format\n\t\t\t */\n\t\t\tif (!gup_huge_pd(__hugepd(pmd_val(pmd)), addr,\n\t\t\t\t\t PMD_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pte_range(pmd, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (pmdp++, addr = next, addr != end);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "gup_huge_pgd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1626-1661",
    "snippet": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageReferenced",
          "args": [
            "head"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "head"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pgd_val(orig) != pgd_val(*pgdp)"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_val",
          "args": [
            "*pgdp"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_val",
          "args": [
            "orig"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_add_speculative",
          "args": [
            "head",
            "refs"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "pgd_page(orig)"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_page",
          "args": [
            "orig"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_page",
          "args": [
            "orig"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "pgd_devmap(orig)"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_devmap",
          "args": [
            "orig"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_access_permitted",
          "args": [
            "orig",
            "write"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}"
  },
  {
    "function_name": "gup_huge_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1588-1624",
    "snippet": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageReferenced",
          "args": [
            "head"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "head"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pud_val(orig) != pud_val(*pudp)"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_val",
          "args": [
            "*pudp"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_val",
          "args": [
            "orig"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_add_speculative",
          "args": [
            "head",
            "refs"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "pud_page(orig)"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_page",
          "args": [
            "orig"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_page",
          "args": [
            "orig"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gup_device_huge_pud",
          "args": [
            "orig",
            "pudp",
            "addr",
            "end",
            "pages",
            "nr"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "__gup_device_huge_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1542-1547",
          "snippet": "static int __gup_device_huge_pud(pud_t pud, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tBUILD_BUG();\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int __gup_device_huge_pud(pud_t pud, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tBUILD_BUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_devmap",
          "args": [
            "orig"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_access_permitted",
          "args": [
            "orig",
            "write"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}"
  },
  {
    "function_name": "gup_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1550-1586",
    "snippet": "static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pmd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pmd_devmap(orig))\n\t\treturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pmd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageReferenced",
          "args": [
            "head"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "head"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pmd_val(orig) != pmd_val(*pmdp)"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_val",
          "args": [
            "*pmdp"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_val",
          "args": [
            "orig"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_add_speculative",
          "args": [
            "head",
            "refs"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "pmd_page(orig)"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "orig"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "orig"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gup_device_huge_pmd",
          "args": [
            "orig",
            "pmdp",
            "addr",
            "end",
            "pages",
            "nr"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "__gup_device_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1535-1540",
          "snippet": "static int __gup_device_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tBUILD_BUG();\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int __gup_device_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tBUILD_BUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "orig"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_access_permitted",
          "args": [
            "orig",
            "write"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pmd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pmd_devmap(orig))\n\t\treturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pmd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}"
  },
  {
    "function_name": "__gup_device_huge_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1542-1547",
    "snippet": "static int __gup_device_huge_pud(pud_t pud, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tBUILD_BUG();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG",
          "args": [],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int __gup_device_huge_pud(pud_t pud, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tBUILD_BUG();\n\treturn 0;\n}"
  },
  {
    "function_name": "__gup_device_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1535-1540",
    "snippet": "static int __gup_device_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tBUILD_BUG();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG",
          "args": [],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int __gup_device_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tBUILD_BUG();\n\treturn 0;\n}"
  },
  {
    "function_name": "__gup_device_huge_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1518-1533",
    "snippet": "static int __gup_device_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tunsigned long fault_pfn;\n\tint nr_start = *nr;\n\n\tfault_pfn = pud_pfn(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tif (!__gup_device_huge(fault_pfn, addr, end, pages, nr))\n\t\treturn 0;\n\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "undo_dev_pagemap",
          "args": [
            "nr",
            "nr_start",
            "pages"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "undo_dev_pagemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1386-1394",
          "snippet": "static void undo_dev_pagemap(int *nr, int nr_start, struct page **pages)\n{\n\twhile ((*nr) - nr_start) {\n\t\tstruct page *page = pages[--(*nr)];\n\n\t\tClearPageReferenced(page);\n\t\tput_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void undo_dev_pagemap(int *nr, int nr_start, struct page **pages)\n{\n\twhile ((*nr) - nr_start) {\n\t\tstruct page *page = pages[--(*nr)];\n\n\t\tClearPageReferenced(page);\n\t\tput_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pud_val(orig) != pud_val(*pudp)"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_val",
          "args": [
            "*pudp"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_val",
          "args": [
            "orig"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gup_device_huge",
          "args": [
            "fault_pfn",
            "addr",
            "end",
            "pages",
            "nr"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "__gup_device_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1475-1499",
          "snippet": "static int __gup_device_huge(unsigned long pfn, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tint nr_start = *nr;\n\tstruct dev_pagemap *pgmap = NULL;\n\n\tdo {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tpgmap = get_dev_pagemap(pfn, pgmap);\n\t\tif (unlikely(!pgmap)) {\n\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\treturn 0;\n\t\t}\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\tget_page(page);\n\t\t(*nr)++;\n\t\tpfn++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int __gup_device_huge(unsigned long pfn, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tint nr_start = *nr;\n\tstruct dev_pagemap *pgmap = NULL;\n\n\tdo {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tpgmap = get_dev_pagemap(pfn, pgmap);\n\t\tif (unlikely(!pgmap)) {\n\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\treturn 0;\n\t\t}\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\tget_page(page);\n\t\t(*nr)++;\n\t\tpfn++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_pfn",
          "args": [
            "orig"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int __gup_device_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tunsigned long fault_pfn;\n\tint nr_start = *nr;\n\n\tfault_pfn = pud_pfn(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tif (!__gup_device_huge(fault_pfn, addr, end, pages, nr))\n\t\treturn 0;\n\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "__gup_device_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1501-1516",
    "snippet": "static int __gup_device_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tunsigned long fault_pfn;\n\tint nr_start = *nr;\n\n\tfault_pfn = pmd_pfn(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tif (!__gup_device_huge(fault_pfn, addr, end, pages, nr))\n\t\treturn 0;\n\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "undo_dev_pagemap",
          "args": [
            "nr",
            "nr_start",
            "pages"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "undo_dev_pagemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1386-1394",
          "snippet": "static void undo_dev_pagemap(int *nr, int nr_start, struct page **pages)\n{\n\twhile ((*nr) - nr_start) {\n\t\tstruct page *page = pages[--(*nr)];\n\n\t\tClearPageReferenced(page);\n\t\tput_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void undo_dev_pagemap(int *nr, int nr_start, struct page **pages)\n{\n\twhile ((*nr) - nr_start) {\n\t\tstruct page *page = pages[--(*nr)];\n\n\t\tClearPageReferenced(page);\n\t\tput_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pmd_val(orig) != pmd_val(*pmdp)"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_val",
          "args": [
            "*pmdp"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_val",
          "args": [
            "orig"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gup_device_huge",
          "args": [
            "fault_pfn",
            "addr",
            "end",
            "pages",
            "nr"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "__gup_device_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1475-1499",
          "snippet": "static int __gup_device_huge(unsigned long pfn, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tint nr_start = *nr;\n\tstruct dev_pagemap *pgmap = NULL;\n\n\tdo {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tpgmap = get_dev_pagemap(pfn, pgmap);\n\t\tif (unlikely(!pgmap)) {\n\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\treturn 0;\n\t\t}\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\tget_page(page);\n\t\t(*nr)++;\n\t\tpfn++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int __gup_device_huge(unsigned long pfn, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tint nr_start = *nr;\n\tstruct dev_pagemap *pgmap = NULL;\n\n\tdo {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tpgmap = get_dev_pagemap(pfn, pgmap);\n\t\tif (unlikely(!pgmap)) {\n\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\treturn 0;\n\t\t}\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\tget_page(page);\n\t\t(*nr)++;\n\t\tpfn++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_pfn",
          "args": [
            "orig"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int __gup_device_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tunsigned long fault_pfn;\n\tint nr_start = *nr;\n\n\tfault_pfn = pmd_pfn(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tif (!__gup_device_huge(fault_pfn, addr, end, pages, nr))\n\t\treturn 0;\n\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "__gup_device_huge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1475-1499",
    "snippet": "static int __gup_device_huge(unsigned long pfn, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tint nr_start = *nr;\n\tstruct dev_pagemap *pgmap = NULL;\n\n\tdo {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tpgmap = get_dev_pagemap(pfn, pgmap);\n\t\tif (unlikely(!pgmap)) {\n\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\treturn 0;\n\t\t}\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\tget_page(page);\n\t\t(*nr)++;\n\t\tpfn++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_dev_pagemap",
          "args": [
            "pgmap"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageReferenced",
          "args": [
            "page"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "undo_dev_pagemap",
          "args": [
            "nr",
            "nr_start",
            "pages"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "undo_dev_pagemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1386-1394",
          "snippet": "static void undo_dev_pagemap(int *nr, int nr_start, struct page **pages)\n{\n\twhile ((*nr) - nr_start) {\n\t\tstruct page *page = pages[--(*nr)];\n\n\t\tClearPageReferenced(page);\n\t\tput_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void undo_dev_pagemap(int *nr, int nr_start, struct page **pages)\n{\n\twhile ((*nr) - nr_start) {\n\t\tstruct page *page = pages[--(*nr)];\n\n\t\tClearPageReferenced(page);\n\t\tput_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pgmap"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dev_pagemap",
          "args": [
            "pfn",
            "pgmap"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int __gup_device_huge(unsigned long pfn, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tint nr_start = *nr;\n\tstruct dev_pagemap *pgmap = NULL;\n\n\tdo {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tpgmap = get_dev_pagemap(pfn, pgmap);\n\t\tif (unlikely(!pgmap)) {\n\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\treturn 0;\n\t\t}\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\tget_page(page);\n\t\t(*nr)++;\n\t\tpfn++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\treturn 1;\n}"
  },
  {
    "function_name": "gup_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1467-1471",
    "snippet": "static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "gup_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1397-1455",
    "snippet": "static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tstruct dev_pagemap *pgmap = NULL;\n\tint nr_start = *nr, ret = 0;\n\tpte_t *ptep, *ptem;\n\n\tptem = ptep = pte_offset_map(&pmd, addr);\n\tdo {\n\t\tpte_t pte = gup_get_pte(ptep);\n\t\tstruct page *head, *page;\n\n\t\t/*\n\t\t * Similar to the PMD case below, NUMA hinting must take slow\n\t\t * path using the pte_protnone check.\n\t\t */\n\t\tif (pte_protnone(pte))\n\t\t\tgoto pte_unmap;\n\n\t\tif (!pte_access_permitted(pte, write))\n\t\t\tgoto pte_unmap;\n\n\t\tif (pte_devmap(pte)) {\n\t\t\tpgmap = get_dev_pagemap(pte_pfn(pte), pgmap);\n\t\t\tif (unlikely(!pgmap)) {\n\t\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\t\tgoto pte_unmap;\n\t\t\t}\n\t\t} else if (pte_special(pte))\n\t\t\tgoto pte_unmap;\n\n\t\tVM_BUG_ON(!pfn_valid(pte_pfn(pte)));\n\t\tpage = pte_page(pte);\n\t\thead = compound_head(page);\n\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto pte_unmap;\n\n\t\tif (unlikely(pte_val(pte) != pte_val(*ptep))) {\n\t\t\tput_page(head);\n\t\t\tgoto pte_unmap;\n\t\t}\n\n\t\tVM_BUG_ON_PAGE(compound_head(page) != head, page);\n\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\n\t} while (ptep++, addr += PAGE_SIZE, addr != end);\n\n\tret = 1;\n\npte_unmap:\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\tpte_unmap(ptem);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "ptem"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dev_pagemap",
          "args": [
            "pgmap"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReferenced",
          "args": [
            "page"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "compound_head(page) != head",
            "page"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "head"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pte_val(pte) != pte_val(*ptep)"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_val",
          "args": [
            "*ptep"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_val",
          "args": [
            "pte"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get_speculative",
          "args": [
            "head"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "pte"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!pfn_valid(pte_pfn(pte))"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pte_pfn(pte)"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pte"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_special",
          "args": [
            "pte"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "undo_dev_pagemap",
          "args": [
            "nr",
            "nr_start",
            "pages"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "undo_dev_pagemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1386-1394",
          "snippet": "static void undo_dev_pagemap(int *nr, int nr_start, struct page **pages)\n{\n\twhile ((*nr) - nr_start) {\n\t\tstruct page *page = pages[--(*nr)];\n\n\t\tClearPageReferenced(page);\n\t\tput_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void undo_dev_pagemap(int *nr, int nr_start, struct page **pages)\n{\n\twhile ((*nr) - nr_start) {\n\t\tstruct page *page = pages[--(*nr)];\n\n\t\tClearPageReferenced(page);\n\t\tput_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pgmap"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dev_pagemap",
          "args": [
            "pte_pfn(pte)",
            "pgmap"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pte"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_devmap",
          "args": [
            "pte"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_access_permitted",
          "args": [
            "pte",
            "write"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_protnone",
          "args": [
            "pte"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gup_get_pte",
          "args": [
            "ptep"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "gup_get_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1380-1383",
          "snippet": "static inline pte_t gup_get_pte(pte_t *ptep)\n{\n\treturn READ_ONCE(*ptep);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic inline pte_t gup_get_pte(pte_t *ptep)\n{\n\treturn READ_ONCE(*ptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "&pmd",
            "addr"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tstruct dev_pagemap *pgmap = NULL;\n\tint nr_start = *nr, ret = 0;\n\tpte_t *ptep, *ptem;\n\n\tptem = ptep = pte_offset_map(&pmd, addr);\n\tdo {\n\t\tpte_t pte = gup_get_pte(ptep);\n\t\tstruct page *head, *page;\n\n\t\t/*\n\t\t * Similar to the PMD case below, NUMA hinting must take slow\n\t\t * path using the pte_protnone check.\n\t\t */\n\t\tif (pte_protnone(pte))\n\t\t\tgoto pte_unmap;\n\n\t\tif (!pte_access_permitted(pte, write))\n\t\t\tgoto pte_unmap;\n\n\t\tif (pte_devmap(pte)) {\n\t\t\tpgmap = get_dev_pagemap(pte_pfn(pte), pgmap);\n\t\t\tif (unlikely(!pgmap)) {\n\t\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\t\tgoto pte_unmap;\n\t\t\t}\n\t\t} else if (pte_special(pte))\n\t\t\tgoto pte_unmap;\n\n\t\tVM_BUG_ON(!pfn_valid(pte_pfn(pte)));\n\t\tpage = pte_page(pte);\n\t\thead = compound_head(page);\n\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto pte_unmap;\n\n\t\tif (unlikely(pte_val(pte) != pte_val(*ptep))) {\n\t\t\tput_page(head);\n\t\t\tgoto pte_unmap;\n\t\t}\n\n\t\tVM_BUG_ON_PAGE(compound_head(page) != head, page);\n\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\n\t} while (ptep++, addr += PAGE_SIZE, addr != end);\n\n\tret = 1;\n\npte_unmap:\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\tpte_unmap(ptem);\n\treturn ret;\n}"
  },
  {
    "function_name": "undo_dev_pagemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1386-1394",
    "snippet": "static void undo_dev_pagemap(int *nr, int nr_start, struct page **pages)\n{\n\twhile ((*nr) - nr_start) {\n\t\tstruct page *page = pages[--(*nr)];\n\n\t\tClearPageReferenced(page);\n\t\tput_page(page);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageReferenced",
          "args": [
            "page"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void undo_dev_pagemap(int *nr, int nr_start, struct page **pages)\n{\n\twhile ((*nr) - nr_start) {\n\t\tstruct page *page = pages[--(*nr)];\n\n\t\tClearPageReferenced(page);\n\t\tput_page(page);\n\t}\n}"
  },
  {
    "function_name": "gup_get_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1380-1383",
    "snippet": "static inline pte_t gup_get_pte(pte_t *ptep)\n{\n\treturn READ_ONCE(*ptep);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*ptep"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic inline pte_t gup_get_pte(pte_t *ptep)\n{\n\treturn READ_ONCE(*ptep);\n}"
  },
  {
    "function_name": "get_dump_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1326-1337",
    "snippet": "struct page *get_dump_page(unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\n\tif (__get_user_pages(current, current->mm, addr, 1,\n\t\t\t     FOLL_FORCE | FOLL_DUMP | FOLL_GET, &page, &vma,\n\t\t\t     NULL) < 1)\n\t\treturn NULL;\n\tflush_cache_page(vma, addr, page_to_pfn(page));\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "addr",
            "page_to_pfn(page)"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_pages",
          "args": [
            "current",
            "current->mm",
            "addr",
            "1",
            "FOLL_FORCE | FOLL_DUMP | FOLL_GET",
            "&page",
            "&vma",
            "NULL"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "__get_user_pages_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "889-981",
          "snippet": "static __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstruct page *get_dump_page(unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\n\tif (__get_user_pages(current, current->mm, addr, 1,\n\t\t\t     FOLL_FORCE | FOLL_DUMP | FOLL_GET, &page, &vma,\n\t\t\t     NULL) < 1)\n\t\treturn NULL;\n\tflush_cache_page(vma, addr, page_to_pfn(page));\n\treturn page;\n}"
  },
  {
    "function_name": "__mm_populate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1258-1309",
    "snippet": "int __mm_populate(unsigned long start, unsigned long len, int ignore_errors)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long end, nstart, nend;\n\tstruct vm_area_struct *vma = NULL;\n\tint locked = 0;\n\tlong ret = 0;\n\n\tend = start + len;\n\n\tfor (nstart = start; nstart < end; nstart = nend) {\n\t\t/*\n\t\t * We want to fault in pages for [nstart; end) address range.\n\t\t * Find first corresponding VMA.\n\t\t */\n\t\tif (!locked) {\n\t\t\tlocked = 1;\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tvma = find_vma(mm, nstart);\n\t\t} else if (nstart >= vma->vm_end)\n\t\t\tvma = vma->vm_next;\n\t\tif (!vma || vma->vm_start >= end)\n\t\t\tbreak;\n\t\t/*\n\t\t * Set [nstart; nend) to intersection of desired address\n\t\t * range with the first VMA. Also, skip undesirable VMA types.\n\t\t */\n\t\tnend = min(end, vma->vm_end);\n\t\tif (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\tcontinue;\n\t\tif (nstart < vma->vm_start)\n\t\t\tnstart = vma->vm_start;\n\t\t/*\n\t\t * Now fault in a range of pages. populate_vma_page_range()\n\t\t * double checks the vma flags, so that it won't mlock pages\n\t\t * if the vma was already munlocked.\n\t\t */\n\t\tret = populate_vma_page_range(vma, nstart, nend, &locked);\n\t\tif (ret < 0) {\n\t\t\tif (ignore_errors) {\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\t/* continue at next VMA */\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tnend = nstart + ret * PAGE_SIZE;\n\t\tret = 0;\n\t}\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn ret;\t/* 0 or negative error code */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_vma_page_range",
          "args": [
            "vma",
            "nstart",
            "nend",
            "&locked"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "populate_vma_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1212-1249",
          "snippet": "long populate_vma_page_range(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end, int *nonblocking)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long nr_pages = (end - start) / PAGE_SIZE;\n\tint gup_flags;\n\n\tVM_BUG_ON(start & ~PAGE_MASK);\n\tVM_BUG_ON(end   & ~PAGE_MASK);\n\tVM_BUG_ON_VMA(start < vma->vm_start, vma);\n\tVM_BUG_ON_VMA(end   > vma->vm_end, vma);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_sem), mm);\n\n\tgup_flags = FOLL_TOUCH | FOLL_POPULATE | FOLL_MLOCK;\n\tif (vma->vm_flags & VM_LOCKONFAULT)\n\t\tgup_flags &= ~FOLL_POPULATE;\n\t/*\n\t * We want to touch writable mappings with a write fault in order\n\t * to break COW, except for shared mappings because these don't COW\n\t * and we would not want to dirty them for nothing.\n\t */\n\tif ((vma->vm_flags & (VM_WRITE | VM_SHARED)) == VM_WRITE)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We want mlock to succeed for regions that have any permissions\n\t * other than PROT_NONE.\n\t */\n\tif (vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC))\n\t\tgup_flags |= FOLL_FORCE;\n\n\t/*\n\t * We made sure addr is within a VMA, so the following will\n\t * not result in a stack expansion that recurses back here.\n\t */\n\treturn __get_user_pages(current, mm, start, nr_pages, gup_flags,\n\t\t\t\tNULL, NULL, nonblocking);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong populate_vma_page_range(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end, int *nonblocking)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long nr_pages = (end - start) / PAGE_SIZE;\n\tint gup_flags;\n\n\tVM_BUG_ON(start & ~PAGE_MASK);\n\tVM_BUG_ON(end   & ~PAGE_MASK);\n\tVM_BUG_ON_VMA(start < vma->vm_start, vma);\n\tVM_BUG_ON_VMA(end   > vma->vm_end, vma);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_sem), mm);\n\n\tgup_flags = FOLL_TOUCH | FOLL_POPULATE | FOLL_MLOCK;\n\tif (vma->vm_flags & VM_LOCKONFAULT)\n\t\tgup_flags &= ~FOLL_POPULATE;\n\t/*\n\t * We want to touch writable mappings with a write fault in order\n\t * to break COW, except for shared mappings because these don't COW\n\t * and we would not want to dirty them for nothing.\n\t */\n\tif ((vma->vm_flags & (VM_WRITE | VM_SHARED)) == VM_WRITE)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We want mlock to succeed for regions that have any permissions\n\t * other than PROT_NONE.\n\t */\n\tif (vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC))\n\t\tgup_flags |= FOLL_FORCE;\n\n\t/*\n\t * We made sure addr is within a VMA, so the following will\n\t * not result in a stack expansion that recurses back here.\n\t */\n\treturn __get_user_pages(current, mm, start, nr_pages, gup_flags,\n\t\t\t\tNULL, NULL, nonblocking);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "vma->vm_end"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "nstart"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint __mm_populate(unsigned long start, unsigned long len, int ignore_errors)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long end, nstart, nend;\n\tstruct vm_area_struct *vma = NULL;\n\tint locked = 0;\n\tlong ret = 0;\n\n\tend = start + len;\n\n\tfor (nstart = start; nstart < end; nstart = nend) {\n\t\t/*\n\t\t * We want to fault in pages for [nstart; end) address range.\n\t\t * Find first corresponding VMA.\n\t\t */\n\t\tif (!locked) {\n\t\t\tlocked = 1;\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tvma = find_vma(mm, nstart);\n\t\t} else if (nstart >= vma->vm_end)\n\t\t\tvma = vma->vm_next;\n\t\tif (!vma || vma->vm_start >= end)\n\t\t\tbreak;\n\t\t/*\n\t\t * Set [nstart; nend) to intersection of desired address\n\t\t * range with the first VMA. Also, skip undesirable VMA types.\n\t\t */\n\t\tnend = min(end, vma->vm_end);\n\t\tif (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\tcontinue;\n\t\tif (nstart < vma->vm_start)\n\t\t\tnstart = vma->vm_start;\n\t\t/*\n\t\t * Now fault in a range of pages. populate_vma_page_range()\n\t\t * double checks the vma flags, so that it won't mlock pages\n\t\t * if the vma was already munlocked.\n\t\t */\n\t\tret = populate_vma_page_range(vma, nstart, nend, &locked);\n\t\tif (ret < 0) {\n\t\t\tif (ignore_errors) {\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\t/* continue at next VMA */\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tnend = nstart + ret * PAGE_SIZE;\n\t\tret = 0;\n\t}\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn ret;\t/* 0 or negative error code */\n}"
  },
  {
    "function_name": "populate_vma_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1212-1249",
    "snippet": "long populate_vma_page_range(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end, int *nonblocking)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long nr_pages = (end - start) / PAGE_SIZE;\n\tint gup_flags;\n\n\tVM_BUG_ON(start & ~PAGE_MASK);\n\tVM_BUG_ON(end   & ~PAGE_MASK);\n\tVM_BUG_ON_VMA(start < vma->vm_start, vma);\n\tVM_BUG_ON_VMA(end   > vma->vm_end, vma);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_sem), mm);\n\n\tgup_flags = FOLL_TOUCH | FOLL_POPULATE | FOLL_MLOCK;\n\tif (vma->vm_flags & VM_LOCKONFAULT)\n\t\tgup_flags &= ~FOLL_POPULATE;\n\t/*\n\t * We want to touch writable mappings with a write fault in order\n\t * to break COW, except for shared mappings because these don't COW\n\t * and we would not want to dirty them for nothing.\n\t */\n\tif ((vma->vm_flags & (VM_WRITE | VM_SHARED)) == VM_WRITE)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We want mlock to succeed for regions that have any permissions\n\t * other than PROT_NONE.\n\t */\n\tif (vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC))\n\t\tgup_flags |= FOLL_FORCE;\n\n\t/*\n\t * We made sure addr is within a VMA, so the following will\n\t * not result in a stack expansion that recurses back here.\n\t */\n\treturn __get_user_pages(current, mm, start, nr_pages, gup_flags,\n\t\t\t\tNULL, NULL, nonblocking);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user_pages",
          "args": [
            "current",
            "mm",
            "start",
            "nr_pages",
            "gup_flags",
            "NULL",
            "NULL",
            "nonblocking"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "__get_user_pages_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "889-981",
          "snippet": "static __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_MM",
          "args": [
            "!rwsem_is_locked(&mm->mmap_sem)",
            "mm"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "end   > vma->vm_end",
            "vma"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "start < vma->vm_start",
            "vma"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "end   & ~PAGE_MASK"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "start & ~PAGE_MASK"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong populate_vma_page_range(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end, int *nonblocking)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long nr_pages = (end - start) / PAGE_SIZE;\n\tint gup_flags;\n\n\tVM_BUG_ON(start & ~PAGE_MASK);\n\tVM_BUG_ON(end   & ~PAGE_MASK);\n\tVM_BUG_ON_VMA(start < vma->vm_start, vma);\n\tVM_BUG_ON_VMA(end   > vma->vm_end, vma);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_sem), mm);\n\n\tgup_flags = FOLL_TOUCH | FOLL_POPULATE | FOLL_MLOCK;\n\tif (vma->vm_flags & VM_LOCKONFAULT)\n\t\tgup_flags &= ~FOLL_POPULATE;\n\t/*\n\t * We want to touch writable mappings with a write fault in order\n\t * to break COW, except for shared mappings because these don't COW\n\t * and we would not want to dirty them for nothing.\n\t */\n\tif ((vma->vm_flags & (VM_WRITE | VM_SHARED)) == VM_WRITE)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We want mlock to succeed for regions that have any permissions\n\t * other than PROT_NONE.\n\t */\n\tif (vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC))\n\t\tgup_flags |= FOLL_FORCE;\n\n\t/*\n\t * We made sure addr is within a VMA, so the following will\n\t * not result in a stack expansion that recurses back here.\n\t */\n\treturn __get_user_pages(current, mm, start, nr_pages, gup_flags,\n\t\t\t\tNULL, NULL, nonblocking);\n}"
  },
  {
    "function_name": "get_user_pages_longterm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1142-1189",
    "snippet": "long get_user_pages_longterm(unsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas_arg)\n{\n\tstruct vm_area_struct **vmas = vmas_arg;\n\tstruct vm_area_struct *vma_prev = NULL;\n\tlong rc, i;\n\n\tif (!pages)\n\t\treturn -EINVAL;\n\n\tif (!vmas) {\n\t\tvmas = kcalloc(nr_pages, sizeof(struct vm_area_struct *),\n\t\t\t       GFP_KERNEL);\n\t\tif (!vmas)\n\t\t\treturn -ENOMEM;\n\t}\n\n\trc = get_user_pages(start, nr_pages, gup_flags, pages, vmas);\n\n\tfor (i = 0; i < rc; i++) {\n\t\tstruct vm_area_struct *vma = vmas[i];\n\n\t\tif (vma == vma_prev)\n\t\t\tcontinue;\n\n\t\tvma_prev = vma;\n\n\t\tif (vma_is_fsdax(vma))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Either get_user_pages() failed, or the vma validation\n\t * succeeded, in either case we don't need to put_page() before\n\t * returning.\n\t */\n\tif (i >= rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < rc; i++)\n\t\tput_page(pages[i]);\n\trc = -EOPNOTSUPP;\nout:\n\tif (vmas != vmas_arg)\n\t\tkfree(vmas);\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vmas"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pages[i]"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_fsdax",
          "args": [
            "vma"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages",
          "args": [
            "start",
            "nr_pages",
            "gup_flags",
            "pages",
            "vmas"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_pages_longterm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1142-1189",
          "snippet": "long get_user_pages_longterm(unsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas_arg)\n{\n\tstruct vm_area_struct **vmas = vmas_arg;\n\tstruct vm_area_struct *vma_prev = NULL;\n\tlong rc, i;\n\n\tif (!pages)\n\t\treturn -EINVAL;\n\n\tif (!vmas) {\n\t\tvmas = kcalloc(nr_pages, sizeof(struct vm_area_struct *),\n\t\t\t       GFP_KERNEL);\n\t\tif (!vmas)\n\t\t\treturn -ENOMEM;\n\t}\n\n\trc = get_user_pages(start, nr_pages, gup_flags, pages, vmas);\n\n\tfor (i = 0; i < rc; i++) {\n\t\tstruct vm_area_struct *vma = vmas[i];\n\n\t\tif (vma == vma_prev)\n\t\t\tcontinue;\n\n\t\tvma_prev = vma;\n\n\t\tif (vma_is_fsdax(vma))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Either get_user_pages() failed, or the vma validation\n\t * succeeded, in either case we don't need to put_page() before\n\t * returning.\n\t */\n\tif (i >= rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < rc; i++)\n\t\tput_page(pages[i]);\n\trc = -EOPNOTSUPP;\nout:\n\tif (vmas != vmas_arg)\n\t\tkfree(vmas);\n\treturn rc;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_pages",
            "sizeof(struct vm_area_struct *)",
            "GFP_KERNEL"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong get_user_pages_longterm(unsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas_arg)\n{\n\tstruct vm_area_struct **vmas = vmas_arg;\n\tstruct vm_area_struct *vma_prev = NULL;\n\tlong rc, i;\n\n\tif (!pages)\n\t\treturn -EINVAL;\n\n\tif (!vmas) {\n\t\tvmas = kcalloc(nr_pages, sizeof(struct vm_area_struct *),\n\t\t\t       GFP_KERNEL);\n\t\tif (!vmas)\n\t\t\treturn -ENOMEM;\n\t}\n\n\trc = get_user_pages(start, nr_pages, gup_flags, pages, vmas);\n\n\tfor (i = 0; i < rc; i++) {\n\t\tstruct vm_area_struct *vma = vmas[i];\n\n\t\tif (vma == vma_prev)\n\t\t\tcontinue;\n\n\t\tvma_prev = vma;\n\n\t\tif (vma_is_fsdax(vma))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Either get_user_pages() failed, or the vma validation\n\t * succeeded, in either case we don't need to put_page() before\n\t * returning.\n\t */\n\tif (i >= rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < rc; i++)\n\t\tput_page(pages[i]);\n\trc = -EOPNOTSUPP;\nout:\n\tif (vmas != vmas_arg)\n\t\tkfree(vmas);\n\treturn rc;\n}"
  },
  {
    "function_name": "get_user_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1119-1126",
    "snippet": "long get_user_pages(unsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas)\n{\n\treturn __get_user_pages_locked(current, current->mm, start, nr_pages,\n\t\t\t\t       pages, vmas, NULL,\n\t\t\t\t       gup_flags | FOLL_TOUCH);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user_pages_locked",
          "args": [
            "current",
            "current->mm",
            "start",
            "nr_pages",
            "pages",
            "vmas",
            "NULL",
            "gup_flags | FOLL_TOUCH"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "__get_user_pages_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "889-981",
          "snippet": "static __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong get_user_pages(unsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas)\n{\n\treturn __get_user_pages_locked(current, current->mm, start, nr_pages,\n\t\t\t\t       pages, vmas, NULL,\n\t\t\t\t       gup_flags | FOLL_TOUCH);\n}"
  },
  {
    "function_name": "get_user_pages_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1101-1109",
    "snippet": "long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas, int *locked)\n{\n\treturn __get_user_pages_locked(tsk, mm, start, nr_pages, pages, vmas,\n\t\t\t\t       locked,\n\t\t\t\t       gup_flags | FOLL_TOUCH | FOLL_REMOTE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user_pages_locked",
          "args": [
            "tsk",
            "mm",
            "start",
            "nr_pages",
            "pages",
            "vmas",
            "locked",
            "gup_flags | FOLL_TOUCH | FOLL_REMOTE"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "__get_user_pages_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "889-981",
          "snippet": "static __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas, int *locked)\n{\n\treturn __get_user_pages_locked(tsk, mm, start, nr_pages, pages, vmas,\n\t\t\t\t       locked,\n\t\t\t\t       gup_flags | FOLL_TOUCH | FOLL_REMOTE);\n}"
  },
  {
    "function_name": "get_user_pages_unlocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1029-1042",
    "snippet": "long get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,\n\t\t\t     struct page **pages, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint locked = 1;\n\tlong ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = __get_user_pages_locked(current, mm, start, nr_pages, pages, NULL,\n\t\t\t\t      &locked, gup_flags | FOLL_TOUCH);\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_pages_locked",
          "args": [
            "current",
            "mm",
            "start",
            "nr_pages",
            "pages",
            "NULL",
            "&locked",
            "gup_flags | FOLL_TOUCH"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "__get_user_pages_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "889-981",
          "snippet": "static __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,\n\t\t\t     struct page **pages, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint locked = 1;\n\tlong ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = __get_user_pages_locked(current, mm, start, nr_pages, pages, NULL,\n\t\t\t\t      &locked, gup_flags | FOLL_TOUCH);\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_user_pages_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "1004-1011",
    "snippet": "long get_user_pages_locked(unsigned long start, unsigned long nr_pages,\n\t\t\t   unsigned int gup_flags, struct page **pages,\n\t\t\t   int *locked)\n{\n\treturn __get_user_pages_locked(current, current->mm, start, nr_pages,\n\t\t\t\t       pages, NULL, locked,\n\t\t\t\t       gup_flags | FOLL_TOUCH);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user_pages_locked",
          "args": [
            "current",
            "current->mm",
            "start",
            "nr_pages",
            "pages",
            "NULL",
            "locked",
            "gup_flags | FOLL_TOUCH"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "__get_user_pages_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "889-981",
          "snippet": "static __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong get_user_pages_locked(unsigned long start, unsigned long nr_pages,\n\t\t\t   unsigned int gup_flags, struct page **pages,\n\t\t\t   int *locked)\n{\n\treturn __get_user_pages_locked(current, current->mm, start, nr_pages,\n\t\t\t\t       pages, NULL, locked,\n\t\t\t\t       gup_flags | FOLL_TOUCH);\n}"
  },
  {
    "function_name": "__get_user_pages_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "889-981",
    "snippet": "static __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret > 1"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_pages",
          "args": [
            "tsk",
            "mm",
            "start",
            "1",
            "flags | FOLL_TRIED",
            "pages",
            "NULL",
            "NULL"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "__get_user_pages_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "889-981",
          "snippet": "static __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret >= nr_pages"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*locked != 1"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vmas"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}"
  },
  {
    "function_name": "fixup_user_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "841-886",
    "snippet": "int fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,\n\t\t     unsigned long address, unsigned int fault_flags,\n\t\t     bool *unlocked)\n{\n\tstruct vm_area_struct *vma;\n\tvm_fault_t ret, major = 0;\n\n\tif (unlocked)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\nretry:\n\tvma = find_extend_vma(mm, address);\n\tif (!vma || address < vma->vm_start)\n\t\treturn -EFAULT;\n\n\tif (!vma_permits_fault(vma, fault_flags))\n\t\treturn -EFAULT;\n\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tmajor |= ret & VM_FAULT_MAJOR;\n\tif (ret & VM_FAULT_ERROR) {\n\t\tint err = vm_fault_to_errno(ret, 0);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tBUG();\n\t}\n\n\tif (ret & VM_FAULT_RETRY) {\n\t\tdown_read(&mm->mmap_sem);\n\t\tif (!(fault_flags & FAULT_FLAG_TRIED)) {\n\t\t\t*unlocked = true;\n\t\t\tfault_flags &= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (tsk) {\n\t\tif (major)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_fault_to_errno",
          "args": [
            "ret",
            "0"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_mm_fault",
          "args": [
            "vma",
            "address",
            "fault_flags"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "handle_mm_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3898-3941",
          "snippet": "vm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags)\n{\n\tvm_fault_t ret;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tcount_memcg_event_mm(vma->vm_mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (!arch_vma_access_permitted(vma, flags & FAULT_FLAG_WRITE,\n\t\t\t\t\t    flags & FAULT_FLAG_INSTRUCTION,\n\t\t\t\t\t    flags & FAULT_FLAG_REMOTE))\n\t\treturn VM_FAULT_SIGSEGV;\n\n\t/*\n\t * Enable the memcg OOM handling for faults triggered in user\n\t * space.  Kernel faults are handled more gracefully.\n\t */\n\tif (flags & FAULT_FLAG_USER)\n\t\tmem_cgroup_enter_user_fault();\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\tret = hugetlb_fault(vma->vm_mm, vma, address, flags);\n\telse\n\t\tret = __handle_mm_fault(vma, address, flags);\n\n\tif (flags & FAULT_FLAG_USER) {\n\t\tmem_cgroup_exit_user_fault();\n\t\t/*\n\t\t * The task may have entered a memcg OOM situation but\n\t\t * if the allocation error was handled gracefully (no\n\t\t * VM_FAULT_OOM), there is no need to kill anything.\n\t\t * Just clean up the OOM state peacefully.\n\t\t */\n\t\tif (task_in_memcg_oom(current) && !(ret & VM_FAULT_OOM))\n\t\t\tmem_cgroup_oom_synchronize(false);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags)\n{\n\tvm_fault_t ret;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tcount_memcg_event_mm(vma->vm_mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (!arch_vma_access_permitted(vma, flags & FAULT_FLAG_WRITE,\n\t\t\t\t\t    flags & FAULT_FLAG_INSTRUCTION,\n\t\t\t\t\t    flags & FAULT_FLAG_REMOTE))\n\t\treturn VM_FAULT_SIGSEGV;\n\n\t/*\n\t * Enable the memcg OOM handling for faults triggered in user\n\t * space.  Kernel faults are handled more gracefully.\n\t */\n\tif (flags & FAULT_FLAG_USER)\n\t\tmem_cgroup_enter_user_fault();\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\tret = hugetlb_fault(vma->vm_mm, vma, address, flags);\n\telse\n\t\tret = __handle_mm_fault(vma, address, flags);\n\n\tif (flags & FAULT_FLAG_USER) {\n\t\tmem_cgroup_exit_user_fault();\n\t\t/*\n\t\t * The task may have entered a memcg OOM situation but\n\t\t * if the allocation error was handled gracefully (no\n\t\t * VM_FAULT_OOM), there is no need to kill anything.\n\t\t * Just clean up the OOM state peacefully.\n\t\t */\n\t\tif (task_in_memcg_oom(current) && !(ret & VM_FAULT_OOM))\n\t\t\tmem_cgroup_oom_synchronize(false);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_permits_fault",
          "args": [
            "vma",
            "fault_flags"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "vma_permits_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "788-809",
          "snippet": "static bool vma_permits_fault(struct vm_area_struct *vma,\n\t\t\t      unsigned int fault_flags)\n{\n\tbool write   = !!(fault_flags & FAULT_FLAG_WRITE);\n\tbool foreign = !!(fault_flags & FAULT_FLAG_REMOTE);\n\tvm_flags_t vm_flags = write ? VM_WRITE : VM_READ;\n\n\tif (!(vm_flags & vma->vm_flags))\n\t\treturn false;\n\n\t/*\n\t * The architecture might have a hardware protection\n\t * mechanism other than read/write that can deny access.\n\t *\n\t * gup always represents data access, not instruction\n\t * fetches, so execute=false here:\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic bool vma_permits_fault(struct vm_area_struct *vma,\n\t\t\t      unsigned int fault_flags)\n{\n\tbool write   = !!(fault_flags & FAULT_FLAG_WRITE);\n\tbool foreign = !!(fault_flags & FAULT_FLAG_REMOTE);\n\tvm_flags_t vm_flags = write ? VM_WRITE : VM_READ;\n\n\tif (!(vm_flags & vma->vm_flags))\n\t\treturn false;\n\n\t/*\n\t * The architecture might have a hardware protection\n\t * mechanism other than read/write that can deny access.\n\t *\n\t * gup always represents data access, not instruction\n\t * fetches, so execute=false here:\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_extend_vma",
          "args": [
            "mm",
            "address"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "find_extend_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "803-806",
          "snippet": "struct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\treturn find_vma(mm, addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\treturn find_vma(mm, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,\n\t\t     unsigned long address, unsigned int fault_flags,\n\t\t     bool *unlocked)\n{\n\tstruct vm_area_struct *vma;\n\tvm_fault_t ret, major = 0;\n\n\tif (unlocked)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\nretry:\n\tvma = find_extend_vma(mm, address);\n\tif (!vma || address < vma->vm_start)\n\t\treturn -EFAULT;\n\n\tif (!vma_permits_fault(vma, fault_flags))\n\t\treturn -EFAULT;\n\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tmajor |= ret & VM_FAULT_MAJOR;\n\tif (ret & VM_FAULT_ERROR) {\n\t\tint err = vm_fault_to_errno(ret, 0);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tBUG();\n\t}\n\n\tif (ret & VM_FAULT_RETRY) {\n\t\tdown_read(&mm->mmap_sem);\n\t\tif (!(fault_flags & FAULT_FLAG_TRIED)) {\n\t\t\t*unlocked = true;\n\t\t\tfault_flags &= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (tsk) {\n\t\tif (major)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "vma_permits_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "788-809",
    "snippet": "static bool vma_permits_fault(struct vm_area_struct *vma,\n\t\t\t      unsigned int fault_flags)\n{\n\tbool write   = !!(fault_flags & FAULT_FLAG_WRITE);\n\tbool foreign = !!(fault_flags & FAULT_FLAG_REMOTE);\n\tvm_flags_t vm_flags = write ? VM_WRITE : VM_READ;\n\n\tif (!(vm_flags & vma->vm_flags))\n\t\treturn false;\n\n\t/*\n\t * The architecture might have a hardware protection\n\t * mechanism other than read/write that can deny access.\n\t *\n\t * gup always represents data access, not instruction\n\t * fetches, so execute=false here:\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_vma_access_permitted",
          "args": [
            "vma",
            "write",
            "false",
            "foreign"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic bool vma_permits_fault(struct vm_area_struct *vma,\n\t\t\t      unsigned int fault_flags)\n{\n\tbool write   = !!(fault_flags & FAULT_FLAG_WRITE);\n\tbool foreign = !!(fault_flags & FAULT_FLAG_REMOTE);\n\tvm_flags_t vm_flags = write ? VM_WRITE : VM_READ;\n\n\tif (!(vm_flags & vma->vm_flags))\n\t\treturn false;\n\n\t/*\n\t * The architecture might have a hardware protection\n\t * mechanism other than read/write that can deny access.\n\t *\n\t * gup always represents data access, not instruction\n\t * fetches, so execute=false here:\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "__get_user_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "674-786",
    "snippet": "static long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas, int *nonblocking)\n{\n\tlong ret = 0, i = 0;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct follow_page_context ctx = { NULL };\n\n\tif (!nr_pages)\n\t\treturn 0;\n\n\tVM_BUG_ON(!!pages != !!(gup_flags & FOLL_GET));\n\n\t/*\n\t * If FOLL_FORCE is set then do not force a full fault as the hinting\n\t * fault information is unrelated to the reference behaviour of a task\n\t * using the address space\n\t */\n\tif (!(gup_flags & FOLL_FORCE))\n\t\tgup_flags |= FOLL_NUMA;\n\n\tdo {\n\t\tstruct page *page;\n\t\tunsigned int foll_flags = gup_flags;\n\t\tunsigned int page_increm;\n\n\t\t/* first iteration or cross vma bound */\n\t\tif (!vma || start >= vma->vm_end) {\n\t\t\tvma = find_extend_vma(mm, start);\n\t\t\tif (!vma && in_gate_area(mm, start)) {\n\t\t\t\tret = get_gate_page(mm, start & PAGE_MASK,\n\t\t\t\t\t\tgup_flags, &vma,\n\t\t\t\t\t\tpages ? &pages[i] : NULL);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tctx.page_mask = 0;\n\t\t\t\tgoto next_page;\n\t\t\t}\n\n\t\t\tif (!vma || check_vma_flags(vma, gup_flags)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &nr_pages, i,\n\t\t\t\t\t\tgup_flags, nonblocking);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\nretry:\n\t\t/*\n\t\t * If we have a pending SIGKILL, don't keep faulting pages and\n\t\t * potentially allocating memory.\n\t\t */\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tgoto out;\n\t\t}\n\t\tcond_resched();\n\n\t\tpage = follow_page_mask(vma, start, foll_flags, &ctx);\n\t\tif (!page) {\n\t\t\tret = faultin_page(tsk, vma, start, &foll_flags,\n\t\t\t\t\tnonblocking);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tgoto retry;\n\t\t\tcase -EBUSY:\n\t\t\t\tret = 0;\n\t\t\t\t/* FALLTHRU */\n\t\t\tcase -EFAULT:\n\t\t\tcase -ENOMEM:\n\t\t\tcase -EHWPOISON:\n\t\t\t\tgoto out;\n\t\t\tcase -ENOENT:\n\t\t\t\tgoto next_page;\n\t\t\t}\n\t\t\tBUG();\n\t\t} else if (PTR_ERR(page) == -EEXIST) {\n\t\t\t/*\n\t\t\t * Proper page table entry exists, but no corresponding\n\t\t\t * struct page.\n\t\t\t */\n\t\t\tgoto next_page;\n\t\t} else if (IS_ERR(page)) {\n\t\t\tret = PTR_ERR(page);\n\t\t\tgoto out;\n\t\t}\n\t\tif (pages) {\n\t\t\tpages[i] = page;\n\t\t\tflush_anon_page(vma, page, start);\n\t\t\tflush_dcache_page(page);\n\t\t\tctx.page_mask = 0;\n\t\t}\nnext_page:\n\t\tif (vmas) {\n\t\t\tvmas[i] = vma;\n\t\t\tctx.page_mask = 0;\n\t\t}\n\t\tpage_increm = 1 + (~(start >> PAGE_SHIFT) & ctx.page_mask);\n\t\tif (page_increm > nr_pages)\n\t\t\tpage_increm = nr_pages;\n\t\ti += page_increm;\n\t\tstart += page_increm * PAGE_SIZE;\n\t\tnr_pages -= page_increm;\n\t} while (nr_pages);\nout:\n\tif (ctx.pgmap)\n\t\tput_dev_pagemap(ctx.pgmap);\n\treturn i ? i : ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_dev_pagemap",
          "args": [
            "ctx.pgmap"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_anon_page",
          "args": [
            "vma",
            "page",
            "start"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "faultin_page",
          "args": [
            "tsk",
            "vma",
            "start",
            "&foll_flags",
            "nonblocking"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "faultin_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "513-569",
          "snippet": "static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tvm_fault_t ret;\n\n\t/* mlock all present pages, but do not fault in new pages */\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tint err = vm_fault_to_errno(ret, *flags);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tBUG();\n\t}\n\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking && !(fault_flags & FAULT_FLAG_RETRY_NOWAIT))\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when\n\t * necessary, even if maybe_mkwrite decided not to set pte_write. We\n\t * can thus safely do subsequent page lookups as if they were reads.\n\t * But only do so when looping for pte_write is futile: in some cases\n\t * userspace may also be wanting to write to the gotten user page,\n\t * which a read fault here might prevent (a readonly page might get\n\t * reCOWed by userspace write).\n\t */\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags |= FOLL_COW;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tvm_fault_t ret;\n\n\t/* mlock all present pages, but do not fault in new pages */\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tint err = vm_fault_to_errno(ret, *flags);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tBUG();\n\t}\n\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking && !(fault_flags & FAULT_FLAG_RETRY_NOWAIT))\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when\n\t * necessary, even if maybe_mkwrite decided not to set pte_write. We\n\t * can thus safely do subsequent page lookups as if they were reads.\n\t * But only do so when looping for pte_write is futile: in some cases\n\t * userspace may also be wanting to write to the gotten user page,\n\t * which a read fault here might prevent (a readonly page might get\n\t * reCOWed by userspace write).\n\t */\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags |= FOLL_COW;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "follow_page_mask",
          "args": [
            "vma",
            "start",
            "foll_flags",
            "&ctx"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "follow_page_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "402-440",
          "snippet": "struct page *follow_page_mask(struct vm_area_struct *vma,\n\t\t\t      unsigned long address, unsigned int flags,\n\t\t\t      struct follow_page_context *ctx)\n{\n\tpgd_t *pgd;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tctx->page_mask = 0;\n\n\t/* make this handle hugepd */\n\tpage = follow_huge_addr(mm, address, flags & FOLL_WRITE);\n\tif (!IS_ERR(page)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\treturn page;\n\t}\n\n\tpgd = pgd_offset(mm, address);\n\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\treturn no_page_table(vma, flags);\n\n\tif (pgd_huge(*pgd)) {\n\t\tpage = follow_huge_pgd(mm, address, pgd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pgd_val(*pgd)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pgd_val(*pgd)), flags,\n\t\t\t\t      PGDIR_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\n\treturn follow_p4d_mask(vma, address, pgd, flags, ctx);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstruct page *follow_page_mask(struct vm_area_struct *vma,\n\t\t\t      unsigned long address, unsigned int flags,\n\t\t\t      struct follow_page_context *ctx)\n{\n\tpgd_t *pgd;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tctx->page_mask = 0;\n\n\t/* make this handle hugepd */\n\tpage = follow_huge_addr(mm, address, flags & FOLL_WRITE);\n\tif (!IS_ERR(page)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\treturn page;\n\t}\n\n\tpgd = pgd_offset(mm, address);\n\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\treturn no_page_table(vma, flags);\n\n\tif (pgd_huge(*pgd)) {\n\t\tpage = follow_huge_pgd(mm, address, pgd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pgd_val(*pgd)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pgd_val(*pgd)), flags,\n\t\t\t\t      PGDIR_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\n\treturn follow_p4d_mask(vma, address, pgd, flags, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fatal_signal_pending(current)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_hugetlb_page",
          "args": [
            "mm",
            "vma",
            "pages",
            "vmas",
            "&start",
            "&nr_pages",
            "i",
            "gup_flags",
            "nonblocking"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "follow_hugetlb_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4181-4323",
          "snippet": "long follow_hugetlb_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t struct page **pages, struct vm_area_struct **vmas,\n\t\t\t unsigned long *position, unsigned long *nr_pages,\n\t\t\t long i, unsigned int flags, int *nonblocking)\n{\n\tunsigned long pfn_offset;\n\tunsigned long vaddr = *position;\n\tunsigned long remainder = *nr_pages;\n\tstruct hstate *h = hstate_vma(vma);\n\tint err = -EFAULT;\n\n\twhile (vaddr < vma->vm_end && remainder) {\n\t\tpte_t *pte;\n\t\tspinlock_t *ptl = NULL;\n\t\tint absent;\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * If we have a pending SIGKILL, don't keep faulting pages and\n\t\t * potentially allocating memory.\n\t\t */\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Some archs (sparc64, sh*) have multiple pte_ts to\n\t\t * each hugepage.  We have to make sure we get the\n\t\t * first, for the page indexing below to work.\n\t\t *\n\t\t * Note that page table lock is not held when pte is null.\n\t\t */\n\t\tpte = huge_pte_offset(mm, vaddr & huge_page_mask(h),\n\t\t\t\t      huge_page_size(h));\n\t\tif (pte)\n\t\t\tptl = huge_pte_lock(h, mm, pte);\n\t\tabsent = !pte || huge_pte_none(huge_ptep_get(pte));\n\n\t\t/*\n\t\t * When coredumping, it suits get_dump_page if we just return\n\t\t * an error where there's an empty slot with no huge pagecache\n\t\t * to back it.  This way, we avoid allocating a hugepage, and\n\t\t * the sparse dumpfile avoids allocating disk blocks, but its\n\t\t * huge holes still show up with zeroes where they need to be.\n\t\t */\n\t\tif (absent && (flags & FOLL_DUMP) &&\n\t\t    !hugetlbfs_pagecache_present(h, vma, vaddr)) {\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need call hugetlb_fault for both hugepages under migration\n\t\t * (in which case hugetlb_fault waits for the migration,) and\n\t\t * hwpoisoned hugepages (in which case we need to prevent the\n\t\t * caller from accessing to them.) In order to do this, we use\n\t\t * here is_swap_pte instead of is_hugetlb_entry_migration and\n\t\t * is_hugetlb_entry_hwpoisoned. This is because it simply covers\n\t\t * both cases, and because we can't follow correct pages\n\t\t * directly from any kind of swap entries.\n\t\t */\n\t\tif (absent || is_swap_pte(huge_ptep_get(pte)) ||\n\t\t    ((flags & FOLL_WRITE) &&\n\t\t      !huge_pte_write(huge_ptep_get(pte)))) {\n\t\t\tvm_fault_t ret;\n\t\t\tunsigned int fault_flags = 0;\n\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tif (flags & FOLL_WRITE)\n\t\t\t\tfault_flags |= FAULT_FLAG_WRITE;\n\t\t\tif (nonblocking)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\t\t\tif (flags & FOLL_NOWAIT)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY |\n\t\t\t\t\tFAULT_FLAG_RETRY_NOWAIT;\n\t\t\tif (flags & FOLL_TRIED) {\n\t\t\t\tVM_WARN_ON_ONCE(fault_flags &\n\t\t\t\t\t\tFAULT_FLAG_ALLOW_RETRY);\n\t\t\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t\t\t}\n\t\t\tret = hugetlb_fault(mm, vma, vaddr, fault_flags);\n\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\terr = vm_fault_to_errno(ret, flags);\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\t\tif (nonblocking)\n\t\t\t\t\t*nonblocking = 0;\n\t\t\t\t*nr_pages = 0;\n\t\t\t\t/*\n\t\t\t\t * VM_FAULT_RETRY must not return an\n\t\t\t\t * error, it will return zero\n\t\t\t\t * instead.\n\t\t\t\t *\n\t\t\t\t * No need to update \"position\" as the\n\t\t\t\t * caller will not check it after\n\t\t\t\t * *nr_pages is set to 0.\n\t\t\t\t */\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn_offset = (vaddr & ~huge_page_mask(h)) >> PAGE_SHIFT;\n\t\tpage = pte_page(huge_ptep_get(pte));\nsame_page:\n\t\tif (pages) {\n\t\t\tpages[i] = mem_map_offset(page, pfn_offset);\n\t\t\tget_page(pages[i]);\n\t\t}\n\n\t\tif (vmas)\n\t\t\tvmas[i] = vma;\n\n\t\tvaddr += PAGE_SIZE;\n\t\t++pfn_offset;\n\t\t--remainder;\n\t\t++i;\n\t\tif (vaddr < vma->vm_end && remainder &&\n\t\t\t\tpfn_offset < pages_per_huge_page(h)) {\n\t\t\t/*\n\t\t\t * We use pfn_offset to avoid touching the pageframes\n\t\t\t * of this compound page.\n\t\t\t */\n\t\t\tgoto same_page;\n\t\t}\n\t\tspin_unlock(ptl);\n\t}\n\t*nr_pages = remainder;\n\t/*\n\t * setting position is actually required only if remainder is\n\t * not zero but it's faster not to add a \"if (remainder)\"\n\t * branch.\n\t */\n\t*position = vaddr;\n\n\treturn i ? i : err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nlong follow_hugetlb_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t struct page **pages, struct vm_area_struct **vmas,\n\t\t\t unsigned long *position, unsigned long *nr_pages,\n\t\t\t long i, unsigned int flags, int *nonblocking)\n{\n\tunsigned long pfn_offset;\n\tunsigned long vaddr = *position;\n\tunsigned long remainder = *nr_pages;\n\tstruct hstate *h = hstate_vma(vma);\n\tint err = -EFAULT;\n\n\twhile (vaddr < vma->vm_end && remainder) {\n\t\tpte_t *pte;\n\t\tspinlock_t *ptl = NULL;\n\t\tint absent;\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * If we have a pending SIGKILL, don't keep faulting pages and\n\t\t * potentially allocating memory.\n\t\t */\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Some archs (sparc64, sh*) have multiple pte_ts to\n\t\t * each hugepage.  We have to make sure we get the\n\t\t * first, for the page indexing below to work.\n\t\t *\n\t\t * Note that page table lock is not held when pte is null.\n\t\t */\n\t\tpte = huge_pte_offset(mm, vaddr & huge_page_mask(h),\n\t\t\t\t      huge_page_size(h));\n\t\tif (pte)\n\t\t\tptl = huge_pte_lock(h, mm, pte);\n\t\tabsent = !pte || huge_pte_none(huge_ptep_get(pte));\n\n\t\t/*\n\t\t * When coredumping, it suits get_dump_page if we just return\n\t\t * an error where there's an empty slot with no huge pagecache\n\t\t * to back it.  This way, we avoid allocating a hugepage, and\n\t\t * the sparse dumpfile avoids allocating disk blocks, but its\n\t\t * huge holes still show up with zeroes where they need to be.\n\t\t */\n\t\tif (absent && (flags & FOLL_DUMP) &&\n\t\t    !hugetlbfs_pagecache_present(h, vma, vaddr)) {\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need call hugetlb_fault for both hugepages under migration\n\t\t * (in which case hugetlb_fault waits for the migration,) and\n\t\t * hwpoisoned hugepages (in which case we need to prevent the\n\t\t * caller from accessing to them.) In order to do this, we use\n\t\t * here is_swap_pte instead of is_hugetlb_entry_migration and\n\t\t * is_hugetlb_entry_hwpoisoned. This is because it simply covers\n\t\t * both cases, and because we can't follow correct pages\n\t\t * directly from any kind of swap entries.\n\t\t */\n\t\tif (absent || is_swap_pte(huge_ptep_get(pte)) ||\n\t\t    ((flags & FOLL_WRITE) &&\n\t\t      !huge_pte_write(huge_ptep_get(pte)))) {\n\t\t\tvm_fault_t ret;\n\t\t\tunsigned int fault_flags = 0;\n\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tif (flags & FOLL_WRITE)\n\t\t\t\tfault_flags |= FAULT_FLAG_WRITE;\n\t\t\tif (nonblocking)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\t\t\tif (flags & FOLL_NOWAIT)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY |\n\t\t\t\t\tFAULT_FLAG_RETRY_NOWAIT;\n\t\t\tif (flags & FOLL_TRIED) {\n\t\t\t\tVM_WARN_ON_ONCE(fault_flags &\n\t\t\t\t\t\tFAULT_FLAG_ALLOW_RETRY);\n\t\t\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t\t\t}\n\t\t\tret = hugetlb_fault(mm, vma, vaddr, fault_flags);\n\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\terr = vm_fault_to_errno(ret, flags);\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\t\tif (nonblocking)\n\t\t\t\t\t*nonblocking = 0;\n\t\t\t\t*nr_pages = 0;\n\t\t\t\t/*\n\t\t\t\t * VM_FAULT_RETRY must not return an\n\t\t\t\t * error, it will return zero\n\t\t\t\t * instead.\n\t\t\t\t *\n\t\t\t\t * No need to update \"position\" as the\n\t\t\t\t * caller will not check it after\n\t\t\t\t * *nr_pages is set to 0.\n\t\t\t\t */\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn_offset = (vaddr & ~huge_page_mask(h)) >> PAGE_SHIFT;\n\t\tpage = pte_page(huge_ptep_get(pte));\nsame_page:\n\t\tif (pages) {\n\t\t\tpages[i] = mem_map_offset(page, pfn_offset);\n\t\t\tget_page(pages[i]);\n\t\t}\n\n\t\tif (vmas)\n\t\t\tvmas[i] = vma;\n\n\t\tvaddr += PAGE_SIZE;\n\t\t++pfn_offset;\n\t\t--remainder;\n\t\t++i;\n\t\tif (vaddr < vma->vm_end && remainder &&\n\t\t\t\tpfn_offset < pages_per_huge_page(h)) {\n\t\t\t/*\n\t\t\t * We use pfn_offset to avoid touching the pageframes\n\t\t\t * of this compound page.\n\t\t\t */\n\t\t\tgoto same_page;\n\t\t}\n\t\tspin_unlock(ptl);\n\t}\n\t*nr_pages = remainder;\n\t/*\n\t * setting position is actually required only if remainder is\n\t * not zero but it's faster not to add a \"if (remainder)\"\n\t * branch.\n\t */\n\t*position = vaddr;\n\n\treturn i ? i : err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_vma_flags",
          "args": [
            "vma",
            "gup_flags"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "check_vma_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "571-616",
          "snippet": "static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tint write = (gup_flags & FOLL_WRITE);\n\tint foreign = (gup_flags & FOLL_REMOTE);\n\n\tif (vm_flags & (VM_IO | VM_PFNMAP))\n\t\treturn -EFAULT;\n\n\tif (gup_flags & FOLL_ANON && !vma_is_anonymous(vma))\n\t\treturn -EFAULT;\n\n\tif (write) {\n\t\tif (!(vm_flags & VM_WRITE)) {\n\t\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\t\treturn -EFAULT;\n\t\t\t/*\n\t\t\t * We used to let the write,force case do COW in a\n\t\t\t * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could\n\t\t\t * set a breakpoint in a read-only mapping of an\n\t\t\t * executable, without corrupting the file (yet only\n\t\t\t * when that file had been opened for writing!).\n\t\t\t * Anon pages in shared mappings are surprising: now\n\t\t\t * just reject it.\n\t\t\t */\n\t\t\tif (!is_cow_mapping(vm_flags))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (!(vm_flags & VM_READ)) {\n\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\treturn -EFAULT;\n\t\t/*\n\t\t * Is there actually any vma we can reach here which does not\n\t\t * have VM_MAYREAD set?\n\t\t */\n\t\tif (!(vm_flags & VM_MAYREAD))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * gups are always data accesses, not instruction\n\t * fetches, so execute=false here\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tint write = (gup_flags & FOLL_WRITE);\n\tint foreign = (gup_flags & FOLL_REMOTE);\n\n\tif (vm_flags & (VM_IO | VM_PFNMAP))\n\t\treturn -EFAULT;\n\n\tif (gup_flags & FOLL_ANON && !vma_is_anonymous(vma))\n\t\treturn -EFAULT;\n\n\tif (write) {\n\t\tif (!(vm_flags & VM_WRITE)) {\n\t\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\t\treturn -EFAULT;\n\t\t\t/*\n\t\t\t * We used to let the write,force case do COW in a\n\t\t\t * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could\n\t\t\t * set a breakpoint in a read-only mapping of an\n\t\t\t * executable, without corrupting the file (yet only\n\t\t\t * when that file had been opened for writing!).\n\t\t\t * Anon pages in shared mappings are surprising: now\n\t\t\t * just reject it.\n\t\t\t */\n\t\t\tif (!is_cow_mapping(vm_flags))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (!(vm_flags & VM_READ)) {\n\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\treturn -EFAULT;\n\t\t/*\n\t\t * Is there actually any vma we can reach here which does not\n\t\t * have VM_MAYREAD set?\n\t\t */\n\t\tif (!(vm_flags & VM_MAYREAD))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * gups are always data accesses, not instruction\n\t * fetches, so execute=false here\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gate_page",
          "args": [
            "mm",
            "start & PAGE_MASK",
            "gup_flags",
            "&vma",
            "pages ? &pages[i] : NULL"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "get_gate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "454-506",
          "snippet": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\n\t/* user gate pages are read-only */\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\n\t\t/*\n\t\t * This should never happen (a device public page in the gate\n\t\t * area).\n\t\t */\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\n\t/* user gate pages are read-only */\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\n\t\t/*\n\t\t * This should never happen (a device public page in the gate\n\t\t * area).\n\t\t */\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_gate_area",
          "args": [
            "mm",
            "start"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_extend_vma",
          "args": [
            "mm",
            "start"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "find_extend_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "803-806",
          "snippet": "struct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\treturn find_vma(mm, addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\treturn find_vma(mm, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!!pages != !!(gup_flags & FOLL_GET)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas, int *nonblocking)\n{\n\tlong ret = 0, i = 0;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct follow_page_context ctx = { NULL };\n\n\tif (!nr_pages)\n\t\treturn 0;\n\n\tVM_BUG_ON(!!pages != !!(gup_flags & FOLL_GET));\n\n\t/*\n\t * If FOLL_FORCE is set then do not force a full fault as the hinting\n\t * fault information is unrelated to the reference behaviour of a task\n\t * using the address space\n\t */\n\tif (!(gup_flags & FOLL_FORCE))\n\t\tgup_flags |= FOLL_NUMA;\n\n\tdo {\n\t\tstruct page *page;\n\t\tunsigned int foll_flags = gup_flags;\n\t\tunsigned int page_increm;\n\n\t\t/* first iteration or cross vma bound */\n\t\tif (!vma || start >= vma->vm_end) {\n\t\t\tvma = find_extend_vma(mm, start);\n\t\t\tif (!vma && in_gate_area(mm, start)) {\n\t\t\t\tret = get_gate_page(mm, start & PAGE_MASK,\n\t\t\t\t\t\tgup_flags, &vma,\n\t\t\t\t\t\tpages ? &pages[i] : NULL);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tctx.page_mask = 0;\n\t\t\t\tgoto next_page;\n\t\t\t}\n\n\t\t\tif (!vma || check_vma_flags(vma, gup_flags)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &nr_pages, i,\n\t\t\t\t\t\tgup_flags, nonblocking);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\nretry:\n\t\t/*\n\t\t * If we have a pending SIGKILL, don't keep faulting pages and\n\t\t * potentially allocating memory.\n\t\t */\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tgoto out;\n\t\t}\n\t\tcond_resched();\n\n\t\tpage = follow_page_mask(vma, start, foll_flags, &ctx);\n\t\tif (!page) {\n\t\t\tret = faultin_page(tsk, vma, start, &foll_flags,\n\t\t\t\t\tnonblocking);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tgoto retry;\n\t\t\tcase -EBUSY:\n\t\t\t\tret = 0;\n\t\t\t\t/* FALLTHRU */\n\t\t\tcase -EFAULT:\n\t\t\tcase -ENOMEM:\n\t\t\tcase -EHWPOISON:\n\t\t\t\tgoto out;\n\t\t\tcase -ENOENT:\n\t\t\t\tgoto next_page;\n\t\t\t}\n\t\t\tBUG();\n\t\t} else if (PTR_ERR(page) == -EEXIST) {\n\t\t\t/*\n\t\t\t * Proper page table entry exists, but no corresponding\n\t\t\t * struct page.\n\t\t\t */\n\t\t\tgoto next_page;\n\t\t} else if (IS_ERR(page)) {\n\t\t\tret = PTR_ERR(page);\n\t\t\tgoto out;\n\t\t}\n\t\tif (pages) {\n\t\t\tpages[i] = page;\n\t\t\tflush_anon_page(vma, page, start);\n\t\t\tflush_dcache_page(page);\n\t\t\tctx.page_mask = 0;\n\t\t}\nnext_page:\n\t\tif (vmas) {\n\t\t\tvmas[i] = vma;\n\t\t\tctx.page_mask = 0;\n\t\t}\n\t\tpage_increm = 1 + (~(start >> PAGE_SHIFT) & ctx.page_mask);\n\t\tif (page_increm > nr_pages)\n\t\t\tpage_increm = nr_pages;\n\t\ti += page_increm;\n\t\tstart += page_increm * PAGE_SIZE;\n\t\tnr_pages -= page_increm;\n\t} while (nr_pages);\nout:\n\tif (ctx.pgmap)\n\t\tput_dev_pagemap(ctx.pgmap);\n\treturn i ? i : ret;\n}"
  },
  {
    "function_name": "check_vma_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "571-616",
    "snippet": "static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tint write = (gup_flags & FOLL_WRITE);\n\tint foreign = (gup_flags & FOLL_REMOTE);\n\n\tif (vm_flags & (VM_IO | VM_PFNMAP))\n\t\treturn -EFAULT;\n\n\tif (gup_flags & FOLL_ANON && !vma_is_anonymous(vma))\n\t\treturn -EFAULT;\n\n\tif (write) {\n\t\tif (!(vm_flags & VM_WRITE)) {\n\t\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\t\treturn -EFAULT;\n\t\t\t/*\n\t\t\t * We used to let the write,force case do COW in a\n\t\t\t * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could\n\t\t\t * set a breakpoint in a read-only mapping of an\n\t\t\t * executable, without corrupting the file (yet only\n\t\t\t * when that file had been opened for writing!).\n\t\t\t * Anon pages in shared mappings are surprising: now\n\t\t\t * just reject it.\n\t\t\t */\n\t\t\tif (!is_cow_mapping(vm_flags))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (!(vm_flags & VM_READ)) {\n\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\treturn -EFAULT;\n\t\t/*\n\t\t * Is there actually any vma we can reach here which does not\n\t\t * have VM_MAYREAD set?\n\t\t */\n\t\tif (!(vm_flags & VM_MAYREAD))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * gups are always data accesses, not instruction\n\t * fetches, so execute=false here\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_vma_access_permitted",
          "args": [
            "vma",
            "write",
            "false",
            "foreign"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cow_mapping",
          "args": [
            "vm_flags"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "is_cow_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "247-250",
          "snippet": "static inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vma"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tint write = (gup_flags & FOLL_WRITE);\n\tint foreign = (gup_flags & FOLL_REMOTE);\n\n\tif (vm_flags & (VM_IO | VM_PFNMAP))\n\t\treturn -EFAULT;\n\n\tif (gup_flags & FOLL_ANON && !vma_is_anonymous(vma))\n\t\treturn -EFAULT;\n\n\tif (write) {\n\t\tif (!(vm_flags & VM_WRITE)) {\n\t\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\t\treturn -EFAULT;\n\t\t\t/*\n\t\t\t * We used to let the write,force case do COW in a\n\t\t\t * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could\n\t\t\t * set a breakpoint in a read-only mapping of an\n\t\t\t * executable, without corrupting the file (yet only\n\t\t\t * when that file had been opened for writing!).\n\t\t\t * Anon pages in shared mappings are surprising: now\n\t\t\t * just reject it.\n\t\t\t */\n\t\t\tif (!is_cow_mapping(vm_flags))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (!(vm_flags & VM_READ)) {\n\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\treturn -EFAULT;\n\t\t/*\n\t\t * Is there actually any vma we can reach here which does not\n\t\t * have VM_MAYREAD set?\n\t\t */\n\t\tif (!(vm_flags & VM_MAYREAD))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * gups are always data accesses, not instruction\n\t * fetches, so execute=false here\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "faultin_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "513-569",
    "snippet": "static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tvm_fault_t ret;\n\n\t/* mlock all present pages, but do not fault in new pages */\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tint err = vm_fault_to_errno(ret, *flags);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tBUG();\n\t}\n\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking && !(fault_flags & FAULT_FLAG_RETRY_NOWAIT))\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when\n\t * necessary, even if maybe_mkwrite decided not to set pte_write. We\n\t * can thus safely do subsequent page lookups as if they were reads.\n\t * But only do so when looping for pte_write is futile: in some cases\n\t * userspace may also be wanting to write to the gotten user page,\n\t * which a read fault here might prevent (a readonly page might get\n\t * reCOWed by userspace write).\n\t */\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags |= FOLL_COW;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_fault_to_errno",
          "args": [
            "ret",
            "*flags"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_mm_fault",
          "args": [
            "vma",
            "address",
            "fault_flags"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "handle_mm_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3898-3941",
          "snippet": "vm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags)\n{\n\tvm_fault_t ret;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tcount_memcg_event_mm(vma->vm_mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (!arch_vma_access_permitted(vma, flags & FAULT_FLAG_WRITE,\n\t\t\t\t\t    flags & FAULT_FLAG_INSTRUCTION,\n\t\t\t\t\t    flags & FAULT_FLAG_REMOTE))\n\t\treturn VM_FAULT_SIGSEGV;\n\n\t/*\n\t * Enable the memcg OOM handling for faults triggered in user\n\t * space.  Kernel faults are handled more gracefully.\n\t */\n\tif (flags & FAULT_FLAG_USER)\n\t\tmem_cgroup_enter_user_fault();\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\tret = hugetlb_fault(vma->vm_mm, vma, address, flags);\n\telse\n\t\tret = __handle_mm_fault(vma, address, flags);\n\n\tif (flags & FAULT_FLAG_USER) {\n\t\tmem_cgroup_exit_user_fault();\n\t\t/*\n\t\t * The task may have entered a memcg OOM situation but\n\t\t * if the allocation error was handled gracefully (no\n\t\t * VM_FAULT_OOM), there is no need to kill anything.\n\t\t * Just clean up the OOM state peacefully.\n\t\t */\n\t\tif (task_in_memcg_oom(current) && !(ret & VM_FAULT_OOM))\n\t\t\tmem_cgroup_oom_synchronize(false);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags)\n{\n\tvm_fault_t ret;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tcount_memcg_event_mm(vma->vm_mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (!arch_vma_access_permitted(vma, flags & FAULT_FLAG_WRITE,\n\t\t\t\t\t    flags & FAULT_FLAG_INSTRUCTION,\n\t\t\t\t\t    flags & FAULT_FLAG_REMOTE))\n\t\treturn VM_FAULT_SIGSEGV;\n\n\t/*\n\t * Enable the memcg OOM handling for faults triggered in user\n\t * space.  Kernel faults are handled more gracefully.\n\t */\n\tif (flags & FAULT_FLAG_USER)\n\t\tmem_cgroup_enter_user_fault();\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\tret = hugetlb_fault(vma->vm_mm, vma, address, flags);\n\telse\n\t\tret = __handle_mm_fault(vma, address, flags);\n\n\tif (flags & FAULT_FLAG_USER) {\n\t\tmem_cgroup_exit_user_fault();\n\t\t/*\n\t\t * The task may have entered a memcg OOM situation but\n\t\t * if the allocation error was handled gracefully (no\n\t\t * VM_FAULT_OOM), there is no need to kill anything.\n\t\t * Just clean up the OOM state peacefully.\n\t\t */\n\t\tif (task_in_memcg_oom(current) && !(ret & VM_FAULT_OOM))\n\t\t\tmem_cgroup_oom_synchronize(false);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON_ONCE",
          "args": [
            "fault_flags & FAULT_FLAG_ALLOW_RETRY"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tvm_fault_t ret;\n\n\t/* mlock all present pages, but do not fault in new pages */\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tint err = vm_fault_to_errno(ret, *flags);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tBUG();\n\t}\n\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking && !(fault_flags & FAULT_FLAG_RETRY_NOWAIT))\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when\n\t * necessary, even if maybe_mkwrite decided not to set pte_write. We\n\t * can thus safely do subsequent page lookups as if they were reads.\n\t * But only do so when looping for pte_write is futile: in some cases\n\t * userspace may also be wanting to write to the gotten user page,\n\t * which a read fault here might prevent (a readonly page might get\n\t * reCOWed by userspace write).\n\t */\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags |= FOLL_COW;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_gate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "454-506",
    "snippet": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\n\t/* user gate pages are read-only */\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\n\t\t/*\n\t\t * This should never happen (a device public page in the gate\n\t\t * area).\n\t\t */\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "pte"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "*page"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_device_public_page",
          "args": [
            "*page"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "*pte"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pte_pfn(*pte)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*pte"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "*vma",
            "address",
            "*pte"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "vm_normal_page_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "651-689",
          "snippet": "struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gate_vma",
          "args": [
            "mm"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*pte"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmd",
            "address"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "pmd_trans_huge(*pmd)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "*pmd"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "address"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pud_none(*pud)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_none",
          "args": [
            "*pud"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "address"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p4d_none(*p4d)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_none",
          "args": [
            "*p4d"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "address"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pgd_none(*pgd)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_none",
          "args": [
            "*pgd"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset_gate",
          "args": [
            "mm",
            "address"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset_k",
          "args": [
            "address"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\n\t/* user gate pages are read-only */\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\n\t\t/*\n\t\t * This should never happen (a device public page in the gate\n\t\t * area).\n\t\t */\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}"
  },
  {
    "function_name": "follow_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "442-452",
    "snippet": "struct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\tstruct follow_page_context ctx = { NULL };\n\tstruct page *page;\n\n\tpage = follow_page_mask(vma, address, foll_flags, &ctx);\n\tif (ctx.pgmap)\n\t\tput_dev_pagemap(ctx.pgmap);\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_dev_pagemap",
          "args": [
            "ctx.pgmap"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_page_mask",
          "args": [
            "vma",
            "address",
            "foll_flags",
            "&ctx"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "follow_page_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "402-440",
          "snippet": "struct page *follow_page_mask(struct vm_area_struct *vma,\n\t\t\t      unsigned long address, unsigned int flags,\n\t\t\t      struct follow_page_context *ctx)\n{\n\tpgd_t *pgd;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tctx->page_mask = 0;\n\n\t/* make this handle hugepd */\n\tpage = follow_huge_addr(mm, address, flags & FOLL_WRITE);\n\tif (!IS_ERR(page)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\treturn page;\n\t}\n\n\tpgd = pgd_offset(mm, address);\n\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\treturn no_page_table(vma, flags);\n\n\tif (pgd_huge(*pgd)) {\n\t\tpage = follow_huge_pgd(mm, address, pgd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pgd_val(*pgd)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pgd_val(*pgd)), flags,\n\t\t\t\t      PGDIR_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\n\treturn follow_p4d_mask(vma, address, pgd, flags, ctx);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstruct page *follow_page_mask(struct vm_area_struct *vma,\n\t\t\t      unsigned long address, unsigned int flags,\n\t\t\t      struct follow_page_context *ctx)\n{\n\tpgd_t *pgd;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tctx->page_mask = 0;\n\n\t/* make this handle hugepd */\n\tpage = follow_huge_addr(mm, address, flags & FOLL_WRITE);\n\tif (!IS_ERR(page)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\treturn page;\n\t}\n\n\tpgd = pgd_offset(mm, address);\n\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\treturn no_page_table(vma, flags);\n\n\tif (pgd_huge(*pgd)) {\n\t\tpage = follow_huge_pgd(mm, address, pgd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pgd_val(*pgd)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pgd_val(*pgd)), flags,\n\t\t\t\t      PGDIR_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\n\treturn follow_p4d_mask(vma, address, pgd, flags, ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstruct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\tstruct follow_page_context ctx = { NULL };\n\tstruct page *page;\n\n\tpage = follow_page_mask(vma, address, foll_flags, &ctx);\n\tif (ctx.pgmap)\n\t\tput_dev_pagemap(ctx.pgmap);\n\treturn page;\n}"
  },
  {
    "function_name": "follow_page_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "402-440",
    "snippet": "struct page *follow_page_mask(struct vm_area_struct *vma,\n\t\t\t      unsigned long address, unsigned int flags,\n\t\t\t      struct follow_page_context *ctx)\n{\n\tpgd_t *pgd;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tctx->page_mask = 0;\n\n\t/* make this handle hugepd */\n\tpage = follow_huge_addr(mm, address, flags & FOLL_WRITE);\n\tif (!IS_ERR(page)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\treturn page;\n\t}\n\n\tpgd = pgd_offset(mm, address);\n\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\treturn no_page_table(vma, flags);\n\n\tif (pgd_huge(*pgd)) {\n\t\tpage = follow_huge_pgd(mm, address, pgd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pgd_val(*pgd)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pgd_val(*pgd)), flags,\n\t\t\t\t      PGDIR_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\n\treturn follow_p4d_mask(vma, address, pgd, flags, ctx);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "follow_p4d_mask",
          "args": [
            "vma",
            "address",
            "pgd",
            "flags",
            "ctx"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "follow_p4d_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "357-381",
          "snippet": "static struct page *follow_p4d_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pgd_t *pgdp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tp4d_t *p4d;\n\tstruct page *page;\n\n\tp4d = p4d_offset(pgdp, address);\n\tif (p4d_none(*p4d))\n\t\treturn no_page_table(vma, flags);\n\tBUILD_BUG_ON(p4d_huge(*p4d));\n\tif (unlikely(p4d_bad(*p4d)))\n\t\treturn no_page_table(vma, flags);\n\n\tif (is_hugepd(__hugepd(p4d_val(*p4d)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(p4d_val(*p4d)), flags,\n\t\t\t\t      P4D_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\treturn follow_pud_mask(vma, address, p4d, flags, ctx);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *follow_p4d_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pgd_t *pgdp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tp4d_t *p4d;\n\tstruct page *page;\n\n\tp4d = p4d_offset(pgdp, address);\n\tif (p4d_none(*p4d))\n\t\treturn no_page_table(vma, flags);\n\tBUILD_BUG_ON(p4d_huge(*p4d));\n\tif (unlikely(p4d_bad(*p4d)))\n\t\treturn no_page_table(vma, flags);\n\n\tif (is_hugepd(__hugepd(p4d_val(*p4d)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(p4d_val(*p4d)), flags,\n\t\t\t\t      P4D_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\treturn follow_pud_mask(vma, address, p4d, flags, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_page_table",
          "args": [
            "vma",
            "flags"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "no_page_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "28-42",
          "snippet": "static struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "follow_huge_pd",
          "args": [
            "vma",
            "address",
            "__hugepd(pgd_val(*pgd))",
            "flags",
            "PGDIR_SHIFT"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "follow_huge_pd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4827-4833",
          "snippet": "struct page * __weak\nfollow_huge_pd(struct vm_area_struct *vma,\n\t       unsigned long address, hugepd_t hpd, int flags, int pdshift)\n{\n\tWARN(1, \"hugepd follow called with no support for hugepage directory format\\n\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_pd(struct vm_area_struct *vma,\n\t       unsigned long address, hugepd_t hpd, int flags, int pdshift)\n{\n\tWARN(1, \"hugepd follow called with no support for hugepage directory format\\n\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pgd_val(*pgd)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_val",
          "args": [
            "*pgd"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugepd",
          "args": [
            "__hugepd(pgd_val(*pgd))"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pgd_val(*pgd)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_val",
          "args": [
            "*pgd"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_huge_pgd",
          "args": [
            "mm",
            "address",
            "pgd",
            "flags"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "follow_huge_pgd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4882-4889",
          "snippet": "struct page * __weak\nfollow_huge_pgd(struct mm_struct *mm, unsigned long address, pgd_t *pgd, int flags)\n{\n\tif (flags & FOLL_GET)\n\t\treturn NULL;\n\n\treturn pte_page(*(pte_t *)pgd) + ((address & ~PGDIR_MASK) >> PAGE_SHIFT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_pgd(struct mm_struct *mm, unsigned long address, pgd_t *pgd, int flags)\n{\n\tif (flags & FOLL_GET)\n\t\treturn NULL;\n\n\treturn pte_page(*(pte_t *)pgd) + ((address & ~PGDIR_MASK) >> PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_huge",
          "args": [
            "*pgd"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pgd_bad(*pgd)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_bad",
          "args": [
            "*pgd"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_none",
          "args": [
            "*pgd"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "address"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "flags & FOLL_GET"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_huge_addr",
          "args": [
            "mm",
            "address",
            "flags & FOLL_WRITE"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "follow_huge_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4820-4825",
          "snippet": "struct page * __weak\nfollow_huge_addr(struct mm_struct *mm, unsigned long address,\n\t\t\t      int write)\n{\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_addr(struct mm_struct *mm, unsigned long address,\n\t\t\t      int write)\n{\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstruct page *follow_page_mask(struct vm_area_struct *vma,\n\t\t\t      unsigned long address, unsigned int flags,\n\t\t\t      struct follow_page_context *ctx)\n{\n\tpgd_t *pgd;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tctx->page_mask = 0;\n\n\t/* make this handle hugepd */\n\tpage = follow_huge_addr(mm, address, flags & FOLL_WRITE);\n\tif (!IS_ERR(page)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\treturn page;\n\t}\n\n\tpgd = pgd_offset(mm, address);\n\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\treturn no_page_table(vma, flags);\n\n\tif (pgd_huge(*pgd)) {\n\t\tpage = follow_huge_pgd(mm, address, pgd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pgd_val(*pgd)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pgd_val(*pgd)), flags,\n\t\t\t\t      PGDIR_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\n\treturn follow_p4d_mask(vma, address, pgd, flags, ctx);\n}"
  },
  {
    "function_name": "follow_p4d_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "357-381",
    "snippet": "static struct page *follow_p4d_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pgd_t *pgdp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tp4d_t *p4d;\n\tstruct page *page;\n\n\tp4d = p4d_offset(pgdp, address);\n\tif (p4d_none(*p4d))\n\t\treturn no_page_table(vma, flags);\n\tBUILD_BUG_ON(p4d_huge(*p4d));\n\tif (unlikely(p4d_bad(*p4d)))\n\t\treturn no_page_table(vma, flags);\n\n\tif (is_hugepd(__hugepd(p4d_val(*p4d)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(p4d_val(*p4d)), flags,\n\t\t\t\t      P4D_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\treturn follow_pud_mask(vma, address, p4d, flags, ctx);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "follow_pud_mask",
          "args": [
            "vma",
            "address",
            "p4d",
            "flags",
            "ctx"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "follow_pud_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "317-355",
          "snippet": "static struct page *follow_pud_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, p4d_t *p4dp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpud_t *pud;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpud = pud_offset(p4dp, address);\n\tif (pud_none(*pud))\n\t\treturn no_page_table(vma, flags);\n\tif (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pud(mm, address, pud, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pud_val(*pud)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pud_val(*pud)), flags,\n\t\t\t\t      PUD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (pud_devmap(*pud)) {\n\t\tptl = pud_lock(mm, pud);\n\t\tpage = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(pud_bad(*pud)))\n\t\treturn no_page_table(vma, flags);\n\n\treturn follow_pmd_mask(vma, address, pud, flags, ctx);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *follow_pud_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, p4d_t *p4dp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpud_t *pud;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpud = pud_offset(p4dp, address);\n\tif (pud_none(*pud))\n\t\treturn no_page_table(vma, flags);\n\tif (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pud(mm, address, pud, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pud_val(*pud)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pud_val(*pud)), flags,\n\t\t\t\t      PUD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (pud_devmap(*pud)) {\n\t\tptl = pud_lock(mm, pud);\n\t\tpage = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(pud_bad(*pud)))\n\t\treturn no_page_table(vma, flags);\n\n\treturn follow_pmd_mask(vma, address, pud, flags, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_page_table",
          "args": [
            "vma",
            "flags"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "no_page_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "28-42",
          "snippet": "static struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "follow_huge_pd",
          "args": [
            "vma",
            "address",
            "__hugepd(p4d_val(*p4d))",
            "flags",
            "P4D_SHIFT"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "follow_huge_pd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4827-4833",
          "snippet": "struct page * __weak\nfollow_huge_pd(struct vm_area_struct *vma,\n\t       unsigned long address, hugepd_t hpd, int flags, int pdshift)\n{\n\tWARN(1, \"hugepd follow called with no support for hugepage directory format\\n\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_pd(struct vm_area_struct *vma,\n\t       unsigned long address, hugepd_t hpd, int flags, int pdshift)\n{\n\tWARN(1, \"hugepd follow called with no support for hugepage directory format\\n\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "p4d_val(*p4d)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_val",
          "args": [
            "*p4d"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugepd",
          "args": [
            "__hugepd(p4d_val(*p4d))"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "p4d_val(*p4d)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_val",
          "args": [
            "*p4d"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p4d_bad(*p4d)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_bad",
          "args": [
            "*p4d"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "p4d_huge(*p4d)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_huge",
          "args": [
            "*p4d"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_none",
          "args": [
            "*p4d"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgdp",
            "address"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *follow_p4d_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pgd_t *pgdp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tp4d_t *p4d;\n\tstruct page *page;\n\n\tp4d = p4d_offset(pgdp, address);\n\tif (p4d_none(*p4d))\n\t\treturn no_page_table(vma, flags);\n\tBUILD_BUG_ON(p4d_huge(*p4d));\n\tif (unlikely(p4d_bad(*p4d)))\n\t\treturn no_page_table(vma, flags);\n\n\tif (is_hugepd(__hugepd(p4d_val(*p4d)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(p4d_val(*p4d)), flags,\n\t\t\t\t      P4D_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\treturn follow_pud_mask(vma, address, p4d, flags, ctx);\n}"
  },
  {
    "function_name": "follow_pud_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "317-355",
    "snippet": "static struct page *follow_pud_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, p4d_t *p4dp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpud_t *pud;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpud = pud_offset(p4dp, address);\n\tif (pud_none(*pud))\n\t\treturn no_page_table(vma, flags);\n\tif (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pud(mm, address, pud, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pud_val(*pud)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pud_val(*pud)), flags,\n\t\t\t\t      PUD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (pud_devmap(*pud)) {\n\t\tptl = pud_lock(mm, pud);\n\t\tpage = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(pud_bad(*pud)))\n\t\treturn no_page_table(vma, flags);\n\n\treturn follow_pmd_mask(vma, address, pud, flags, ctx);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "follow_pmd_mask",
          "args": [
            "vma",
            "address",
            "pud",
            "flags",
            "ctx"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "follow_pmd_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "209-315",
          "snippet": "static struct page *follow_pmd_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pud_t *pudp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpmd_t *pmd, pmdval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpmd = pmd_offset(pudp, address);\n\t/*\n\t * The READ_ONCE() will stabilize the pmdval in a register or\n\t * on the stack so that it will stop changing under the code.\n\t */\n\tpmdval = READ_ONCE(*pmd);\n\tif (pmd_none(pmdval))\n\t\treturn no_page_table(vma, flags);\n\tif (pmd_huge(pmdval) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pmd_val(pmdval)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pmd_val(pmdval)), flags,\n\t\t\t\t      PMD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\nretry:\n\tif (!pmd_present(pmdval)) {\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(pmdval));\n\t\tif (is_pmd_migration_entry(pmdval))\n\t\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tpmdval = READ_ONCE(*pmd);\n\t\t/*\n\t\t * MADV_DONTNEED may convert the pmd to null because\n\t\t * mmap_sem is held in read mode\n\t\t */\n\t\tif (pmd_none(pmdval))\n\t\t\treturn no_page_table(vma, flags);\n\t\tgoto retry;\n\t}\n\tif (pmd_devmap(pmdval)) {\n\t\tptl = pmd_lock(mm, pmd);\n\t\tpage = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (likely(!pmd_trans_huge(pmdval)))\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\n\tif ((flags & FOLL_NUMA) && pmd_protnone(pmdval))\n\t\treturn no_page_table(vma, flags);\n\nretry_locked:\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(pmd_none(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (unlikely(!pmd_present(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tgoto retry_locked;\n\t}\n\tif (unlikely(!pmd_trans_huge(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tif (flags & FOLL_SPLIT) {\n\t\tint ret;\n\t\tpage = pmd_page(*pmd);\n\t\tif (is_huge_zero_page(page)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tret = 0;\n\t\t\tsplit_huge_pmd(vma, pmd, address);\n\t\t\tif (pmd_trans_unstable(pmd))\n\t\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tget_page(page);\n\t\t\tspin_unlock(ptl);\n\t\t\tlock_page(page);\n\t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn no_page_table(vma, flags);\n\t\t}\n\n\t\treturn ret ? ERR_PTR(ret) :\n\t\t\tfollow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tpage = follow_trans_huge_pmd(vma, address, pmd, flags);\n\tspin_unlock(ptl);\n\tctx->page_mask = HPAGE_PMD_NR - 1;\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *follow_pmd_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pud_t *pudp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpmd_t *pmd, pmdval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpmd = pmd_offset(pudp, address);\n\t/*\n\t * The READ_ONCE() will stabilize the pmdval in a register or\n\t * on the stack so that it will stop changing under the code.\n\t */\n\tpmdval = READ_ONCE(*pmd);\n\tif (pmd_none(pmdval))\n\t\treturn no_page_table(vma, flags);\n\tif (pmd_huge(pmdval) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pmd_val(pmdval)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pmd_val(pmdval)), flags,\n\t\t\t\t      PMD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\nretry:\n\tif (!pmd_present(pmdval)) {\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(pmdval));\n\t\tif (is_pmd_migration_entry(pmdval))\n\t\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tpmdval = READ_ONCE(*pmd);\n\t\t/*\n\t\t * MADV_DONTNEED may convert the pmd to null because\n\t\t * mmap_sem is held in read mode\n\t\t */\n\t\tif (pmd_none(pmdval))\n\t\t\treturn no_page_table(vma, flags);\n\t\tgoto retry;\n\t}\n\tif (pmd_devmap(pmdval)) {\n\t\tptl = pmd_lock(mm, pmd);\n\t\tpage = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (likely(!pmd_trans_huge(pmdval)))\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\n\tif ((flags & FOLL_NUMA) && pmd_protnone(pmdval))\n\t\treturn no_page_table(vma, flags);\n\nretry_locked:\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(pmd_none(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (unlikely(!pmd_present(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tgoto retry_locked;\n\t}\n\tif (unlikely(!pmd_trans_huge(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tif (flags & FOLL_SPLIT) {\n\t\tint ret;\n\t\tpage = pmd_page(*pmd);\n\t\tif (is_huge_zero_page(page)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tret = 0;\n\t\t\tsplit_huge_pmd(vma, pmd, address);\n\t\t\tif (pmd_trans_unstable(pmd))\n\t\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tget_page(page);\n\t\t\tspin_unlock(ptl);\n\t\t\tlock_page(page);\n\t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn no_page_table(vma, flags);\n\t\t}\n\n\t\treturn ret ? ERR_PTR(ret) :\n\t\t\tfollow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tpage = follow_trans_huge_pmd(vma, address, pmd, flags);\n\tspin_unlock(ptl);\n\tctx->page_mask = HPAGE_PMD_NR - 1;\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_page_table",
          "args": [
            "vma",
            "flags"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "no_page_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "28-42",
          "snippet": "static struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pud_bad(*pud)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_bad",
          "args": [
            "*pud"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_devmap_pud",
          "args": [
            "vma",
            "address",
            "pud",
            "flags",
            "&ctx->pgmap"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "follow_devmap_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1019-1054",
          "snippet": "struct page *follow_devmap_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pud_pfn(*pud);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\n\tassert_spin_locked(pud_lockptr(mm, pud));\n\n\tif (flags & FOLL_WRITE && !pud_write(*pud))\n\t\treturn NULL;\n\n\tif (pud_present(*pud) && pud_devmap(*pud))\n\t\t/* pass */;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pud(vma, addr, pud, flags);\n\n\t/*\n\t * device mapped pages can only be returned if the\n\t * caller will manage the page reference count.\n\t */\n\tif (!(flags & FOLL_GET))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PUD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\tget_page(page);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstruct page *follow_devmap_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pud_pfn(*pud);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\n\tassert_spin_locked(pud_lockptr(mm, pud));\n\n\tif (flags & FOLL_WRITE && !pud_write(*pud))\n\t\treturn NULL;\n\n\tif (pud_present(*pud) && pud_devmap(*pud))\n\t\t/* pass */;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pud(vma, addr, pud, flags);\n\n\t/*\n\t * device mapped pages can only be returned if the\n\t * caller will manage the page reference count.\n\t */\n\tif (!(flags & FOLL_GET))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PUD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\tget_page(page);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_lock",
          "args": [
            "mm",
            "pud"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_devmap",
          "args": [
            "*pud"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_huge_pd",
          "args": [
            "vma",
            "address",
            "__hugepd(pud_val(*pud))",
            "flags",
            "PUD_SHIFT"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "follow_huge_pd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4827-4833",
          "snippet": "struct page * __weak\nfollow_huge_pd(struct vm_area_struct *vma,\n\t       unsigned long address, hugepd_t hpd, int flags, int pdshift)\n{\n\tWARN(1, \"hugepd follow called with no support for hugepage directory format\\n\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_pd(struct vm_area_struct *vma,\n\t       unsigned long address, hugepd_t hpd, int flags, int pdshift)\n{\n\tWARN(1, \"hugepd follow called with no support for hugepage directory format\\n\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pud_val(*pud)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_val",
          "args": [
            "*pud"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugepd",
          "args": [
            "__hugepd(pud_val(*pud))"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pud_val(*pud)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_val",
          "args": [
            "*pud"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_huge_pud",
          "args": [
            "mm",
            "address",
            "pud",
            "flags"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "follow_huge_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4872-4880",
          "snippet": "struct page * __weak\nfollow_huge_pud(struct mm_struct *mm, unsigned long address,\n\t\tpud_t *pud, int flags)\n{\n\tif (flags & FOLL_GET)\n\t\treturn NULL;\n\n\treturn pte_page(*(pte_t *)pud) + ((address & ~PUD_MASK) >> PAGE_SHIFT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_pud(struct mm_struct *mm, unsigned long address,\n\t\tpud_t *pud, int flags)\n{\n\tif (flags & FOLL_GET)\n\t\treturn NULL;\n\n\treturn pte_page(*(pte_t *)pud) + ((address & ~PUD_MASK) >> PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_huge",
          "args": [
            "*pud"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_none",
          "args": [
            "*pud"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4dp",
            "address"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *follow_pud_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, p4d_t *p4dp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpud_t *pud;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpud = pud_offset(p4dp, address);\n\tif (pud_none(*pud))\n\t\treturn no_page_table(vma, flags);\n\tif (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pud(mm, address, pud, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pud_val(*pud)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pud_val(*pud)), flags,\n\t\t\t\t      PUD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (pud_devmap(*pud)) {\n\t\tptl = pud_lock(mm, pud);\n\t\tpage = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(pud_bad(*pud)))\n\t\treturn no_page_table(vma, flags);\n\n\treturn follow_pmd_mask(vma, address, pud, flags, ctx);\n}"
  },
  {
    "function_name": "follow_pmd_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "209-315",
    "snippet": "static struct page *follow_pmd_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pud_t *pudp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpmd_t *pmd, pmdval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpmd = pmd_offset(pudp, address);\n\t/*\n\t * The READ_ONCE() will stabilize the pmdval in a register or\n\t * on the stack so that it will stop changing under the code.\n\t */\n\tpmdval = READ_ONCE(*pmd);\n\tif (pmd_none(pmdval))\n\t\treturn no_page_table(vma, flags);\n\tif (pmd_huge(pmdval) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pmd_val(pmdval)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pmd_val(pmdval)), flags,\n\t\t\t\t      PMD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\nretry:\n\tif (!pmd_present(pmdval)) {\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(pmdval));\n\t\tif (is_pmd_migration_entry(pmdval))\n\t\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tpmdval = READ_ONCE(*pmd);\n\t\t/*\n\t\t * MADV_DONTNEED may convert the pmd to null because\n\t\t * mmap_sem is held in read mode\n\t\t */\n\t\tif (pmd_none(pmdval))\n\t\t\treturn no_page_table(vma, flags);\n\t\tgoto retry;\n\t}\n\tif (pmd_devmap(pmdval)) {\n\t\tptl = pmd_lock(mm, pmd);\n\t\tpage = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (likely(!pmd_trans_huge(pmdval)))\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\n\tif ((flags & FOLL_NUMA) && pmd_protnone(pmdval))\n\t\treturn no_page_table(vma, flags);\n\nretry_locked:\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(pmd_none(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (unlikely(!pmd_present(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tgoto retry_locked;\n\t}\n\tif (unlikely(!pmd_trans_huge(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tif (flags & FOLL_SPLIT) {\n\t\tint ret;\n\t\tpage = pmd_page(*pmd);\n\t\tif (is_huge_zero_page(page)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tret = 0;\n\t\t\tsplit_huge_pmd(vma, pmd, address);\n\t\t\tif (pmd_trans_unstable(pmd))\n\t\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tget_page(page);\n\t\t\tspin_unlock(ptl);\n\t\t\tlock_page(page);\n\t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn no_page_table(vma, flags);\n\t\t}\n\n\t\treturn ret ? ERR_PTR(ret) :\n\t\t\tfollow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tpage = follow_trans_huge_pmd(vma, address, pmd, flags);\n\tspin_unlock(ptl);\n\tctx->page_mask = HPAGE_PMD_NR - 1;\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_trans_huge_pmd",
          "args": [
            "vma",
            "address",
            "pmd",
            "flags"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "follow_trans_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1408-1474",
          "snippet": "struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   pmd_t *pmd,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page = NULL;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\tif (flags & FOLL_WRITE && !can_follow_write_pmd(*pmd, flags))\n\t\tgoto out;\n\n\t/* Avoid dumping huge zero page */\n\tif ((flags & FOLL_DUMP) && is_huge_zero_pmd(*pmd))\n\t\treturn ERR_PTR(-EFAULT);\n\n\t/* Full NUMA hinting faults to serialise migration in fault paths */\n\tif ((flags & FOLL_NUMA) && pmd_protnone(*pmd))\n\t\tgoto out;\n\n\tpage = pmd_page(*pmd);\n\tVM_BUG_ON_PAGE(!PageHead(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags);\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/*\n\t\t * We don't mlock() pte-mapped THPs. This way we can avoid\n\t\t * leaking mlocked pages into non-VM_LOCKED VMAs.\n\t\t *\n\t\t * For anon THP:\n\t\t *\n\t\t * In most cases the pmd is the only mapping of the page as we\n\t\t * break COW for the mlock() -- see gup_flags |= FOLL_WRITE for\n\t\t * writable private mappings in populate_vma_page_range().\n\t\t *\n\t\t * The only scenario when we have the page shared here is if we\n\t\t * mlocking read-only mapping shared over fork(). We skip\n\t\t * mlocking such pages.\n\t\t *\n\t\t * For file THP:\n\t\t *\n\t\t * We can expect PageDoubleMap() to be stable under page lock:\n\t\t * for file pages we set it in page_add_file_rmap(), which\n\t\t * requires page to be locked.\n\t\t */\n\n\t\tif (PageAnon(page) && compound_mapcount(page) != 1)\n\t\t\tgoto skip_mlock;\n\t\tif (PageDoubleMap(page) || !page->mapping)\n\t\t\tgoto skip_mlock;\n\t\tif (!trylock_page(page))\n\t\t\tgoto skip_mlock;\n\t\tlru_add_drain();\n\t\tif (page->mapping && !PageDoubleMap(page))\n\t\t\tmlock_vma_page(page);\n\t\tunlock_page(page);\n\t}\nskip_mlock:\n\tpage += (addr & ~HPAGE_PMD_MASK) >> PAGE_SHIFT;\n\tVM_BUG_ON_PAGE(!PageCompound(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\nout:\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstruct page *follow_trans_huge_pmd(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   pmd_t *pmd,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page = NULL;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\tif (flags & FOLL_WRITE && !can_follow_write_pmd(*pmd, flags))\n\t\tgoto out;\n\n\t/* Avoid dumping huge zero page */\n\tif ((flags & FOLL_DUMP) && is_huge_zero_pmd(*pmd))\n\t\treturn ERR_PTR(-EFAULT);\n\n\t/* Full NUMA hinting faults to serialise migration in fault paths */\n\tif ((flags & FOLL_NUMA) && pmd_protnone(*pmd))\n\t\tgoto out;\n\n\tpage = pmd_page(*pmd);\n\tVM_BUG_ON_PAGE(!PageHead(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags);\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/*\n\t\t * We don't mlock() pte-mapped THPs. This way we can avoid\n\t\t * leaking mlocked pages into non-VM_LOCKED VMAs.\n\t\t *\n\t\t * For anon THP:\n\t\t *\n\t\t * In most cases the pmd is the only mapping of the page as we\n\t\t * break COW for the mlock() -- see gup_flags |= FOLL_WRITE for\n\t\t * writable private mappings in populate_vma_page_range().\n\t\t *\n\t\t * The only scenario when we have the page shared here is if we\n\t\t * mlocking read-only mapping shared over fork(). We skip\n\t\t * mlocking such pages.\n\t\t *\n\t\t * For file THP:\n\t\t *\n\t\t * We can expect PageDoubleMap() to be stable under page lock:\n\t\t * for file pages we set it in page_add_file_rmap(), which\n\t\t * requires page to be locked.\n\t\t */\n\n\t\tif (PageAnon(page) && compound_mapcount(page) != 1)\n\t\t\tgoto skip_mlock;\n\t\tif (PageDoubleMap(page) || !page->mapping)\n\t\t\tgoto skip_mlock;\n\t\tif (!trylock_page(page))\n\t\t\tgoto skip_mlock;\n\t\tlru_add_drain();\n\t\tif (page->mapping && !PageDoubleMap(page))\n\t\t\tmlock_vma_page(page);\n\t\tunlock_page(page);\n\t}\nskip_mlock:\n\tpage += (addr & ~HPAGE_PMD_MASK) >> PAGE_SHIFT;\n\tVM_BUG_ON_PAGE(!PageCompound(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "follow_page_pte",
          "args": [
            "vma",
            "address",
            "pmd",
            "flags",
            "&ctx->pgmap"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "follow_page_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "78-207",
          "snippet": "static struct page *follow_page_pte(struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd, unsigned int flags,\n\t\tstruct dev_pagemap **pgmap)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t *ptep, pte;\n\nretry:\n\tif (unlikely(pmd_bad(*pmd)))\n\t\treturn no_page_table(vma, flags);\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tpte = *ptep;\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry;\n\t\t/*\n\t\t * KSM's break_ksm() relies upon recognizing a ksm page\n\t\t * even while it is being migrated, so for that case we\n\t\t * need migration_entry_wait().\n\t\t */\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\tgoto no_page;\n\t\tif (pte_none(pte))\n\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n\n\tpage = vm_normal_page(vma, address, pte);\n\tif (!page && pte_devmap(pte) && (flags & FOLL_GET)) {\n\t\t/*\n\t\t * Only return device mapping pages in the FOLL_GET case since\n\t\t * they are only valid while holding the pgmap reference.\n\t\t */\n\t\t*pgmap = get_dev_pagemap(pte_pfn(pte), *pgmap);\n\t\tif (*pgmap)\n\t\t\tpage = pte_page(pte);\n\t\telse\n\t\t\tgoto no_page;\n\t} else if (unlikely(!page)) {\n\t\tif (flags & FOLL_DUMP) {\n\t\t\t/* Avoid special (like zero) pages in core dumps */\n\t\t\tpage = ERR_PTR(-EFAULT);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (is_zero_pfn(pte_pfn(pte))) {\n\t\t\tpage = pte_page(pte);\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tret = follow_pfn_pte(vma, address, ptep, flags);\n\t\t\tpage = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (flags & FOLL_SPLIT && PageTransCompound(page)) {\n\t\tint ret;\n\t\tget_page(page);\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tlock_page(page);\n\t\tret = split_huge_page(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tgoto retry;\n\t}\n\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * pte_mkyoung() would be more correct here, but atomic care\n\t\t * is needed to avoid losing the dirty bit: it is easier to use\n\t\t * mark_page_accessed().\n\t\t */\n\t\tmark_page_accessed(page);\n\t}\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/* Do not mlock pte-mapped THP */\n\t\tif (PageTransCompound(page))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * The preliminary mapping check is mainly to avoid the\n\t\t * pointless overhead of lock_page on the ZERO_PAGE\n\t\t * which might bounce very badly if there is contention.\n\t\t *\n\t\t * If the page is already locked, we don't need to\n\t\t * handle it now - vmscan will handle it later if and\n\t\t * when it attempts to reclaim the page.\n\t\t */\n\t\tif (page->mapping && trylock_page(page)) {\n\t\t\tlru_add_drain();  /* push cached pages to LRU */\n\t\t\t/*\n\t\t\t * Because we lock page here, and migration is\n\t\t\t * blocked by the pte's page reference, and we\n\t\t\t * know the page is still mapped, we don't even\n\t\t\t * need to check for file-cache page truncation.\n\t\t\t */\n\t\t\tmlock_vma_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\treturn page;\nno_page:\n\tpte_unmap_unlock(ptep, ptl);\n\tif (!pte_none(pte))\n\t\treturn NULL;\n\treturn no_page_table(vma, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *follow_page_pte(struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd, unsigned int flags,\n\t\tstruct dev_pagemap **pgmap)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t *ptep, pte;\n\nretry:\n\tif (unlikely(pmd_bad(*pmd)))\n\t\treturn no_page_table(vma, flags);\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tpte = *ptep;\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry;\n\t\t/*\n\t\t * KSM's break_ksm() relies upon recognizing a ksm page\n\t\t * even while it is being migrated, so for that case we\n\t\t * need migration_entry_wait().\n\t\t */\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\tgoto no_page;\n\t\tif (pte_none(pte))\n\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n\n\tpage = vm_normal_page(vma, address, pte);\n\tif (!page && pte_devmap(pte) && (flags & FOLL_GET)) {\n\t\t/*\n\t\t * Only return device mapping pages in the FOLL_GET case since\n\t\t * they are only valid while holding the pgmap reference.\n\t\t */\n\t\t*pgmap = get_dev_pagemap(pte_pfn(pte), *pgmap);\n\t\tif (*pgmap)\n\t\t\tpage = pte_page(pte);\n\t\telse\n\t\t\tgoto no_page;\n\t} else if (unlikely(!page)) {\n\t\tif (flags & FOLL_DUMP) {\n\t\t\t/* Avoid special (like zero) pages in core dumps */\n\t\t\tpage = ERR_PTR(-EFAULT);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (is_zero_pfn(pte_pfn(pte))) {\n\t\t\tpage = pte_page(pte);\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tret = follow_pfn_pte(vma, address, ptep, flags);\n\t\t\tpage = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (flags & FOLL_SPLIT && PageTransCompound(page)) {\n\t\tint ret;\n\t\tget_page(page);\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tlock_page(page);\n\t\tret = split_huge_page(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tgoto retry;\n\t}\n\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * pte_mkyoung() would be more correct here, but atomic care\n\t\t * is needed to avoid losing the dirty bit: it is easier to use\n\t\t * mark_page_accessed().\n\t\t */\n\t\tmark_page_accessed(page);\n\t}\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/* Do not mlock pte-mapped THP */\n\t\tif (PageTransCompound(page))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * The preliminary mapping check is mainly to avoid the\n\t\t * pointless overhead of lock_page on the ZERO_PAGE\n\t\t * which might bounce very badly if there is contention.\n\t\t *\n\t\t * If the page is already locked, we don't need to\n\t\t * handle it now - vmscan will handle it later if and\n\t\t * when it attempts to reclaim the page.\n\t\t */\n\t\tif (page->mapping && trylock_page(page)) {\n\t\t\tlru_add_drain();  /* push cached pages to LRU */\n\t\t\t/*\n\t\t\t * Because we lock page here, and migration is\n\t\t\t * blocked by the pte's page reference, and we\n\t\t\t * know the page is still mapped, we don't even\n\t\t\t * need to check for file-cache page truncation.\n\t\t\t */\n\t\t\tmlock_vma_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\treturn page;\nno_page:\n\tpte_unmap_unlock(ptep, ptl);\n\tif (!pte_none(pte))\n\t\treturn NULL;\n\treturn no_page_table(vma, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no_page_table",
          "args": [
            "vma",
            "flags"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "no_page_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "28-42",
          "snippet": "static struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_page",
          "args": [
            "page"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_pmd",
          "args": [
            "vma",
            "pmd",
            "address"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_page",
          "args": [
            "page"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "*pmd"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_trans_huge(*pmd)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_migration_entry_wait",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_migration_entry_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "361-378",
          "snippet": "void pmd_migration_entry_wait(struct mm_struct *mm, pmd_t *pmd)\n{\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tptl = pmd_lock(mm, pmd);\n\tif (!is_pmd_migration_entry(*pmd))\n\t\tgoto unlock;\n\tpage = migration_entry_to_page(pmd_to_swp_entry(*pmd));\n\tif (!get_page_unless_zero(page))\n\t\tgoto unlock;\n\tspin_unlock(ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nunlock:\n\tspin_unlock(ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid pmd_migration_entry_wait(struct mm_struct *mm, pmd_t *pmd)\n{\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tptl = pmd_lock(mm, pmd);\n\tif (!is_pmd_migration_entry(*pmd))\n\t\tgoto unlock;\n\tpage = migration_entry_to_page(pmd_to_swp_entry(*pmd));\n\tif (!get_page_unless_zero(page))\n\t\tgoto unlock;\n\tspin_unlock(ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nunlock:\n\tspin_unlock(ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(flags & FOLL_MIGRATION)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_present(*pmd)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "*pmd"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pmd_none(*pmd)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_protnone",
          "args": [
            "pmdval"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!pmd_trans_huge(pmdval)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "pmdval"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_devmap_pmd",
          "args": [
            "vma",
            "address",
            "pmd",
            "flags",
            "&ctx->pgmap"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "follow_devmap_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "873-914",
          "snippet": "struct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pmd_pfn(*pmd);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\t/*\n\t * When we COW a devmap PMD entry, we split it into PTEs, so we should\n\t * not be in this function with `flags & FOLL_COW` set.\n\t */\n\tWARN_ONCE(flags & FOLL_COW, \"mm: In follow_devmap_pmd with FOLL_COW set\");\n\n\tif (flags & FOLL_WRITE && !pmd_write(*pmd))\n\t\treturn NULL;\n\n\tif (pmd_present(*pmd) && pmd_devmap(*pmd))\n\t\t/* pass */;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags);\n\n\t/*\n\t * device mapped pages can only be returned if the\n\t * caller will manage the page reference count.\n\t */\n\tif (!(flags & FOLL_GET))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PMD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\tget_page(page);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstruct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pmd_pfn(*pmd);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\t/*\n\t * When we COW a devmap PMD entry, we split it into PTEs, so we should\n\t * not be in this function with `flags & FOLL_COW` set.\n\t */\n\tWARN_ONCE(flags & FOLL_COW, \"mm: In follow_devmap_pmd with FOLL_COW set\");\n\n\tif (flags & FOLL_WRITE && !pmd_write(*pmd))\n\t\treturn NULL;\n\n\tif (pmd_present(*pmd) && pmd_devmap(*pmd))\n\t\t/* pass */;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags);\n\n\t/*\n\t * device mapped pages can only be returned if the\n\t * caller will manage the page reference count.\n\t */\n\tif (!(flags & FOLL_GET))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PMD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\tget_page(page);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "pmdval"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "pmdval"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*pmd"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "pmdval"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(pmdval)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "pmdval"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thp_migration_supported",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(flags & FOLL_MIGRATION)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "pmdval"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_huge_pd",
          "args": [
            "vma",
            "address",
            "__hugepd(pmd_val(pmdval))",
            "flags",
            "PMD_SHIFT"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "follow_huge_pd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4827-4833",
          "snippet": "struct page * __weak\nfollow_huge_pd(struct vm_area_struct *vma,\n\t       unsigned long address, hugepd_t hpd, int flags, int pdshift)\n{\n\tWARN(1, \"hugepd follow called with no support for hugepage directory format\\n\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_pd(struct vm_area_struct *vma,\n\t       unsigned long address, hugepd_t hpd, int flags, int pdshift)\n{\n\tWARN(1, \"hugepd follow called with no support for hugepage directory format\\n\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pmd_val(pmdval)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_val",
          "args": [
            "pmdval"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugepd",
          "args": [
            "__hugepd(pmd_val(pmdval))"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hugepd",
          "args": [
            "pmd_val(pmdval)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_val",
          "args": [
            "pmdval"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_huge_pmd",
          "args": [
            "mm",
            "address",
            "pmd",
            "flags"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "follow_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4835-4870",
          "snippet": "struct page * __weak\nfollow_huge_pmd(struct mm_struct *mm, unsigned long address,\n\t\tpmd_t *pmd, int flags)\n{\n\tstruct page *page = NULL;\n\tspinlock_t *ptl;\n\tpte_t pte;\nretry:\n\tptl = pmd_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\t/*\n\t * make sure that the address range covered by this pmd is not\n\t * unmapped from other threads.\n\t */\n\tif (!pmd_huge(*pmd))\n\t\tgoto out;\n\tpte = huge_ptep_get((pte_t *)pmd);\n\tif (pte_present(pte)) {\n\t\tpage = pmd_page(*pmd) + ((address & ~PMD_MASK) >> PAGE_SHIFT);\n\t\tif (flags & FOLL_GET)\n\t\t\tget_page(page);\n\t} else {\n\t\tif (is_hugetlb_entry_migration(pte)) {\n\t\t\tspin_unlock(ptl);\n\t\t\t__migration_entry_wait(mm, (pte_t *)pmd, ptl);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * hwpoisoned entry is treated as no_page_table in\n\t\t * follow_page_mask().\n\t\t */\n\t}\nout:\n\tspin_unlock(ptl);\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_pmd(struct mm_struct *mm, unsigned long address,\n\t\tpmd_t *pmd, int flags)\n{\n\tstruct page *page = NULL;\n\tspinlock_t *ptl;\n\tpte_t pte;\nretry:\n\tptl = pmd_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\t/*\n\t * make sure that the address range covered by this pmd is not\n\t * unmapped from other threads.\n\t */\n\tif (!pmd_huge(*pmd))\n\t\tgoto out;\n\tpte = huge_ptep_get((pte_t *)pmd);\n\tif (pte_present(pte)) {\n\t\tpage = pmd_page(*pmd) + ((address & ~PMD_MASK) >> PAGE_SHIFT);\n\t\tif (flags & FOLL_GET)\n\t\t\tget_page(page);\n\t} else {\n\t\tif (is_hugetlb_entry_migration(pte)) {\n\t\t\tspin_unlock(ptl);\n\t\t\t__migration_entry_wait(mm, (pte_t *)pmd, ptl);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * hwpoisoned entry is treated as no_page_table in\n\t\t * follow_page_mask().\n\t\t */\n\t}\nout:\n\tspin_unlock(ptl);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_huge",
          "args": [
            "pmdval"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "pmdval"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*pmd"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pudp",
            "address"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *follow_pmd_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pud_t *pudp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpmd_t *pmd, pmdval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpmd = pmd_offset(pudp, address);\n\t/*\n\t * The READ_ONCE() will stabilize the pmdval in a register or\n\t * on the stack so that it will stop changing under the code.\n\t */\n\tpmdval = READ_ONCE(*pmd);\n\tif (pmd_none(pmdval))\n\t\treturn no_page_table(vma, flags);\n\tif (pmd_huge(pmdval) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pmd_val(pmdval)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pmd_val(pmdval)), flags,\n\t\t\t\t      PMD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\nretry:\n\tif (!pmd_present(pmdval)) {\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(pmdval));\n\t\tif (is_pmd_migration_entry(pmdval))\n\t\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tpmdval = READ_ONCE(*pmd);\n\t\t/*\n\t\t * MADV_DONTNEED may convert the pmd to null because\n\t\t * mmap_sem is held in read mode\n\t\t */\n\t\tif (pmd_none(pmdval))\n\t\t\treturn no_page_table(vma, flags);\n\t\tgoto retry;\n\t}\n\tif (pmd_devmap(pmdval)) {\n\t\tptl = pmd_lock(mm, pmd);\n\t\tpage = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (likely(!pmd_trans_huge(pmdval)))\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\n\tif ((flags & FOLL_NUMA) && pmd_protnone(pmdval))\n\t\treturn no_page_table(vma, flags);\n\nretry_locked:\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(pmd_none(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (unlikely(!pmd_present(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tgoto retry_locked;\n\t}\n\tif (unlikely(!pmd_trans_huge(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tif (flags & FOLL_SPLIT) {\n\t\tint ret;\n\t\tpage = pmd_page(*pmd);\n\t\tif (is_huge_zero_page(page)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tret = 0;\n\t\t\tsplit_huge_pmd(vma, pmd, address);\n\t\t\tif (pmd_trans_unstable(pmd))\n\t\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tget_page(page);\n\t\t\tspin_unlock(ptl);\n\t\t\tlock_page(page);\n\t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn no_page_table(vma, flags);\n\t\t}\n\n\t\treturn ret ? ERR_PTR(ret) :\n\t\t\tfollow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tpage = follow_trans_huge_pmd(vma, address, pmd, flags);\n\tspin_unlock(ptl);\n\tctx->page_mask = HPAGE_PMD_NR - 1;\n\treturn page;\n}"
  },
  {
    "function_name": "follow_page_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "78-207",
    "snippet": "static struct page *follow_page_pte(struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd, unsigned int flags,\n\t\tstruct dev_pagemap **pgmap)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t *ptep, pte;\n\nretry:\n\tif (unlikely(pmd_bad(*pmd)))\n\t\treturn no_page_table(vma, flags);\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tpte = *ptep;\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry;\n\t\t/*\n\t\t * KSM's break_ksm() relies upon recognizing a ksm page\n\t\t * even while it is being migrated, so for that case we\n\t\t * need migration_entry_wait().\n\t\t */\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\tgoto no_page;\n\t\tif (pte_none(pte))\n\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n\n\tpage = vm_normal_page(vma, address, pte);\n\tif (!page && pte_devmap(pte) && (flags & FOLL_GET)) {\n\t\t/*\n\t\t * Only return device mapping pages in the FOLL_GET case since\n\t\t * they are only valid while holding the pgmap reference.\n\t\t */\n\t\t*pgmap = get_dev_pagemap(pte_pfn(pte), *pgmap);\n\t\tif (*pgmap)\n\t\t\tpage = pte_page(pte);\n\t\telse\n\t\t\tgoto no_page;\n\t} else if (unlikely(!page)) {\n\t\tif (flags & FOLL_DUMP) {\n\t\t\t/* Avoid special (like zero) pages in core dumps */\n\t\t\tpage = ERR_PTR(-EFAULT);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (is_zero_pfn(pte_pfn(pte))) {\n\t\t\tpage = pte_page(pte);\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tret = follow_pfn_pte(vma, address, ptep, flags);\n\t\t\tpage = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (flags & FOLL_SPLIT && PageTransCompound(page)) {\n\t\tint ret;\n\t\tget_page(page);\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tlock_page(page);\n\t\tret = split_huge_page(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tgoto retry;\n\t}\n\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * pte_mkyoung() would be more correct here, but atomic care\n\t\t * is needed to avoid losing the dirty bit: it is easier to use\n\t\t * mark_page_accessed().\n\t\t */\n\t\tmark_page_accessed(page);\n\t}\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/* Do not mlock pte-mapped THP */\n\t\tif (PageTransCompound(page))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * The preliminary mapping check is mainly to avoid the\n\t\t * pointless overhead of lock_page on the ZERO_PAGE\n\t\t * which might bounce very badly if there is contention.\n\t\t *\n\t\t * If the page is already locked, we don't need to\n\t\t * handle it now - vmscan will handle it later if and\n\t\t * when it attempts to reclaim the page.\n\t\t */\n\t\tif (page->mapping && trylock_page(page)) {\n\t\t\tlru_add_drain();  /* push cached pages to LRU */\n\t\t\t/*\n\t\t\t * Because we lock page here, and migration is\n\t\t\t * blocked by the pte's page reference, and we\n\t\t\t * know the page is still mapped, we don't even\n\t\t\t * need to check for file-cache page truncation.\n\t\t\t */\n\t\t\tmlock_vma_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\treturn page;\nno_page:\n\tpte_unmap_unlock(ptep, ptl);\n\tif (!pte_none(pte))\n\t\treturn NULL;\n\treturn no_page_table(vma, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "no_page_table",
          "args": [
            "vma",
            "flags"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "no_page_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "28-42",
          "snippet": "static struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pte"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlock_vma_page",
          "args": [
            "page"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "mlock_vma_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "359-359",
          "snippet": "static inline void mlock_vma_page(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mlock_vma_page(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "page"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "mark_page_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "376-400",
          "snippet": "void mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "pte"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_page",
          "args": [
            "page"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_pfn_pte",
          "args": [
            "vma",
            "address",
            "ptep",
            "flags"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "follow_pfn_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "44-66",
          "snippet": "static int follow_pfn_pte(struct vm_area_struct *vma, unsigned long address,\n\t\tpte_t *pte, unsigned int flags)\n{\n\t/* No page to get reference */\n\tif (flags & FOLL_GET)\n\t\treturn -EFAULT;\n\n\tif (flags & FOLL_TOUCH) {\n\t\tpte_t entry = *pte;\n\n\t\tif (flags & FOLL_WRITE)\n\t\t\tentry = pte_mkdirty(entry);\n\t\tentry = pte_mkyoung(entry);\n\n\t\tif (!pte_same(*pte, entry)) {\n\t\t\tset_pte_at(vma->vm_mm, address, pte, entry);\n\t\t\tupdate_mmu_cache(vma, address, pte);\n\t\t}\n\t}\n\n\t/* Proper page table entry exists, but no corresponding struct page */\n\treturn -EEXIST;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int follow_pfn_pte(struct vm_area_struct *vma, unsigned long address,\n\t\tpte_t *pte, unsigned int flags)\n{\n\t/* No page to get reference */\n\tif (flags & FOLL_GET)\n\t\treturn -EFAULT;\n\n\tif (flags & FOLL_TOUCH) {\n\t\tpte_t entry = *pte;\n\n\t\tif (flags & FOLL_WRITE)\n\t\t\tentry = pte_mkdirty(entry);\n\t\tentry = pte_mkyoung(entry);\n\n\t\tif (!pte_same(*pte, entry)) {\n\t\t\tset_pte_at(vma->vm_mm, address, pte, entry);\n\t\t\tupdate_mmu_cache(vma, address, pte);\n\t\t}\n\t}\n\n\t/* Proper page table entry exists, but no corresponding struct page */\n\treturn -EEXIST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "pte"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pte_pfn(pte)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pte"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dev_pagemap",
          "args": [
            "pte_pfn(pte)",
            "*pgmap"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pte"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_devmap",
          "args": [
            "pte"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "address",
            "pte"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "vm_normal_page_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "651-689",
          "snippet": "struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_follow_write_pte",
          "args": [
            "pte",
            "flags"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "can_follow_write_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "72-76",
          "snippet": "static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)\n{\n\treturn pte_write(pte) ||\n\t\t((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic inline bool can_follow_write_pte(pte_t pte, unsigned int flags)\n{\n\treturn pte_write(pte) ||\n\t\t((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_protnone",
          "args": [
            "pte"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migration_entry_wait",
          "args": [
            "mm",
            "pmd",
            "address"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "migration_entry_wait_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "353-358",
          "snippet": "void migration_entry_wait_huge(struct vm_area_struct *vma,\n\t\tstruct mm_struct *mm, pte_t *pte)\n{\n\tspinlock_t *ptl = huge_pte_lockptr(hstate_vma(vma), mm, pte);\n\t__migration_entry_wait(mm, pte, ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migration_entry_wait_huge(struct vm_area_struct *vma,\n\t\tstruct mm_struct *mm, pte_t *pte)\n{\n\tspinlock_t *ptl = huge_pte_lockptr(hstate_vma(vma), mm, pte);\n\t__migration_entry_wait(mm, pte, ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migration_entry",
          "args": [
            "entry"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pte"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pte"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(flags & FOLL_MIGRATION)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "pmd",
            "address",
            "&ptl"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pmd_bad(*pmd)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_bad",
          "args": [
            "*pmd"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *follow_page_pte(struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd, unsigned int flags,\n\t\tstruct dev_pagemap **pgmap)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t *ptep, pte;\n\nretry:\n\tif (unlikely(pmd_bad(*pmd)))\n\t\treturn no_page_table(vma, flags);\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tpte = *ptep;\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry;\n\t\t/*\n\t\t * KSM's break_ksm() relies upon recognizing a ksm page\n\t\t * even while it is being migrated, so for that case we\n\t\t * need migration_entry_wait().\n\t\t */\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\tgoto no_page;\n\t\tif (pte_none(pte))\n\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n\n\tpage = vm_normal_page(vma, address, pte);\n\tif (!page && pte_devmap(pte) && (flags & FOLL_GET)) {\n\t\t/*\n\t\t * Only return device mapping pages in the FOLL_GET case since\n\t\t * they are only valid while holding the pgmap reference.\n\t\t */\n\t\t*pgmap = get_dev_pagemap(pte_pfn(pte), *pgmap);\n\t\tif (*pgmap)\n\t\t\tpage = pte_page(pte);\n\t\telse\n\t\t\tgoto no_page;\n\t} else if (unlikely(!page)) {\n\t\tif (flags & FOLL_DUMP) {\n\t\t\t/* Avoid special (like zero) pages in core dumps */\n\t\t\tpage = ERR_PTR(-EFAULT);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (is_zero_pfn(pte_pfn(pte))) {\n\t\t\tpage = pte_page(pte);\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tret = follow_pfn_pte(vma, address, ptep, flags);\n\t\t\tpage = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (flags & FOLL_SPLIT && PageTransCompound(page)) {\n\t\tint ret;\n\t\tget_page(page);\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tlock_page(page);\n\t\tret = split_huge_page(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tgoto retry;\n\t}\n\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * pte_mkyoung() would be more correct here, but atomic care\n\t\t * is needed to avoid losing the dirty bit: it is easier to use\n\t\t * mark_page_accessed().\n\t\t */\n\t\tmark_page_accessed(page);\n\t}\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/* Do not mlock pte-mapped THP */\n\t\tif (PageTransCompound(page))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * The preliminary mapping check is mainly to avoid the\n\t\t * pointless overhead of lock_page on the ZERO_PAGE\n\t\t * which might bounce very badly if there is contention.\n\t\t *\n\t\t * If the page is already locked, we don't need to\n\t\t * handle it now - vmscan will handle it later if and\n\t\t * when it attempts to reclaim the page.\n\t\t */\n\t\tif (page->mapping && trylock_page(page)) {\n\t\t\tlru_add_drain();  /* push cached pages to LRU */\n\t\t\t/*\n\t\t\t * Because we lock page here, and migration is\n\t\t\t * blocked by the pte's page reference, and we\n\t\t\t * know the page is still mapped, we don't even\n\t\t\t * need to check for file-cache page truncation.\n\t\t\t */\n\t\t\tmlock_vma_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\treturn page;\nno_page:\n\tpte_unmap_unlock(ptep, ptl);\n\tif (!pte_none(pte))\n\t\treturn NULL;\n\treturn no_page_table(vma, flags);\n}"
  },
  {
    "function_name": "can_follow_write_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "72-76",
    "snippet": "static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)\n{\n\treturn pte_write(pte) ||\n\t\t((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "pte"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "pte"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic inline bool can_follow_write_pte(pte_t pte, unsigned int flags)\n{\n\treturn pte_write(pte) ||\n\t\t((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));\n}"
  },
  {
    "function_name": "follow_pfn_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "44-66",
    "snippet": "static int follow_pfn_pte(struct vm_area_struct *vma, unsigned long address,\n\t\tpte_t *pte, unsigned int flags)\n{\n\t/* No page to get reference */\n\tif (flags & FOLL_GET)\n\t\treturn -EFAULT;\n\n\tif (flags & FOLL_TOUCH) {\n\t\tpte_t entry = *pte;\n\n\t\tif (flags & FOLL_WRITE)\n\t\t\tentry = pte_mkdirty(entry);\n\t\tentry = pte_mkyoung(entry);\n\n\t\tif (!pte_same(*pte, entry)) {\n\t\t\tset_pte_at(vma->vm_mm, address, pte, entry);\n\t\t\tupdate_mmu_cache(vma, address, pte);\n\t\t}\n\t}\n\n\t/* Proper page table entry exists, but no corresponding struct page */\n\treturn -EEXIST;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "address",
            "pte"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "vma->vm_mm",
            "address",
            "pte",
            "entry"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "*pte",
            "entry"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_mkyoung",
          "args": [
            "entry"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdirty",
          "args": [
            "entry"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int follow_pfn_pte(struct vm_area_struct *vma, unsigned long address,\n\t\tpte_t *pte, unsigned int flags)\n{\n\t/* No page to get reference */\n\tif (flags & FOLL_GET)\n\t\treturn -EFAULT;\n\n\tif (flags & FOLL_TOUCH) {\n\t\tpte_t entry = *pte;\n\n\t\tif (flags & FOLL_WRITE)\n\t\t\tentry = pte_mkdirty(entry);\n\t\tentry = pte_mkyoung(entry);\n\n\t\tif (!pte_same(*pte, entry)) {\n\t\t\tset_pte_at(vma->vm_mm, address, pte, entry);\n\t\t\tupdate_mmu_cache(vma, address, pte);\n\t\t}\n\t}\n\n\t/* Proper page table entry exists, but no corresponding struct page */\n\treturn -EEXIST;\n}"
  },
  {
    "function_name": "no_page_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
    "lines": "28-42",
    "snippet": "static struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic struct page *no_page_table(struct vm_area_struct *vma,\n\t\tunsigned int flags)\n{\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) && (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn NULL;\n}"
  }
]