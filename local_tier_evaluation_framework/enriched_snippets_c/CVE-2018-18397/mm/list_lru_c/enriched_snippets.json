[
  {
    "function_name": "list_lru_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "641-659",
    "snippet": "void list_lru_destroy(struct list_lru *lru)\n{\n\t/* Already destroyed or not yet initialized? */\n\tif (!lru->node)\n\t\treturn;\n\n\tmemcg_get_cache_ids();\n\n\tlist_lru_unregister(lru);\n\n\tmemcg_destroy_list_lru(lru);\n\tkfree(lru->node);\n\tlru->node = NULL;\n\n#ifdef CONFIG_MEMCG_KMEM\n\tlru->shrinker_id = -1;\n#endif\n\tmemcg_put_cache_ids();\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_put_cache_ids",
          "args": [],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_put_cache_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "287-290",
          "snippet": "void memcg_put_cache_ids(void)\n{\n\tup_read(&memcg_cache_ids_sem);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nvoid memcg_put_cache_ids(void)\n{\n\tup_read(&memcg_cache_ids_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lru->node"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_destroy_list_lru",
          "args": [
            "lru"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_destroy_list_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "595-597",
          "snippet": "static void memcg_destroy_list_lru(struct list_lru *lru)\n{\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_destroy_list_lru(struct list_lru *lru)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_unregister",
          "args": [
            "lru"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "97-99",
          "snippet": "static void list_lru_unregister(struct list_lru *lru)\n{\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void list_lru_unregister(struct list_lru *lru)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_get_cache_ids",
          "args": [],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_get_cache_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "282-285",
          "snippet": "void memcg_get_cache_ids(void)\n{\n\tdown_read(&memcg_cache_ids_sem);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nvoid memcg_get_cache_ids(void)\n{\n\tdown_read(&memcg_cache_ids_sem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid list_lru_destroy(struct list_lru *lru)\n{\n\t/* Already destroyed or not yet initialized? */\n\tif (!lru->node)\n\t\treturn;\n\n\tmemcg_get_cache_ids();\n\n\tlist_lru_unregister(lru);\n\n\tmemcg_destroy_list_lru(lru);\n\tkfree(lru->node);\n\tlru->node = NULL;\n\n#ifdef CONFIG_MEMCG_KMEM\n\tlru->shrinker_id = -1;\n#endif\n\tmemcg_put_cache_ids();\n}"
  },
  {
    "function_name": "__list_lru_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "600-638",
    "snippet": "int __list_lru_init(struct list_lru *lru, bool memcg_aware,\n\t\t    struct lock_class_key *key, struct shrinker *shrinker)\n{\n\tint i;\n\tsize_t size = sizeof(*lru->node) * nr_node_ids;\n\tint err = -ENOMEM;\n\n#ifdef CONFIG_MEMCG_KMEM\n\tif (shrinker)\n\t\tlru->shrinker_id = shrinker->id;\n\telse\n\t\tlru->shrinker_id = -1;\n#endif\n\tmemcg_get_cache_ids();\n\n\tlru->node = kzalloc(size, GFP_KERNEL);\n\tif (!lru->node)\n\t\tgoto out;\n\n\tfor_each_node(i) {\n\t\tspin_lock_init(&lru->node[i].lock);\n\t\tif (key)\n\t\t\tlockdep_set_class(&lru->node[i].lock, key);\n\t\tinit_one_lru(&lru->node[i].lru);\n\t}\n\n\terr = memcg_init_list_lru(lru, memcg_aware);\n\tif (err) {\n\t\tkfree(lru->node);\n\t\t/* Do this so a list_lru_destroy() doesn't crash: */\n\t\tlru->node = NULL;\n\t\tgoto out;\n\t}\n\n\tlist_lru_register(lru);\nout:\n\tmemcg_put_cache_ids();\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_put_cache_ids",
          "args": [],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_put_cache_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "287-290",
          "snippet": "void memcg_put_cache_ids(void)\n{\n\tup_read(&memcg_cache_ids_sem);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nvoid memcg_put_cache_ids(void)\n{\n\tup_read(&memcg_cache_ids_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_register",
          "args": [
            "lru"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "93-95",
          "snippet": "static void list_lru_register(struct list_lru *lru)\n{\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void list_lru_register(struct list_lru *lru)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lru->node"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_init_list_lru",
          "args": [
            "lru",
            "memcg_aware"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_init_list_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "590-593",
          "snippet": "static int memcg_init_list_lru(struct list_lru *lru, bool memcg_aware)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int memcg_init_list_lru(struct list_lru *lru, bool memcg_aware)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_one_lru",
          "args": [
            "&lru->node[i].lru"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "init_one_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "327-331",
          "snippet": "static void init_one_lru(struct list_lru_one *l)\n{\n\tINIT_LIST_HEAD(&l->list);\n\tl->nr_items = 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void init_one_lru(struct list_lru_one *l)\n{\n\tINIT_LIST_HEAD(&l->list);\n\tl->nr_items = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&lru->node[i].lock",
            "key"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&lru->node[i].lock"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_get_cache_ids",
          "args": [],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_get_cache_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "282-285",
          "snippet": "void memcg_get_cache_ids(void)\n{\n\tdown_read(&memcg_cache_ids_sem);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nvoid memcg_get_cache_ids(void)\n{\n\tdown_read(&memcg_cache_ids_sem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint __list_lru_init(struct list_lru *lru, bool memcg_aware,\n\t\t    struct lock_class_key *key, struct shrinker *shrinker)\n{\n\tint i;\n\tsize_t size = sizeof(*lru->node) * nr_node_ids;\n\tint err = -ENOMEM;\n\n#ifdef CONFIG_MEMCG_KMEM\n\tif (shrinker)\n\t\tlru->shrinker_id = shrinker->id;\n\telse\n\t\tlru->shrinker_id = -1;\n#endif\n\tmemcg_get_cache_ids();\n\n\tlru->node = kzalloc(size, GFP_KERNEL);\n\tif (!lru->node)\n\t\tgoto out;\n\n\tfor_each_node(i) {\n\t\tspin_lock_init(&lru->node[i].lock);\n\t\tif (key)\n\t\t\tlockdep_set_class(&lru->node[i].lock, key);\n\t\tinit_one_lru(&lru->node[i].lru);\n\t}\n\n\terr = memcg_init_list_lru(lru, memcg_aware);\n\tif (err) {\n\t\tkfree(lru->node);\n\t\t/* Do this so a list_lru_destroy() doesn't crash: */\n\t\tlru->node = NULL;\n\t\tgoto out;\n\t}\n\n\tlist_lru_register(lru);\nout:\n\tmemcg_put_cache_ids();\n\treturn err;\n}"
  },
  {
    "function_name": "memcg_destroy_list_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "595-597",
    "snippet": "static void memcg_destroy_list_lru(struct list_lru *lru)\n{\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_destroy_list_lru(struct list_lru *lru)\n{\n}"
  },
  {
    "function_name": "memcg_init_list_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "590-593",
    "snippet": "static int memcg_init_list_lru(struct list_lru *lru, bool memcg_aware)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int memcg_init_list_lru(struct list_lru *lru, bool memcg_aware)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_drain_all_list_lrus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "580-588",
    "snippet": "void memcg_drain_all_list_lrus(int src_idx, struct mem_cgroup *dst_memcg)\n{\n\tstruct list_lru *lru;\n\n\tmutex_lock(&list_lrus_mutex);\n\tlist_for_each_entry(lru, &list_lrus, list)\n\t\tmemcg_drain_list_lru(lru, src_idx, dst_memcg);\n\tmutex_unlock(&list_lrus_mutex);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&list_lrus_mutex"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_drain_list_lru",
          "args": [
            "lru",
            "src_idx",
            "dst_memcg"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_drain_list_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "568-578",
          "snippet": "static void memcg_drain_list_lru(struct list_lru *lru,\n\t\t\t\t int src_idx, struct mem_cgroup *dst_memcg)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn;\n\n\tfor_each_node(i)\n\t\tmemcg_drain_list_lru_node(lru, i, src_idx, dst_memcg);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_drain_list_lru(struct list_lru *lru,\n\t\t\t\t int src_idx, struct mem_cgroup *dst_memcg)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn;\n\n\tfor_each_node(i)\n\t\tmemcg_drain_list_lru_node(lru, i, src_idx, dst_memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lru",
            "&list_lrus",
            "list"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&list_lrus_mutex"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid memcg_drain_all_list_lrus(int src_idx, struct mem_cgroup *dst_memcg)\n{\n\tstruct list_lru *lru;\n\n\tmutex_lock(&list_lrus_mutex);\n\tlist_for_each_entry(lru, &list_lrus, list)\n\t\tmemcg_drain_list_lru(lru, src_idx, dst_memcg);\n\tmutex_unlock(&list_lrus_mutex);\n}"
  },
  {
    "function_name": "memcg_drain_list_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "568-578",
    "snippet": "static void memcg_drain_list_lru(struct list_lru *lru,\n\t\t\t\t int src_idx, struct mem_cgroup *dst_memcg)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn;\n\n\tfor_each_node(i)\n\t\tmemcg_drain_list_lru_node(lru, i, src_idx, dst_memcg);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_memcg_aware",
          "args": [
            "lru"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_memcg_aware",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "106-109",
          "snippet": "static inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_drain_list_lru(struct list_lru *lru,\n\t\t\t\t int src_idx, struct mem_cgroup *dst_memcg)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn;\n\n\tfor_each_node(i)\n\t\tmemcg_drain_list_lru_node(lru, i, src_idx, dst_memcg);\n}"
  },
  {
    "function_name": "memcg_drain_list_lru_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "541-566",
    "snippet": "static void memcg_drain_list_lru_node(struct list_lru *lru, int nid,\n\t\t\t\t      int src_idx, struct mem_cgroup *dst_memcg)\n{\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tint dst_idx = dst_memcg->kmemcg_id;\n\tstruct list_lru_one *src, *dst;\n\tbool set;\n\n\t/*\n\t * Since list_lru_{add,del} may be called under an IRQ-safe lock,\n\t * we have to use IRQ-safe primitives here to avoid deadlock.\n\t */\n\tspin_lock_irq(&nlru->lock);\n\n\tsrc = list_lru_from_memcg_idx(nlru, src_idx);\n\tdst = list_lru_from_memcg_idx(nlru, dst_idx);\n\n\tlist_splice_init(&src->list, &dst->list);\n\tset = (!dst->nr_items && src->nr_items);\n\tdst->nr_items += src->nr_items;\n\tif (set)\n\t\tmemcg_set_shrinker_bit(dst_memcg, nid, lru_shrinker_id(lru));\n\tsrc->nr_items = 0;\n\n\tspin_unlock_irq(&nlru->lock);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&nlru->lock"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_set_shrinker_bit",
          "args": [
            "dst_memcg",
            "nid",
            "lru_shrinker_id(lru)"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_set_shrinker_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "426-438",
          "snippet": "void memcg_set_shrinker_bit(struct mem_cgroup *memcg, int nid, int shrinker_id)\n{\n\tif (shrinker_id >= 0 && memcg && !mem_cgroup_is_root(memcg)) {\n\t\tstruct memcg_shrinker_map *map;\n\n\t\trcu_read_lock();\n\t\tmap = rcu_dereference(memcg->nodeinfo[nid]->shrinker_map);\n\t\t/* Pairs with smp mb in shrink_slab() */\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(shrinker_id, map->map);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid memcg_set_shrinker_bit(struct mem_cgroup *memcg, int nid, int shrinker_id)\n{\n\tif (shrinker_id >= 0 && memcg && !mem_cgroup_is_root(memcg)) {\n\t\tstruct memcg_shrinker_map *map;\n\n\t\trcu_read_lock();\n\t\tmap = rcu_dereference(memcg->nodeinfo[nid]->shrinker_map);\n\t\t/* Pairs with smp mb in shrink_slab() */\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(shrinker_id, map->map);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_shrinker_id",
          "args": [
            "lru"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "lru_shrinker_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "101-104",
          "snippet": "static int lru_shrinker_id(struct list_lru *lru)\n{\n\treturn -1;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int lru_shrinker_id(struct list_lru *lru)\n{\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&src->list",
            "&dst->list"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_from_memcg_idx",
          "args": [
            "nlru",
            "dst_idx"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_from_memcg_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "111-115",
          "snippet": "static inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\treturn &nlru->lru;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\treturn &nlru->lru;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&nlru->lock"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_drain_list_lru_node(struct list_lru *lru, int nid,\n\t\t\t\t      int src_idx, struct mem_cgroup *dst_memcg)\n{\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tint dst_idx = dst_memcg->kmemcg_id;\n\tstruct list_lru_one *src, *dst;\n\tbool set;\n\n\t/*\n\t * Since list_lru_{add,del} may be called under an IRQ-safe lock,\n\t * we have to use IRQ-safe primitives here to avoid deadlock.\n\t */\n\tspin_lock_irq(&nlru->lock);\n\n\tsrc = list_lru_from_memcg_idx(nlru, src_idx);\n\tdst = list_lru_from_memcg_idx(nlru, dst_idx);\n\n\tlist_splice_init(&src->list, &dst->list);\n\tset = (!dst->nr_items && src->nr_items);\n\tdst->nr_items += src->nr_items;\n\tif (set)\n\t\tmemcg_set_shrinker_bit(dst_memcg, nid, lru_shrinker_id(lru));\n\tsrc->nr_items = 0;\n\n\tspin_unlock_irq(&nlru->lock);\n}"
  },
  {
    "function_name": "memcg_update_all_list_lrus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "520-539",
    "snippet": "int memcg_update_all_list_lrus(int new_size)\n{\n\tint ret = 0;\n\tstruct list_lru *lru;\n\tint old_size = memcg_nr_cache_ids;\n\n\tmutex_lock(&list_lrus_mutex);\n\tlist_for_each_entry(lru, &list_lrus, list) {\n\t\tret = memcg_update_list_lru(lru, old_size, new_size);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\nout:\n\tmutex_unlock(&list_lrus_mutex);\n\treturn ret;\nfail:\n\tlist_for_each_entry_continue_reverse(lru, &list_lrus, list)\n\t\tmemcg_cancel_update_list_lru(lru, old_size, new_size);\n\tgoto out;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_cancel_update_list_lru",
          "args": [
            "lru",
            "old_size",
            "new_size"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_cancel_update_list_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "507-518",
          "snippet": "static void memcg_cancel_update_list_lru(struct list_lru *lru,\n\t\t\t\t\t int old_size, int new_size)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn;\n\n\tfor_each_node(i)\n\t\tmemcg_cancel_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t\t  old_size, new_size);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_cancel_update_list_lru(struct list_lru *lru,\n\t\t\t\t\t int old_size, int new_size)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn;\n\n\tfor_each_node(i)\n\t\tmemcg_cancel_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t\t  old_size, new_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue_reverse",
          "args": [
            "lru",
            "&list_lrus",
            "list"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&list_lrus_mutex"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_update_list_lru",
          "args": [
            "lru",
            "old_size",
            "new_size"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_update_list_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "482-505",
          "snippet": "static int memcg_update_list_lru(struct list_lru *lru,\n\t\t\t\t int old_size, int new_size)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn 0;\n\n\tfor_each_node(i) {\n\t\tif (memcg_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t       old_size, new_size))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tfor (i = i - 1; i >= 0; i--) {\n\t\tif (!lru->node[i].memcg_lrus)\n\t\t\tcontinue;\n\n\t\tmemcg_cancel_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t\t  old_size, new_size);\n\t}\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int memcg_update_list_lru(struct list_lru *lru,\n\t\t\t\t int old_size, int new_size)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn 0;\n\n\tfor_each_node(i) {\n\t\tif (memcg_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t       old_size, new_size))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tfor (i = i - 1; i >= 0; i--) {\n\t\tif (!lru->node[i].memcg_lrus)\n\t\t\tcontinue;\n\n\t\tmemcg_cancel_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t\t  old_size, new_size);\n\t}\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lru",
            "&list_lrus",
            "list"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&list_lrus_mutex"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint memcg_update_all_list_lrus(int new_size)\n{\n\tint ret = 0;\n\tstruct list_lru *lru;\n\tint old_size = memcg_nr_cache_ids;\n\n\tmutex_lock(&list_lrus_mutex);\n\tlist_for_each_entry(lru, &list_lrus, list) {\n\t\tret = memcg_update_list_lru(lru, old_size, new_size);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\nout:\n\tmutex_unlock(&list_lrus_mutex);\n\treturn ret;\nfail:\n\tlist_for_each_entry_continue_reverse(lru, &list_lrus, list)\n\t\tmemcg_cancel_update_list_lru(lru, old_size, new_size);\n\tgoto out;\n}"
  },
  {
    "function_name": "memcg_cancel_update_list_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "507-518",
    "snippet": "static void memcg_cancel_update_list_lru(struct list_lru *lru,\n\t\t\t\t\t int old_size, int new_size)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn;\n\n\tfor_each_node(i)\n\t\tmemcg_cancel_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t\t  old_size, new_size);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_memcg_aware",
          "args": [
            "lru"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_memcg_aware",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "106-109",
          "snippet": "static inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_cancel_update_list_lru(struct list_lru *lru,\n\t\t\t\t\t int old_size, int new_size)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn;\n\n\tfor_each_node(i)\n\t\tmemcg_cancel_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t\t  old_size, new_size);\n}"
  },
  {
    "function_name": "memcg_update_list_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "482-505",
    "snippet": "static int memcg_update_list_lru(struct list_lru *lru,\n\t\t\t\t int old_size, int new_size)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn 0;\n\n\tfor_each_node(i) {\n\t\tif (memcg_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t       old_size, new_size))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tfor (i = i - 1; i >= 0; i--) {\n\t\tif (!lru->node[i].memcg_lrus)\n\t\t\tcontinue;\n\n\t\tmemcg_cancel_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t\t  old_size, new_size);\n\t}\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_cancel_update_list_lru_node",
          "args": [
            "&lru->node[i]",
            "old_size",
            "new_size"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_cancel_update_list_lru_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "438-448",
          "snippet": "static void memcg_cancel_update_list_lru_node(struct list_lru_node *nlru,\n\t\t\t\t\t      int old_size, int new_size)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\n\tmemcg_lrus = rcu_dereference_protected(nlru->memcg_lrus,\n\t\t\t\t\t       lockdep_is_held(&list_lrus_mutex));\n\t/* do not bother shrinking the array back to the old size, because we\n\t * cannot handle allocation failures here */\n\t__memcg_destroy_list_lru_node(memcg_lrus, old_size, new_size);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_cancel_update_list_lru_node(struct list_lru_node *nlru,\n\t\t\t\t\t      int old_size, int new_size)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\n\tmemcg_lrus = rcu_dereference_protected(nlru->memcg_lrus,\n\t\t\t\t\t       lockdep_is_held(&list_lrus_mutex));\n\t/* do not bother shrinking the array back to the old size, because we\n\t * cannot handle allocation failures here */\n\t__memcg_destroy_list_lru_node(memcg_lrus, old_size, new_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_update_list_lru_node",
          "args": [
            "&lru->node[i]",
            "old_size",
            "new_size"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_update_list_lru_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "403-436",
          "snippet": "static int memcg_update_list_lru_node(struct list_lru_node *nlru,\n\t\t\t\t      int old_size, int new_size)\n{\n\tstruct list_lru_memcg *old, *new;\n\n\tBUG_ON(old_size > new_size);\n\n\told = rcu_dereference_protected(nlru->memcg_lrus,\n\t\t\t\t\tlockdep_is_held(&list_lrus_mutex));\n\tnew = kvmalloc(sizeof(*new) + new_size * sizeof(void *), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (__memcg_init_list_lru_node(new, old_size, new_size)) {\n\t\tkvfree(new);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&new->lru, &old->lru, old_size * sizeof(void *));\n\n\t/*\n\t * The locking below allows readers that hold nlru->lock avoid taking\n\t * rcu_read_lock (see list_lru_from_memcg_idx).\n\t *\n\t * Since list_lru_{add,del} may be called under an IRQ-safe lock,\n\t * we have to use IRQ-safe primitives here to avoid deadlock.\n\t */\n\tspin_lock_irq(&nlru->lock);\n\trcu_assign_pointer(nlru->memcg_lrus, new);\n\tspin_unlock_irq(&nlru->lock);\n\n\tcall_rcu(&old->rcu, kvfree_rcu);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int memcg_update_list_lru_node(struct list_lru_node *nlru,\n\t\t\t\t      int old_size, int new_size)\n{\n\tstruct list_lru_memcg *old, *new;\n\n\tBUG_ON(old_size > new_size);\n\n\told = rcu_dereference_protected(nlru->memcg_lrus,\n\t\t\t\t\tlockdep_is_held(&list_lrus_mutex));\n\tnew = kvmalloc(sizeof(*new) + new_size * sizeof(void *), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (__memcg_init_list_lru_node(new, old_size, new_size)) {\n\t\tkvfree(new);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&new->lru, &old->lru, old_size * sizeof(void *));\n\n\t/*\n\t * The locking below allows readers that hold nlru->lock avoid taking\n\t * rcu_read_lock (see list_lru_from_memcg_idx).\n\t *\n\t * Since list_lru_{add,del} may be called under an IRQ-safe lock,\n\t * we have to use IRQ-safe primitives here to avoid deadlock.\n\t */\n\tspin_lock_irq(&nlru->lock);\n\trcu_assign_pointer(nlru->memcg_lrus, new);\n\tspin_unlock_irq(&nlru->lock);\n\n\tcall_rcu(&old->rcu, kvfree_rcu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_memcg_aware",
          "args": [
            "lru"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_memcg_aware",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "106-109",
          "snippet": "static inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int memcg_update_list_lru(struct list_lru *lru,\n\t\t\t\t int old_size, int new_size)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn 0;\n\n\tfor_each_node(i) {\n\t\tif (memcg_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t       old_size, new_size))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tfor (i = i - 1; i >= 0; i--) {\n\t\tif (!lru->node[i].memcg_lrus)\n\t\t\tcontinue;\n\n\t\tmemcg_cancel_update_list_lru_node(&lru->node[i],\n\t\t\t\t\t\t  old_size, new_size);\n\t}\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "memcg_destroy_list_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "471-480",
    "snippet": "static void memcg_destroy_list_lru(struct list_lru *lru)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn;\n\n\tfor_each_node(i)\n\t\tmemcg_destroy_list_lru_node(&lru->node[i]);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_memcg_aware",
          "args": [
            "lru"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_memcg_aware",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "106-109",
          "snippet": "static inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_destroy_list_lru(struct list_lru *lru)\n{\n\tint i;\n\n\tif (!list_lru_memcg_aware(lru))\n\t\treturn;\n\n\tfor_each_node(i)\n\t\tmemcg_destroy_list_lru_node(&lru->node[i]);\n}"
  },
  {
    "function_name": "memcg_init_list_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "450-469",
    "snippet": "static int memcg_init_list_lru(struct list_lru *lru, bool memcg_aware)\n{\n\tint i;\n\n\tif (!memcg_aware)\n\t\treturn 0;\n\n\tfor_each_node(i) {\n\t\tif (memcg_init_list_lru_node(&lru->node[i]))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tfor (i = i - 1; i >= 0; i--) {\n\t\tif (!lru->node[i].memcg_lrus)\n\t\t\tcontinue;\n\t\tmemcg_destroy_list_lru_node(&lru->node[i]);\n\t}\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_destroy_list_lru_node",
          "args": [
            "&lru->node[i]"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_destroy_list_lru_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "383-393",
          "snippet": "static void memcg_destroy_list_lru_node(struct list_lru_node *nlru)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\t/*\n\t * This is called when shrinker has already been unregistered,\n\t * and nobody can use it. So, there is no need to use kvfree_rcu().\n\t */\n\tmemcg_lrus = rcu_dereference_protected(nlru->memcg_lrus, true);\n\t__memcg_destroy_list_lru_node(memcg_lrus, 0, memcg_nr_cache_ids);\n\tkvfree(memcg_lrus);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_destroy_list_lru_node(struct list_lru_node *nlru)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\t/*\n\t * This is called when shrinker has already been unregistered,\n\t * and nobody can use it. So, there is no need to use kvfree_rcu().\n\t */\n\tmemcg_lrus = rcu_dereference_protected(nlru->memcg_lrus, true);\n\t__memcg_destroy_list_lru_node(memcg_lrus, 0, memcg_nr_cache_ids);\n\tkvfree(memcg_lrus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_init_list_lru_node",
          "args": [
            "&lru->node[i]"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_init_list_lru_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "364-381",
          "snippet": "static int memcg_init_list_lru_node(struct list_lru_node *nlru)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\tint size = memcg_nr_cache_ids;\n\n\tmemcg_lrus = kvmalloc(sizeof(*memcg_lrus) +\n\t\t\t      size * sizeof(void *), GFP_KERNEL);\n\tif (!memcg_lrus)\n\t\treturn -ENOMEM;\n\n\tif (__memcg_init_list_lru_node(memcg_lrus, 0, size)) {\n\t\tkvfree(memcg_lrus);\n\t\treturn -ENOMEM;\n\t}\n\tRCU_INIT_POINTER(nlru->memcg_lrus, memcg_lrus);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int memcg_init_list_lru_node(struct list_lru_node *nlru)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\tint size = memcg_nr_cache_ids;\n\n\tmemcg_lrus = kvmalloc(sizeof(*memcg_lrus) +\n\t\t\t      size * sizeof(void *), GFP_KERNEL);\n\tif (!memcg_lrus)\n\t\treturn -ENOMEM;\n\n\tif (__memcg_init_list_lru_node(memcg_lrus, 0, size)) {\n\t\tkvfree(memcg_lrus);\n\t\treturn -ENOMEM;\n\t}\n\tRCU_INIT_POINTER(nlru->memcg_lrus, memcg_lrus);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int memcg_init_list_lru(struct list_lru *lru, bool memcg_aware)\n{\n\tint i;\n\n\tif (!memcg_aware)\n\t\treturn 0;\n\n\tfor_each_node(i) {\n\t\tif (memcg_init_list_lru_node(&lru->node[i]))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tfor (i = i - 1; i >= 0; i--) {\n\t\tif (!lru->node[i].memcg_lrus)\n\t\t\tcontinue;\n\t\tmemcg_destroy_list_lru_node(&lru->node[i]);\n\t}\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "memcg_cancel_update_list_lru_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "438-448",
    "snippet": "static void memcg_cancel_update_list_lru_node(struct list_lru_node *nlru,\n\t\t\t\t\t      int old_size, int new_size)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\n\tmemcg_lrus = rcu_dereference_protected(nlru->memcg_lrus,\n\t\t\t\t\t       lockdep_is_held(&list_lrus_mutex));\n\t/* do not bother shrinking the array back to the old size, because we\n\t * cannot handle allocation failures here */\n\t__memcg_destroy_list_lru_node(memcg_lrus, old_size, new_size);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__memcg_destroy_list_lru_node",
          "args": [
            "memcg_lrus",
            "old_size",
            "new_size"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "__memcg_destroy_list_lru_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "334-341",
          "snippet": "static void __memcg_destroy_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t\t  int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++)\n\t\tkfree(memcg_lrus->lru[i]);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void __memcg_destroy_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t\t  int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++)\n\t\tkfree(memcg_lrus->lru[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "nlru->memcg_lrus",
            "lockdep_is_held(&list_lrus_mutex)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&list_lrus_mutex"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_cancel_update_list_lru_node(struct list_lru_node *nlru,\n\t\t\t\t\t      int old_size, int new_size)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\n\tmemcg_lrus = rcu_dereference_protected(nlru->memcg_lrus,\n\t\t\t\t\t       lockdep_is_held(&list_lrus_mutex));\n\t/* do not bother shrinking the array back to the old size, because we\n\t * cannot handle allocation failures here */\n\t__memcg_destroy_list_lru_node(memcg_lrus, old_size, new_size);\n}"
  },
  {
    "function_name": "memcg_update_list_lru_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "403-436",
    "snippet": "static int memcg_update_list_lru_node(struct list_lru_node *nlru,\n\t\t\t\t      int old_size, int new_size)\n{\n\tstruct list_lru_memcg *old, *new;\n\n\tBUG_ON(old_size > new_size);\n\n\told = rcu_dereference_protected(nlru->memcg_lrus,\n\t\t\t\t\tlockdep_is_held(&list_lrus_mutex));\n\tnew = kvmalloc(sizeof(*new) + new_size * sizeof(void *), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (__memcg_init_list_lru_node(new, old_size, new_size)) {\n\t\tkvfree(new);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&new->lru, &old->lru, old_size * sizeof(void *));\n\n\t/*\n\t * The locking below allows readers that hold nlru->lock avoid taking\n\t * rcu_read_lock (see list_lru_from_memcg_idx).\n\t *\n\t * Since list_lru_{add,del} may be called under an IRQ-safe lock,\n\t * we have to use IRQ-safe primitives here to avoid deadlock.\n\t */\n\tspin_lock_irq(&nlru->lock);\n\trcu_assign_pointer(nlru->memcg_lrus, new);\n\tspin_unlock_irq(&nlru->lock);\n\n\tcall_rcu(&old->rcu, kvfree_rcu);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&old->rcu",
            "kvfree_rcu"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&nlru->lock"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "nlru->memcg_lrus",
            "new"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&nlru->lock"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new->lru",
            "&old->lru",
            "old_size * sizeof(void *)"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "new"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__memcg_init_list_lru_node",
          "args": [
            "new",
            "old_size",
            "new_size"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "__memcg_init_list_lru_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "343-362",
          "snippet": "static int __memcg_init_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t      int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++) {\n\t\tstruct list_lru_one *l;\n\n\t\tl = kmalloc(sizeof(struct list_lru_one), GFP_KERNEL);\n\t\tif (!l)\n\t\t\tgoto fail;\n\n\t\tinit_one_lru(l);\n\t\tmemcg_lrus->lru[i] = l;\n\t}\n\treturn 0;\nfail:\n\t__memcg_destroy_list_lru_node(memcg_lrus, begin, i - 1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int __memcg_init_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t      int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++) {\n\t\tstruct list_lru_one *l;\n\n\t\tl = kmalloc(sizeof(struct list_lru_one), GFP_KERNEL);\n\t\tif (!l)\n\t\t\tgoto fail;\n\n\t\tinit_one_lru(l);\n\t\tmemcg_lrus->lru[i] = l;\n\t}\n\treturn 0;\nfail:\n\t__memcg_destroy_list_lru_node(memcg_lrus, begin, i - 1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "sizeof(*new) + new_size * sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "nlru->memcg_lrus",
            "lockdep_is_held(&list_lrus_mutex)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&list_lrus_mutex"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "old_size > new_size"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int memcg_update_list_lru_node(struct list_lru_node *nlru,\n\t\t\t\t      int old_size, int new_size)\n{\n\tstruct list_lru_memcg *old, *new;\n\n\tBUG_ON(old_size > new_size);\n\n\told = rcu_dereference_protected(nlru->memcg_lrus,\n\t\t\t\t\tlockdep_is_held(&list_lrus_mutex));\n\tnew = kvmalloc(sizeof(*new) + new_size * sizeof(void *), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (__memcg_init_list_lru_node(new, old_size, new_size)) {\n\t\tkvfree(new);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&new->lru, &old->lru, old_size * sizeof(void *));\n\n\t/*\n\t * The locking below allows readers that hold nlru->lock avoid taking\n\t * rcu_read_lock (see list_lru_from_memcg_idx).\n\t *\n\t * Since list_lru_{add,del} may be called under an IRQ-safe lock,\n\t * we have to use IRQ-safe primitives here to avoid deadlock.\n\t */\n\tspin_lock_irq(&nlru->lock);\n\trcu_assign_pointer(nlru->memcg_lrus, new);\n\tspin_unlock_irq(&nlru->lock);\n\n\tcall_rcu(&old->rcu, kvfree_rcu);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvfree_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "395-401",
    "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "mlru"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structlist_lru_memcg",
            "rcu"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
  },
  {
    "function_name": "memcg_destroy_list_lru_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "383-393",
    "snippet": "static void memcg_destroy_list_lru_node(struct list_lru_node *nlru)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\t/*\n\t * This is called when shrinker has already been unregistered,\n\t * and nobody can use it. So, there is no need to use kvfree_rcu().\n\t */\n\tmemcg_lrus = rcu_dereference_protected(nlru->memcg_lrus, true);\n\t__memcg_destroy_list_lru_node(memcg_lrus, 0, memcg_nr_cache_ids);\n\tkvfree(memcg_lrus);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "memcg_lrus"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__memcg_destroy_list_lru_node",
          "args": [
            "memcg_lrus",
            "0",
            "memcg_nr_cache_ids"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "__memcg_destroy_list_lru_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "334-341",
          "snippet": "static void __memcg_destroy_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t\t  int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++)\n\t\tkfree(memcg_lrus->lru[i]);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void __memcg_destroy_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t\t  int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++)\n\t\tkfree(memcg_lrus->lru[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "nlru->memcg_lrus",
            "true"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void memcg_destroy_list_lru_node(struct list_lru_node *nlru)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\t/*\n\t * This is called when shrinker has already been unregistered,\n\t * and nobody can use it. So, there is no need to use kvfree_rcu().\n\t */\n\tmemcg_lrus = rcu_dereference_protected(nlru->memcg_lrus, true);\n\t__memcg_destroy_list_lru_node(memcg_lrus, 0, memcg_nr_cache_ids);\n\tkvfree(memcg_lrus);\n}"
  },
  {
    "function_name": "memcg_init_list_lru_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "364-381",
    "snippet": "static int memcg_init_list_lru_node(struct list_lru_node *nlru)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\tint size = memcg_nr_cache_ids;\n\n\tmemcg_lrus = kvmalloc(sizeof(*memcg_lrus) +\n\t\t\t      size * sizeof(void *), GFP_KERNEL);\n\tif (!memcg_lrus)\n\t\treturn -ENOMEM;\n\n\tif (__memcg_init_list_lru_node(memcg_lrus, 0, size)) {\n\t\tkvfree(memcg_lrus);\n\t\treturn -ENOMEM;\n\t}\n\tRCU_INIT_POINTER(nlru->memcg_lrus, memcg_lrus);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "nlru->memcg_lrus",
            "memcg_lrus"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "memcg_lrus"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__memcg_init_list_lru_node",
          "args": [
            "memcg_lrus",
            "0",
            "size"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "__memcg_init_list_lru_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "343-362",
          "snippet": "static int __memcg_init_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t      int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++) {\n\t\tstruct list_lru_one *l;\n\n\t\tl = kmalloc(sizeof(struct list_lru_one), GFP_KERNEL);\n\t\tif (!l)\n\t\t\tgoto fail;\n\n\t\tinit_one_lru(l);\n\t\tmemcg_lrus->lru[i] = l;\n\t}\n\treturn 0;\nfail:\n\t__memcg_destroy_list_lru_node(memcg_lrus, begin, i - 1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int __memcg_init_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t      int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++) {\n\t\tstruct list_lru_one *l;\n\n\t\tl = kmalloc(sizeof(struct list_lru_one), GFP_KERNEL);\n\t\tif (!l)\n\t\t\tgoto fail;\n\n\t\tinit_one_lru(l);\n\t\tmemcg_lrus->lru[i] = l;\n\t}\n\treturn 0;\nfail:\n\t__memcg_destroy_list_lru_node(memcg_lrus, begin, i - 1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "sizeof(*memcg_lrus) +\n\t\t\t      size * sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int memcg_init_list_lru_node(struct list_lru_node *nlru)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\tint size = memcg_nr_cache_ids;\n\n\tmemcg_lrus = kvmalloc(sizeof(*memcg_lrus) +\n\t\t\t      size * sizeof(void *), GFP_KERNEL);\n\tif (!memcg_lrus)\n\t\treturn -ENOMEM;\n\n\tif (__memcg_init_list_lru_node(memcg_lrus, 0, size)) {\n\t\tkvfree(memcg_lrus);\n\t\treturn -ENOMEM;\n\t}\n\tRCU_INIT_POINTER(nlru->memcg_lrus, memcg_lrus);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__memcg_init_list_lru_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "343-362",
    "snippet": "static int __memcg_init_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t      int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++) {\n\t\tstruct list_lru_one *l;\n\n\t\tl = kmalloc(sizeof(struct list_lru_one), GFP_KERNEL);\n\t\tif (!l)\n\t\t\tgoto fail;\n\n\t\tinit_one_lru(l);\n\t\tmemcg_lrus->lru[i] = l;\n\t}\n\treturn 0;\nfail:\n\t__memcg_destroy_list_lru_node(memcg_lrus, begin, i - 1);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__memcg_destroy_list_lru_node",
          "args": [
            "memcg_lrus",
            "begin",
            "i - 1"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "__memcg_destroy_list_lru_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "334-341",
          "snippet": "static void __memcg_destroy_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t\t  int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++)\n\t\tkfree(memcg_lrus->lru[i]);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void __memcg_destroy_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t\t  int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++)\n\t\tkfree(memcg_lrus->lru[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_one_lru",
          "args": [
            "l"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "init_one_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "327-331",
          "snippet": "static void init_one_lru(struct list_lru_one *l)\n{\n\tINIT_LIST_HEAD(&l->list);\n\tl->nr_items = 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void init_one_lru(struct list_lru_one *l)\n{\n\tINIT_LIST_HEAD(&l->list);\n\tl->nr_items = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct list_lru_one)",
            "GFP_KERNEL"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int __memcg_init_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t      int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++) {\n\t\tstruct list_lru_one *l;\n\n\t\tl = kmalloc(sizeof(struct list_lru_one), GFP_KERNEL);\n\t\tif (!l)\n\t\t\tgoto fail;\n\n\t\tinit_one_lru(l);\n\t\tmemcg_lrus->lru[i] = l;\n\t}\n\treturn 0;\nfail:\n\t__memcg_destroy_list_lru_node(memcg_lrus, begin, i - 1);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "__memcg_destroy_list_lru_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "334-341",
    "snippet": "static void __memcg_destroy_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t\t  int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++)\n\t\tkfree(memcg_lrus->lru[i]);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "memcg_lrus->lru[i]"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void __memcg_destroy_list_lru_node(struct list_lru_memcg *memcg_lrus,\n\t\t\t\t\t  int begin, int end)\n{\n\tint i;\n\n\tfor (i = begin; i < end; i++)\n\t\tkfree(memcg_lrus->lru[i]);\n}"
  },
  {
    "function_name": "init_one_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "327-331",
    "snippet": "static void init_one_lru(struct list_lru_one *l)\n{\n\tINIT_LIST_HEAD(&l->list);\n\tl->nr_items = 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&l->list"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void init_one_lru(struct list_lru_one *l)\n{\n\tINIT_LIST_HEAD(&l->list);\n\tl->nr_items = 0;\n}"
  },
  {
    "function_name": "list_lru_walk_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "300-324",
    "snippet": "unsigned long list_lru_walk_node(struct list_lru *lru, int nid,\n\t\t\t\t list_lru_walk_cb isolate, void *cb_arg,\n\t\t\t\t unsigned long *nr_to_walk)\n{\n\tlong isolated = 0;\n\tint memcg_idx;\n\n\tisolated += list_lru_walk_one(lru, nid, NULL, isolate, cb_arg,\n\t\t\t\t      nr_to_walk);\n\tif (*nr_to_walk > 0 && list_lru_memcg_aware(lru)) {\n\t\tfor_each_memcg_cache_index(memcg_idx) {\n\t\t\tstruct list_lru_node *nlru = &lru->node[nid];\n\n\t\t\tspin_lock(&nlru->lock);\n\t\t\tisolated += __list_lru_walk_one(nlru, memcg_idx,\n\t\t\t\t\t\t\tisolate, cb_arg,\n\t\t\t\t\t\t\tnr_to_walk);\n\t\t\tspin_unlock(&nlru->lock);\n\n\t\t\tif (*nr_to_walk <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn isolated;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlru->lock"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__list_lru_walk_one",
          "args": [
            "nlru",
            "memcg_idx",
            "isolate",
            "cb_arg",
            "nr_to_walk"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "__list_lru_walk_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "211-267",
          "snippet": "static unsigned long\n__list_lru_walk_one(struct list_lru_node *nlru, int memcg_idx,\n\t\t    list_lru_walk_cb isolate, void *cb_arg,\n\t\t    unsigned long *nr_to_walk)\n{\n\n\tstruct list_lru_one *l;\n\tstruct list_head *item, *n;\n\tunsigned long isolated = 0;\n\n\tl = list_lru_from_memcg_idx(nlru, memcg_idx);\nrestart:\n\tlist_for_each_safe(item, n, &l->list) {\n\t\tenum lru_status ret;\n\n\t\t/*\n\t\t * decrement nr_to_walk first so that we don't livelock if we\n\t\t * get stuck on large numbesr of LRU_RETRY items\n\t\t */\n\t\tif (!*nr_to_walk)\n\t\t\tbreak;\n\t\t--*nr_to_walk;\n\n\t\tret = isolate(item, l, &nlru->lock, cb_arg);\n\t\tswitch (ret) {\n\t\tcase LRU_REMOVED_RETRY:\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\t/* fall through */\n\t\tcase LRU_REMOVED:\n\t\t\tisolated++;\n\t\t\tnlru->nr_items--;\n\t\t\t/*\n\t\t\t * If the lru lock has been dropped, our list\n\t\t\t * traversal is now invalid and so we have to\n\t\t\t * restart from scratch.\n\t\t\t */\n\t\t\tif (ret == LRU_REMOVED_RETRY)\n\t\t\t\tgoto restart;\n\t\t\tbreak;\n\t\tcase LRU_ROTATE:\n\t\t\tlist_move_tail(item, &l->list);\n\t\t\tbreak;\n\t\tcase LRU_SKIP:\n\t\t\tbreak;\n\t\tcase LRU_RETRY:\n\t\t\t/*\n\t\t\t * The lru lock has been dropped, our list traversal is\n\t\t\t * now invalid and so we have to restart from scratch.\n\t\t\t */\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\tgoto restart;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\treturn isolated;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\n__list_lru_walk_one(struct list_lru_node *nlru, int memcg_idx,\n\t\t    list_lru_walk_cb isolate, void *cb_arg,\n\t\t    unsigned long *nr_to_walk)\n{\n\n\tstruct list_lru_one *l;\n\tstruct list_head *item, *n;\n\tunsigned long isolated = 0;\n\n\tl = list_lru_from_memcg_idx(nlru, memcg_idx);\nrestart:\n\tlist_for_each_safe(item, n, &l->list) {\n\t\tenum lru_status ret;\n\n\t\t/*\n\t\t * decrement nr_to_walk first so that we don't livelock if we\n\t\t * get stuck on large numbesr of LRU_RETRY items\n\t\t */\n\t\tif (!*nr_to_walk)\n\t\t\tbreak;\n\t\t--*nr_to_walk;\n\n\t\tret = isolate(item, l, &nlru->lock, cb_arg);\n\t\tswitch (ret) {\n\t\tcase LRU_REMOVED_RETRY:\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\t/* fall through */\n\t\tcase LRU_REMOVED:\n\t\t\tisolated++;\n\t\t\tnlru->nr_items--;\n\t\t\t/*\n\t\t\t * If the lru lock has been dropped, our list\n\t\t\t * traversal is now invalid and so we have to\n\t\t\t * restart from scratch.\n\t\t\t */\n\t\t\tif (ret == LRU_REMOVED_RETRY)\n\t\t\t\tgoto restart;\n\t\t\tbreak;\n\t\tcase LRU_ROTATE:\n\t\t\tlist_move_tail(item, &l->list);\n\t\t\tbreak;\n\t\tcase LRU_SKIP:\n\t\t\tbreak;\n\t\tcase LRU_RETRY:\n\t\t\t/*\n\t\t\t * The lru lock has been dropped, our list traversal is\n\t\t\t * now invalid and so we have to restart from scratch.\n\t\t\t */\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\tgoto restart;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\treturn isolated;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlru->lock"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_memcg_aware",
          "args": [
            "lru"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_memcg_aware",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "106-109",
          "snippet": "static inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_walk_one",
          "args": [
            "lru",
            "nid",
            "NULL",
            "isolate",
            "cb_arg",
            "nr_to_walk"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_walk_one_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "285-298",
          "snippet": "unsigned long\nlist_lru_walk_one_irq(struct list_lru *lru, int nid, struct mem_cgroup *memcg,\n\t\t      list_lru_walk_cb isolate, void *cb_arg,\n\t\t      unsigned long *nr_to_walk)\n{\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tunsigned long ret;\n\n\tspin_lock_irq(&nlru->lock);\n\tret = __list_lru_walk_one(nlru, memcg_cache_id(memcg), isolate, cb_arg,\n\t\t\t\t  nr_to_walk);\n\tspin_unlock_irq(&nlru->lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nunsigned long\nlist_lru_walk_one_irq(struct list_lru *lru, int nid, struct mem_cgroup *memcg,\n\t\t      list_lru_walk_cb isolate, void *cb_arg,\n\t\t      unsigned long *nr_to_walk)\n{\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tunsigned long ret;\n\n\tspin_lock_irq(&nlru->lock);\n\tret = __list_lru_walk_one(nlru, memcg_cache_id(memcg), isolate, cb_arg,\n\t\t\t\t  nr_to_walk);\n\tspin_unlock_irq(&nlru->lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nunsigned long list_lru_walk_node(struct list_lru *lru, int nid,\n\t\t\t\t list_lru_walk_cb isolate, void *cb_arg,\n\t\t\t\t unsigned long *nr_to_walk)\n{\n\tlong isolated = 0;\n\tint memcg_idx;\n\n\tisolated += list_lru_walk_one(lru, nid, NULL, isolate, cb_arg,\n\t\t\t\t      nr_to_walk);\n\tif (*nr_to_walk > 0 && list_lru_memcg_aware(lru)) {\n\t\tfor_each_memcg_cache_index(memcg_idx) {\n\t\t\tstruct list_lru_node *nlru = &lru->node[nid];\n\n\t\t\tspin_lock(&nlru->lock);\n\t\t\tisolated += __list_lru_walk_one(nlru, memcg_idx,\n\t\t\t\t\t\t\tisolate, cb_arg,\n\t\t\t\t\t\t\tnr_to_walk);\n\t\t\tspin_unlock(&nlru->lock);\n\n\t\t\tif (*nr_to_walk <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn isolated;\n}"
  },
  {
    "function_name": "list_lru_walk_one_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "285-298",
    "snippet": "unsigned long\nlist_lru_walk_one_irq(struct list_lru *lru, int nid, struct mem_cgroup *memcg,\n\t\t      list_lru_walk_cb isolate, void *cb_arg,\n\t\t      unsigned long *nr_to_walk)\n{\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tunsigned long ret;\n\n\tspin_lock_irq(&nlru->lock);\n\tret = __list_lru_walk_one(nlru, memcg_cache_id(memcg), isolate, cb_arg,\n\t\t\t\t  nr_to_walk);\n\tspin_unlock_irq(&nlru->lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&nlru->lock"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__list_lru_walk_one",
          "args": [
            "nlru",
            "memcg_cache_id(memcg)",
            "isolate",
            "cb_arg",
            "nr_to_walk"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "__list_lru_walk_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "211-267",
          "snippet": "static unsigned long\n__list_lru_walk_one(struct list_lru_node *nlru, int memcg_idx,\n\t\t    list_lru_walk_cb isolate, void *cb_arg,\n\t\t    unsigned long *nr_to_walk)\n{\n\n\tstruct list_lru_one *l;\n\tstruct list_head *item, *n;\n\tunsigned long isolated = 0;\n\n\tl = list_lru_from_memcg_idx(nlru, memcg_idx);\nrestart:\n\tlist_for_each_safe(item, n, &l->list) {\n\t\tenum lru_status ret;\n\n\t\t/*\n\t\t * decrement nr_to_walk first so that we don't livelock if we\n\t\t * get stuck on large numbesr of LRU_RETRY items\n\t\t */\n\t\tif (!*nr_to_walk)\n\t\t\tbreak;\n\t\t--*nr_to_walk;\n\n\t\tret = isolate(item, l, &nlru->lock, cb_arg);\n\t\tswitch (ret) {\n\t\tcase LRU_REMOVED_RETRY:\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\t/* fall through */\n\t\tcase LRU_REMOVED:\n\t\t\tisolated++;\n\t\t\tnlru->nr_items--;\n\t\t\t/*\n\t\t\t * If the lru lock has been dropped, our list\n\t\t\t * traversal is now invalid and so we have to\n\t\t\t * restart from scratch.\n\t\t\t */\n\t\t\tif (ret == LRU_REMOVED_RETRY)\n\t\t\t\tgoto restart;\n\t\t\tbreak;\n\t\tcase LRU_ROTATE:\n\t\t\tlist_move_tail(item, &l->list);\n\t\t\tbreak;\n\t\tcase LRU_SKIP:\n\t\t\tbreak;\n\t\tcase LRU_RETRY:\n\t\t\t/*\n\t\t\t * The lru lock has been dropped, our list traversal is\n\t\t\t * now invalid and so we have to restart from scratch.\n\t\t\t */\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\tgoto restart;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\treturn isolated;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\n__list_lru_walk_one(struct list_lru_node *nlru, int memcg_idx,\n\t\t    list_lru_walk_cb isolate, void *cb_arg,\n\t\t    unsigned long *nr_to_walk)\n{\n\n\tstruct list_lru_one *l;\n\tstruct list_head *item, *n;\n\tunsigned long isolated = 0;\n\n\tl = list_lru_from_memcg_idx(nlru, memcg_idx);\nrestart:\n\tlist_for_each_safe(item, n, &l->list) {\n\t\tenum lru_status ret;\n\n\t\t/*\n\t\t * decrement nr_to_walk first so that we don't livelock if we\n\t\t * get stuck on large numbesr of LRU_RETRY items\n\t\t */\n\t\tif (!*nr_to_walk)\n\t\t\tbreak;\n\t\t--*nr_to_walk;\n\n\t\tret = isolate(item, l, &nlru->lock, cb_arg);\n\t\tswitch (ret) {\n\t\tcase LRU_REMOVED_RETRY:\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\t/* fall through */\n\t\tcase LRU_REMOVED:\n\t\t\tisolated++;\n\t\t\tnlru->nr_items--;\n\t\t\t/*\n\t\t\t * If the lru lock has been dropped, our list\n\t\t\t * traversal is now invalid and so we have to\n\t\t\t * restart from scratch.\n\t\t\t */\n\t\t\tif (ret == LRU_REMOVED_RETRY)\n\t\t\t\tgoto restart;\n\t\t\tbreak;\n\t\tcase LRU_ROTATE:\n\t\t\tlist_move_tail(item, &l->list);\n\t\t\tbreak;\n\t\tcase LRU_SKIP:\n\t\t\tbreak;\n\t\tcase LRU_RETRY:\n\t\t\t/*\n\t\t\t * The lru lock has been dropped, our list traversal is\n\t\t\t * now invalid and so we have to restart from scratch.\n\t\t\t */\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\tgoto restart;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\treturn isolated;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_cache_id",
          "args": [
            "memcg"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&nlru->lock"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nunsigned long\nlist_lru_walk_one_irq(struct list_lru *lru, int nid, struct mem_cgroup *memcg,\n\t\t      list_lru_walk_cb isolate, void *cb_arg,\n\t\t      unsigned long *nr_to_walk)\n{\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tunsigned long ret;\n\n\tspin_lock_irq(&nlru->lock);\n\tret = __list_lru_walk_one(nlru, memcg_cache_id(memcg), isolate, cb_arg,\n\t\t\t\t  nr_to_walk);\n\tspin_unlock_irq(&nlru->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "list_lru_walk_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "269-282",
    "snippet": "unsigned long\nlist_lru_walk_one(struct list_lru *lru, int nid, struct mem_cgroup *memcg,\n\t\t  list_lru_walk_cb isolate, void *cb_arg,\n\t\t  unsigned long *nr_to_walk)\n{\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tunsigned long ret;\n\n\tspin_lock(&nlru->lock);\n\tret = __list_lru_walk_one(nlru, memcg_cache_id(memcg), isolate, cb_arg,\n\t\t\t\t  nr_to_walk);\n\tspin_unlock(&nlru->lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlru->lock"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__list_lru_walk_one",
          "args": [
            "nlru",
            "memcg_cache_id(memcg)",
            "isolate",
            "cb_arg",
            "nr_to_walk"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "__list_lru_walk_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "211-267",
          "snippet": "static unsigned long\n__list_lru_walk_one(struct list_lru_node *nlru, int memcg_idx,\n\t\t    list_lru_walk_cb isolate, void *cb_arg,\n\t\t    unsigned long *nr_to_walk)\n{\n\n\tstruct list_lru_one *l;\n\tstruct list_head *item, *n;\n\tunsigned long isolated = 0;\n\n\tl = list_lru_from_memcg_idx(nlru, memcg_idx);\nrestart:\n\tlist_for_each_safe(item, n, &l->list) {\n\t\tenum lru_status ret;\n\n\t\t/*\n\t\t * decrement nr_to_walk first so that we don't livelock if we\n\t\t * get stuck on large numbesr of LRU_RETRY items\n\t\t */\n\t\tif (!*nr_to_walk)\n\t\t\tbreak;\n\t\t--*nr_to_walk;\n\n\t\tret = isolate(item, l, &nlru->lock, cb_arg);\n\t\tswitch (ret) {\n\t\tcase LRU_REMOVED_RETRY:\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\t/* fall through */\n\t\tcase LRU_REMOVED:\n\t\t\tisolated++;\n\t\t\tnlru->nr_items--;\n\t\t\t/*\n\t\t\t * If the lru lock has been dropped, our list\n\t\t\t * traversal is now invalid and so we have to\n\t\t\t * restart from scratch.\n\t\t\t */\n\t\t\tif (ret == LRU_REMOVED_RETRY)\n\t\t\t\tgoto restart;\n\t\t\tbreak;\n\t\tcase LRU_ROTATE:\n\t\t\tlist_move_tail(item, &l->list);\n\t\t\tbreak;\n\t\tcase LRU_SKIP:\n\t\t\tbreak;\n\t\tcase LRU_RETRY:\n\t\t\t/*\n\t\t\t * The lru lock has been dropped, our list traversal is\n\t\t\t * now invalid and so we have to restart from scratch.\n\t\t\t */\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\tgoto restart;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\treturn isolated;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\n__list_lru_walk_one(struct list_lru_node *nlru, int memcg_idx,\n\t\t    list_lru_walk_cb isolate, void *cb_arg,\n\t\t    unsigned long *nr_to_walk)\n{\n\n\tstruct list_lru_one *l;\n\tstruct list_head *item, *n;\n\tunsigned long isolated = 0;\n\n\tl = list_lru_from_memcg_idx(nlru, memcg_idx);\nrestart:\n\tlist_for_each_safe(item, n, &l->list) {\n\t\tenum lru_status ret;\n\n\t\t/*\n\t\t * decrement nr_to_walk first so that we don't livelock if we\n\t\t * get stuck on large numbesr of LRU_RETRY items\n\t\t */\n\t\tif (!*nr_to_walk)\n\t\t\tbreak;\n\t\t--*nr_to_walk;\n\n\t\tret = isolate(item, l, &nlru->lock, cb_arg);\n\t\tswitch (ret) {\n\t\tcase LRU_REMOVED_RETRY:\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\t/* fall through */\n\t\tcase LRU_REMOVED:\n\t\t\tisolated++;\n\t\t\tnlru->nr_items--;\n\t\t\t/*\n\t\t\t * If the lru lock has been dropped, our list\n\t\t\t * traversal is now invalid and so we have to\n\t\t\t * restart from scratch.\n\t\t\t */\n\t\t\tif (ret == LRU_REMOVED_RETRY)\n\t\t\t\tgoto restart;\n\t\t\tbreak;\n\t\tcase LRU_ROTATE:\n\t\t\tlist_move_tail(item, &l->list);\n\t\t\tbreak;\n\t\tcase LRU_SKIP:\n\t\t\tbreak;\n\t\tcase LRU_RETRY:\n\t\t\t/*\n\t\t\t * The lru lock has been dropped, our list traversal is\n\t\t\t * now invalid and so we have to restart from scratch.\n\t\t\t */\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\tgoto restart;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\treturn isolated;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_cache_id",
          "args": [
            "memcg"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlru->lock"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nunsigned long\nlist_lru_walk_one(struct list_lru *lru, int nid, struct mem_cgroup *memcg,\n\t\t  list_lru_walk_cb isolate, void *cb_arg,\n\t\t  unsigned long *nr_to_walk)\n{\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tunsigned long ret;\n\n\tspin_lock(&nlru->lock);\n\tret = __list_lru_walk_one(nlru, memcg_cache_id(memcg), isolate, cb_arg,\n\t\t\t\t  nr_to_walk);\n\tspin_unlock(&nlru->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__list_lru_walk_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "211-267",
    "snippet": "static unsigned long\n__list_lru_walk_one(struct list_lru_node *nlru, int memcg_idx,\n\t\t    list_lru_walk_cb isolate, void *cb_arg,\n\t\t    unsigned long *nr_to_walk)\n{\n\n\tstruct list_lru_one *l;\n\tstruct list_head *item, *n;\n\tunsigned long isolated = 0;\n\n\tl = list_lru_from_memcg_idx(nlru, memcg_idx);\nrestart:\n\tlist_for_each_safe(item, n, &l->list) {\n\t\tenum lru_status ret;\n\n\t\t/*\n\t\t * decrement nr_to_walk first so that we don't livelock if we\n\t\t * get stuck on large numbesr of LRU_RETRY items\n\t\t */\n\t\tif (!*nr_to_walk)\n\t\t\tbreak;\n\t\t--*nr_to_walk;\n\n\t\tret = isolate(item, l, &nlru->lock, cb_arg);\n\t\tswitch (ret) {\n\t\tcase LRU_REMOVED_RETRY:\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\t/* fall through */\n\t\tcase LRU_REMOVED:\n\t\t\tisolated++;\n\t\t\tnlru->nr_items--;\n\t\t\t/*\n\t\t\t * If the lru lock has been dropped, our list\n\t\t\t * traversal is now invalid and so we have to\n\t\t\t * restart from scratch.\n\t\t\t */\n\t\t\tif (ret == LRU_REMOVED_RETRY)\n\t\t\t\tgoto restart;\n\t\t\tbreak;\n\t\tcase LRU_ROTATE:\n\t\t\tlist_move_tail(item, &l->list);\n\t\t\tbreak;\n\t\tcase LRU_SKIP:\n\t\t\tbreak;\n\t\tcase LRU_RETRY:\n\t\t\t/*\n\t\t\t * The lru lock has been dropped, our list traversal is\n\t\t\t * now invalid and so we have to restart from scratch.\n\t\t\t */\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\tgoto restart;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\treturn isolated;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&nlru->lock"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "item",
            "&l->list"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&nlru->lock"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate",
          "args": [
            "item",
            "l",
            "&nlru->lock",
            "cb_arg"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_migratepages_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "692-960",
          "snippet": "static unsigned long\nisolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,\n\t\t\tunsigned long end_pfn, isolate_mode_t isolate_mode)\n{\n\tstruct zone *zone = cc->zone;\n\tunsigned long nr_scanned = 0, nr_isolated = 0;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tstruct page *page = NULL, *valid_page = NULL;\n\tunsigned long start_pfn = low_pfn;\n\tbool skip_on_failure = false;\n\tunsigned long next_skip_pfn = 0;\n\n\t/*\n\t * Ensure that there are not too many pages isolated from the LRU\n\t * list by either parallel reclaimers or compaction. If there are,\n\t * delay for some time until fewer pages are isolated\n\t */\n\twhile (unlikely(too_many_isolated(zone))) {\n\t\t/* async migration should just abort */\n\t\tif (cc->mode == MIGRATE_ASYNC)\n\t\t\treturn 0;\n\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn 0;\n\t}\n\n\tif (compact_should_abort(cc))\n\t\treturn 0;\n\n\tif (cc->direct_compaction && (cc->mode == MIGRATE_ASYNC)) {\n\t\tskip_on_failure = true;\n\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t}\n\n\t/* Time to isolate some pages for migration */\n\tfor (; low_pfn < end_pfn; low_pfn++) {\n\n\t\tif (skip_on_failure && low_pfn >= next_skip_pfn) {\n\t\t\t/*\n\t\t\t * We have isolated all migration candidates in the\n\t\t\t * previous order-aligned block, and did not skip it due\n\t\t\t * to failure. We should migrate the pages now and\n\t\t\t * hopefully succeed compaction.\n\t\t\t */\n\t\t\tif (nr_isolated)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * We failed to isolate in the previous order-aligned\n\t\t\t * block. Set the new boundary to the end of the\n\t\t\t * current block. Note we can't simply increase\n\t\t\t * next_skip_pfn by 1 << order, as low_pfn might have\n\t\t\t * been incremented by a higher number due to skipping\n\t\t\t * a compound or a high-order buddy page in the\n\t\t\t * previous loop iteration.\n\t\t\t */\n\t\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t\t}\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort async compaction\n\t\t * if contended.\n\t\t */\n\t\tif (!(low_pfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(zone_lru_lock(zone), flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tif (!pfn_valid_within(low_pfn))\n\t\t\tgoto isolate_fail;\n\t\tnr_scanned++;\n\n\t\tpage = pfn_to_page(low_pfn);\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * Skip if free. We read page order here without zone lock\n\t\t * which is generally unsafe, but the race window is small and\n\t\t * the worst thing that can happen is that we skip some\n\t\t * potential isolation targets.\n\t\t */\n\t\tif (PageBuddy(page)) {\n\t\t\tunsigned long freepage_order = page_order_unsafe(page);\n\n\t\t\t/*\n\t\t\t * Without lock, we cannot be sure that what we got is\n\t\t\t * a valid page order. Consider only values in the\n\t\t\t * valid order range to prevent low_pfn overflow.\n\t\t\t */\n\t\t\tif (freepage_order > 0 && freepage_order < MAX_ORDER)\n\t\t\t\tlow_pfn += (1UL << freepage_order) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Regardless of being on LRU, compound pages such as THP and\n\t\t * hugetlbfs are not to be compacted. We can potentially save\n\t\t * a lot of iterations if we skip them at once. The check is\n\t\t * racy, but we can consider only valid values and the only\n\t\t * danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER))\n\t\t\t\tlow_pfn += (1UL << order) - 1;\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Check may be lockless but that's ok as we recheck later.\n\t\t * It's possible to migrate LRU and non-lru movable pages.\n\t\t * Skip any other type of page\n\t\t */\n\t\tif (!PageLRU(page)) {\n\t\t\t/*\n\t\t\t * __PageMovable can return false positive so we need\n\t\t\t * to verify it under page_lock.\n\t\t\t */\n\t\t\tif (unlikely(__PageMovable(page)) &&\n\t\t\t\t\t!PageIsolated(page)) {\n\t\t\t\tif (locked) {\n\t\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\t\tlocked = false;\n\t\t\t\t}\n\n\t\t\t\tif (!isolate_movable_page(page, isolate_mode))\n\t\t\t\t\tgoto isolate_success;\n\t\t\t}\n\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Migration will fail if an anonymous page is pinned in memory,\n\t\t * so avoid taking lru_lock and isolating it unnecessarily in an\n\t\t * admittedly racy check.\n\t\t */\n\t\tif (!page_mapping(page) &&\n\t\t    page_count(page) > page_mapcount(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * Only allow to migrate anonymous pages in GFP_NOFS context\n\t\t * because those do not depend on fs locks.\n\t\t */\n\t\tif (!(cc->gfp_mask & __GFP_FS) && page_mapping(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/* If we already hold the lock, we can skip some rechecking */\n\t\tif (!locked) {\n\t\t\tlocked = compact_trylock_irqsave(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck PageLRU and PageCompound under lock */\n\t\t\tif (!PageLRU(page))\n\t\t\t\tgoto isolate_fail;\n\n\t\t\t/*\n\t\t\t * Page become compound since the non-locked check,\n\t\t\t * and it's on LRU. It can only be a THP so the order\n\t\t\t * is safe to read and it's 0 for tail pages.\n\t\t\t */\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tlow_pfn += (1UL << compound_order(page)) - 1;\n\t\t\t\tgoto isolate_fail;\n\t\t\t}\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\n\t\t/* Try isolate the page */\n\t\tif (__isolate_lru_page(page, isolate_mode) != 0)\n\t\t\tgoto isolate_fail;\n\n\t\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\n\t\t/* Successfully isolated */\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\nisolate_success:\n\t\tlist_add(&page->lru, &cc->migratepages);\n\t\tcc->nr_migratepages++;\n\t\tnr_isolated++;\n\n\t\t/*\n\t\t * Record where we could have freed pages by migration and not\n\t\t * yet flushed them to buddy allocator.\n\t\t * - this is the lowest page that was isolated and likely be\n\t\t * then freed by migration.\n\t\t */\n\t\tif (!cc->last_migrated_pfn)\n\t\t\tcc->last_migrated_pfn = low_pfn;\n\n\t\t/* Avoid isolating too much */\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX) {\n\t\t\t++low_pfn;\n\t\t\tbreak;\n\t\t}\n\n\t\tcontinue;\nisolate_fail:\n\t\tif (!skip_on_failure)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have isolated some pages, but then failed. Release them\n\t\t * instead of migrating, as we cannot form the cc->order buddy\n\t\t * page anyway.\n\t\t */\n\t\tif (nr_isolated) {\n\t\t\tif (locked) {\n\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t\t\t\tlocked = false;\n\t\t\t}\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tcc->last_migrated_pfn = 0;\n\t\t\tnr_isolated = 0;\n\t\t}\n\n\t\tif (low_pfn < next_skip_pfn) {\n\t\t\tlow_pfn = next_skip_pfn - 1;\n\t\t\t/*\n\t\t\t * The check near the loop beginning would have updated\n\t\t\t * next_skip_pfn too, but this is a bit simpler.\n\t\t\t */\n\t\t\tnext_skip_pfn += 1UL << cc->order;\n\t\t}\n\t}\n\n\t/*\n\t * The PageBuddy() check could have potentially brought us outside\n\t * the range to be scanned.\n\t */\n\tif (unlikely(low_pfn > end_pfn))\n\t\tlow_pfn = end_pfn;\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\n\t/*\n\t * Update the pageblock-skip information and cached scanner pfn,\n\t * if the whole pageblock was scanned without isolating any page.\n\t */\n\tif (low_pfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, nr_isolated, true);\n\n\ttrace_mm_compaction_isolate_migratepages(start_pfn, low_pfn,\n\t\t\t\t\t\tnr_scanned, nr_isolated);\n\n\tcc->total_migrate_scanned += nr_scanned;\n\tif (nr_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, nr_isolated);\n\n\treturn low_pfn;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic unsigned long\nisolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,\n\t\t\tunsigned long end_pfn, isolate_mode_t isolate_mode)\n{\n\tstruct zone *zone = cc->zone;\n\tunsigned long nr_scanned = 0, nr_isolated = 0;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tstruct page *page = NULL, *valid_page = NULL;\n\tunsigned long start_pfn = low_pfn;\n\tbool skip_on_failure = false;\n\tunsigned long next_skip_pfn = 0;\n\n\t/*\n\t * Ensure that there are not too many pages isolated from the LRU\n\t * list by either parallel reclaimers or compaction. If there are,\n\t * delay for some time until fewer pages are isolated\n\t */\n\twhile (unlikely(too_many_isolated(zone))) {\n\t\t/* async migration should just abort */\n\t\tif (cc->mode == MIGRATE_ASYNC)\n\t\t\treturn 0;\n\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn 0;\n\t}\n\n\tif (compact_should_abort(cc))\n\t\treturn 0;\n\n\tif (cc->direct_compaction && (cc->mode == MIGRATE_ASYNC)) {\n\t\tskip_on_failure = true;\n\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t}\n\n\t/* Time to isolate some pages for migration */\n\tfor (; low_pfn < end_pfn; low_pfn++) {\n\n\t\tif (skip_on_failure && low_pfn >= next_skip_pfn) {\n\t\t\t/*\n\t\t\t * We have isolated all migration candidates in the\n\t\t\t * previous order-aligned block, and did not skip it due\n\t\t\t * to failure. We should migrate the pages now and\n\t\t\t * hopefully succeed compaction.\n\t\t\t */\n\t\t\tif (nr_isolated)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * We failed to isolate in the previous order-aligned\n\t\t\t * block. Set the new boundary to the end of the\n\t\t\t * current block. Note we can't simply increase\n\t\t\t * next_skip_pfn by 1 << order, as low_pfn might have\n\t\t\t * been incremented by a higher number due to skipping\n\t\t\t * a compound or a high-order buddy page in the\n\t\t\t * previous loop iteration.\n\t\t\t */\n\t\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t\t}\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort async compaction\n\t\t * if contended.\n\t\t */\n\t\tif (!(low_pfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(zone_lru_lock(zone), flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tif (!pfn_valid_within(low_pfn))\n\t\t\tgoto isolate_fail;\n\t\tnr_scanned++;\n\n\t\tpage = pfn_to_page(low_pfn);\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * Skip if free. We read page order here without zone lock\n\t\t * which is generally unsafe, but the race window is small and\n\t\t * the worst thing that can happen is that we skip some\n\t\t * potential isolation targets.\n\t\t */\n\t\tif (PageBuddy(page)) {\n\t\t\tunsigned long freepage_order = page_order_unsafe(page);\n\n\t\t\t/*\n\t\t\t * Without lock, we cannot be sure that what we got is\n\t\t\t * a valid page order. Consider only values in the\n\t\t\t * valid order range to prevent low_pfn overflow.\n\t\t\t */\n\t\t\tif (freepage_order > 0 && freepage_order < MAX_ORDER)\n\t\t\t\tlow_pfn += (1UL << freepage_order) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Regardless of being on LRU, compound pages such as THP and\n\t\t * hugetlbfs are not to be compacted. We can potentially save\n\t\t * a lot of iterations if we skip them at once. The check is\n\t\t * racy, but we can consider only valid values and the only\n\t\t * danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER))\n\t\t\t\tlow_pfn += (1UL << order) - 1;\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Check may be lockless but that's ok as we recheck later.\n\t\t * It's possible to migrate LRU and non-lru movable pages.\n\t\t * Skip any other type of page\n\t\t */\n\t\tif (!PageLRU(page)) {\n\t\t\t/*\n\t\t\t * __PageMovable can return false positive so we need\n\t\t\t * to verify it under page_lock.\n\t\t\t */\n\t\t\tif (unlikely(__PageMovable(page)) &&\n\t\t\t\t\t!PageIsolated(page)) {\n\t\t\t\tif (locked) {\n\t\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\t\tlocked = false;\n\t\t\t\t}\n\n\t\t\t\tif (!isolate_movable_page(page, isolate_mode))\n\t\t\t\t\tgoto isolate_success;\n\t\t\t}\n\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Migration will fail if an anonymous page is pinned in memory,\n\t\t * so avoid taking lru_lock and isolating it unnecessarily in an\n\t\t * admittedly racy check.\n\t\t */\n\t\tif (!page_mapping(page) &&\n\t\t    page_count(page) > page_mapcount(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * Only allow to migrate anonymous pages in GFP_NOFS context\n\t\t * because those do not depend on fs locks.\n\t\t */\n\t\tif (!(cc->gfp_mask & __GFP_FS) && page_mapping(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/* If we already hold the lock, we can skip some rechecking */\n\t\tif (!locked) {\n\t\t\tlocked = compact_trylock_irqsave(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck PageLRU and PageCompound under lock */\n\t\t\tif (!PageLRU(page))\n\t\t\t\tgoto isolate_fail;\n\n\t\t\t/*\n\t\t\t * Page become compound since the non-locked check,\n\t\t\t * and it's on LRU. It can only be a THP so the order\n\t\t\t * is safe to read and it's 0 for tail pages.\n\t\t\t */\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tlow_pfn += (1UL << compound_order(page)) - 1;\n\t\t\t\tgoto isolate_fail;\n\t\t\t}\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\n\t\t/* Try isolate the page */\n\t\tif (__isolate_lru_page(page, isolate_mode) != 0)\n\t\t\tgoto isolate_fail;\n\n\t\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\n\t\t/* Successfully isolated */\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\nisolate_success:\n\t\tlist_add(&page->lru, &cc->migratepages);\n\t\tcc->nr_migratepages++;\n\t\tnr_isolated++;\n\n\t\t/*\n\t\t * Record where we could have freed pages by migration and not\n\t\t * yet flushed them to buddy allocator.\n\t\t * - this is the lowest page that was isolated and likely be\n\t\t * then freed by migration.\n\t\t */\n\t\tif (!cc->last_migrated_pfn)\n\t\t\tcc->last_migrated_pfn = low_pfn;\n\n\t\t/* Avoid isolating too much */\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX) {\n\t\t\t++low_pfn;\n\t\t\tbreak;\n\t\t}\n\n\t\tcontinue;\nisolate_fail:\n\t\tif (!skip_on_failure)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have isolated some pages, but then failed. Release them\n\t\t * instead of migrating, as we cannot form the cc->order buddy\n\t\t * page anyway.\n\t\t */\n\t\tif (nr_isolated) {\n\t\t\tif (locked) {\n\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t\t\t\tlocked = false;\n\t\t\t}\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tcc->last_migrated_pfn = 0;\n\t\t\tnr_isolated = 0;\n\t\t}\n\n\t\tif (low_pfn < next_skip_pfn) {\n\t\t\tlow_pfn = next_skip_pfn - 1;\n\t\t\t/*\n\t\t\t * The check near the loop beginning would have updated\n\t\t\t * next_skip_pfn too, but this is a bit simpler.\n\t\t\t */\n\t\t\tnext_skip_pfn += 1UL << cc->order;\n\t\t}\n\t}\n\n\t/*\n\t * The PageBuddy() check could have potentially brought us outside\n\t * the range to be scanned.\n\t */\n\tif (unlikely(low_pfn > end_pfn))\n\t\tlow_pfn = end_pfn;\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\n\t/*\n\t * Update the pageblock-skip information and cached scanner pfn,\n\t * if the whole pageblock was scanned without isolating any page.\n\t */\n\tif (low_pfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, nr_isolated, true);\n\n\ttrace_mm_compaction_isolate_migratepages(start_pfn, low_pfn,\n\t\t\t\t\t\tnr_scanned, nr_isolated);\n\n\tcc->total_migrate_scanned += nr_scanned;\n\tif (nr_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, nr_isolated);\n\n\treturn low_pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "item",
            "n",
            "&l->list"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_from_memcg_idx",
          "args": [
            "nlru",
            "memcg_idx"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_from_memcg_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "111-115",
          "snippet": "static inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\treturn &nlru->lru;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\treturn &nlru->lru;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\n__list_lru_walk_one(struct list_lru_node *nlru, int memcg_idx,\n\t\t    list_lru_walk_cb isolate, void *cb_arg,\n\t\t    unsigned long *nr_to_walk)\n{\n\n\tstruct list_lru_one *l;\n\tstruct list_head *item, *n;\n\tunsigned long isolated = 0;\n\n\tl = list_lru_from_memcg_idx(nlru, memcg_idx);\nrestart:\n\tlist_for_each_safe(item, n, &l->list) {\n\t\tenum lru_status ret;\n\n\t\t/*\n\t\t * decrement nr_to_walk first so that we don't livelock if we\n\t\t * get stuck on large numbesr of LRU_RETRY items\n\t\t */\n\t\tif (!*nr_to_walk)\n\t\t\tbreak;\n\t\t--*nr_to_walk;\n\n\t\tret = isolate(item, l, &nlru->lock, cb_arg);\n\t\tswitch (ret) {\n\t\tcase LRU_REMOVED_RETRY:\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\t/* fall through */\n\t\tcase LRU_REMOVED:\n\t\t\tisolated++;\n\t\t\tnlru->nr_items--;\n\t\t\t/*\n\t\t\t * If the lru lock has been dropped, our list\n\t\t\t * traversal is now invalid and so we have to\n\t\t\t * restart from scratch.\n\t\t\t */\n\t\t\tif (ret == LRU_REMOVED_RETRY)\n\t\t\t\tgoto restart;\n\t\t\tbreak;\n\t\tcase LRU_ROTATE:\n\t\t\tlist_move_tail(item, &l->list);\n\t\t\tbreak;\n\t\tcase LRU_SKIP:\n\t\t\tbreak;\n\t\tcase LRU_RETRY:\n\t\t\t/*\n\t\t\t * The lru lock has been dropped, our list traversal is\n\t\t\t * now invalid and so we have to restart from scratch.\n\t\t\t */\n\t\t\tassert_spin_locked(&nlru->lock);\n\t\t\tgoto restart;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\treturn isolated;\n}"
  },
  {
    "function_name": "list_lru_count_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "202-208",
    "snippet": "unsigned long list_lru_count_node(struct list_lru *lru, int nid)\n{\n\tstruct list_lru_node *nlru;\n\n\tnlru = &lru->node[nid];\n\treturn nlru->nr_items;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nunsigned long list_lru_count_node(struct list_lru *lru, int nid)\n{\n\tstruct list_lru_node *nlru;\n\n\tnlru = &lru->node[nid];\n\treturn nlru->nr_items;\n}"
  },
  {
    "function_name": "list_lru_count_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "186-199",
    "snippet": "unsigned long list_lru_count_one(struct list_lru *lru,\n\t\t\t\t int nid, struct mem_cgroup *memcg)\n{\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tstruct list_lru_one *l;\n\tunsigned long count;\n\n\trcu_read_lock();\n\tl = list_lru_from_memcg_idx(nlru, memcg_cache_id(memcg));\n\tcount = l->nr_items;\n\trcu_read_unlock();\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_from_memcg_idx",
          "args": [
            "nlru",
            "memcg_cache_id(memcg)"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_from_memcg_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "111-115",
          "snippet": "static inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\treturn &nlru->lru;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\treturn &nlru->lru;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_cache_id",
          "args": [
            "memcg"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nunsigned long list_lru_count_one(struct list_lru *lru,\n\t\t\t\t int nid, struct mem_cgroup *memcg)\n{\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tstruct list_lru_one *l;\n\tunsigned long count;\n\n\trcu_read_lock();\n\tl = list_lru_from_memcg_idx(nlru, memcg_cache_id(memcg));\n\tcount = l->nr_items;\n\trcu_read_unlock();\n\n\treturn count;\n}"
  },
  {
    "function_name": "list_lru_isolate_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "178-183",
    "snippet": "void list_lru_isolate_move(struct list_lru_one *list, struct list_head *item,\n\t\t\t   struct list_head *head)\n{\n\tlist_move(item, head);\n\tlist->nr_items--;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "item",
            "head"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid list_lru_isolate_move(struct list_lru_one *list, struct list_head *item,\n\t\t\t   struct list_head *head)\n{\n\tlist_move(item, head);\n\tlist->nr_items--;\n}"
  },
  {
    "function_name": "list_lru_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "171-175",
    "snippet": "void list_lru_isolate(struct list_lru_one *list, struct list_head *item)\n{\n\tlist_del_init(item);\n\tlist->nr_items--;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "item"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid list_lru_isolate(struct list_lru_one *list, struct list_head *item)\n{\n\tlist_del_init(item);\n\tlist->nr_items--;\n}"
  },
  {
    "function_name": "list_lru_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "151-168",
    "snippet": "bool list_lru_del(struct list_lru *lru, struct list_head *item)\n{\n\tint nid = page_to_nid(virt_to_page(item));\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tstruct list_lru_one *l;\n\n\tspin_lock(&nlru->lock);\n\tif (!list_empty(item)) {\n\t\tl = list_lru_from_kmem(nlru, item, NULL);\n\t\tlist_del_init(item);\n\t\tl->nr_items--;\n\t\tnlru->nr_items--;\n\t\tspin_unlock(&nlru->lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nlru->lock);\n\treturn false;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlru->lock"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlru->lock"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "item"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_from_kmem",
          "args": [
            "nlru",
            "item",
            "NULL"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_from_kmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "117-124",
          "snippet": "static inline struct list_lru_one *\nlist_lru_from_kmem(struct list_lru_node *nlru, void *ptr,\n\t\t   struct mem_cgroup **memcg_ptr)\n{\n\tif (memcg_ptr)\n\t\t*memcg_ptr = NULL;\n\treturn &nlru->lru;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline struct list_lru_one *\nlist_lru_from_kmem(struct list_lru_node *nlru, void *ptr,\n\t\t   struct mem_cgroup **memcg_ptr)\n{\n\tif (memcg_ptr)\n\t\t*memcg_ptr = NULL;\n\treturn &nlru->lru;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "item"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlru->lock"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "virt_to_page(item)"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "item"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nbool list_lru_del(struct list_lru *lru, struct list_head *item)\n{\n\tint nid = page_to_nid(virt_to_page(item));\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tstruct list_lru_one *l;\n\n\tspin_lock(&nlru->lock);\n\tif (!list_empty(item)) {\n\t\tl = list_lru_from_kmem(nlru, item, NULL);\n\t\tlist_del_init(item);\n\t\tl->nr_items--;\n\t\tnlru->nr_items--;\n\t\tspin_unlock(&nlru->lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nlru->lock);\n\treturn false;\n}"
  },
  {
    "function_name": "list_lru_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "127-148",
    "snippet": "bool list_lru_add(struct list_lru *lru, struct list_head *item)\n{\n\tint nid = page_to_nid(virt_to_page(item));\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tstruct mem_cgroup *memcg;\n\tstruct list_lru_one *l;\n\n\tspin_lock(&nlru->lock);\n\tif (list_empty(item)) {\n\t\tl = list_lru_from_kmem(nlru, item, &memcg);\n\t\tlist_add_tail(item, &l->list);\n\t\t/* Set shrinker bit if the first element was added */\n\t\tif (!l->nr_items++)\n\t\t\tmemcg_set_shrinker_bit(memcg, nid,\n\t\t\t\t\t       lru_shrinker_id(lru));\n\t\tnlru->nr_items++;\n\t\tspin_unlock(&nlru->lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nlru->lock);\n\treturn false;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlru->lock"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlru->lock"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_set_shrinker_bit",
          "args": [
            "memcg",
            "nid",
            "lru_shrinker_id(lru)"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_set_shrinker_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "426-438",
          "snippet": "void memcg_set_shrinker_bit(struct mem_cgroup *memcg, int nid, int shrinker_id)\n{\n\tif (shrinker_id >= 0 && memcg && !mem_cgroup_is_root(memcg)) {\n\t\tstruct memcg_shrinker_map *map;\n\n\t\trcu_read_lock();\n\t\tmap = rcu_dereference(memcg->nodeinfo[nid]->shrinker_map);\n\t\t/* Pairs with smp mb in shrink_slab() */\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(shrinker_id, map->map);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid memcg_set_shrinker_bit(struct mem_cgroup *memcg, int nid, int shrinker_id)\n{\n\tif (shrinker_id >= 0 && memcg && !mem_cgroup_is_root(memcg)) {\n\t\tstruct memcg_shrinker_map *map;\n\n\t\trcu_read_lock();\n\t\tmap = rcu_dereference(memcg->nodeinfo[nid]->shrinker_map);\n\t\t/* Pairs with smp mb in shrink_slab() */\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(shrinker_id, map->map);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_shrinker_id",
          "args": [
            "lru"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "lru_shrinker_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "101-104",
          "snippet": "static int lru_shrinker_id(struct list_lru *lru)\n{\n\treturn -1;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int lru_shrinker_id(struct list_lru *lru)\n{\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "item",
            "&l->list"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_from_kmem",
          "args": [
            "nlru",
            "item",
            "&memcg"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_from_kmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "117-124",
          "snippet": "static inline struct list_lru_one *\nlist_lru_from_kmem(struct list_lru_node *nlru, void *ptr,\n\t\t   struct mem_cgroup **memcg_ptr)\n{\n\tif (memcg_ptr)\n\t\t*memcg_ptr = NULL;\n\treturn &nlru->lru;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline struct list_lru_one *\nlist_lru_from_kmem(struct list_lru_node *nlru, void *ptr,\n\t\t   struct mem_cgroup **memcg_ptr)\n{\n\tif (memcg_ptr)\n\t\t*memcg_ptr = NULL;\n\treturn &nlru->lru;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "item"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlru->lock"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "virt_to_page(item)"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "item"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nbool list_lru_add(struct list_lru *lru, struct list_head *item)\n{\n\tint nid = page_to_nid(virt_to_page(item));\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tstruct mem_cgroup *memcg;\n\tstruct list_lru_one *l;\n\n\tspin_lock(&nlru->lock);\n\tif (list_empty(item)) {\n\t\tl = list_lru_from_kmem(nlru, item, &memcg);\n\t\tlist_add_tail(item, &l->list);\n\t\t/* Set shrinker bit if the first element was added */\n\t\tif (!l->nr_items++)\n\t\t\tmemcg_set_shrinker_bit(memcg, nid,\n\t\t\t\t\t       lru_shrinker_id(lru));\n\t\tnlru->nr_items++;\n\t\tspin_unlock(&nlru->lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nlru->lock);\n\treturn false;\n}"
  },
  {
    "function_name": "list_lru_from_kmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "117-124",
    "snippet": "static inline struct list_lru_one *\nlist_lru_from_kmem(struct list_lru_node *nlru, void *ptr,\n\t\t   struct mem_cgroup **memcg_ptr)\n{\n\tif (memcg_ptr)\n\t\t*memcg_ptr = NULL;\n\treturn &nlru->lru;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline struct list_lru_one *\nlist_lru_from_kmem(struct list_lru_node *nlru, void *ptr,\n\t\t   struct mem_cgroup **memcg_ptr)\n{\n\tif (memcg_ptr)\n\t\t*memcg_ptr = NULL;\n\treturn &nlru->lru;\n}"
  },
  {
    "function_name": "list_lru_from_memcg_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "111-115",
    "snippet": "static inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\treturn &nlru->lru;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\treturn &nlru->lru;\n}"
  },
  {
    "function_name": "list_lru_memcg_aware",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "106-109",
    "snippet": "static inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "lru_shrinker_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "101-104",
    "snippet": "static int lru_shrinker_id(struct list_lru *lru)\n{\n\treturn -1;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int lru_shrinker_id(struct list_lru *lru)\n{\n\treturn -1;\n}"
  },
  {
    "function_name": "list_lru_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "97-99",
    "snippet": "static void list_lru_unregister(struct list_lru *lru)\n{\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void list_lru_unregister(struct list_lru *lru)\n{\n}"
  },
  {
    "function_name": "list_lru_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "93-95",
    "snippet": "static void list_lru_register(struct list_lru *lru)\n{\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void list_lru_register(struct list_lru *lru)\n{\n}"
  },
  {
    "function_name": "list_lru_from_kmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "72-91",
    "snippet": "static inline struct list_lru_one *\nlist_lru_from_kmem(struct list_lru_node *nlru, void *ptr,\n\t\t   struct mem_cgroup **memcg_ptr)\n{\n\tstruct list_lru_one *l = &nlru->lru;\n\tstruct mem_cgroup *memcg = NULL;\n\n\tif (!nlru->memcg_lrus)\n\t\tgoto out;\n\n\tmemcg = mem_cgroup_from_kmem(ptr);\n\tif (!memcg)\n\t\tgoto out;\n\n\tl = list_lru_from_memcg_idx(nlru, memcg_cache_id(memcg));\nout:\n\tif (memcg_ptr)\n\t\t*memcg_ptr = memcg;\n\treturn l;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_from_memcg_idx",
          "args": [
            "nlru",
            "memcg_cache_id(memcg)"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_from_memcg_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "111-115",
          "snippet": "static inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\treturn &nlru->lru;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\treturn &nlru->lru;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_cache_id",
          "args": [
            "memcg"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_kmem",
          "args": [
            "ptr"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_from_kmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "62-70",
          "snippet": "mem_cgroup *mem_cgroup_from_kmem(void *ptr)\n{\n\tstruct page *page;\n\n\tif (!memcg_kmem_enabled())\n\t\treturn NULL;\n\tpage = virt_to_head_page(ptr);\n\treturn page->mem_cgroup;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nmem_cgroup *mem_cgroup_from_kmem(void *ptr)\n{\n\tstruct page *page;\n\n\tif (!memcg_kmem_enabled())\n\t\treturn NULL;\n\tpage = virt_to_head_page(ptr);\n\treturn page->mem_cgroup;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline struct list_lru_one *\nlist_lru_from_kmem(struct list_lru_node *nlru, void *ptr,\n\t\t   struct mem_cgroup **memcg_ptr)\n{\n\tstruct list_lru_one *l = &nlru->lru;\n\tstruct mem_cgroup *memcg = NULL;\n\n\tif (!nlru->memcg_lrus)\n\t\tgoto out;\n\n\tmemcg = mem_cgroup_from_kmem(ptr);\n\tif (!memcg)\n\t\tgoto out;\n\n\tl = list_lru_from_memcg_idx(nlru, memcg_cache_id(memcg));\nout:\n\tif (memcg_ptr)\n\t\t*memcg_ptr = memcg;\n\treturn l;\n}"
  },
  {
    "function_name": "mem_cgroup_from_kmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "62-70",
    "snippet": "mem_cgroup *mem_cgroup_from_kmem(void *ptr)\n{\n\tstruct page *page;\n\n\tif (!memcg_kmem_enabled())\n\t\treturn NULL;\n\tpage = virt_to_head_page(ptr);\n\treturn page->mem_cgroup;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "ptr"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_kmem_enabled",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nmem_cgroup *mem_cgroup_from_kmem(void *ptr)\n{\n\tstruct page *page;\n\n\tif (!memcg_kmem_enabled())\n\t\treturn NULL;\n\tpage = virt_to_head_page(ptr);\n\treturn page->mem_cgroup;\n}"
  },
  {
    "function_name": "list_lru_from_memcg_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "47-60",
    "snippet": "static inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\t/*\n\t * Either lock or RCU protects the array of per cgroup lists\n\t * from relocation (see memcg_update_list_lru_node).\n\t */\n\tmemcg_lrus = rcu_dereference_check(nlru->memcg_lrus,\n\t\t\t\t\t   lockdep_is_held(&nlru->lock));\n\tif (memcg_lrus && idx >= 0)\n\t\treturn memcg_lrus->lru[idx];\n\treturn &nlru->lru;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "nlru->memcg_lrus",
            "lockdep_is_held(&nlru->lock)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&nlru->lock"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline struct list_lru_one *\nlist_lru_from_memcg_idx(struct list_lru_node *nlru, int idx)\n{\n\tstruct list_lru_memcg *memcg_lrus;\n\t/*\n\t * Either lock or RCU protects the array of per cgroup lists\n\t * from relocation (see memcg_update_list_lru_node).\n\t */\n\tmemcg_lrus = rcu_dereference_check(nlru->memcg_lrus,\n\t\t\t\t\t   lockdep_is_held(&nlru->lock));\n\tif (memcg_lrus && idx >= 0)\n\t\treturn memcg_lrus->lru[idx];\n\treturn &nlru->lru;\n}"
  },
  {
    "function_name": "list_lru_memcg_aware",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "38-45",
    "snippet": "static inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\t/*\n\t * This needs node 0 to be always present, even\n\t * in the systems supporting sparse numa ids.\n\t */\n\treturn !!lru->node[0].memcg_lrus;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline bool list_lru_memcg_aware(struct list_lru *lru)\n{\n\t/*\n\t * This needs node 0 to be always present, even\n\t * in the systems supporting sparse numa ids.\n\t */\n\treturn !!lru->node[0].memcg_lrus;\n}"
  },
  {
    "function_name": "lru_shrinker_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "33-36",
    "snippet": "static int lru_shrinker_id(struct list_lru *lru)\n{\n\treturn lru->shrinker_id;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int lru_shrinker_id(struct list_lru *lru)\n{\n\treturn lru->shrinker_id;\n}"
  },
  {
    "function_name": "list_lru_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "26-31",
    "snippet": "static void list_lru_unregister(struct list_lru *lru)\n{\n\tmutex_lock(&list_lrus_mutex);\n\tlist_del(&lru->list);\n\tmutex_unlock(&list_lrus_mutex);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&list_lrus_mutex"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&lru->list"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&list_lrus_mutex"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void list_lru_unregister(struct list_lru *lru)\n{\n\tmutex_lock(&list_lrus_mutex);\n\tlist_del(&lru->list);\n\tmutex_unlock(&list_lrus_mutex);\n}"
  },
  {
    "function_name": "list_lru_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
    "lines": "19-24",
    "snippet": "static void list_lru_register(struct list_lru *lru)\n{\n\tmutex_lock(&list_lrus_mutex);\n\tlist_add(&lru->list, &list_lrus);\n\tmutex_unlock(&list_lrus_mutex);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&list_lrus_mutex"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lru->list",
            "&list_lrus"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&list_lrus_mutex"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void list_lru_register(struct list_lru *lru)\n{\n\tmutex_lock(&list_lrus_mutex);\n\tlist_add(&lru->list, &list_lrus);\n\tmutex_unlock(&list_lrus_mutex);\n}"
  }
]