[
  {
    "function_name": "memfd_fcntl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
    "lines": "218-239",
    "snippet": "long memfd_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong error;\n\n\tswitch (cmd) {\n\tcase F_ADD_SEALS:\n\t\t/* disallow upper 32bit */\n\t\tif (arg > UINT_MAX)\n\t\t\treturn -EINVAL;\n\n\t\terror = memfd_add_seals(file, arg);\n\t\tbreak;\n\tcase F_GET_SEALS:\n\t\terror = memfd_get_seals(file);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <uapi/linux/memfd.h>",
      "#include <linux/memfd.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memfd_get_seals",
          "args": [
            "file"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "memfd_get_seals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
          "lines": "211-216",
          "snippet": "static int memfd_get_seals(struct file *file)\n{\n\tunsigned int *seals = memfd_file_seals_ptr(file);\n\n\treturn seals ? *seals : -EINVAL;\n}",
          "includes": [
            "#include <uapi/linux/memfd.h>",
            "#include <linux/memfd.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int memfd_get_seals(struct file *file)\n{\n\tunsigned int *seals = memfd_file_seals_ptr(file);\n\n\treturn seals ? *seals : -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memfd_add_seals",
          "args": [
            "file",
            "arg"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "memfd_add_seals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
          "lines": "136-209",
          "snippet": "static int memfd_add_seals(struct file *file, unsigned int seals)\n{\n\tstruct inode *inode = file_inode(file);\n\tunsigned int *file_seals;\n\tint error;\n\n\t/*\n\t * SEALING\n\t * Sealing allows multiple parties to share a tmpfs or hugetlbfs file\n\t * but restrict access to a specific subset of file operations. Seals\n\t * can only be added, but never removed. This way, mutually untrusted\n\t * parties can share common memory regions with a well-defined policy.\n\t * A malicious peer can thus never perform unwanted operations on a\n\t * shared object.\n\t *\n\t * Seals are only supported on special tmpfs or hugetlbfs files and\n\t * always affect the whole underlying inode. Once a seal is set, it\n\t * may prevent some kinds of access to the file. Currently, the\n\t * following seals are defined:\n\t *   SEAL_SEAL: Prevent further seals from being set on this file\n\t *   SEAL_SHRINK: Prevent the file from shrinking\n\t *   SEAL_GROW: Prevent the file from growing\n\t *   SEAL_WRITE: Prevent write access to the file\n\t *\n\t * As we don't require any trust relationship between two parties, we\n\t * must prevent seals from being removed. Therefore, sealing a file\n\t * only adds a given set of seals to the file, it never touches\n\t * existing seals. Furthermore, the \"setting seals\"-operation can be\n\t * sealed itself, which basically prevents any further seal from being\n\t * added.\n\t *\n\t * Semantics of sealing are only defined on volatile files. Only\n\t * anonymous tmpfs and hugetlbfs files support sealing. More\n\t * importantly, seals are never written to disk. Therefore, there's\n\t * no plan to support it on other file types.\n\t */\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EPERM;\n\tif (seals & ~(unsigned int)F_ALL_SEALS)\n\t\treturn -EINVAL;\n\n\tinode_lock(inode);\n\n\tfile_seals = memfd_file_seals_ptr(file);\n\tif (!file_seals) {\n\t\terror = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (*file_seals & F_SEAL_SEAL) {\n\t\terror = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tif ((seals & F_SEAL_WRITE) && !(*file_seals & F_SEAL_WRITE)) {\n\t\terror = mapping_deny_writable(file->f_mapping);\n\t\tif (error)\n\t\t\tgoto unlock;\n\n\t\terror = memfd_wait_for_pins(file->f_mapping);\n\t\tif (error) {\n\t\t\tmapping_allow_writable(file->f_mapping);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t*file_seals |= seals;\n\terror = 0;\n\nunlock:\n\tinode_unlock(inode);\n\treturn error;\n}",
          "includes": [
            "#include <uapi/linux/memfd.h>",
            "#include <linux/memfd.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define F_ALL_SEALS (F_SEAL_SEAL | \\\n\t\t     F_SEAL_SHRINK | \\\n\t\t     F_SEAL_GROW | \\\n\t\t     F_SEAL_WRITE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n#define F_ALL_SEALS (F_SEAL_SEAL | \\\n\t\t     F_SEAL_SHRINK | \\\n\t\t     F_SEAL_GROW | \\\n\t\t     F_SEAL_WRITE)\n\nstatic int memfd_add_seals(struct file *file, unsigned int seals)\n{\n\tstruct inode *inode = file_inode(file);\n\tunsigned int *file_seals;\n\tint error;\n\n\t/*\n\t * SEALING\n\t * Sealing allows multiple parties to share a tmpfs or hugetlbfs file\n\t * but restrict access to a specific subset of file operations. Seals\n\t * can only be added, but never removed. This way, mutually untrusted\n\t * parties can share common memory regions with a well-defined policy.\n\t * A malicious peer can thus never perform unwanted operations on a\n\t * shared object.\n\t *\n\t * Seals are only supported on special tmpfs or hugetlbfs files and\n\t * always affect the whole underlying inode. Once a seal is set, it\n\t * may prevent some kinds of access to the file. Currently, the\n\t * following seals are defined:\n\t *   SEAL_SEAL: Prevent further seals from being set on this file\n\t *   SEAL_SHRINK: Prevent the file from shrinking\n\t *   SEAL_GROW: Prevent the file from growing\n\t *   SEAL_WRITE: Prevent write access to the file\n\t *\n\t * As we don't require any trust relationship between two parties, we\n\t * must prevent seals from being removed. Therefore, sealing a file\n\t * only adds a given set of seals to the file, it never touches\n\t * existing seals. Furthermore, the \"setting seals\"-operation can be\n\t * sealed itself, which basically prevents any further seal from being\n\t * added.\n\t *\n\t * Semantics of sealing are only defined on volatile files. Only\n\t * anonymous tmpfs and hugetlbfs files support sealing. More\n\t * importantly, seals are never written to disk. Therefore, there's\n\t * no plan to support it on other file types.\n\t */\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EPERM;\n\tif (seals & ~(unsigned int)F_ALL_SEALS)\n\t\treturn -EINVAL;\n\n\tinode_lock(inode);\n\n\tfile_seals = memfd_file_seals_ptr(file);\n\tif (!file_seals) {\n\t\terror = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (*file_seals & F_SEAL_SEAL) {\n\t\terror = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tif ((seals & F_SEAL_WRITE) && !(*file_seals & F_SEAL_WRITE)) {\n\t\terror = mapping_deny_writable(file->f_mapping);\n\t\tif (error)\n\t\t\tgoto unlock;\n\n\t\terror = memfd_wait_for_pins(file->f_mapping);\n\t\tif (error) {\n\t\t\tmapping_allow_writable(file->f_mapping);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t*file_seals |= seals;\n\terror = 0;\n\nunlock:\n\tinode_unlock(inode);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nlong memfd_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong error;\n\n\tswitch (cmd) {\n\tcase F_ADD_SEALS:\n\t\t/* disallow upper 32bit */\n\t\tif (arg > UINT_MAX)\n\t\t\treturn -EINVAL;\n\n\t\terror = memfd_add_seals(file, arg);\n\t\tbreak;\n\tcase F_GET_SEALS:\n\t\terror = memfd_get_seals(file);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "memfd_get_seals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
    "lines": "211-216",
    "snippet": "static int memfd_get_seals(struct file *file)\n{\n\tunsigned int *seals = memfd_file_seals_ptr(file);\n\n\treturn seals ? *seals : -EINVAL;\n}",
    "includes": [
      "#include <uapi/linux/memfd.h>",
      "#include <linux/memfd.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memfd_file_seals_ptr",
          "args": [
            "file"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "memfd_file_seals_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
          "lines": "118-129",
          "snippet": "static unsigned int *memfd_file_seals_ptr(struct file *file)\n{\n\tif (shmem_file(file))\n\t\treturn &SHMEM_I(file_inode(file))->seals;\n\n#ifdef CONFIG_HUGETLBFS\n\tif (is_file_hugepages(file))\n\t\treturn &HUGETLBFS_I(file_inode(file))->seals;\n#endif\n\n\treturn NULL;\n}",
          "includes": [
            "#include <uapi/linux/memfd.h>",
            "#include <linux/memfd.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic unsigned int *memfd_file_seals_ptr(struct file *file)\n{\n\tif (shmem_file(file))\n\t\treturn &SHMEM_I(file_inode(file))->seals;\n\n#ifdef CONFIG_HUGETLBFS\n\tif (is_file_hugepages(file))\n\t\treturn &HUGETLBFS_I(file_inode(file))->seals;\n#endif\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int memfd_get_seals(struct file *file)\n{\n\tunsigned int *seals = memfd_file_seals_ptr(file);\n\n\treturn seals ? *seals : -EINVAL;\n}"
  },
  {
    "function_name": "memfd_add_seals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
    "lines": "136-209",
    "snippet": "static int memfd_add_seals(struct file *file, unsigned int seals)\n{\n\tstruct inode *inode = file_inode(file);\n\tunsigned int *file_seals;\n\tint error;\n\n\t/*\n\t * SEALING\n\t * Sealing allows multiple parties to share a tmpfs or hugetlbfs file\n\t * but restrict access to a specific subset of file operations. Seals\n\t * can only be added, but never removed. This way, mutually untrusted\n\t * parties can share common memory regions with a well-defined policy.\n\t * A malicious peer can thus never perform unwanted operations on a\n\t * shared object.\n\t *\n\t * Seals are only supported on special tmpfs or hugetlbfs files and\n\t * always affect the whole underlying inode. Once a seal is set, it\n\t * may prevent some kinds of access to the file. Currently, the\n\t * following seals are defined:\n\t *   SEAL_SEAL: Prevent further seals from being set on this file\n\t *   SEAL_SHRINK: Prevent the file from shrinking\n\t *   SEAL_GROW: Prevent the file from growing\n\t *   SEAL_WRITE: Prevent write access to the file\n\t *\n\t * As we don't require any trust relationship between two parties, we\n\t * must prevent seals from being removed. Therefore, sealing a file\n\t * only adds a given set of seals to the file, it never touches\n\t * existing seals. Furthermore, the \"setting seals\"-operation can be\n\t * sealed itself, which basically prevents any further seal from being\n\t * added.\n\t *\n\t * Semantics of sealing are only defined on volatile files. Only\n\t * anonymous tmpfs and hugetlbfs files support sealing. More\n\t * importantly, seals are never written to disk. Therefore, there's\n\t * no plan to support it on other file types.\n\t */\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EPERM;\n\tif (seals & ~(unsigned int)F_ALL_SEALS)\n\t\treturn -EINVAL;\n\n\tinode_lock(inode);\n\n\tfile_seals = memfd_file_seals_ptr(file);\n\tif (!file_seals) {\n\t\terror = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (*file_seals & F_SEAL_SEAL) {\n\t\terror = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tif ((seals & F_SEAL_WRITE) && !(*file_seals & F_SEAL_WRITE)) {\n\t\terror = mapping_deny_writable(file->f_mapping);\n\t\tif (error)\n\t\t\tgoto unlock;\n\n\t\terror = memfd_wait_for_pins(file->f_mapping);\n\t\tif (error) {\n\t\t\tmapping_allow_writable(file->f_mapping);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t*file_seals |= seals;\n\terror = 0;\n\nunlock:\n\tinode_unlock(inode);\n\treturn error;\n}",
    "includes": [
      "#include <uapi/linux/memfd.h>",
      "#include <linux/memfd.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define F_ALL_SEALS (F_SEAL_SEAL | \\\n\t\t     F_SEAL_SHRINK | \\\n\t\t     F_SEAL_GROW | \\\n\t\t     F_SEAL_WRITE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_allow_writable",
          "args": [
            "file->f_mapping"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memfd_wait_for_pins",
          "args": [
            "file->f_mapping"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "memfd_wait_for_pins",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
          "lines": "65-116",
          "snippet": "static int memfd_wait_for_pins(struct address_space *mapping)\n{\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\tstruct page *page;\n\tint error, scan;\n\n\tmemfd_tag_pins(&xas);\n\n\terror = 0;\n\tfor (scan = 0; scan <= LAST_SCAN; scan++) {\n\t\tunsigned int tagged = 0;\n\n\t\tif (!xas_marked(&xas, MEMFD_TAG_PINNED))\n\t\t\tbreak;\n\n\t\tif (!scan)\n\t\t\tlru_add_drain_all();\n\t\telse if (schedule_timeout_killable((HZ << scan) / 200))\n\t\t\tscan = LAST_SCAN;\n\n\t\txas_set(&xas, 0);\n\t\txas_lock_irq(&xas);\n\t\txas_for_each_marked(&xas, page, ULONG_MAX, MEMFD_TAG_PINNED) {\n\t\t\tbool clear = true;\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\t\t\tif (page_count(page) - page_mapcount(page) != 1) {\n\t\t\t\t/*\n\t\t\t\t * On the last scan, we clean up all those tags\n\t\t\t\t * we inserted; but make a note that we still\n\t\t\t\t * found pages pinned.\n\t\t\t\t */\n\t\t\t\tif (scan == LAST_SCAN)\n\t\t\t\t\terror = -EBUSY;\n\t\t\t\telse\n\t\t\t\t\tclear = false;\n\t\t\t}\n\t\t\tif (clear)\n\t\t\t\txas_clear_mark(&xas, MEMFD_TAG_PINNED);\n\t\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\t\tcontinue;\n\n\t\t\txas_pause(&xas);\n\t\t\txas_unlock_irq(&xas);\n\t\t\tcond_resched();\n\t\t\txas_lock_irq(&xas);\n\t\t}\n\t\txas_unlock_irq(&xas);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <uapi/linux/memfd.h>",
            "#include <linux/memfd.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define LAST_SCAN               4       /* about 150ms max */",
            "#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n#define LAST_SCAN               4       /* about 150ms max */\n#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE\n\nstatic int memfd_wait_for_pins(struct address_space *mapping)\n{\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\tstruct page *page;\n\tint error, scan;\n\n\tmemfd_tag_pins(&xas);\n\n\terror = 0;\n\tfor (scan = 0; scan <= LAST_SCAN; scan++) {\n\t\tunsigned int tagged = 0;\n\n\t\tif (!xas_marked(&xas, MEMFD_TAG_PINNED))\n\t\t\tbreak;\n\n\t\tif (!scan)\n\t\t\tlru_add_drain_all();\n\t\telse if (schedule_timeout_killable((HZ << scan) / 200))\n\t\t\tscan = LAST_SCAN;\n\n\t\txas_set(&xas, 0);\n\t\txas_lock_irq(&xas);\n\t\txas_for_each_marked(&xas, page, ULONG_MAX, MEMFD_TAG_PINNED) {\n\t\t\tbool clear = true;\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\t\t\tif (page_count(page) - page_mapcount(page) != 1) {\n\t\t\t\t/*\n\t\t\t\t * On the last scan, we clean up all those tags\n\t\t\t\t * we inserted; but make a note that we still\n\t\t\t\t * found pages pinned.\n\t\t\t\t */\n\t\t\t\tif (scan == LAST_SCAN)\n\t\t\t\t\terror = -EBUSY;\n\t\t\t\telse\n\t\t\t\t\tclear = false;\n\t\t\t}\n\t\t\tif (clear)\n\t\t\t\txas_clear_mark(&xas, MEMFD_TAG_PINNED);\n\t\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\t\tcontinue;\n\n\t\t\txas_pause(&xas);\n\t\t\txas_unlock_irq(&xas);\n\t\t\tcond_resched();\n\t\t\txas_lock_irq(&xas);\n\t\t}\n\t\txas_unlock_irq(&xas);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_deny_writable",
          "args": [
            "file->f_mapping"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memfd_file_seals_ptr",
          "args": [
            "file"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "memfd_file_seals_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
          "lines": "118-129",
          "snippet": "static unsigned int *memfd_file_seals_ptr(struct file *file)\n{\n\tif (shmem_file(file))\n\t\treturn &SHMEM_I(file_inode(file))->seals;\n\n#ifdef CONFIG_HUGETLBFS\n\tif (is_file_hugepages(file))\n\t\treturn &HUGETLBFS_I(file_inode(file))->seals;\n#endif\n\n\treturn NULL;\n}",
          "includes": [
            "#include <uapi/linux/memfd.h>",
            "#include <linux/memfd.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic unsigned int *memfd_file_seals_ptr(struct file *file)\n{\n\tif (shmem_file(file))\n\t\treturn &SHMEM_I(file_inode(file))->seals;\n\n#ifdef CONFIG_HUGETLBFS\n\tif (is_file_hugepages(file))\n\t\treturn &HUGETLBFS_I(file_inode(file))->seals;\n#endif\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n#define F_ALL_SEALS (F_SEAL_SEAL | \\\n\t\t     F_SEAL_SHRINK | \\\n\t\t     F_SEAL_GROW | \\\n\t\t     F_SEAL_WRITE)\n\nstatic int memfd_add_seals(struct file *file, unsigned int seals)\n{\n\tstruct inode *inode = file_inode(file);\n\tunsigned int *file_seals;\n\tint error;\n\n\t/*\n\t * SEALING\n\t * Sealing allows multiple parties to share a tmpfs or hugetlbfs file\n\t * but restrict access to a specific subset of file operations. Seals\n\t * can only be added, but never removed. This way, mutually untrusted\n\t * parties can share common memory regions with a well-defined policy.\n\t * A malicious peer can thus never perform unwanted operations on a\n\t * shared object.\n\t *\n\t * Seals are only supported on special tmpfs or hugetlbfs files and\n\t * always affect the whole underlying inode. Once a seal is set, it\n\t * may prevent some kinds of access to the file. Currently, the\n\t * following seals are defined:\n\t *   SEAL_SEAL: Prevent further seals from being set on this file\n\t *   SEAL_SHRINK: Prevent the file from shrinking\n\t *   SEAL_GROW: Prevent the file from growing\n\t *   SEAL_WRITE: Prevent write access to the file\n\t *\n\t * As we don't require any trust relationship between two parties, we\n\t * must prevent seals from being removed. Therefore, sealing a file\n\t * only adds a given set of seals to the file, it never touches\n\t * existing seals. Furthermore, the \"setting seals\"-operation can be\n\t * sealed itself, which basically prevents any further seal from being\n\t * added.\n\t *\n\t * Semantics of sealing are only defined on volatile files. Only\n\t * anonymous tmpfs and hugetlbfs files support sealing. More\n\t * importantly, seals are never written to disk. Therefore, there's\n\t * no plan to support it on other file types.\n\t */\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EPERM;\n\tif (seals & ~(unsigned int)F_ALL_SEALS)\n\t\treturn -EINVAL;\n\n\tinode_lock(inode);\n\n\tfile_seals = memfd_file_seals_ptr(file);\n\tif (!file_seals) {\n\t\terror = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (*file_seals & F_SEAL_SEAL) {\n\t\terror = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tif ((seals & F_SEAL_WRITE) && !(*file_seals & F_SEAL_WRITE)) {\n\t\terror = mapping_deny_writable(file->f_mapping);\n\t\tif (error)\n\t\t\tgoto unlock;\n\n\t\terror = memfd_wait_for_pins(file->f_mapping);\n\t\tif (error) {\n\t\t\tmapping_allow_writable(file->f_mapping);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t*file_seals |= seals;\n\terror = 0;\n\nunlock:\n\tinode_unlock(inode);\n\treturn error;\n}"
  },
  {
    "function_name": "memfd_file_seals_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
    "lines": "118-129",
    "snippet": "static unsigned int *memfd_file_seals_ptr(struct file *file)\n{\n\tif (shmem_file(file))\n\t\treturn &SHMEM_I(file_inode(file))->seals;\n\n#ifdef CONFIG_HUGETLBFS\n\tif (is_file_hugepages(file))\n\t\treturn &HUGETLBFS_I(file_inode(file))->seals;\n#endif\n\n\treturn NULL;\n}",
    "includes": [
      "#include <uapi/linux/memfd.h>",
      "#include <linux/memfd.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HUGETLBFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_file_hugepages",
          "args": [
            "file"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHMEM_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_file",
          "args": [
            "file"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic unsigned int *memfd_file_seals_ptr(struct file *file)\n{\n\tif (shmem_file(file))\n\t\treturn &SHMEM_I(file_inode(file))->seals;\n\n#ifdef CONFIG_HUGETLBFS\n\tif (is_file_hugepages(file))\n\t\treturn &HUGETLBFS_I(file_inode(file))->seals;\n#endif\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "memfd_wait_for_pins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
    "lines": "65-116",
    "snippet": "static int memfd_wait_for_pins(struct address_space *mapping)\n{\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\tstruct page *page;\n\tint error, scan;\n\n\tmemfd_tag_pins(&xas);\n\n\terror = 0;\n\tfor (scan = 0; scan <= LAST_SCAN; scan++) {\n\t\tunsigned int tagged = 0;\n\n\t\tif (!xas_marked(&xas, MEMFD_TAG_PINNED))\n\t\t\tbreak;\n\n\t\tif (!scan)\n\t\t\tlru_add_drain_all();\n\t\telse if (schedule_timeout_killable((HZ << scan) / 200))\n\t\t\tscan = LAST_SCAN;\n\n\t\txas_set(&xas, 0);\n\t\txas_lock_irq(&xas);\n\t\txas_for_each_marked(&xas, page, ULONG_MAX, MEMFD_TAG_PINNED) {\n\t\t\tbool clear = true;\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\t\t\tif (page_count(page) - page_mapcount(page) != 1) {\n\t\t\t\t/*\n\t\t\t\t * On the last scan, we clean up all those tags\n\t\t\t\t * we inserted; but make a note that we still\n\t\t\t\t * found pages pinned.\n\t\t\t\t */\n\t\t\t\tif (scan == LAST_SCAN)\n\t\t\t\t\terror = -EBUSY;\n\t\t\t\telse\n\t\t\t\t\tclear = false;\n\t\t\t}\n\t\t\tif (clear)\n\t\t\t\txas_clear_mark(&xas, MEMFD_TAG_PINNED);\n\t\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\t\tcontinue;\n\n\t\t\txas_pause(&xas);\n\t\t\txas_unlock_irq(&xas);\n\t\t\tcond_resched();\n\t\t\txas_lock_irq(&xas);\n\t\t}\n\t\txas_unlock_irq(&xas);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <uapi/linux/memfd.h>",
      "#include <linux/memfd.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define LAST_SCAN               4       /* about 150ms max */",
      "#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_pause",
          "args": [
            "&xas"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_clear_mark",
          "args": [
            "&xas",
            "MEMFD_TAG_PINNED"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each_marked",
          "args": [
            "&xas",
            "page",
            "ULONG_MAX",
            "MEMFD_TAG_PINNED"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set",
          "args": [
            "&xas",
            "0"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_killable",
          "args": [
            "(HZ << scan) / 200"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_marked",
          "args": [
            "&xas",
            "MEMFD_TAG_PINNED"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memfd_tag_pins",
          "args": [
            "&xas"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "memfd_tag_pins",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
          "lines": "31-54",
          "snippet": "static void memfd_tag_pins(struct xa_state *xas)\n{\n\tstruct page *page;\n\tunsigned int tagged = 0;\n\n\tlru_add_drain();\n\n\txas_lock_irq(xas);\n\txas_for_each(xas, page, ULONG_MAX) {\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\tif (page_count(page) - page_mapcount(page) > 1)\n\t\t\txas_set_mark(xas, MEMFD_TAG_PINNED);\n\n\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(xas);\n\t\txas_unlock_irq(xas);\n\t\tcond_resched();\n\t\txas_lock_irq(xas);\n\t}\n\txas_unlock_irq(xas);\n}",
          "includes": [
            "#include <uapi/linux/memfd.h>",
            "#include <linux/memfd.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE\n\nstatic void memfd_tag_pins(struct xa_state *xas)\n{\n\tstruct page *page;\n\tunsigned int tagged = 0;\n\n\tlru_add_drain();\n\n\txas_lock_irq(xas);\n\txas_for_each(xas, page, ULONG_MAX) {\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\tif (page_count(page) - page_mapcount(page) > 1)\n\t\t\txas_set_mark(xas, MEMFD_TAG_PINNED);\n\n\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(xas);\n\t\txas_unlock_irq(xas);\n\t\tcond_resched();\n\t\txas_lock_irq(xas);\n\t}\n\txas_unlock_irq(xas);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "0"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n#define LAST_SCAN               4       /* about 150ms max */\n#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE\n\nstatic int memfd_wait_for_pins(struct address_space *mapping)\n{\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\tstruct page *page;\n\tint error, scan;\n\n\tmemfd_tag_pins(&xas);\n\n\terror = 0;\n\tfor (scan = 0; scan <= LAST_SCAN; scan++) {\n\t\tunsigned int tagged = 0;\n\n\t\tif (!xas_marked(&xas, MEMFD_TAG_PINNED))\n\t\t\tbreak;\n\n\t\tif (!scan)\n\t\t\tlru_add_drain_all();\n\t\telse if (schedule_timeout_killable((HZ << scan) / 200))\n\t\t\tscan = LAST_SCAN;\n\n\t\txas_set(&xas, 0);\n\t\txas_lock_irq(&xas);\n\t\txas_for_each_marked(&xas, page, ULONG_MAX, MEMFD_TAG_PINNED) {\n\t\t\tbool clear = true;\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\t\t\tif (page_count(page) - page_mapcount(page) != 1) {\n\t\t\t\t/*\n\t\t\t\t * On the last scan, we clean up all those tags\n\t\t\t\t * we inserted; but make a note that we still\n\t\t\t\t * found pages pinned.\n\t\t\t\t */\n\t\t\t\tif (scan == LAST_SCAN)\n\t\t\t\t\terror = -EBUSY;\n\t\t\t\telse\n\t\t\t\t\tclear = false;\n\t\t\t}\n\t\t\tif (clear)\n\t\t\t\txas_clear_mark(&xas, MEMFD_TAG_PINNED);\n\t\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\t\tcontinue;\n\n\t\t\txas_pause(&xas);\n\t\t\txas_unlock_irq(&xas);\n\t\t\tcond_resched();\n\t\t\txas_lock_irq(&xas);\n\t\t}\n\t\txas_unlock_irq(&xas);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "memfd_tag_pins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
    "lines": "31-54",
    "snippet": "static void memfd_tag_pins(struct xa_state *xas)\n{\n\tstruct page *page;\n\tunsigned int tagged = 0;\n\n\tlru_add_drain();\n\n\txas_lock_irq(xas);\n\txas_for_each(xas, page, ULONG_MAX) {\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\tif (page_count(page) - page_mapcount(page) > 1)\n\t\t\txas_set_mark(xas, MEMFD_TAG_PINNED);\n\n\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(xas);\n\t\txas_unlock_irq(xas);\n\t\tcond_resched();\n\t\txas_lock_irq(xas);\n\t}\n\txas_unlock_irq(xas);\n}",
    "includes": [
      "#include <uapi/linux/memfd.h>",
      "#include <linux/memfd.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "xas"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "xas"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "xas"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_pause",
          "args": [
            "xas"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set_mark",
          "args": [
            "xas",
            "MEMFD_TAG_PINNED"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each",
          "args": [
            "xas",
            "page",
            "ULONG_MAX"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "xas"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE\n\nstatic void memfd_tag_pins(struct xa_state *xas)\n{\n\tstruct page *page;\n\tunsigned int tagged = 0;\n\n\tlru_add_drain();\n\n\txas_lock_irq(xas);\n\txas_for_each(xas, page, ULONG_MAX) {\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\tif (page_count(page) - page_mapcount(page) > 1)\n\t\t\txas_set_mark(xas, MEMFD_TAG_PINNED);\n\n\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(xas);\n\t\txas_unlock_irq(xas);\n\t\tcond_resched();\n\t\txas_lock_irq(xas);\n\t}\n\txas_unlock_irq(xas);\n}"
  },
  {
    "function_name": "memfd_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memfd.c",
    "lines": "247-326",
    "snippet": "SYSCALL_DEFINE2(memfd_create,\n\t\tconst char __user *, uname,\n\t\tunsigned int, flags)\n{\n\tunsigned int *file_seals;\n\tstruct file *file;\n\tint fd, error;\n\tchar *name;\n\tlong len;\n\n\tif (!(flags & MFD_HUGETLB)) {\n\t\tif (flags & ~(unsigned int)MFD_ALL_FLAGS)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* Allow huge page size encoding in flags. */\n\t\tif (flags & ~(unsigned int)(MFD_ALL_FLAGS |\n\t\t\t\t(MFD_HUGE_MASK << MFD_HUGE_SHIFT)))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* length includes terminating zero */\n\tlen = strnlen_user(uname, MFD_NAME_MAX_LEN + 1);\n\tif (len <= 0)\n\t\treturn -EFAULT;\n\tif (len > MFD_NAME_MAX_LEN + 1)\n\t\treturn -EINVAL;\n\n\tname = kmalloc(len + MFD_NAME_PREFIX_LEN, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tstrcpy(name, MFD_NAME_PREFIX);\n\tif (copy_from_user(&name[MFD_NAME_PREFIX_LEN], uname, len)) {\n\t\terror = -EFAULT;\n\t\tgoto err_name;\n\t}\n\n\t/* terminating-zero may have changed after strnlen_user() returned */\n\tif (name[len + MFD_NAME_PREFIX_LEN - 1]) {\n\t\terror = -EFAULT;\n\t\tgoto err_name;\n\t}\n\n\tfd = get_unused_fd_flags((flags & MFD_CLOEXEC) ? O_CLOEXEC : 0);\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto err_name;\n\t}\n\n\tif (flags & MFD_HUGETLB) {\n\t\tstruct user_struct *user = NULL;\n\n\t\tfile = hugetlb_file_setup(name, 0, VM_NORESERVE, &user,\n\t\t\t\t\tHUGETLB_ANONHUGE_INODE,\n\t\t\t\t\t(flags >> MFD_HUGE_SHIFT) &\n\t\t\t\t\tMFD_HUGE_MASK);\n\t} else\n\t\tfile = shmem_file_setup(name, 0, VM_NORESERVE);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_fd;\n\t}\n\tfile->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tfile->f_flags |= O_LARGEFILE;\n\n\tif (flags & MFD_ALLOW_SEALING) {\n\t\tfile_seals = memfd_file_seals_ptr(file);\n\t\t*file_seals &= ~F_SEAL_SEAL;\n\t}\n\n\tfd_install(fd, file);\n\tkfree(name);\n\treturn fd;\n\nerr_fd:\n\tput_unused_fd(fd);\nerr_name:\n\tkfree(name);\n\treturn error;\n}",
    "includes": [
      "#include <uapi/linux/memfd.h>",
      "#include <linux/memfd.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MFD_ALL_FLAGS (MFD_CLOEXEC | MFD_ALLOW_SEALING | MFD_HUGETLB)",
      "#define MFD_NAME_MAX_LEN (NAME_MAX - MFD_NAME_PREFIX_LEN)",
      "#define MFD_NAME_PREFIX_LEN (sizeof(MFD_NAME_PREFIX) - 1)",
      "#define MFD_NAME_PREFIX \"memfd:\""
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/memfd.h>\n#include <linux/memfd.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/syscalls.h>\n#include <linux/khugepaged.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n#define MFD_ALL_FLAGS (MFD_CLOEXEC | MFD_ALLOW_SEALING | MFD_HUGETLB)\n#define MFD_NAME_MAX_LEN (NAME_MAX - MFD_NAME_PREFIX_LEN)\n#define MFD_NAME_PREFIX_LEN (sizeof(MFD_NAME_PREFIX) - 1)\n#define MFD_NAME_PREFIX \"memfd:\"\n\nSYSCALL_DEFINE2(memfd_create,\n\t\tconst char __user *, uname,\n\t\tunsigned int, flags)\n{\n\tunsigned int *file_seals;\n\tstruct file *file;\n\tint fd, error;\n\tchar *name;\n\tlong len;\n\n\tif (!(flags & MFD_HUGETLB)) {\n\t\tif (flags & ~(unsigned int)MFD_ALL_FLAGS)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* Allow huge page size encoding in flags. */\n\t\tif (flags & ~(unsigned int)(MFD_ALL_FLAGS |\n\t\t\t\t(MFD_HUGE_MASK << MFD_HUGE_SHIFT)))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* length includes terminating zero */\n\tlen = strnlen_user(uname, MFD_NAME_MAX_LEN + 1);\n\tif (len <= 0)\n\t\treturn -EFAULT;\n\tif (len > MFD_NAME_MAX_LEN + 1)\n\t\treturn -EINVAL;\n\n\tname = kmalloc(len + MFD_NAME_PREFIX_LEN, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tstrcpy(name, MFD_NAME_PREFIX);\n\tif (copy_from_user(&name[MFD_NAME_PREFIX_LEN], uname, len)) {\n\t\terror = -EFAULT;\n\t\tgoto err_name;\n\t}\n\n\t/* terminating-zero may have changed after strnlen_user() returned */\n\tif (name[len + MFD_NAME_PREFIX_LEN - 1]) {\n\t\terror = -EFAULT;\n\t\tgoto err_name;\n\t}\n\n\tfd = get_unused_fd_flags((flags & MFD_CLOEXEC) ? O_CLOEXEC : 0);\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto err_name;\n\t}\n\n\tif (flags & MFD_HUGETLB) {\n\t\tstruct user_struct *user = NULL;\n\n\t\tfile = hugetlb_file_setup(name, 0, VM_NORESERVE, &user,\n\t\t\t\t\tHUGETLB_ANONHUGE_INODE,\n\t\t\t\t\t(flags >> MFD_HUGE_SHIFT) &\n\t\t\t\t\tMFD_HUGE_MASK);\n\t} else\n\t\tfile = shmem_file_setup(name, 0, VM_NORESERVE);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_fd;\n\t}\n\tfile->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tfile->f_flags |= O_LARGEFILE;\n\n\tif (flags & MFD_ALLOW_SEALING) {\n\t\tfile_seals = memfd_file_seals_ptr(file);\n\t\t*file_seals &= ~F_SEAL_SEAL;\n\t}\n\n\tfd_install(fd, file);\n\tkfree(name);\n\treturn fd;\n\nerr_fd:\n\tput_unused_fd(fd);\nerr_name:\n\tkfree(name);\n\treturn error;\n}"
  }
]