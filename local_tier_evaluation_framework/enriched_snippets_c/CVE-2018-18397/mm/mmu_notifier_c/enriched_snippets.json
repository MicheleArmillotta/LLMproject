[
  {
    "function_name": "mmu_notifier_unregister_no_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "392-405",
    "snippet": "void mmu_notifier_unregister_no_release(struct mmu_notifier *mn,\n\t\t\t\t\tstruct mm_struct *mm)\n{\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\t/*\n\t * Can not use list_del_rcu() since __mmu_notifier_release\n\t * can delete it before we hold the lock.\n\t */\n\thlist_del_init_rcu(&mn->hlist);\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\n\tBUG_ON(atomic_read(&mm->mm_count) <= 0);\n\tmmdrop(mm);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&mm->mm_count) <= 0"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_count"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->mmu_notifier_mm->lock"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&mn->hlist"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->mmu_notifier_mm->lock"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid mmu_notifier_unregister_no_release(struct mmu_notifier *mn,\n\t\t\t\t\tstruct mm_struct *mm)\n{\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\t/*\n\t * Can not use list_del_rcu() since __mmu_notifier_release\n\t * can delete it before we hold the lock.\n\t */\n\thlist_del_init_rcu(&mn->hlist);\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\n\tBUG_ON(atomic_read(&mm->mm_count) <= 0);\n\tmmdrop(mm);\n}"
  },
  {
    "function_name": "mmu_notifier_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "348-386",
    "snippet": "void mmu_notifier_unregister(struct mmu_notifier *mn, struct mm_struct *mm)\n{\n\tBUG_ON(atomic_read(&mm->mm_count) <= 0);\n\n\tif (!hlist_unhashed(&mn->hlist)) {\n\t\t/*\n\t\t * SRCU here will force exit_mmap to wait for ->release to\n\t\t * finish before freeing the pages.\n\t\t */\n\t\tint id;\n\n\t\tid = srcu_read_lock(&srcu);\n\t\t/*\n\t\t * exit_mmap will block in mmu_notifier_release to guarantee\n\t\t * that ->release is called before freeing the pages.\n\t\t */\n\t\tif (mn->ops->release)\n\t\t\tmn->ops->release(mn, mm);\n\t\tsrcu_read_unlock(&srcu, id);\n\n\t\tspin_lock(&mm->mmu_notifier_mm->lock);\n\t\t/*\n\t\t * Can not use list_del_rcu() since __mmu_notifier_release\n\t\t * can delete it before we hold the lock.\n\t\t */\n\t\thlist_del_init_rcu(&mn->hlist);\n\t\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\t}\n\n\t/*\n\t * Wait for any running method to finish, of course including\n\t * ->release if it was run by mmu_notifier_release instead of us.\n\t */\n\tsynchronize_srcu(&srcu);\n\n\tBUG_ON(atomic_read(&mm->mm_count) <= 0);\n\n\tmmdrop(mm);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&mm->mm_count) <= 0"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_count"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "&srcu"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->mmu_notifier_mm->lock"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&mn->hlist"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->mmu_notifier_mm->lock"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&srcu",
            "id"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mn->ops->release",
          "args": [
            "mn",
            "mm"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&srcu"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&mn->hlist"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&mm->mm_count) <= 0"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_count"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid mmu_notifier_unregister(struct mmu_notifier *mn, struct mm_struct *mm)\n{\n\tBUG_ON(atomic_read(&mm->mm_count) <= 0);\n\n\tif (!hlist_unhashed(&mn->hlist)) {\n\t\t/*\n\t\t * SRCU here will force exit_mmap to wait for ->release to\n\t\t * finish before freeing the pages.\n\t\t */\n\t\tint id;\n\n\t\tid = srcu_read_lock(&srcu);\n\t\t/*\n\t\t * exit_mmap will block in mmu_notifier_release to guarantee\n\t\t * that ->release is called before freeing the pages.\n\t\t */\n\t\tif (mn->ops->release)\n\t\t\tmn->ops->release(mn, mm);\n\t\tsrcu_read_unlock(&srcu, id);\n\n\t\tspin_lock(&mm->mmu_notifier_mm->lock);\n\t\t/*\n\t\t * Can not use list_del_rcu() since __mmu_notifier_release\n\t\t * can delete it before we hold the lock.\n\t\t */\n\t\thlist_del_init_rcu(&mn->hlist);\n\t\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\t}\n\n\t/*\n\t * Wait for any running method to finish, of course including\n\t * ->release if it was run by mmu_notifier_release instead of us.\n\t */\n\tsynchronize_srcu(&srcu);\n\n\tBUG_ON(atomic_read(&mm->mm_count) <= 0);\n\n\tmmdrop(mm);\n}"
  },
  {
    "function_name": "__mmu_notifier_mm_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "331-336",
    "snippet": "void __mmu_notifier_mm_destroy(struct mm_struct *mm)\n{\n\tBUG_ON(!hlist_empty(&mm->mmu_notifier_mm->list));\n\tkfree(mm->mmu_notifier_mm);\n\tmm->mmu_notifier_mm = LIST_POISON1; /* debug */\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mm->mmu_notifier_mm"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!hlist_empty(&mm->mmu_notifier_mm->list)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&mm->mmu_notifier_mm->list"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid __mmu_notifier_mm_destroy(struct mm_struct *mm)\n{\n\tBUG_ON(!hlist_empty(&mm->mmu_notifier_mm->list));\n\tkfree(mm->mmu_notifier_mm);\n\tmm->mmu_notifier_mm = LIST_POISON1; /* debug */\n}"
  },
  {
    "function_name": "__mmu_notifier_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "324-327",
    "snippet": "int __mmu_notifier_register(struct mmu_notifier *mn, struct mm_struct *mm)\n{\n\treturn do_mmu_notifier_register(mn, mm, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_mmu_notifier_register",
          "args": [
            "mn",
            "mm",
            "0"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmu_notifier_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
          "lines": "250-299",
          "snippet": "static int do_mmu_notifier_register(struct mmu_notifier *mn,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    int take_mmap_sem)\n{\n\tstruct mmu_notifier_mm *mmu_notifier_mm;\n\tint ret;\n\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\n\tret = -ENOMEM;\n\tmmu_notifier_mm = kmalloc(sizeof(struct mmu_notifier_mm), GFP_KERNEL);\n\tif (unlikely(!mmu_notifier_mm))\n\t\tgoto out;\n\n\tif (take_mmap_sem)\n\t\tdown_write(&mm->mmap_sem);\n\tret = mm_take_all_locks(mm);\n\tif (unlikely(ret))\n\t\tgoto out_clean;\n\n\tif (!mm_has_notifiers(mm)) {\n\t\tINIT_HLIST_HEAD(&mmu_notifier_mm->list);\n\t\tspin_lock_init(&mmu_notifier_mm->lock);\n\n\t\tmm->mmu_notifier_mm = mmu_notifier_mm;\n\t\tmmu_notifier_mm = NULL;\n\t}\n\tmmgrab(mm);\n\n\t/*\n\t * Serialize the update against mmu_notifier_unregister. A\n\t * side note: mmu_notifier_release can't run concurrently with\n\t * us because we hold the mm_users pin (either implicitly as\n\t * current->mm or explicitly with get_task_mm() or similar).\n\t * We can't race against any other mmu notifier method either\n\t * thanks to mm_take_all_locks().\n\t */\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\thlist_add_head(&mn->hlist, &mm->mmu_notifier_mm->list);\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\n\tmm_drop_all_locks(mm);\nout_clean:\n\tif (take_mmap_sem)\n\t\tup_write(&mm->mmap_sem);\n\tkfree(mmu_notifier_mm);\nout:\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/srcu.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nstatic int do_mmu_notifier_register(struct mmu_notifier *mn,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    int take_mmap_sem)\n{\n\tstruct mmu_notifier_mm *mmu_notifier_mm;\n\tint ret;\n\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\n\tret = -ENOMEM;\n\tmmu_notifier_mm = kmalloc(sizeof(struct mmu_notifier_mm), GFP_KERNEL);\n\tif (unlikely(!mmu_notifier_mm))\n\t\tgoto out;\n\n\tif (take_mmap_sem)\n\t\tdown_write(&mm->mmap_sem);\n\tret = mm_take_all_locks(mm);\n\tif (unlikely(ret))\n\t\tgoto out_clean;\n\n\tif (!mm_has_notifiers(mm)) {\n\t\tINIT_HLIST_HEAD(&mmu_notifier_mm->list);\n\t\tspin_lock_init(&mmu_notifier_mm->lock);\n\n\t\tmm->mmu_notifier_mm = mmu_notifier_mm;\n\t\tmmu_notifier_mm = NULL;\n\t}\n\tmmgrab(mm);\n\n\t/*\n\t * Serialize the update against mmu_notifier_unregister. A\n\t * side note: mmu_notifier_release can't run concurrently with\n\t * us because we hold the mm_users pin (either implicitly as\n\t * current->mm or explicitly with get_task_mm() or similar).\n\t * We can't race against any other mmu notifier method either\n\t * thanks to mm_take_all_locks().\n\t */\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\thlist_add_head(&mn->hlist, &mm->mmu_notifier_mm->list);\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\n\tmm_drop_all_locks(mm);\nout_clean:\n\tif (take_mmap_sem)\n\t\tup_write(&mm->mmap_sem);\n\tkfree(mmu_notifier_mm);\nout:\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nint __mmu_notifier_register(struct mmu_notifier *mn, struct mm_struct *mm)\n{\n\treturn do_mmu_notifier_register(mn, mm, 0);\n}"
  },
  {
    "function_name": "mmu_notifier_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "314-317",
    "snippet": "int mmu_notifier_register(struct mmu_notifier *mn, struct mm_struct *mm)\n{\n\treturn do_mmu_notifier_register(mn, mm, 1);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_mmu_notifier_register",
          "args": [
            "mn",
            "mm",
            "1"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmu_notifier_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
          "lines": "250-299",
          "snippet": "static int do_mmu_notifier_register(struct mmu_notifier *mn,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    int take_mmap_sem)\n{\n\tstruct mmu_notifier_mm *mmu_notifier_mm;\n\tint ret;\n\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\n\tret = -ENOMEM;\n\tmmu_notifier_mm = kmalloc(sizeof(struct mmu_notifier_mm), GFP_KERNEL);\n\tif (unlikely(!mmu_notifier_mm))\n\t\tgoto out;\n\n\tif (take_mmap_sem)\n\t\tdown_write(&mm->mmap_sem);\n\tret = mm_take_all_locks(mm);\n\tif (unlikely(ret))\n\t\tgoto out_clean;\n\n\tif (!mm_has_notifiers(mm)) {\n\t\tINIT_HLIST_HEAD(&mmu_notifier_mm->list);\n\t\tspin_lock_init(&mmu_notifier_mm->lock);\n\n\t\tmm->mmu_notifier_mm = mmu_notifier_mm;\n\t\tmmu_notifier_mm = NULL;\n\t}\n\tmmgrab(mm);\n\n\t/*\n\t * Serialize the update against mmu_notifier_unregister. A\n\t * side note: mmu_notifier_release can't run concurrently with\n\t * us because we hold the mm_users pin (either implicitly as\n\t * current->mm or explicitly with get_task_mm() or similar).\n\t * We can't race against any other mmu notifier method either\n\t * thanks to mm_take_all_locks().\n\t */\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\thlist_add_head(&mn->hlist, &mm->mmu_notifier_mm->list);\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\n\tmm_drop_all_locks(mm);\nout_clean:\n\tif (take_mmap_sem)\n\t\tup_write(&mm->mmap_sem);\n\tkfree(mmu_notifier_mm);\nout:\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/srcu.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nstatic int do_mmu_notifier_register(struct mmu_notifier *mn,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    int take_mmap_sem)\n{\n\tstruct mmu_notifier_mm *mmu_notifier_mm;\n\tint ret;\n\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\n\tret = -ENOMEM;\n\tmmu_notifier_mm = kmalloc(sizeof(struct mmu_notifier_mm), GFP_KERNEL);\n\tif (unlikely(!mmu_notifier_mm))\n\t\tgoto out;\n\n\tif (take_mmap_sem)\n\t\tdown_write(&mm->mmap_sem);\n\tret = mm_take_all_locks(mm);\n\tif (unlikely(ret))\n\t\tgoto out_clean;\n\n\tif (!mm_has_notifiers(mm)) {\n\t\tINIT_HLIST_HEAD(&mmu_notifier_mm->list);\n\t\tspin_lock_init(&mmu_notifier_mm->lock);\n\n\t\tmm->mmu_notifier_mm = mmu_notifier_mm;\n\t\tmmu_notifier_mm = NULL;\n\t}\n\tmmgrab(mm);\n\n\t/*\n\t * Serialize the update against mmu_notifier_unregister. A\n\t * side note: mmu_notifier_release can't run concurrently with\n\t * us because we hold the mm_users pin (either implicitly as\n\t * current->mm or explicitly with get_task_mm() or similar).\n\t * We can't race against any other mmu notifier method either\n\t * thanks to mm_take_all_locks().\n\t */\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\thlist_add_head(&mn->hlist, &mm->mmu_notifier_mm->list);\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\n\tmm_drop_all_locks(mm);\nout_clean:\n\tif (take_mmap_sem)\n\t\tup_write(&mm->mmap_sem);\n\tkfree(mmu_notifier_mm);\nout:\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nint mmu_notifier_register(struct mmu_notifier *mn, struct mm_struct *mm)\n{\n\treturn do_mmu_notifier_register(mn, mm, 1);\n}"
  },
  {
    "function_name": "do_mmu_notifier_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "250-299",
    "snippet": "static int do_mmu_notifier_register(struct mmu_notifier *mn,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    int take_mmap_sem)\n{\n\tstruct mmu_notifier_mm *mmu_notifier_mm;\n\tint ret;\n\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\n\tret = -ENOMEM;\n\tmmu_notifier_mm = kmalloc(sizeof(struct mmu_notifier_mm), GFP_KERNEL);\n\tif (unlikely(!mmu_notifier_mm))\n\t\tgoto out;\n\n\tif (take_mmap_sem)\n\t\tdown_write(&mm->mmap_sem);\n\tret = mm_take_all_locks(mm);\n\tif (unlikely(ret))\n\t\tgoto out_clean;\n\n\tif (!mm_has_notifiers(mm)) {\n\t\tINIT_HLIST_HEAD(&mmu_notifier_mm->list);\n\t\tspin_lock_init(&mmu_notifier_mm->lock);\n\n\t\tmm->mmu_notifier_mm = mmu_notifier_mm;\n\t\tmmu_notifier_mm = NULL;\n\t}\n\tmmgrab(mm);\n\n\t/*\n\t * Serialize the update against mmu_notifier_unregister. A\n\t * side note: mmu_notifier_release can't run concurrently with\n\t * us because we hold the mm_users pin (either implicitly as\n\t * current->mm or explicitly with get_task_mm() or similar).\n\t * We can't race against any other mmu notifier method either\n\t * thanks to mm_take_all_locks().\n\t */\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\thlist_add_head(&mn->hlist, &mm->mmu_notifier_mm->list);\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\n\tmm_drop_all_locks(mm);\nout_clean:\n\tif (take_mmap_sem)\n\t\tup_write(&mm->mmap_sem);\n\tkfree(mmu_notifier_mm);\nout:\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&mm->mm_users) <= 0"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_users"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mmu_notifier_mm"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_drop_all_locks",
          "args": [
            "mm"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "mm_drop_all_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3621-3638",
          "snippet": "void mm_drop_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\tBUG_ON(!mutex_is_locked(&mm_all_locks_mutex));\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_unlock_anon_vma(avc->anon_vma);\n\t\tif (vma->vm_file && vma->vm_file->f_mapping)\n\t\t\tvm_unlock_mapping(vma->vm_file->f_mapping);\n\t}\n\n\tmutex_unlock(&mm_all_locks_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(mm_all_locks_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nvoid mm_drop_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\tBUG_ON(!mutex_is_locked(&mm_all_locks_mutex));\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_unlock_anon_vma(avc->anon_vma);\n\t\tif (vma->vm_file && vma->vm_file->f_mapping)\n\t\t\tvm_unlock_mapping(vma->vm_file->f_mapping);\n\t}\n\n\tmutex_unlock(&mm_all_locks_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->mmu_notifier_mm->lock"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&mn->hlist",
            "&mm->mmu_notifier_mm->list"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->mmu_notifier_mm->lock"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "mm"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mmu_notifier_mm->lock"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&mmu_notifier_mm->list"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_has_notifiers",
          "args": [
            "mm"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_take_all_locks",
          "args": [
            "mm"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "mm_take_all_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3541-3579",
          "snippet": "int mm_take_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\n\tmutex_lock(&mm_all_locks_mutex);\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\tis_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\t!is_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_lock_anon_vma(mm, avc->anon_vma);\n\t}\n\n\treturn 0;\n\nout_unlock:\n\tmm_drop_all_locks(mm);\n\treturn -EINTR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(mm_all_locks_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nint mm_take_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\n\tmutex_lock(&mm_all_locks_mutex);\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\tis_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\t!is_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_lock_anon_vma(mm, avc->anon_vma);\n\t}\n\n\treturn 0;\n\nout_unlock:\n\tmm_drop_all_locks(mm);\n\treturn -EINTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mmu_notifier_mm"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct mmu_notifier_mm)",
            "GFP_KERNEL"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&mm->mm_users) <= 0"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_users"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nstatic int do_mmu_notifier_register(struct mmu_notifier *mn,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    int take_mmap_sem)\n{\n\tstruct mmu_notifier_mm *mmu_notifier_mm;\n\tint ret;\n\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\n\tret = -ENOMEM;\n\tmmu_notifier_mm = kmalloc(sizeof(struct mmu_notifier_mm), GFP_KERNEL);\n\tif (unlikely(!mmu_notifier_mm))\n\t\tgoto out;\n\n\tif (take_mmap_sem)\n\t\tdown_write(&mm->mmap_sem);\n\tret = mm_take_all_locks(mm);\n\tif (unlikely(ret))\n\t\tgoto out_clean;\n\n\tif (!mm_has_notifiers(mm)) {\n\t\tINIT_HLIST_HEAD(&mmu_notifier_mm->list);\n\t\tspin_lock_init(&mmu_notifier_mm->lock);\n\n\t\tmm->mmu_notifier_mm = mmu_notifier_mm;\n\t\tmmu_notifier_mm = NULL;\n\t}\n\tmmgrab(mm);\n\n\t/*\n\t * Serialize the update against mmu_notifier_unregister. A\n\t * side note: mmu_notifier_release can't run concurrently with\n\t * us because we hold the mm_users pin (either implicitly as\n\t * current->mm or explicitly with get_task_mm() or similar).\n\t * We can't race against any other mmu notifier method either\n\t * thanks to mm_take_all_locks().\n\t */\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\thlist_add_head(&mn->hlist, &mm->mmu_notifier_mm->list);\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\n\tmm_drop_all_locks(mm);\nout_clean:\n\tif (take_mmap_sem)\n\t\tup_write(&mm->mmap_sem);\n\tkfree(mmu_notifier_mm);\nout:\n\tBUG_ON(atomic_read(&mm->mm_users) <= 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "__mmu_notifier_invalidate_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "235-247",
    "snippet": "void __mmu_notifier_invalidate_range(struct mm_struct *mm,\n\t\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->invalidate_range)\n\t\t\tmn->ops->invalidate_range(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&srcu",
            "id"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mn->ops->invalidate_range",
          "args": [
            "mn",
            "mm",
            "start",
            "end"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "mn",
            "&mm->mmu_notifier_mm->list",
            "hlist"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&srcu"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid __mmu_notifier_invalidate_range(struct mm_struct *mm,\n\t\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->invalidate_range)\n\t\t\tmn->ops->invalidate_range(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}"
  },
  {
    "function_name": "__mmu_notifier_invalidate_range_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "203-232",
    "snippet": "void __mmu_notifier_invalidate_range_end(struct mm_struct *mm,\n\t\t\t\t\t unsigned long start,\n\t\t\t\t\t unsigned long end,\n\t\t\t\t\t bool only_end)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\t/*\n\t\t * Call invalidate_range here too to avoid the need for the\n\t\t * subsystem of having to register an invalidate_range_end\n\t\t * call-back when there is invalidate_range already. Usually a\n\t\t * subsystem registers either invalidate_range_start()/end() or\n\t\t * invalidate_range(), so this will be no additional overhead\n\t\t * (besides the pointer check).\n\t\t *\n\t\t * We skip call to invalidate_range() if we know it is safe ie\n\t\t * call site use mmu_notifier_invalidate_range_only_end() which\n\t\t * is safe to do when we know that a call to invalidate_range()\n\t\t * already happen under page table lock.\n\t\t */\n\t\tif (!only_end && mn->ops->invalidate_range)\n\t\t\tmn->ops->invalidate_range(mn, mm, start, end);\n\t\tif (mn->ops->invalidate_range_end)\n\t\t\tmn->ops->invalidate_range_end(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&srcu",
            "id"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mn->ops->invalidate_range_end",
          "args": [
            "mn",
            "mm",
            "start",
            "end"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mn->ops->invalidate_range",
          "args": [
            "mn",
            "mm",
            "start",
            "end"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "mn",
            "&mm->mmu_notifier_mm->list",
            "hlist"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&srcu"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid __mmu_notifier_invalidate_range_end(struct mm_struct *mm,\n\t\t\t\t\t unsigned long start,\n\t\t\t\t\t unsigned long end,\n\t\t\t\t\t bool only_end)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\t/*\n\t\t * Call invalidate_range here too to avoid the need for the\n\t\t * subsystem of having to register an invalidate_range_end\n\t\t * call-back when there is invalidate_range already. Usually a\n\t\t * subsystem registers either invalidate_range_start()/end() or\n\t\t * invalidate_range(), so this will be no additional overhead\n\t\t * (besides the pointer check).\n\t\t *\n\t\t * We skip call to invalidate_range() if we know it is safe ie\n\t\t * call site use mmu_notifier_invalidate_range_only_end() which\n\t\t * is safe to do when we know that a call to invalidate_range()\n\t\t * already happen under page table lock.\n\t\t */\n\t\tif (!only_end && mn->ops->invalidate_range)\n\t\t\tmn->ops->invalidate_range(mn, mm, start, end);\n\t\tif (mn->ops->invalidate_range_end)\n\t\t\tmn->ops->invalidate_range_end(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}"
  },
  {
    "function_name": "__mmu_notifier_invalidate_range_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "177-200",
    "snippet": "int __mmu_notifier_invalidate_range_start(struct mm_struct *mm,\n\t\t\t\t  unsigned long start, unsigned long end,\n\t\t\t\t  bool blockable)\n{\n\tstruct mmu_notifier *mn;\n\tint ret = 0;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->invalidate_range_start) {\n\t\t\tint _ret = mn->ops->invalidate_range_start(mn, mm, start, end, blockable);\n\t\t\tif (_ret) {\n\t\t\t\tpr_info(\"%pS callback failed with %d in %sblockable context.\\n\",\n\t\t\t\t\t\tmn->ops->invalidate_range_start, _ret,\n\t\t\t\t\t\t!blockable ? \"non-\" : \"\");\n\t\t\t\tret = _ret;\n\t\t\t}\n\t\t}\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&srcu",
            "id"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%pS callback failed with %d in %sblockable context.\\n\"",
            "mn->ops->invalidate_range_start",
            "_ret",
            "!blockable ? \"non-\" : \"\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mn->ops->invalidate_range_start",
          "args": [
            "mn",
            "mm",
            "start",
            "end",
            "blockable"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "mn",
            "&mm->mmu_notifier_mm->list",
            "hlist"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&srcu"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nint __mmu_notifier_invalidate_range_start(struct mm_struct *mm,\n\t\t\t\t  unsigned long start, unsigned long end,\n\t\t\t\t  bool blockable)\n{\n\tstruct mmu_notifier *mn;\n\tint ret = 0;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->invalidate_range_start) {\n\t\t\tint _ret = mn->ops->invalidate_range_start(mn, mm, start, end, blockable);\n\t\t\tif (_ret) {\n\t\t\t\tpr_info(\"%pS callback failed with %d in %sblockable context.\\n\",\n\t\t\t\t\t\tmn->ops->invalidate_range_start, _ret,\n\t\t\t\t\t\t!blockable ? \"non-\" : \"\");\n\t\t\t\tret = _ret;\n\t\t\t}\n\t\t}\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__mmu_notifier_change_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "163-175",
    "snippet": "void __mmu_notifier_change_pte(struct mm_struct *mm, unsigned long address,\n\t\t\t       pte_t pte)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->change_pte)\n\t\t\tmn->ops->change_pte(mn, mm, address, pte);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&srcu",
            "id"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mn->ops->change_pte",
          "args": [
            "mn",
            "mm",
            "address",
            "pte"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "mn",
            "&mm->mmu_notifier_mm->list",
            "hlist"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&srcu"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid __mmu_notifier_change_pte(struct mm_struct *mm, unsigned long address,\n\t\t\t       pte_t pte)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->change_pte)\n\t\t\tmn->ops->change_pte(mn, mm, address, pte);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}"
  },
  {
    "function_name": "__mmu_notifier_test_young",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "144-161",
    "snippet": "int __mmu_notifier_test_young(struct mm_struct *mm,\n\t\t\t      unsigned long address)\n{\n\tstruct mmu_notifier *mn;\n\tint young = 0, id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->test_young) {\n\t\t\tyoung = mn->ops->test_young(mn, mm, address);\n\t\t\tif (young)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn young;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&srcu",
            "id"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mn->ops->test_young",
          "args": [
            "mn",
            "mm",
            "address"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "mn",
            "&mm->mmu_notifier_mm->list",
            "hlist"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&srcu"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nint __mmu_notifier_test_young(struct mm_struct *mm,\n\t\t\t      unsigned long address)\n{\n\tstruct mmu_notifier *mn;\n\tint young = 0, id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->test_young) {\n\t\t\tyoung = mn->ops->test_young(mn, mm, address);\n\t\t\tif (young)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn young;\n}"
  },
  {
    "function_name": "__mmu_notifier_clear_young",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "127-142",
    "snippet": "int __mmu_notifier_clear_young(struct mm_struct *mm,\n\t\t\t       unsigned long start,\n\t\t\t       unsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint young = 0, id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->clear_young)\n\t\t\tyoung |= mn->ops->clear_young(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn young;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&srcu",
            "id"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mn->ops->clear_young",
          "args": [
            "mn",
            "mm",
            "start",
            "end"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "mn",
            "&mm->mmu_notifier_mm->list",
            "hlist"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&srcu"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nint __mmu_notifier_clear_young(struct mm_struct *mm,\n\t\t\t       unsigned long start,\n\t\t\t       unsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint young = 0, id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->clear_young)\n\t\t\tyoung |= mn->ops->clear_young(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn young;\n}"
  },
  {
    "function_name": "__mmu_notifier_clear_flush_young",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "110-125",
    "snippet": "int __mmu_notifier_clear_flush_young(struct mm_struct *mm,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint young = 0, id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->clear_flush_young)\n\t\t\tyoung |= mn->ops->clear_flush_young(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn young;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&srcu",
            "id"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mn->ops->clear_flush_young",
          "args": [
            "mn",
            "mm",
            "start",
            "end"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "mn",
            "&mm->mmu_notifier_mm->list",
            "hlist"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&srcu"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nint __mmu_notifier_clear_flush_young(struct mm_struct *mm,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint young = 0, id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->clear_flush_young)\n\t\t\tyoung |= mn->ops->clear_flush_young(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn young;\n}"
  },
  {
    "function_name": "__mmu_notifier_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "57-103",
    "snippet": "void __mmu_notifier_release(struct mm_struct *mm)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\t/*\n\t * SRCU here will block mmu_notifier_unregister until\n\t * ->release returns.\n\t */\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist)\n\t\t/*\n\t\t * If ->release runs before mmu_notifier_unregister it must be\n\t\t * handled, as it's the only way for the driver to flush all\n\t\t * existing sptes and stop the driver from establishing any more\n\t\t * sptes before all the pages in the mm are freed.\n\t\t */\n\t\tif (mn->ops->release)\n\t\t\tmn->ops->release(mn, mm);\n\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\twhile (unlikely(!hlist_empty(&mm->mmu_notifier_mm->list))) {\n\t\tmn = hlist_entry(mm->mmu_notifier_mm->list.first,\n\t\t\t\t struct mmu_notifier,\n\t\t\t\t hlist);\n\t\t/*\n\t\t * We arrived before mmu_notifier_unregister so\n\t\t * mmu_notifier_unregister will do nothing other than to wait\n\t\t * for ->release to finish and for mmu_notifier_unregister to\n\t\t * return.\n\t\t */\n\t\thlist_del_init_rcu(&mn->hlist);\n\t}\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\tsrcu_read_unlock(&srcu, id);\n\n\t/*\n\t * synchronize_srcu here prevents mmu_notifier_release from returning to\n\t * exit_mmap (which would proceed with freeing all pages in the mm)\n\t * until the ->release method returns, if it was invoked by\n\t * mmu_notifier_unregister.\n\t *\n\t * The mmu_notifier_mm can't go away from under us because one mm_count\n\t * is held by exit_mmap.\n\t */\n\tsynchronize_srcu(&srcu);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "&srcu"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&srcu",
            "id"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->mmu_notifier_mm->lock"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&mn->hlist"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "mm->mmu_notifier_mm->list.first",
            "structmmu_notifier",
            "hlist"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!hlist_empty(&mm->mmu_notifier_mm->list)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&mm->mmu_notifier_mm->list"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->mmu_notifier_mm->lock"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mn->ops->release",
          "args": [
            "mn",
            "mm"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "mn",
            "&mm->mmu_notifier_mm->list",
            "hlist"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&srcu"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid __mmu_notifier_release(struct mm_struct *mm)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\t/*\n\t * SRCU here will block mmu_notifier_unregister until\n\t * ->release returns.\n\t */\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist)\n\t\t/*\n\t\t * If ->release runs before mmu_notifier_unregister it must be\n\t\t * handled, as it's the only way for the driver to flush all\n\t\t * existing sptes and stop the driver from establishing any more\n\t\t * sptes before all the pages in the mm are freed.\n\t\t */\n\t\tif (mn->ops->release)\n\t\t\tmn->ops->release(mn, mm);\n\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\twhile (unlikely(!hlist_empty(&mm->mmu_notifier_mm->list))) {\n\t\tmn = hlist_entry(mm->mmu_notifier_mm->list.first,\n\t\t\t\t struct mmu_notifier,\n\t\t\t\t hlist);\n\t\t/*\n\t\t * We arrived before mmu_notifier_unregister so\n\t\t * mmu_notifier_unregister will do nothing other than to wait\n\t\t * for ->release to finish and for mmu_notifier_unregister to\n\t\t * return.\n\t\t */\n\t\thlist_del_init_rcu(&mn->hlist);\n\t}\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\tsrcu_read_unlock(&srcu, id);\n\n\t/*\n\t * synchronize_srcu here prevents mmu_notifier_release from returning to\n\t * exit_mmap (which would proceed with freeing all pages in the mm)\n\t * until the ->release method returns, if it was invoked by\n\t * mmu_notifier_unregister.\n\t *\n\t * The mmu_notifier_mm can't go away from under us because one mm_count\n\t * is held by exit_mmap.\n\t */\n\tsynchronize_srcu(&srcu);\n}"
  },
  {
    "function_name": "mmu_notifier_synchronize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "38-42",
    "snippet": "void mmu_notifier_synchronize(void)\n{\n\t/* Wait for any running method to finish. */\n\tsrcu_barrier(&srcu);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_barrier",
          "args": [
            "&srcu"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid mmu_notifier_synchronize(void)\n{\n\t/* Wait for any running method to finish. */\n\tsrcu_barrier(&srcu);\n}"
  },
  {
    "function_name": "mmu_notifier_call_srcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
    "lines": "31-35",
    "snippet": "void mmu_notifier_call_srcu(struct rcu_head *rcu,\n\t\t\t    void (*func)(struct rcu_head *rcu))\n{\n\tcall_srcu(&srcu, rcu, func);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/srcu.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_srcu",
          "args": [
            "&srcu",
            "rcu",
            "func"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid mmu_notifier_call_srcu(struct rcu_head *rcu,\n\t\t\t    void (*func)(struct rcu_head *rcu))\n{\n\tcall_srcu(&srcu, rcu, func);\n}"
  }
]