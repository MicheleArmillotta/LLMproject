[
  {
    "function_name": "set_hardened_usercopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
    "lines": "299-304",
    "snippet": "static int __init set_hardened_usercopy(void)\n{\n\tif (enable_checks == false)\n\t\tstatic_branch_enable(&bypass_usercopy_checks);\n\treturn 1;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE_RO(bypass_usercopy_checks);",
      "static bool enable_checks"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&bypass_usercopy_checks"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic DEFINE_STATIC_KEY_FALSE_RO(bypass_usercopy_checks);\nstatic bool enable_checks;\n\nstatic int __init set_hardened_usercopy(void)\n{\n\tif (enable_checks == false)\n\t\tstatic_branch_enable(&bypass_usercopy_checks);\n\treturn 1;\n}"
  },
  {
    "function_name": "parse_hardened_usercopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
    "lines": "292-295",
    "snippet": "static int __init parse_hardened_usercopy(char *str)\n{\n\treturn strtobool(str, &enable_checks);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool enable_checks"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtobool",
          "args": [
            "str",
            "&enable_checks"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic bool enable_checks;\n\nstatic int __init parse_hardened_usercopy(char *str)\n{\n\treturn strtobool(str, &enable_checks);\n}"
  },
  {
    "function_name": "__check_object_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
    "lines": "253-287",
    "snippet": "void __check_object_size(const void *ptr, unsigned long n, bool to_user)\n{\n\tif (static_branch_unlikely(&bypass_usercopy_checks))\n\t\treturn;\n\n\t/* Skip all tests if size is zero. */\n\tif (!n)\n\t\treturn;\n\n\t/* Check for invalid addresses. */\n\tcheck_bogus_address((const unsigned long)ptr, n, to_user);\n\n\t/* Check for bad heap object. */\n\tcheck_heap_object(ptr, n, to_user);\n\n\t/* Check for bad stack object. */\n\tswitch (check_stack_object(ptr, n)) {\n\tcase NOT_STACK:\n\t\t/* Object is not touching the current process stack. */\n\t\tbreak;\n\tcase GOOD_FRAME:\n\tcase GOOD_STACK:\n\t\t/*\n\t\t * Object is either in the correct frame (when it\n\t\t * is possible to check) or just generally on the\n\t\t * process stack (when frame checking not available).\n\t\t */\n\t\treturn;\n\tdefault:\n\t\tusercopy_abort(\"process stack\", NULL, to_user, 0, n);\n\t}\n\n\t/* Check for object in kernel to avoid text exposure. */\n\tcheck_kernel_text_object((const unsigned long)ptr, n, to_user);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE_RO(bypass_usercopy_checks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_kernel_text_object",
          "args": [
            "(const unsigned long)ptr",
            "n",
            "to_user"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "check_kernel_text_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "120-148",
          "snippet": "static inline void check_kernel_text_object(const unsigned long ptr,\n\t\t\t\t\t    unsigned long n, bool to_user)\n{\n\tunsigned long textlow = (unsigned long)_stext;\n\tunsigned long texthigh = (unsigned long)_etext;\n\tunsigned long textlow_linear, texthigh_linear;\n\n\tif (overlaps(ptr, n, textlow, texthigh))\n\t\tusercopy_abort(\"kernel text\", NULL, to_user, ptr - textlow, n);\n\n\t/*\n\t * Some architectures have virtual memory mappings with a secondary\n\t * mapping of the kernel text, i.e. there is more than one virtual\n\t * kernel address that points to the kernel image. It is usually\n\t * when there is a separate linear physical memory mapping, in that\n\t * __pa() is not just the reverse of __va(). This can be detected\n\t * and checked:\n\t */\n\ttextlow_linear = (unsigned long)lm_alias(textlow);\n\t/* No different mapping: we're done. */\n\tif (textlow_linear == textlow)\n\t\treturn;\n\n\t/* Check the secondary mapping... */\n\ttexthigh_linear = (unsigned long)lm_alias(texthigh);\n\tif (overlaps(ptr, n, textlow_linear, texthigh_linear))\n\t\tusercopy_abort(\"linear kernel text\", NULL, to_user,\n\t\t\t       ptr - textlow_linear, n);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_kernel_text_object(const unsigned long ptr,\n\t\t\t\t\t    unsigned long n, bool to_user)\n{\n\tunsigned long textlow = (unsigned long)_stext;\n\tunsigned long texthigh = (unsigned long)_etext;\n\tunsigned long textlow_linear, texthigh_linear;\n\n\tif (overlaps(ptr, n, textlow, texthigh))\n\t\tusercopy_abort(\"kernel text\", NULL, to_user, ptr - textlow, n);\n\n\t/*\n\t * Some architectures have virtual memory mappings with a secondary\n\t * mapping of the kernel text, i.e. there is more than one virtual\n\t * kernel address that points to the kernel image. It is usually\n\t * when there is a separate linear physical memory mapping, in that\n\t * __pa() is not just the reverse of __va(). This can be detected\n\t * and checked:\n\t */\n\ttextlow_linear = (unsigned long)lm_alias(textlow);\n\t/* No different mapping: we're done. */\n\tif (textlow_linear == textlow)\n\t\treturn;\n\n\t/* Check the secondary mapping... */\n\ttexthigh_linear = (unsigned long)lm_alias(texthigh);\n\tif (overlaps(ptr, n, textlow_linear, texthigh_linear))\n\t\tusercopy_abort(\"linear kernel text\", NULL, to_user,\n\t\t\t       ptr - textlow_linear, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usercopy_abort",
          "args": [
            "\"process stack\"",
            "NULL",
            "to_user",
            "0",
            "n"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "usercopy_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "86-103",
          "snippet": "void __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_object",
          "args": [
            "ptr",
            "n"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "check_stack_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "37-61",
          "snippet": "static noinline int check_stack_object(const void *obj, unsigned long len)\n{\n\tconst void * const stack = task_stack_page(current);\n\tconst void * const stackend = stack + THREAD_SIZE;\n\tint ret;\n\n\t/* Object is not on the stack at all. */\n\tif (obj + len <= stack || stackend <= obj)\n\t\treturn NOT_STACK;\n\n\t/*\n\t * Reject: object partially overlaps the stack (passing the\n\t * the check above means at least one end is within the stack,\n\t * so if this check fails, the other end is outside the stack).\n\t */\n\tif (obj < stack || stackend < obj + len)\n\t\treturn BAD_STACK;\n\n\t/* Check if object is safely within a valid frame. */\n\tret = arch_within_stack_frames(stack, stackend, obj, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn GOOD_STACK;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic noinline int check_stack_object(const void *obj, unsigned long len)\n{\n\tconst void * const stack = task_stack_page(current);\n\tconst void * const stackend = stack + THREAD_SIZE;\n\tint ret;\n\n\t/* Object is not on the stack at all. */\n\tif (obj + len <= stack || stackend <= obj)\n\t\treturn NOT_STACK;\n\n\t/*\n\t * Reject: object partially overlaps the stack (passing the\n\t * the check above means at least one end is within the stack,\n\t * so if this check fails, the other end is outside the stack).\n\t */\n\tif (obj < stack || stackend < obj + len)\n\t\treturn BAD_STACK;\n\n\t/* Check if object is safely within a valid frame. */\n\tret = arch_within_stack_frames(stack, stackend, obj, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn GOOD_STACK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_heap_object",
          "args": [
            "ptr",
            "n",
            "to_user"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "check_heap_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "226-243",
          "snippet": "static inline void check_heap_object(const void *ptr, unsigned long n,\n\t\t\t\t     bool to_user)\n{\n\tstruct page *page;\n\n\tif (!virt_addr_valid(ptr))\n\t\treturn;\n\n\tpage = virt_to_head_page(ptr);\n\n\tif (PageSlab(page)) {\n\t\t/* Check slab allocator for flags and size. */\n\t\t__check_heap_object(ptr, n, page, to_user);\n\t} else {\n\t\t/* Verify object does not incorrectly span multiple pages. */\n\t\tcheck_page_span(ptr, n, page, to_user);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_heap_object(const void *ptr, unsigned long n,\n\t\t\t\t     bool to_user)\n{\n\tstruct page *page;\n\n\tif (!virt_addr_valid(ptr))\n\t\treturn;\n\n\tpage = virt_to_head_page(ptr);\n\n\tif (PageSlab(page)) {\n\t\t/* Check slab allocator for flags and size. */\n\t\t__check_heap_object(ptr, n, page, to_user);\n\t} else {\n\t\t/* Verify object does not incorrectly span multiple pages. */\n\t\tcheck_page_span(ptr, n, page, to_user);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_bogus_address",
          "args": [
            "(const unsigned long)ptr",
            "n",
            "to_user"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "check_bogus_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "150-160",
          "snippet": "static inline void check_bogus_address(const unsigned long ptr, unsigned long n,\n\t\t\t\t       bool to_user)\n{\n\t/* Reject if object wraps past end of memory. */\n\tif (ptr + n < ptr)\n\t\tusercopy_abort(\"wrapped address\", NULL, to_user, 0, ptr + n);\n\n\t/* Reject if NULL or ZERO-allocation. */\n\tif (ZERO_OR_NULL_PTR(ptr))\n\t\tusercopy_abort(\"null address\", NULL, to_user, ptr, n);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_bogus_address(const unsigned long ptr, unsigned long n,\n\t\t\t\t       bool to_user)\n{\n\t/* Reject if object wraps past end of memory. */\n\tif (ptr + n < ptr)\n\t\tusercopy_abort(\"wrapped address\", NULL, to_user, 0, ptr + n);\n\n\t/* Reject if NULL or ZERO-allocation. */\n\tif (ZERO_OR_NULL_PTR(ptr))\n\t\tusercopy_abort(\"null address\", NULL, to_user, ptr, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&bypass_usercopy_checks"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic DEFINE_STATIC_KEY_FALSE_RO(bypass_usercopy_checks);\n\nvoid __check_object_size(const void *ptr, unsigned long n, bool to_user)\n{\n\tif (static_branch_unlikely(&bypass_usercopy_checks))\n\t\treturn;\n\n\t/* Skip all tests if size is zero. */\n\tif (!n)\n\t\treturn;\n\n\t/* Check for invalid addresses. */\n\tcheck_bogus_address((const unsigned long)ptr, n, to_user);\n\n\t/* Check for bad heap object. */\n\tcheck_heap_object(ptr, n, to_user);\n\n\t/* Check for bad stack object. */\n\tswitch (check_stack_object(ptr, n)) {\n\tcase NOT_STACK:\n\t\t/* Object is not touching the current process stack. */\n\t\tbreak;\n\tcase GOOD_FRAME:\n\tcase GOOD_STACK:\n\t\t/*\n\t\t * Object is either in the correct frame (when it\n\t\t * is possible to check) or just generally on the\n\t\t * process stack (when frame checking not available).\n\t\t */\n\t\treturn;\n\tdefault:\n\t\tusercopy_abort(\"process stack\", NULL, to_user, 0, n);\n\t}\n\n\t/* Check for object in kernel to avoid text exposure. */\n\tcheck_kernel_text_object((const unsigned long)ptr, n, to_user);\n}"
  },
  {
    "function_name": "check_heap_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
    "lines": "226-243",
    "snippet": "static inline void check_heap_object(const void *ptr, unsigned long n,\n\t\t\t\t     bool to_user)\n{\n\tstruct page *page;\n\n\tif (!virt_addr_valid(ptr))\n\t\treturn;\n\n\tpage = virt_to_head_page(ptr);\n\n\tif (PageSlab(page)) {\n\t\t/* Check slab allocator for flags and size. */\n\t\t__check_heap_object(ptr, n, page, to_user);\n\t} else {\n\t\t/* Verify object does not incorrectly span multiple pages. */\n\t\tcheck_page_span(ptr, n, page, to_user);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_page_span",
          "args": [
            "ptr",
            "n",
            "page",
            "to_user"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "check_page_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "163-224",
          "snippet": "static inline void check_page_span(const void *ptr, unsigned long n,\n\t\t\t\t   struct page *page, bool to_user)\n{\n#ifdef CONFIG_HARDENED_USERCOPY_PAGESPAN\n\tconst void *end = ptr + n - 1;\n\tstruct page *endpage;\n\tbool is_reserved, is_cma;\n\n\t/*\n\t * Sometimes the kernel data regions are not marked Reserved (see\n\t * check below). And sometimes [_sdata,_edata) does not cover\n\t * rodata and/or bss, so check each range explicitly.\n\t */\n\n\t/* Allow reads of kernel rodata region (if not marked as Reserved). */\n\tif (ptr >= (const void *)__start_rodata &&\n\t    end <= (const void *)__end_rodata) {\n\t\tif (!to_user)\n\t\t\tusercopy_abort(\"rodata\", NULL, to_user, 0, n);\n\t\treturn;\n\t}\n\n\t/* Allow kernel data region (if not marked as Reserved). */\n\tif (ptr >= (const void *)_sdata && end <= (const void *)_edata)\n\t\treturn;\n\n\t/* Allow kernel bss region (if not marked as Reserved). */\n\tif (ptr >= (const void *)__bss_start &&\n\t    end <= (const void *)__bss_stop)\n\t\treturn;\n\n\t/* Is the object wholly within one base page? */\n\tif (likely(((unsigned long)ptr & (unsigned long)PAGE_MASK) ==\n\t\t   ((unsigned long)end & (unsigned long)PAGE_MASK)))\n\t\treturn;\n\n\t/* Allow if fully inside the same compound (__GFP_COMP) page. */\n\tendpage = virt_to_head_page(end);\n\tif (likely(endpage == page))\n\t\treturn;\n\n\t/*\n\t * Reject if range is entirely either Reserved (i.e. special or\n\t * device memory), or CMA. Otherwise, reject since the object spans\n\t * several independently allocated pages.\n\t */\n\tis_reserved = PageReserved(page);\n\tis_cma = is_migrate_cma_page(page);\n\tif (!is_reserved && !is_cma)\n\t\tusercopy_abort(\"spans multiple pages\", NULL, to_user, 0, n);\n\n\tfor (ptr += PAGE_SIZE; ptr <= end; ptr += PAGE_SIZE) {\n\t\tpage = virt_to_head_page(ptr);\n\t\tif (is_reserved && !PageReserved(page))\n\t\t\tusercopy_abort(\"spans Reserved and non-Reserved pages\",\n\t\t\t\t       NULL, to_user, 0, n);\n\t\tif (is_cma && !is_migrate_cma_page(page))\n\t\t\tusercopy_abort(\"spans CMA and non-CMA pages\", NULL,\n\t\t\t\t       to_user, 0, n);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_page_span(const void *ptr, unsigned long n,\n\t\t\t\t   struct page *page, bool to_user)\n{\n#ifdef CONFIG_HARDENED_USERCOPY_PAGESPAN\n\tconst void *end = ptr + n - 1;\n\tstruct page *endpage;\n\tbool is_reserved, is_cma;\n\n\t/*\n\t * Sometimes the kernel data regions are not marked Reserved (see\n\t * check below). And sometimes [_sdata,_edata) does not cover\n\t * rodata and/or bss, so check each range explicitly.\n\t */\n\n\t/* Allow reads of kernel rodata region (if not marked as Reserved). */\n\tif (ptr >= (const void *)__start_rodata &&\n\t    end <= (const void *)__end_rodata) {\n\t\tif (!to_user)\n\t\t\tusercopy_abort(\"rodata\", NULL, to_user, 0, n);\n\t\treturn;\n\t}\n\n\t/* Allow kernel data region (if not marked as Reserved). */\n\tif (ptr >= (const void *)_sdata && end <= (const void *)_edata)\n\t\treturn;\n\n\t/* Allow kernel bss region (if not marked as Reserved). */\n\tif (ptr >= (const void *)__bss_start &&\n\t    end <= (const void *)__bss_stop)\n\t\treturn;\n\n\t/* Is the object wholly within one base page? */\n\tif (likely(((unsigned long)ptr & (unsigned long)PAGE_MASK) ==\n\t\t   ((unsigned long)end & (unsigned long)PAGE_MASK)))\n\t\treturn;\n\n\t/* Allow if fully inside the same compound (__GFP_COMP) page. */\n\tendpage = virt_to_head_page(end);\n\tif (likely(endpage == page))\n\t\treturn;\n\n\t/*\n\t * Reject if range is entirely either Reserved (i.e. special or\n\t * device memory), or CMA. Otherwise, reject since the object spans\n\t * several independently allocated pages.\n\t */\n\tis_reserved = PageReserved(page);\n\tis_cma = is_migrate_cma_page(page);\n\tif (!is_reserved && !is_cma)\n\t\tusercopy_abort(\"spans multiple pages\", NULL, to_user, 0, n);\n\n\tfor (ptr += PAGE_SIZE; ptr <= end; ptr += PAGE_SIZE) {\n\t\tpage = virt_to_head_page(ptr);\n\t\tif (is_reserved && !PageReserved(page))\n\t\t\tusercopy_abort(\"spans Reserved and non-Reserved pages\",\n\t\t\t\t       NULL, to_user, 0, n);\n\t\tif (is_cma && !is_migrate_cma_page(page))\n\t\t\tusercopy_abort(\"spans CMA and non-CMA pages\", NULL,\n\t\t\t\t       to_user, 0, n);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__check_heap_object",
          "args": [
            "ptr",
            "n",
            "page",
            "to_user"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "__check_heap_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4415-4450",
          "snippet": "void __check_heap_object(const void *ptr, unsigned long n, struct page *page,\n\t\t\t bool to_user)\n{\n\tstruct kmem_cache *cachep;\n\tunsigned int objnr;\n\tunsigned long offset;\n\n\t/* Find and validate object. */\n\tcachep = page->slab_cache;\n\tobjnr = obj_to_index(cachep, page, (void *)ptr);\n\tBUG_ON(objnr >= cachep->num);\n\n\t/* Find offset within object. */\n\toffset = ptr - index_to_obj(cachep, page, objnr) - obj_offset(cachep);\n\n\t/* Allow address range falling entirely within usercopy region. */\n\tif (offset >= cachep->useroffset &&\n\t    offset - cachep->useroffset <= cachep->usersize &&\n\t    n <= cachep->useroffset - offset + cachep->usersize)\n\t\treturn;\n\n\t/*\n\t * If the copy is still within the allocated object, produce\n\t * a warning instead of rejecting the copy. This is intended\n\t * to be a temporary method to find any missing usercopy\n\t * whitelists.\n\t */\n\tif (usercopy_fallback &&\n\t    offset <= cachep->object_size &&\n\t    n <= cachep->object_size - offset) {\n\t\tusercopy_warn(\"SLAB object\", cachep->name, to_user, offset, n);\n\t\treturn;\n\t}\n\n\tusercopy_abort(\"SLAB object\", cachep->name, to_user, offset, n);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid __check_heap_object(const void *ptr, unsigned long n, struct page *page,\n\t\t\t bool to_user)\n{\n\tstruct kmem_cache *cachep;\n\tunsigned int objnr;\n\tunsigned long offset;\n\n\t/* Find and validate object. */\n\tcachep = page->slab_cache;\n\tobjnr = obj_to_index(cachep, page, (void *)ptr);\n\tBUG_ON(objnr >= cachep->num);\n\n\t/* Find offset within object. */\n\toffset = ptr - index_to_obj(cachep, page, objnr) - obj_offset(cachep);\n\n\t/* Allow address range falling entirely within usercopy region. */\n\tif (offset >= cachep->useroffset &&\n\t    offset - cachep->useroffset <= cachep->usersize &&\n\t    n <= cachep->useroffset - offset + cachep->usersize)\n\t\treturn;\n\n\t/*\n\t * If the copy is still within the allocated object, produce\n\t * a warning instead of rejecting the copy. This is intended\n\t * to be a temporary method to find any missing usercopy\n\t * whitelists.\n\t */\n\tif (usercopy_fallback &&\n\t    offset <= cachep->object_size &&\n\t    n <= cachep->object_size - offset) {\n\t\tusercopy_warn(\"SLAB object\", cachep->name, to_user, offset, n);\n\t\treturn;\n\t}\n\n\tusercopy_abort(\"SLAB object\", cachep->name, to_user, offset, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "page"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "ptr"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_addr_valid",
          "args": [
            "ptr"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_heap_object(const void *ptr, unsigned long n,\n\t\t\t\t     bool to_user)\n{\n\tstruct page *page;\n\n\tif (!virt_addr_valid(ptr))\n\t\treturn;\n\n\tpage = virt_to_head_page(ptr);\n\n\tif (PageSlab(page)) {\n\t\t/* Check slab allocator for flags and size. */\n\t\t__check_heap_object(ptr, n, page, to_user);\n\t} else {\n\t\t/* Verify object does not incorrectly span multiple pages. */\n\t\tcheck_page_span(ptr, n, page, to_user);\n\t}\n}"
  },
  {
    "function_name": "check_page_span",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
    "lines": "163-224",
    "snippet": "static inline void check_page_span(const void *ptr, unsigned long n,\n\t\t\t\t   struct page *page, bool to_user)\n{\n#ifdef CONFIG_HARDENED_USERCOPY_PAGESPAN\n\tconst void *end = ptr + n - 1;\n\tstruct page *endpage;\n\tbool is_reserved, is_cma;\n\n\t/*\n\t * Sometimes the kernel data regions are not marked Reserved (see\n\t * check below). And sometimes [_sdata,_edata) does not cover\n\t * rodata and/or bss, so check each range explicitly.\n\t */\n\n\t/* Allow reads of kernel rodata region (if not marked as Reserved). */\n\tif (ptr >= (const void *)__start_rodata &&\n\t    end <= (const void *)__end_rodata) {\n\t\tif (!to_user)\n\t\t\tusercopy_abort(\"rodata\", NULL, to_user, 0, n);\n\t\treturn;\n\t}\n\n\t/* Allow kernel data region (if not marked as Reserved). */\n\tif (ptr >= (const void *)_sdata && end <= (const void *)_edata)\n\t\treturn;\n\n\t/* Allow kernel bss region (if not marked as Reserved). */\n\tif (ptr >= (const void *)__bss_start &&\n\t    end <= (const void *)__bss_stop)\n\t\treturn;\n\n\t/* Is the object wholly within one base page? */\n\tif (likely(((unsigned long)ptr & (unsigned long)PAGE_MASK) ==\n\t\t   ((unsigned long)end & (unsigned long)PAGE_MASK)))\n\t\treturn;\n\n\t/* Allow if fully inside the same compound (__GFP_COMP) page. */\n\tendpage = virt_to_head_page(end);\n\tif (likely(endpage == page))\n\t\treturn;\n\n\t/*\n\t * Reject if range is entirely either Reserved (i.e. special or\n\t * device memory), or CMA. Otherwise, reject since the object spans\n\t * several independently allocated pages.\n\t */\n\tis_reserved = PageReserved(page);\n\tis_cma = is_migrate_cma_page(page);\n\tif (!is_reserved && !is_cma)\n\t\tusercopy_abort(\"spans multiple pages\", NULL, to_user, 0, n);\n\n\tfor (ptr += PAGE_SIZE; ptr <= end; ptr += PAGE_SIZE) {\n\t\tpage = virt_to_head_page(ptr);\n\t\tif (is_reserved && !PageReserved(page))\n\t\t\tusercopy_abort(\"spans Reserved and non-Reserved pages\",\n\t\t\t\t       NULL, to_user, 0, n);\n\t\tif (is_cma && !is_migrate_cma_page(page))\n\t\t\tusercopy_abort(\"spans CMA and non-CMA pages\", NULL,\n\t\t\t\t       to_user, 0, n);\n\t}\n#endif\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usercopy_abort",
          "args": [
            "\"spans CMA and non-CMA pages\"",
            "NULL",
            "to_user",
            "0",
            "n"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "usercopy_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "86-103",
          "snippet": "void __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migrate_cma_page",
          "args": [
            "page"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "page"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "ptr"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_cma_page",
          "args": [
            "page"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "page"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "endpage == page"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "end"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "((unsigned long)ptr & (unsigned long)PAGE_MASK) ==\n\t\t   ((unsigned long)end & (unsigned long)PAGE_MASK)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_page_span(const void *ptr, unsigned long n,\n\t\t\t\t   struct page *page, bool to_user)\n{\n#ifdef CONFIG_HARDENED_USERCOPY_PAGESPAN\n\tconst void *end = ptr + n - 1;\n\tstruct page *endpage;\n\tbool is_reserved, is_cma;\n\n\t/*\n\t * Sometimes the kernel data regions are not marked Reserved (see\n\t * check below). And sometimes [_sdata,_edata) does not cover\n\t * rodata and/or bss, so check each range explicitly.\n\t */\n\n\t/* Allow reads of kernel rodata region (if not marked as Reserved). */\n\tif (ptr >= (const void *)__start_rodata &&\n\t    end <= (const void *)__end_rodata) {\n\t\tif (!to_user)\n\t\t\tusercopy_abort(\"rodata\", NULL, to_user, 0, n);\n\t\treturn;\n\t}\n\n\t/* Allow kernel data region (if not marked as Reserved). */\n\tif (ptr >= (const void *)_sdata && end <= (const void *)_edata)\n\t\treturn;\n\n\t/* Allow kernel bss region (if not marked as Reserved). */\n\tif (ptr >= (const void *)__bss_start &&\n\t    end <= (const void *)__bss_stop)\n\t\treturn;\n\n\t/* Is the object wholly within one base page? */\n\tif (likely(((unsigned long)ptr & (unsigned long)PAGE_MASK) ==\n\t\t   ((unsigned long)end & (unsigned long)PAGE_MASK)))\n\t\treturn;\n\n\t/* Allow if fully inside the same compound (__GFP_COMP) page. */\n\tendpage = virt_to_head_page(end);\n\tif (likely(endpage == page))\n\t\treturn;\n\n\t/*\n\t * Reject if range is entirely either Reserved (i.e. special or\n\t * device memory), or CMA. Otherwise, reject since the object spans\n\t * several independently allocated pages.\n\t */\n\tis_reserved = PageReserved(page);\n\tis_cma = is_migrate_cma_page(page);\n\tif (!is_reserved && !is_cma)\n\t\tusercopy_abort(\"spans multiple pages\", NULL, to_user, 0, n);\n\n\tfor (ptr += PAGE_SIZE; ptr <= end; ptr += PAGE_SIZE) {\n\t\tpage = virt_to_head_page(ptr);\n\t\tif (is_reserved && !PageReserved(page))\n\t\t\tusercopy_abort(\"spans Reserved and non-Reserved pages\",\n\t\t\t\t       NULL, to_user, 0, n);\n\t\tif (is_cma && !is_migrate_cma_page(page))\n\t\t\tusercopy_abort(\"spans CMA and non-CMA pages\", NULL,\n\t\t\t\t       to_user, 0, n);\n\t}\n#endif\n}"
  },
  {
    "function_name": "check_bogus_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
    "lines": "150-160",
    "snippet": "static inline void check_bogus_address(const unsigned long ptr, unsigned long n,\n\t\t\t\t       bool to_user)\n{\n\t/* Reject if object wraps past end of memory. */\n\tif (ptr + n < ptr)\n\t\tusercopy_abort(\"wrapped address\", NULL, to_user, 0, ptr + n);\n\n\t/* Reject if NULL or ZERO-allocation. */\n\tif (ZERO_OR_NULL_PTR(ptr))\n\t\tusercopy_abort(\"null address\", NULL, to_user, ptr, n);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usercopy_abort",
          "args": [
            "\"null address\"",
            "NULL",
            "to_user",
            "ptr",
            "n"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "usercopy_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "86-103",
          "snippet": "void __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "ptr"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_bogus_address(const unsigned long ptr, unsigned long n,\n\t\t\t\t       bool to_user)\n{\n\t/* Reject if object wraps past end of memory. */\n\tif (ptr + n < ptr)\n\t\tusercopy_abort(\"wrapped address\", NULL, to_user, 0, ptr + n);\n\n\t/* Reject if NULL or ZERO-allocation. */\n\tif (ZERO_OR_NULL_PTR(ptr))\n\t\tusercopy_abort(\"null address\", NULL, to_user, ptr, n);\n}"
  },
  {
    "function_name": "check_kernel_text_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
    "lines": "120-148",
    "snippet": "static inline void check_kernel_text_object(const unsigned long ptr,\n\t\t\t\t\t    unsigned long n, bool to_user)\n{\n\tunsigned long textlow = (unsigned long)_stext;\n\tunsigned long texthigh = (unsigned long)_etext;\n\tunsigned long textlow_linear, texthigh_linear;\n\n\tif (overlaps(ptr, n, textlow, texthigh))\n\t\tusercopy_abort(\"kernel text\", NULL, to_user, ptr - textlow, n);\n\n\t/*\n\t * Some architectures have virtual memory mappings with a secondary\n\t * mapping of the kernel text, i.e. there is more than one virtual\n\t * kernel address that points to the kernel image. It is usually\n\t * when there is a separate linear physical memory mapping, in that\n\t * __pa() is not just the reverse of __va(). This can be detected\n\t * and checked:\n\t */\n\ttextlow_linear = (unsigned long)lm_alias(textlow);\n\t/* No different mapping: we're done. */\n\tif (textlow_linear == textlow)\n\t\treturn;\n\n\t/* Check the secondary mapping... */\n\ttexthigh_linear = (unsigned long)lm_alias(texthigh);\n\tif (overlaps(ptr, n, textlow_linear, texthigh_linear))\n\t\tusercopy_abort(\"linear kernel text\", NULL, to_user,\n\t\t\t       ptr - textlow_linear, n);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usercopy_abort",
          "args": [
            "\"linear kernel text\"",
            "NULL",
            "to_user",
            "ptr - textlow_linear",
            "n"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "usercopy_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "86-103",
          "snippet": "void __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "overlaps",
          "args": [
            "ptr",
            "n",
            "textlow_linear",
            "texthigh_linear"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "overlaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "106-117",
          "snippet": "static bool overlaps(const unsigned long ptr, unsigned long n,\n\t\t     unsigned long low, unsigned long high)\n{\n\tconst unsigned long check_low = ptr;\n\tunsigned long check_high = check_low + n;\n\n\t/* Does not overlap if entirely above or entirely below. */\n\tif (check_low >= high || check_high <= low)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic bool overlaps(const unsigned long ptr, unsigned long n,\n\t\t     unsigned long low, unsigned long high)\n{\n\tconst unsigned long check_low = ptr;\n\tunsigned long check_high = check_low + n;\n\n\t/* Does not overlap if entirely above or entirely below. */\n\tif (check_low >= high || check_high <= low)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lm_alias",
          "args": [
            "texthigh"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lm_alias",
          "args": [
            "textlow"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_kernel_text_object(const unsigned long ptr,\n\t\t\t\t\t    unsigned long n, bool to_user)\n{\n\tunsigned long textlow = (unsigned long)_stext;\n\tunsigned long texthigh = (unsigned long)_etext;\n\tunsigned long textlow_linear, texthigh_linear;\n\n\tif (overlaps(ptr, n, textlow, texthigh))\n\t\tusercopy_abort(\"kernel text\", NULL, to_user, ptr - textlow, n);\n\n\t/*\n\t * Some architectures have virtual memory mappings with a secondary\n\t * mapping of the kernel text, i.e. there is more than one virtual\n\t * kernel address that points to the kernel image. It is usually\n\t * when there is a separate linear physical memory mapping, in that\n\t * __pa() is not just the reverse of __va(). This can be detected\n\t * and checked:\n\t */\n\ttextlow_linear = (unsigned long)lm_alias(textlow);\n\t/* No different mapping: we're done. */\n\tif (textlow_linear == textlow)\n\t\treturn;\n\n\t/* Check the secondary mapping... */\n\ttexthigh_linear = (unsigned long)lm_alias(texthigh);\n\tif (overlaps(ptr, n, textlow_linear, texthigh_linear))\n\t\tusercopy_abort(\"linear kernel text\", NULL, to_user,\n\t\t\t       ptr - textlow_linear, n);\n}"
  },
  {
    "function_name": "overlaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
    "lines": "106-117",
    "snippet": "static bool overlaps(const unsigned long ptr, unsigned long n,\n\t\t     unsigned long low, unsigned long high)\n{\n\tconst unsigned long check_low = ptr;\n\tunsigned long check_high = check_low + n;\n\n\t/* Does not overlap if entirely above or entirely below. */\n\tif (check_low >= high || check_high <= low)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic bool overlaps(const unsigned long ptr, unsigned long n,\n\t\t     unsigned long low, unsigned long high)\n{\n\tconst unsigned long check_low = ptr;\n\tunsigned long check_high = check_low + n;\n\n\t/* Does not overlap if entirely above or entirely below. */\n\tif (check_low >= high || check_high <= low)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "usercopy_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
    "lines": "86-103",
    "snippet": "void __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\"",
            "to_user ? \"exposure\" : \"overwrite\"",
            "to_user ? \"from\" : \"to\"",
            "name ? : \"unknown?!\"",
            "detail ? \" '\" : \"\"",
            "detail ? : \"\"",
            "detail ? \"'\" : \"\"",
            "offset",
            "len"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}"
  },
  {
    "function_name": "usercopy_warn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
    "lines": "75-84",
    "snippet": "void usercopy_warn(const char *name, const char *detail, bool to_user,\n\t\t   unsigned long offset, unsigned long len)\n{\n\tWARN_ONCE(1, \"Bad or missing usercopy whitelist? Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Bad or missing usercopy whitelist? Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\"",
            "to_user ? \"exposure\" : \"overwrite\"",
            "to_user ? \"from\" : \"to\"",
            "name ? : \"unknown?!\"",
            "detail ? \" '\" : \"\"",
            "detail ? : \"\"",
            "detail ? \"'\" : \"\"",
            "offset",
            "len"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid usercopy_warn(const char *name, const char *detail, bool to_user,\n\t\t   unsigned long offset, unsigned long len)\n{\n\tWARN_ONCE(1, \"Bad or missing usercopy whitelist? Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n}"
  },
  {
    "function_name": "check_stack_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
    "lines": "37-61",
    "snippet": "static noinline int check_stack_object(const void *obj, unsigned long len)\n{\n\tconst void * const stack = task_stack_page(current);\n\tconst void * const stackend = stack + THREAD_SIZE;\n\tint ret;\n\n\t/* Object is not on the stack at all. */\n\tif (obj + len <= stack || stackend <= obj)\n\t\treturn NOT_STACK;\n\n\t/*\n\t * Reject: object partially overlaps the stack (passing the\n\t * the check above means at least one end is within the stack,\n\t * so if this check fails, the other end is outside the stack).\n\t */\n\tif (obj < stack || stackend < obj + len)\n\t\treturn BAD_STACK;\n\n\t/* Check if object is safely within a valid frame. */\n\tret = arch_within_stack_frames(stack, stackend, obj, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn GOOD_STACK;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_within_stack_frames",
          "args": [
            "stack",
            "stackend",
            "obj",
            "len"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_stack_page",
          "args": [
            "current"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic noinline int check_stack_object(const void *obj, unsigned long len)\n{\n\tconst void * const stack = task_stack_page(current);\n\tconst void * const stackend = stack + THREAD_SIZE;\n\tint ret;\n\n\t/* Object is not on the stack at all. */\n\tif (obj + len <= stack || stackend <= obj)\n\t\treturn NOT_STACK;\n\n\t/*\n\t * Reject: object partially overlaps the stack (passing the\n\t * the check above means at least one end is within the stack,\n\t * so if this check fails, the other end is outside the stack).\n\t */\n\tif (obj < stack || stackend < obj + len)\n\t\treturn BAD_STACK;\n\n\t/* Check if object is safely within a valid frame. */\n\tret = arch_within_stack_frames(stack, stackend, obj, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn GOOD_STACK;\n}"
  }
]