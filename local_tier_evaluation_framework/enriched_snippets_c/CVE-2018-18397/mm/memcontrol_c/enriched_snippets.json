[
  {
    "function_name": "mem_cgroup_swap_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6669-6679",
    "snippet": "static int __init mem_cgroup_swap_init(void)\n{\n\tif (!mem_cgroup_disabled() && really_do_swap_account) {\n\t\tdo_swap_account = 1;\n\t\tWARN_ON(cgroup_add_dfl_cftypes(&memory_cgrp_subsys,\n\t\t\t\t\t       swap_files));\n\t\tWARN_ON(cgroup_add_legacy_cftypes(&memory_cgrp_subsys,\n\t\t\t\t\t\t  memsw_cgroup_files));\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define do_swap_account\t\t0"
    ],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_add_legacy_cftypes(&memory_cgrp_subsys,\n\t\t\t\t\t\t  memsw_cgroup_files)"
          ],
          "line": 6675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_legacy_cftypes",
          "args": [
            "&memory_cgrp_subsys",
            "memsw_cgroup_files"
          ],
          "line": 6675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_add_dfl_cftypes(&memory_cgrp_subsys,\n\t\t\t\t\t       swap_files)"
          ],
          "line": 6673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_dfl_cftypes",
          "args": [
            "&memory_cgrp_subsys",
            "swap_files"
          ],
          "line": 6673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 6671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic int __init mem_cgroup_swap_init(void)\n{\n\tif (!mem_cgroup_disabled() && really_do_swap_account) {\n\t\tdo_swap_account = 1;\n\t\tWARN_ON(cgroup_add_dfl_cftypes(&memory_cgrp_subsys,\n\t\t\t\t\t       swap_files));\n\t\tWARN_ON(cgroup_add_legacy_cftypes(&memory_cgrp_subsys,\n\t\t\t\t\t\t  memsw_cgroup_files));\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "swap_events_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6609-6619",
    "snippet": "static int swap_events_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tseq_printf(m, \"max %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_SWAP_MAX]));\n\tseq_printf(m, \"fail %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_SWAP_FAIL]));\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"fail %lu\\n\"",
            "atomic_long_read(&memcg->memory_events[MEMCG_SWAP_FAIL])"
          ],
          "line": 6615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&memcg->memory_events[MEMCG_SWAP_FAIL]"
          ],
          "line": 6616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"max %lu\\n\"",
            "atomic_long_read(&memcg->memory_events[MEMCG_SWAP_MAX])"
          ],
          "line": 6613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&memcg->memory_events[MEMCG_SWAP_MAX]"
          ],
          "line": 6614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 6611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 6611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int swap_events_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tseq_printf(m, \"max %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_SWAP_MAX]));\n\tseq_printf(m, \"fail %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_SWAP_FAIL]));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "swap_max_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6592-6607",
    "snippet": "static ssize_t swap_max_write(struct kernfs_open_file *of,\n\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned long max;\n\tint err;\n\n\tbuf = strstrip(buf);\n\terr = page_counter_memparse(buf, \"max\", &max);\n\tif (err)\n\t\treturn err;\n\n\txchg(&memcg->swap.max, max);\n\n\treturn nbytes;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&memcg->swap.max",
            "max"
          ],
          "line": 6604
        },
        "resolved": true,
        "details": {
          "function_name": "page_cpupid_xchg_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "100-114",
          "snippet": "int page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_memparse",
          "args": [
            "buf",
            "\"max\"",
            "&max"
          ],
          "line": 6600
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "248-266",
          "snippet": "int page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 6599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "of_css(of)"
          ],
          "line": 6595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 6595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic ssize_t swap_max_write(struct kernfs_open_file *of,\n\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned long max;\n\tint err;\n\n\tbuf = strstrip(buf);\n\terr = page_counter_memparse(buf, \"max\", &max);\n\tif (err)\n\t\treturn err;\n\n\txchg(&memcg->swap.max, max);\n\n\treturn nbytes;\n}"
  },
  {
    "function_name": "swap_max_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6579-6590",
    "snippet": "static int swap_max_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long max = READ_ONCE(memcg->swap.max);\n\n\tif (max == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)max * PAGE_SIZE);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%llu\\n\"",
            "(u64)max * PAGE_SIZE"
          ],
          "line": 6587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"max\\n\""
          ],
          "line": 6585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "memcg->swap.max"
          ],
          "line": 6582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 6581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 6581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int swap_max_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long max = READ_ONCE(memcg->swap.max);\n\n\tif (max == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)max * PAGE_SIZE);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "swap_current_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6571-6577",
    "snippet": "static u64 swap_current_read(struct cgroup_subsys_state *css,\n\t\t\t     struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\treturn (u64)page_counter_read(&memcg->swap) * PAGE_SIZE;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->swap"
          ],
          "line": 6576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 6574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic u64 swap_current_read(struct cgroup_subsys_state *css,\n\t\t\t     struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\treturn (u64)page_counter_read(&memcg->swap) * PAGE_SIZE;\n}"
  },
  {
    "function_name": "enable_swap_account",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6561-6568",
    "snippet": "static int __init enable_swap_account(char *s)\n{\n\tif (!strcmp(s, \"1\"))\n\t\treally_do_swap_account = 1;\n\telse if (!strcmp(s, \"0\"))\n\t\treally_do_swap_account = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"0\""
          ],
          "line": 6565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"1\""
          ],
          "line": 6563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic int __init enable_swap_account(char *s)\n{\n\tif (!strcmp(s, \"1\"))\n\t\treally_do_swap_account = 1;\n\telse if (!strcmp(s, \"0\"))\n\t\treally_do_swap_account = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "mem_cgroup_swap_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6532-6552",
    "snippet": "bool mem_cgroup_swap_full(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (vm_swap_full())\n\t\treturn true;\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn false;\n\n\tmemcg = page->mem_cgroup;\n\tif (!memcg)\n\t\treturn false;\n\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tif (page_counter_read(&memcg->swap) * 2 >= memcg->swap.max)\n\t\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define do_swap_account\t\t0"
    ],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->swap"
          ],
          "line": 6548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 6547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 6540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_swap_full",
          "args": [],
          "line": 6538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 6536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 6536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nbool mem_cgroup_swap_full(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (vm_swap_full())\n\t\treturn true;\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn false;\n\n\tmemcg = page->mem_cgroup;\n\tif (!memcg)\n\t\treturn false;\n\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tif (page_counter_read(&memcg->swap) * 2 >= memcg->swap.max)\n\t\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "mem_cgroup_get_nr_swap_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6519-6530",
    "snippet": "long mem_cgroup_get_nr_swap_pages(struct mem_cgroup *memcg)\n{\n\tlong nr_swap_pages = get_nr_swap_pages();\n\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn nr_swap_pages;\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tnr_swap_pages = min_t(long, nr_swap_pages,\n\t\t\t\t      READ_ONCE(memcg->swap.max) -\n\t\t\t\t      page_counter_read(&memcg->swap));\n\treturn nr_swap_pages;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define do_swap_account\t\t0"
    ],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "long",
            "nr_swap_pages",
            "READ_ONCE(memcg->swap.max) -\n\t\t\t\t      page_counter_read(&memcg->swap)"
          ],
          "line": 6526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->swap"
          ],
          "line": 6528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "memcg->swap.max"
          ],
          "line": 6527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 6525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 6523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_swap_pages",
          "args": [],
          "line": 6521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nlong mem_cgroup_get_nr_swap_pages(struct mem_cgroup *memcg)\n{\n\tlong nr_swap_pages = get_nr_swap_pages();\n\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn nr_swap_pages;\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tnr_swap_pages = min_t(long, nr_swap_pages,\n\t\t\t\t      READ_ONCE(memcg->swap.max) -\n\t\t\t\t      page_counter_read(&memcg->swap));\n\treturn nr_swap_pages;\n}"
  },
  {
    "function_name": "mem_cgroup_uncharge_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6495-6517",
    "snippet": "void mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned short id;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tid = swap_cgroup_record(entry, 0, nr_pages);\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_id(id);\n\tif (memcg) {\n\t\tif (!mem_cgroup_is_root(memcg)) {\n\t\t\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\t\t\tpage_counter_uncharge(&memcg->swap, nr_pages);\n\t\t\telse\n\t\t\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\t\t}\n\t\tmod_memcg_state(memcg, MEMCG_SWAP, -nr_pages);\n\t\tmem_cgroup_id_put_many(memcg, nr_pages);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define do_swap_account\t\t0"
    ],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 6516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id_put_many",
          "args": [
            "memcg",
            "nr_pages"
          ],
          "line": 6514
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_put_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4305-4313",
          "snippet": "static void mem_cgroup_id_put_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\tif (refcount_sub_and_test(n, &memcg->id.ref)) {\n\t\tmem_cgroup_id_remove(memcg);\n\n\t\t/* Memcg ID pins CSS */\n\t\tcss_put(&memcg->css);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_id_put_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\tif (refcount_sub_and_test(n, &memcg->id.ref)) {\n\t\tmem_cgroup_id_remove(memcg);\n\n\t\t/* Memcg ID pins CSS */\n\t\tcss_put(&memcg->css);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_memcg_state",
          "args": [
            "memcg",
            "MEMCG_SWAP",
            "-nr_pages"
          ],
          "line": 6513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_uncharge",
          "args": [
            "&memcg->memsw",
            "nr_pages"
          ],
          "line": 6511
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "155-161",
          "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 6508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 6507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_id",
          "args": [
            "id"
          ],
          "line": 6505
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_from_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4331-4335",
          "snippet": "struct mem_cgroup *mem_cgroup_from_id(unsigned short id)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&mem_cgroup_idr, id);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static DEFINE_IDR(mem_cgroup_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\nstatic DEFINE_IDR(mem_cgroup_idr);\n\nstruct mem_cgroup *mem_cgroup_from_id(unsigned short id)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&mem_cgroup_idr, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 6504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_cgroup_record",
          "args": [
            "entry",
            "0",
            "nr_pages"
          ],
          "line": 6503
        },
        "resolved": true,
        "details": {
          "function_name": "swap_cgroup_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "126-154",
          "snippet": "unsigned short swap_cgroup_record(swp_entry_t ent, unsigned short id,\n\t\t\t\t  unsigned int nr_ents)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned short old;\n\tunsigned long flags;\n\tpgoff_t offset = swp_offset(ent);\n\tpgoff_t end = offset + nr_ents;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\told = sc->id;\n\tfor (;;) {\n\t\tVM_BUG_ON(sc->id != old);\n\t\tsc->id = id;\n\t\toffset++;\n\t\tif (offset == end)\n\t\t\tbreak;\n\t\tif (offset % SC_PER_PAGE)\n\t\t\tsc++;\n\t\telse\n\t\t\tsc = __lookup_swap_cgroup(ctrl, offset);\n\t}\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn old;\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [
            "#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))"
          ],
          "globals_used": [
            "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\n#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nunsigned short swap_cgroup_record(swp_entry_t ent, unsigned short id,\n\t\t\t\t  unsigned int nr_ents)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned short old;\n\tunsigned long flags;\n\tpgoff_t offset = swp_offset(ent);\n\tpgoff_t end = offset + nr_ents;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\told = sc->id;\n\tfor (;;) {\n\t\tVM_BUG_ON(sc->id != old);\n\t\tsc->id = id;\n\t\toffset++;\n\t\tif (offset == end)\n\t\t\tbreak;\n\t\tif (offset % SC_PER_PAGE)\n\t\t\tsc++;\n\t\telse\n\t\t\tsc = __lookup_swap_cgroup(ctrl, offset);\n\t}\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn old;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nvoid mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned short id;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tid = swap_cgroup_record(entry, 0, nr_pages);\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_id(id);\n\tif (memcg) {\n\t\tif (!mem_cgroup_is_root(memcg)) {\n\t\t\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\t\t\tpage_counter_uncharge(&memcg->swap, nr_pages);\n\t\t\telse\n\t\t\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\t\t}\n\t\tmod_memcg_state(memcg, MEMCG_SWAP, -nr_pages);\n\t\tmem_cgroup_id_put_many(memcg, nr_pages);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "mem_cgroup_try_charge_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6449-6488",
    "snippet": "int mem_cgroup_try_charge_swap(struct page *page, swp_entry_t entry)\n{\n\tunsigned int nr_pages = hpage_nr_pages(page);\n\tstruct page_counter *counter;\n\tstruct mem_cgroup *memcg;\n\tunsigned short oldid;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) || !do_swap_account)\n\t\treturn 0;\n\n\tmemcg = page->mem_cgroup;\n\n\t/* Readahead page, never charged */\n\tif (!memcg)\n\t\treturn 0;\n\n\tif (!entry.val) {\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_FAIL);\n\t\treturn 0;\n\t}\n\n\tmemcg = mem_cgroup_id_get_online(memcg);\n\n\tif (!mem_cgroup_is_root(memcg) &&\n\t    !page_counter_try_charge(&memcg->swap, nr_pages, &counter)) {\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_MAX);\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_FAIL);\n\t\tmem_cgroup_id_put(memcg);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Get references for the tail pages, too */\n\tif (nr_pages > 1)\n\t\tmem_cgroup_id_get_many(memcg, nr_pages - 1);\n\toldid = swap_cgroup_record(entry, mem_cgroup_id(memcg), nr_pages);\n\tVM_BUG_ON_PAGE(oldid, page);\n\tmod_memcg_state(memcg, MEMCG_SWAP, nr_pages);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define do_swap_account\t\t0"
    ],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_memcg_state",
          "args": [
            "memcg",
            "MEMCG_SWAP",
            "nr_pages"
          ],
          "line": 6485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "oldid",
            "page"
          ],
          "line": 6484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_cgroup_record",
          "args": [
            "entry",
            "mem_cgroup_id(memcg)",
            "nr_pages"
          ],
          "line": 6483
        },
        "resolved": true,
        "details": {
          "function_name": "swap_cgroup_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "126-154",
          "snippet": "unsigned short swap_cgroup_record(swp_entry_t ent, unsigned short id,\n\t\t\t\t  unsigned int nr_ents)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned short old;\n\tunsigned long flags;\n\tpgoff_t offset = swp_offset(ent);\n\tpgoff_t end = offset + nr_ents;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\told = sc->id;\n\tfor (;;) {\n\t\tVM_BUG_ON(sc->id != old);\n\t\tsc->id = id;\n\t\toffset++;\n\t\tif (offset == end)\n\t\t\tbreak;\n\t\tif (offset % SC_PER_PAGE)\n\t\t\tsc++;\n\t\telse\n\t\t\tsc = __lookup_swap_cgroup(ctrl, offset);\n\t}\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn old;\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [
            "#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))"
          ],
          "globals_used": [
            "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\n#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nunsigned short swap_cgroup_record(swp_entry_t ent, unsigned short id,\n\t\t\t\t  unsigned int nr_ents)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned short old;\n\tunsigned long flags;\n\tpgoff_t offset = swp_offset(ent);\n\tpgoff_t end = offset + nr_ents;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\told = sc->id;\n\tfor (;;) {\n\t\tVM_BUG_ON(sc->id != old);\n\t\tsc->id = id;\n\t\toffset++;\n\t\tif (offset == end)\n\t\t\tbreak;\n\t\tif (offset % SC_PER_PAGE)\n\t\t\tsc++;\n\t\telse\n\t\t\tsc = __lookup_swap_cgroup(ctrl, offset);\n\t}\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id",
          "args": [
            "memcg"
          ],
          "line": 6483
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_get_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6356-6372",
          "snippet": "static struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id_get_many",
          "args": [
            "memcg",
            "nr_pages - 1"
          ],
          "line": 6482
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_get_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4300-4303",
          "snippet": "static void mem_cgroup_id_get_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\trefcount_add(n, &memcg->id.ref);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_id_get_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\trefcount_add(n, &memcg->id.ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id_put",
          "args": [
            "memcg"
          ],
          "line": 6476
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4320-4323",
          "snippet": "static inline void mem_cgroup_id_put(struct mem_cgroup *memcg)\n{\n\tmem_cgroup_id_put_many(memcg, 1);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic inline void mem_cgroup_id_put(struct mem_cgroup *memcg)\n{\n\tmem_cgroup_id_put_many(memcg, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_memory_event",
          "args": [
            "memcg",
            "MEMCG_SWAP_FAIL"
          ],
          "line": 6475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_memory_event",
          "args": [
            "memcg",
            "MEMCG_SWAP_MAX"
          ],
          "line": 6474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_try_charge",
          "args": [
            "&memcg->swap",
            "nr_pages",
            "&counter"
          ],
          "line": 6473
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_try_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "99-148",
          "snippet": "bool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nbool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 6472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_memory_event",
          "args": [
            "memcg",
            "MEMCG_SWAP_FAIL"
          ],
          "line": 6466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 6456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 6451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nint mem_cgroup_try_charge_swap(struct page *page, swp_entry_t entry)\n{\n\tunsigned int nr_pages = hpage_nr_pages(page);\n\tstruct page_counter *counter;\n\tstruct mem_cgroup *memcg;\n\tunsigned short oldid;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) || !do_swap_account)\n\t\treturn 0;\n\n\tmemcg = page->mem_cgroup;\n\n\t/* Readahead page, never charged */\n\tif (!memcg)\n\t\treturn 0;\n\n\tif (!entry.val) {\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_FAIL);\n\t\treturn 0;\n\t}\n\n\tmemcg = mem_cgroup_id_get_online(memcg);\n\n\tif (!mem_cgroup_is_root(memcg) &&\n\t    !page_counter_try_charge(&memcg->swap, nr_pages, &counter)) {\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_MAX);\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_FAIL);\n\t\tmem_cgroup_id_put(memcg);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Get references for the tail pages, too */\n\tif (nr_pages > 1)\n\t\tmem_cgroup_id_get_many(memcg, nr_pages - 1);\n\toldid = swap_cgroup_record(entry, mem_cgroup_id(memcg), nr_pages);\n\tVM_BUG_ON_PAGE(oldid, page);\n\tmod_memcg_state(memcg, MEMCG_SWAP, nr_pages);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_swapout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6381-6438",
    "snippet": "void mem_cgroup_swapout(struct page *page, swp_entry_t entry)\n{\n\tstruct mem_cgroup *memcg, *swap_memcg;\n\tunsigned int nr_entries;\n\tunsigned short oldid;\n\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\n\tif (!do_memsw_account())\n\t\treturn;\n\n\tmemcg = page->mem_cgroup;\n\n\t/* Readahead page, never charged */\n\tif (!memcg)\n\t\treturn;\n\n\t/*\n\t * In case the memcg owning these pages has been offlined and doesn't\n\t * have an ID allocated to it anymore, charge the closest online\n\t * ancestor for the swap instead and transfer the memory+swap charge.\n\t */\n\tswap_memcg = mem_cgroup_id_get_online(memcg);\n\tnr_entries = hpage_nr_pages(page);\n\t/* Get references for the tail pages, too */\n\tif (nr_entries > 1)\n\t\tmem_cgroup_id_get_many(swap_memcg, nr_entries - 1);\n\toldid = swap_cgroup_record(entry, mem_cgroup_id(swap_memcg),\n\t\t\t\t   nr_entries);\n\tVM_BUG_ON_PAGE(oldid, page);\n\tmod_memcg_state(swap_memcg, MEMCG_SWAP, nr_entries);\n\n\tpage->mem_cgroup = NULL;\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\tpage_counter_uncharge(&memcg->memory, nr_entries);\n\n\tif (memcg != swap_memcg) {\n\t\tif (!mem_cgroup_is_root(swap_memcg))\n\t\t\tpage_counter_charge(&swap_memcg->memsw, nr_entries);\n\t\tpage_counter_uncharge(&memcg->memsw, nr_entries);\n\t}\n\n\t/*\n\t * Interrupts should be disabled here because the caller holds the\n\t * i_pages lock which is taken with interrupts-off. It is\n\t * important here to have the interrupts disabled because it is the\n\t * only synchronisation we have for updating the per-CPU variables.\n\t */\n\tVM_BUG_ON(!irqs_disabled());\n\tmem_cgroup_charge_statistics(memcg, page, PageTransHuge(page),\n\t\t\t\t     -nr_entries);\n\tmemcg_check_events(memcg, page);\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\tcss_put_many(&memcg->css, nr_entries);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put_many",
          "args": [
            "&memcg->css",
            "nr_entries"
          ],
          "line": 6437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 6436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_check_events",
          "args": [
            "memcg",
            "page"
          ],
          "line": 6434
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_check_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "781-803",
          "snippet": "static void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_charge_statistics",
          "args": [
            "memcg",
            "page",
            "PageTransHuge(page)",
            "-nr_entries"
          ],
          "line": 6432
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_charge_statistics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "689-719",
          "snippet": "static void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t bool compound, int nr_pages)\n{\n\t/*\n\t * Here, RSS means 'mapped anon' and anon's SwapCache. Shmem/tmpfs is\n\t * counted as CACHE even if it's on ANON LRU.\n\t */\n\tif (PageAnon(page))\n\t\t__mod_memcg_state(memcg, MEMCG_RSS, nr_pages);\n\telse {\n\t\t__mod_memcg_state(memcg, MEMCG_CACHE, nr_pages);\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_memcg_state(memcg, NR_SHMEM, nr_pages);\n\t}\n\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t__mod_memcg_state(memcg, MEMCG_RSS_HUGE, nr_pages);\n\t}\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__count_memcg_events(memcg, PGPGIN, 1);\n\telse {\n\t\t__count_memcg_events(memcg, PGPGOUT, 1);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat_cpu->nr_page_events, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t bool compound, int nr_pages)\n{\n\t/*\n\t * Here, RSS means 'mapped anon' and anon's SwapCache. Shmem/tmpfs is\n\t * counted as CACHE even if it's on ANON LRU.\n\t */\n\tif (PageAnon(page))\n\t\t__mod_memcg_state(memcg, MEMCG_RSS, nr_pages);\n\telse {\n\t\t__mod_memcg_state(memcg, MEMCG_CACHE, nr_pages);\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_memcg_state(memcg, NR_SHMEM, nr_pages);\n\t}\n\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t__mod_memcg_state(memcg, MEMCG_RSS_HUGE, nr_pages);\n\t}\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__count_memcg_events(memcg, PGPGIN, 1);\n\telse {\n\t\t__count_memcg_events(memcg, PGPGOUT, 1);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat_cpu->nr_page_events, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 6432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 6431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 6431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_uncharge",
          "args": [
            "&memcg->memsw",
            "nr_entries"
          ],
          "line": 6422
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "155-161",
          "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_charge",
          "args": [
            "&swap_memcg->memsw",
            "nr_entries"
          ],
          "line": 6421
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "72-88",
          "snippet": "void page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "swap_memcg"
          ],
          "line": 6420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 6416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_memcg_state",
          "args": [
            "swap_memcg",
            "MEMCG_SWAP",
            "nr_entries"
          ],
          "line": 6412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "oldid",
            "page"
          ],
          "line": 6411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_cgroup_record",
          "args": [
            "entry",
            "mem_cgroup_id(swap_memcg)",
            "nr_entries"
          ],
          "line": 6409
        },
        "resolved": true,
        "details": {
          "function_name": "swap_cgroup_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "126-154",
          "snippet": "unsigned short swap_cgroup_record(swp_entry_t ent, unsigned short id,\n\t\t\t\t  unsigned int nr_ents)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned short old;\n\tunsigned long flags;\n\tpgoff_t offset = swp_offset(ent);\n\tpgoff_t end = offset + nr_ents;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\told = sc->id;\n\tfor (;;) {\n\t\tVM_BUG_ON(sc->id != old);\n\t\tsc->id = id;\n\t\toffset++;\n\t\tif (offset == end)\n\t\t\tbreak;\n\t\tif (offset % SC_PER_PAGE)\n\t\t\tsc++;\n\t\telse\n\t\t\tsc = __lookup_swap_cgroup(ctrl, offset);\n\t}\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn old;\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [
            "#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))"
          ],
          "globals_used": [
            "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\n#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nunsigned short swap_cgroup_record(swp_entry_t ent, unsigned short id,\n\t\t\t\t  unsigned int nr_ents)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned short old;\n\tunsigned long flags;\n\tpgoff_t offset = swp_offset(ent);\n\tpgoff_t end = offset + nr_ents;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\told = sc->id;\n\tfor (;;) {\n\t\tVM_BUG_ON(sc->id != old);\n\t\tsc->id = id;\n\t\toffset++;\n\t\tif (offset == end)\n\t\t\tbreak;\n\t\tif (offset % SC_PER_PAGE)\n\t\t\tsc++;\n\t\telse\n\t\t\tsc = __lookup_swap_cgroup(ctrl, offset);\n\t}\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id",
          "args": [
            "swap_memcg"
          ],
          "line": 6409
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_get_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6356-6372",
          "snippet": "static struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id_get_many",
          "args": [
            "swap_memcg",
            "nr_entries - 1"
          ],
          "line": 6408
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_get_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4300-4303",
          "snippet": "static void mem_cgroup_id_get_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\trefcount_add(n, &memcg->id.ref);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_id_get_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\trefcount_add(n, &memcg->id.ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 6405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 6390
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_count(page)",
            "page"
          ],
          "line": 6388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 6388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 6387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 6387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_swapout(struct page *page, swp_entry_t entry)\n{\n\tstruct mem_cgroup *memcg, *swap_memcg;\n\tunsigned int nr_entries;\n\tunsigned short oldid;\n\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\n\tif (!do_memsw_account())\n\t\treturn;\n\n\tmemcg = page->mem_cgroup;\n\n\t/* Readahead page, never charged */\n\tif (!memcg)\n\t\treturn;\n\n\t/*\n\t * In case the memcg owning these pages has been offlined and doesn't\n\t * have an ID allocated to it anymore, charge the closest online\n\t * ancestor for the swap instead and transfer the memory+swap charge.\n\t */\n\tswap_memcg = mem_cgroup_id_get_online(memcg);\n\tnr_entries = hpage_nr_pages(page);\n\t/* Get references for the tail pages, too */\n\tif (nr_entries > 1)\n\t\tmem_cgroup_id_get_many(swap_memcg, nr_entries - 1);\n\toldid = swap_cgroup_record(entry, mem_cgroup_id(swap_memcg),\n\t\t\t\t   nr_entries);\n\tVM_BUG_ON_PAGE(oldid, page);\n\tmod_memcg_state(swap_memcg, MEMCG_SWAP, nr_entries);\n\n\tpage->mem_cgroup = NULL;\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\tpage_counter_uncharge(&memcg->memory, nr_entries);\n\n\tif (memcg != swap_memcg) {\n\t\tif (!mem_cgroup_is_root(swap_memcg))\n\t\t\tpage_counter_charge(&swap_memcg->memsw, nr_entries);\n\t\tpage_counter_uncharge(&memcg->memsw, nr_entries);\n\t}\n\n\t/*\n\t * Interrupts should be disabled here because the caller holds the\n\t * i_pages lock which is taken with interrupts-off. It is\n\t * important here to have the interrupts disabled because it is the\n\t * only synchronisation we have for updating the per-CPU variables.\n\t */\n\tVM_BUG_ON(!irqs_disabled());\n\tmem_cgroup_charge_statistics(memcg, page, PageTransHuge(page),\n\t\t\t\t     -nr_entries);\n\tmemcg_check_events(memcg, page);\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\tcss_put_many(&memcg->css, nr_entries);\n}"
  },
  {
    "function_name": "mem_cgroup_id_get_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6356-6372",
    "snippet": "static struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 6367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "1"
          ],
          "line": 6364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "memcg == root_mem_cgroup"
          ],
          "line": 6363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_inc_not_zero",
          "args": [
            "&memcg->id.ref"
          ],
          "line": 6358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}"
  },
  {
    "function_name": "mem_cgroup_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6317-6352",
    "snippet": "static int __init mem_cgroup_init(void)\n{\n\tint cpu, node;\n\n#ifdef CONFIG_MEMCG_KMEM\n\t/*\n\t * Kmem cache creation is mostly done with the slab_mutex held,\n\t * so use a workqueue with limited concurrency to avoid stalling\n\t * all worker threads in case lots of cgroups are created and\n\t * destroyed simultaneously.\n\t */\n\tmemcg_kmem_cache_wq = alloc_workqueue(\"memcg_kmem_cache\", 0, 1);\n\tBUG_ON(!memcg_kmem_cache_wq);\n#endif\n\n\tcpuhp_setup_state_nocalls(CPUHP_MM_MEMCQ_DEAD, \"mm/memctrl:dead\", NULL,\n\t\t\t\t  memcg_hotplug_cpu_dead);\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_WORK(&per_cpu_ptr(&memcg_stock, cpu)->work,\n\t\t\t  drain_local_stock);\n\n\tfor_each_node(node) {\n\t\tstruct mem_cgroup_tree_per_node *rtpn;\n\n\t\trtpn = kzalloc_node(sizeof(*rtpn), GFP_KERNEL,\n\t\t\t\t    node_online(node) ? node : NUMA_NO_NODE);\n\n\t\trtpn->rb_root = RB_ROOT;\n\t\trtpn->rb_rightmost = NULL;\n\t\tspin_lock_init(&rtpn->lock);\n\t\tsoft_limit_tree.rb_tree_per_node[node] = rtpn;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mem_cgroup_tree soft_limit_tree",
      "static __always_inline struct",
      "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&rtpn->lock"
          ],
          "line": 6347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*rtpn)",
            "GFP_KERNEL",
            "node_online(node) ? node : NUMA_NO_NODE"
          ],
          "line": 6342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "node"
          ],
          "line": 6343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&memcg_stock",
            "cpu"
          ],
          "line": 6336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_MM_MEMCQ_DEAD",
            "\"mm/memctrl:dead\"",
            "NULL",
            "memcg_hotplug_cpu_dead"
          ],
          "line": 6332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!memcg_kmem_cache_wq"
          ],
          "line": 6329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"memcg_kmem_cache\"",
            "0",
            "1"
          ],
          "line": 6328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct mem_cgroup_tree soft_limit_tree;\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\n\nstatic int __init mem_cgroup_init(void)\n{\n\tint cpu, node;\n\n#ifdef CONFIG_MEMCG_KMEM\n\t/*\n\t * Kmem cache creation is mostly done with the slab_mutex held,\n\t * so use a workqueue with limited concurrency to avoid stalling\n\t * all worker threads in case lots of cgroups are created and\n\t * destroyed simultaneously.\n\t */\n\tmemcg_kmem_cache_wq = alloc_workqueue(\"memcg_kmem_cache\", 0, 1);\n\tBUG_ON(!memcg_kmem_cache_wq);\n#endif\n\n\tcpuhp_setup_state_nocalls(CPUHP_MM_MEMCQ_DEAD, \"mm/memctrl:dead\", NULL,\n\t\t\t\t  memcg_hotplug_cpu_dead);\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_WORK(&per_cpu_ptr(&memcg_stock, cpu)->work,\n\t\t\t  drain_local_stock);\n\n\tfor_each_node(node) {\n\t\tstruct mem_cgroup_tree_per_node *rtpn;\n\n\t\trtpn = kzalloc_node(sizeof(*rtpn), GFP_KERNEL,\n\t\t\t\t    node_online(node) ? node : NUMA_NO_NODE);\n\n\t\trtpn->rb_root = RB_ROOT;\n\t\trtpn->rb_rightmost = NULL;\n\t\tspin_lock_init(&rtpn->lock);\n\t\tsoft_limit_tree.rb_tree_per_node[node] = rtpn;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6293-6306",
    "snippet": "static int __init cgroup_memory(char *s)\n{\n\tchar *token;\n\n\twhile ((token = strsep(&s, \",\")) != NULL) {\n\t\tif (!*token)\n\t\t\tcontinue;\n\t\tif (!strcmp(token, \"nosocket\"))\n\t\t\tcgroup_memory_nosocket = true;\n\t\tif (!strcmp(token, \"nokmem\"))\n\t\t\tcgroup_memory_nokmem = true;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool cgroup_memory_nosocket;",
      "static bool cgroup_memory_nokmem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "token",
            "\"nokmem\""
          ],
          "line": 6302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "token",
            "\"nosocket\""
          ],
          "line": 6300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&s",
            "\",\""
          ],
          "line": 6297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic bool cgroup_memory_nosocket;\nstatic bool cgroup_memory_nokmem;\n\nstatic int __init cgroup_memory(char *s)\n{\n\tchar *token;\n\n\twhile ((token = strsep(&s, \",\")) != NULL) {\n\t\tif (!*token)\n\t\t\tcontinue;\n\t\tif (!strcmp(token, \"nosocket\"))\n\t\t\tcgroup_memory_nosocket = true;\n\t\tif (!strcmp(token, \"nokmem\"))\n\t\t\tcgroup_memory_nokmem = true;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_uncharge_skmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6281-6291",
    "snippet": "void mem_cgroup_uncharge_skmem(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys)) {\n\t\tpage_counter_uncharge(&memcg->tcpmem, nr_pages);\n\t\treturn;\n\t}\n\n\tmod_memcg_state(memcg, MEMCG_SOCK, -nr_pages);\n\n\trefill_stock(memcg, nr_pages);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "refill_stock",
          "args": [
            "memcg",
            "nr_pages"
          ],
          "line": 6290
        },
        "resolved": true,
        "details": {
          "function_name": "refill_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2004-2022",
          "snippet": "static void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tif (stock->cached != memcg) { /* reset if necessary */\n\t\tdrain_stock(stock);\n\t\tstock->cached = memcg;\n\t}\n\tstock->nr_pages += nr_pages;\n\n\tif (stock->nr_pages > MEMCG_CHARGE_BATCH)\n\t\tdrain_stock(stock);\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\n\nstatic void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tif (stock->cached != memcg) { /* reset if necessary */\n\t\tdrain_stock(stock);\n\t\tstock->cached = memcg;\n\t}\n\tstock->nr_pages += nr_pages;\n\n\tif (stock->nr_pages > MEMCG_CHARGE_BATCH)\n\t\tdrain_stock(stock);\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_memcg_state",
          "args": [
            "memcg",
            "MEMCG_SOCK",
            "-nr_pages"
          ],
          "line": 6288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_uncharge",
          "args": [
            "&memcg->tcpmem",
            "nr_pages"
          ],
          "line": 6284
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "155-161",
          "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 6283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nvoid mem_cgroup_uncharge_skmem(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys)) {\n\t\tpage_counter_uncharge(&memcg->tcpmem, nr_pages);\n\t\treturn;\n\t}\n\n\tmod_memcg_state(memcg, MEMCG_SOCK, -nr_pages);\n\n\trefill_stock(memcg, nr_pages);\n}"
  },
  {
    "function_name": "mem_cgroup_charge_skmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6247-6274",
    "snippet": "bool mem_cgroup_charge_skmem(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tgfp_t gfp_mask = GFP_KERNEL;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys)) {\n\t\tstruct page_counter *fail;\n\n\t\tif (page_counter_try_charge(&memcg->tcpmem, nr_pages, &fail)) {\n\t\t\tmemcg->tcpmem_pressure = 0;\n\t\t\treturn true;\n\t\t}\n\t\tpage_counter_charge(&memcg->tcpmem, nr_pages);\n\t\tmemcg->tcpmem_pressure = 1;\n\t\treturn false;\n\t}\n\n\t/* Don't block in the packet receive path */\n\tif (in_softirq())\n\t\tgfp_mask = GFP_NOWAIT;\n\n\tmod_memcg_state(memcg, MEMCG_SOCK, nr_pages);\n\n\tif (try_charge(memcg, gfp_mask, nr_pages) == 0)\n\t\treturn true;\n\n\ttry_charge(memcg, gfp_mask|__GFP_NOFAIL, nr_pages);\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_charge",
          "args": [
            "memcg",
            "gfp_mask|__GFP_NOFAIL",
            "nr_pages"
          ],
          "line": 6272
        },
        "resolved": true,
        "details": {
          "function_name": "try_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2147-2316",
          "snippet": "static int try_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t      unsigned int nr_pages)\n{\n\tunsigned int batch = max(MEMCG_CHARGE_BATCH, nr_pages);\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct page_counter *counter;\n\tunsigned long nr_reclaimed;\n\tbool may_swap = true;\n\tbool drained = false;\n\tbool oomed = false;\n\tenum oom_status oom_status;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\nretry:\n\tif (consume_stock(memcg, nr_pages))\n\t\treturn 0;\n\n\tif (!do_memsw_account() ||\n\t    page_counter_try_charge(&memcg->memsw, batch, &counter)) {\n\t\tif (page_counter_try_charge(&memcg->memory, batch, &counter))\n\t\t\tgoto done_restock;\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&memcg->memsw, batch);\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memory);\n\t} else {\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memsw);\n\t\tmay_swap = false;\n\t}\n\n\tif (batch > nr_pages) {\n\t\tbatch = nr_pages;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Unlike in global OOM situations, memcg is not in a physical\n\t * memory shortage.  Allow dying and OOM-killed tasks to\n\t * bypass the last charges so that they can exit quickly and\n\t * free their memory.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current) ||\n\t\t     fatal_signal_pending(current) ||\n\t\t     current->flags & PF_EXITING))\n\t\tgoto force;\n\n\t/*\n\t * Prevent unbounded recursion when reclaim operations need to\n\t * allocate memory. This might exceed the limits temporarily,\n\t * but we prefer facilitating memory reclaim and getting back\n\t * under the limit over triggering OOM kills in these cases.\n\t */\n\tif (unlikely(current->flags & PF_MEMALLOC))\n\t\tgoto force;\n\n\tif (unlikely(task_in_memcg_oom(current)))\n\t\tgoto nomem;\n\n\tif (!gfpflags_allow_blocking(gfp_mask))\n\t\tgoto nomem;\n\n\tmemcg_memory_event(mem_over_limit, MEMCG_MAX);\n\n\tnr_reclaimed = try_to_free_mem_cgroup_pages(mem_over_limit, nr_pages,\n\t\t\t\t\t\t    gfp_mask, may_swap);\n\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\tgoto retry;\n\n\tif (!drained) {\n\t\tdrain_all_stock(mem_over_limit);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nomem;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_reclaimed && nr_pages <= (1 << PAGE_ALLOC_COSTLY_ORDER))\n\t\tgoto retry;\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\tgoto retry;\n\n\tif (nr_retries--)\n\t\tgoto retry;\n\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL && oomed)\n\t\tgoto nomem;\n\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\tgoto force;\n\n\tif (fatal_signal_pending(current))\n\t\tgoto force;\n\n\t/*\n\t * keep retrying as long as the memcg oom killer is able to make\n\t * a forward progress or bypass the charge if the oom killer\n\t * couldn't make any progress.\n\t */\n\toom_status = mem_cgroup_oom(mem_over_limit, gfp_mask,\n\t\t       get_order(nr_pages * PAGE_SIZE));\n\tswitch (oom_status) {\n\tcase OOM_SUCCESS:\n\t\tnr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\toomed = true;\n\t\tgoto retry;\n\tcase OOM_FAILED:\n\t\tgoto force;\n\tdefault:\n\t\tgoto nomem;\n\t}\nnomem:\n\tif (!(gfp_mask & __GFP_NOFAIL))\n\t\treturn -ENOMEM;\nforce:\n\t/*\n\t * The allocation either can't fail or will lead to more memory\n\t * being freed very soon.  Allow memory usage go over the limit\n\t * temporarily by force charging it.\n\t */\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\treturn 0;\n\ndone_restock:\n\tcss_get_many(&memcg->css, batch);\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\n\t/*\n\t * If the hierarchy is above the normal consumption range, schedule\n\t * reclaim on returning to userland.  We can perform reclaim here\n\t * if __GFP_RECLAIM but let's always punt for simplicity and so that\n\t * GFP_KERNEL can consistently be used during reclaim.  @memcg is\n\t * not recorded as it most likely matches current's and won't\n\t * change in the meantime.  As high limit is checked again before\n\t * reclaim, the cost of mismatch is negligible.\n\t */\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) > memcg->high) {\n\t\t\t/* Don't bother a random interrupted task */\n\t\t\tif (in_interrupt()) {\n\t\t\t\tschedule_work(&memcg->high_work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->memcg_nr_pages_over_high += batch;\n\t\t\tset_notify_resume(current);\n\t\t\tbreak;\n\t\t}\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define MEM_CGROUP_RECLAIM_RETRIES\t5"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MEM_CGROUP_RECLAIM_RETRIES\t5\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int try_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t      unsigned int nr_pages)\n{\n\tunsigned int batch = max(MEMCG_CHARGE_BATCH, nr_pages);\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct page_counter *counter;\n\tunsigned long nr_reclaimed;\n\tbool may_swap = true;\n\tbool drained = false;\n\tbool oomed = false;\n\tenum oom_status oom_status;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\nretry:\n\tif (consume_stock(memcg, nr_pages))\n\t\treturn 0;\n\n\tif (!do_memsw_account() ||\n\t    page_counter_try_charge(&memcg->memsw, batch, &counter)) {\n\t\tif (page_counter_try_charge(&memcg->memory, batch, &counter))\n\t\t\tgoto done_restock;\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&memcg->memsw, batch);\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memory);\n\t} else {\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memsw);\n\t\tmay_swap = false;\n\t}\n\n\tif (batch > nr_pages) {\n\t\tbatch = nr_pages;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Unlike in global OOM situations, memcg is not in a physical\n\t * memory shortage.  Allow dying and OOM-killed tasks to\n\t * bypass the last charges so that they can exit quickly and\n\t * free their memory.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current) ||\n\t\t     fatal_signal_pending(current) ||\n\t\t     current->flags & PF_EXITING))\n\t\tgoto force;\n\n\t/*\n\t * Prevent unbounded recursion when reclaim operations need to\n\t * allocate memory. This might exceed the limits temporarily,\n\t * but we prefer facilitating memory reclaim and getting back\n\t * under the limit over triggering OOM kills in these cases.\n\t */\n\tif (unlikely(current->flags & PF_MEMALLOC))\n\t\tgoto force;\n\n\tif (unlikely(task_in_memcg_oom(current)))\n\t\tgoto nomem;\n\n\tif (!gfpflags_allow_blocking(gfp_mask))\n\t\tgoto nomem;\n\n\tmemcg_memory_event(mem_over_limit, MEMCG_MAX);\n\n\tnr_reclaimed = try_to_free_mem_cgroup_pages(mem_over_limit, nr_pages,\n\t\t\t\t\t\t    gfp_mask, may_swap);\n\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\tgoto retry;\n\n\tif (!drained) {\n\t\tdrain_all_stock(mem_over_limit);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nomem;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_reclaimed && nr_pages <= (1 << PAGE_ALLOC_COSTLY_ORDER))\n\t\tgoto retry;\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\tgoto retry;\n\n\tif (nr_retries--)\n\t\tgoto retry;\n\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL && oomed)\n\t\tgoto nomem;\n\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\tgoto force;\n\n\tif (fatal_signal_pending(current))\n\t\tgoto force;\n\n\t/*\n\t * keep retrying as long as the memcg oom killer is able to make\n\t * a forward progress or bypass the charge if the oom killer\n\t * couldn't make any progress.\n\t */\n\toom_status = mem_cgroup_oom(mem_over_limit, gfp_mask,\n\t\t       get_order(nr_pages * PAGE_SIZE));\n\tswitch (oom_status) {\n\tcase OOM_SUCCESS:\n\t\tnr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\toomed = true;\n\t\tgoto retry;\n\tcase OOM_FAILED:\n\t\tgoto force;\n\tdefault:\n\t\tgoto nomem;\n\t}\nnomem:\n\tif (!(gfp_mask & __GFP_NOFAIL))\n\t\treturn -ENOMEM;\nforce:\n\t/*\n\t * The allocation either can't fail or will lead to more memory\n\t * being freed very soon.  Allow memory usage go over the limit\n\t * temporarily by force charging it.\n\t */\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\treturn 0;\n\ndone_restock:\n\tcss_get_many(&memcg->css, batch);\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\n\t/*\n\t * If the hierarchy is above the normal consumption range, schedule\n\t * reclaim on returning to userland.  We can perform reclaim here\n\t * if __GFP_RECLAIM but let's always punt for simplicity and so that\n\t * GFP_KERNEL can consistently be used during reclaim.  @memcg is\n\t * not recorded as it most likely matches current's and won't\n\t * change in the meantime.  As high limit is checked again before\n\t * reclaim, the cost of mismatch is negligible.\n\t */\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) > memcg->high) {\n\t\t\t/* Don't bother a random interrupted task */\n\t\t\tif (in_interrupt()) {\n\t\t\t\tschedule_work(&memcg->high_work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->memcg_nr_pages_over_high += batch;\n\t\t\tset_notify_resume(current);\n\t\t\tbreak;\n\t\t}\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_memcg_state",
          "args": [
            "memcg",
            "MEMCG_SOCK",
            "nr_pages"
          ],
          "line": 6267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_softirq",
          "args": [],
          "line": 6264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_charge",
          "args": [
            "&memcg->tcpmem",
            "nr_pages"
          ],
          "line": 6258
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "72-88",
          "snippet": "void page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_try_charge",
          "args": [
            "&memcg->tcpmem",
            "nr_pages",
            "&fail"
          ],
          "line": 6254
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_try_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "99-148",
          "snippet": "bool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nbool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 6251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nbool mem_cgroup_charge_skmem(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tgfp_t gfp_mask = GFP_KERNEL;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys)) {\n\t\tstruct page_counter *fail;\n\n\t\tif (page_counter_try_charge(&memcg->tcpmem, nr_pages, &fail)) {\n\t\t\tmemcg->tcpmem_pressure = 0;\n\t\t\treturn true;\n\t\t}\n\t\tpage_counter_charge(&memcg->tcpmem, nr_pages);\n\t\tmemcg->tcpmem_pressure = 1;\n\t\treturn false;\n\t}\n\n\t/* Don't block in the packet receive path */\n\tif (in_softirq())\n\t\tgfp_mask = GFP_NOWAIT;\n\n\tmod_memcg_state(memcg, MEMCG_SOCK, nr_pages);\n\n\tif (try_charge(memcg, gfp_mask, nr_pages) == 0)\n\t\treturn true;\n\n\ttry_charge(memcg, gfp_mask|__GFP_NOFAIL, nr_pages);\n\treturn false;\n}"
  },
  {
    "function_name": "mem_cgroup_sk_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6233-6237",
    "snippet": "void mem_cgroup_sk_free(struct sock *sk)\n{\n\tif (sk->sk_memcg)\n\t\tcss_put(&sk->sk_memcg->css);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&sk->sk_memcg->css"
          ],
          "line": 6236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_sk_free(struct sock *sk)\n{\n\tif (sk->sk_memcg)\n\t\tcss_put(&sk->sk_memcg->css);\n}"
  },
  {
    "function_name": "mem_cgroup_sk_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6200-6231",
    "snippet": "void mem_cgroup_sk_alloc(struct sock *sk)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (!mem_cgroup_sockets_enabled)\n\t\treturn;\n\n\t/*\n\t * Socket cloning can throw us here with sk_memcg already\n\t * filled. It won't however, necessarily happen from\n\t * process context. So the test for root memcg given\n\t * the current task's memcg won't help us in this case.\n\t *\n\t * Respecting the original socket's memcg is a better\n\t * decision in this case.\n\t */\n\tif (sk->sk_memcg) {\n\t\tcss_get(&sk->sk_memcg->css);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_task(current);\n\tif (memcg == root_mem_cgroup)\n\t\tgoto out;\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && !memcg->tcpmem_active)\n\t\tgoto out;\n\tif (css_tryget_online(&memcg->css))\n\t\tsk->sk_memcg = memcg;\nout:\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 6230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "&memcg->css"
          ],
          "line": 6227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 6225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_task",
          "args": [
            "current"
          ],
          "line": 6222
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_from_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "805-816",
          "snippet": "struct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 6221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "&sk->sk_memcg->css"
          ],
          "line": 6217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nvoid mem_cgroup_sk_alloc(struct sock *sk)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (!mem_cgroup_sockets_enabled)\n\t\treturn;\n\n\t/*\n\t * Socket cloning can throw us here with sk_memcg already\n\t * filled. It won't however, necessarily happen from\n\t * process context. So the test for root memcg given\n\t * the current task's memcg won't help us in this case.\n\t *\n\t * Respecting the original socket's memcg is a better\n\t * decision in this case.\n\t */\n\tif (sk->sk_memcg) {\n\t\tcss_get(&sk->sk_memcg->css);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_task(current);\n\tif (memcg == root_mem_cgroup)\n\t\tgoto out;\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && !memcg->tcpmem_active)\n\t\tgoto out;\n\tif (css_tryget_online(&memcg->css))\n\t\tsk->sk_memcg = memcg;\nout:\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "mem_cgroup_migrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6155-6195",
    "snippet": "void mem_cgroup_migrate(struct page *oldpage, struct page *newpage)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned int nr_pages;\n\tbool compound;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageLocked(oldpage), oldpage);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageAnon(oldpage) != PageAnon(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageTransHuge(oldpage) != PageTransHuge(newpage),\n\t\t       newpage);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\t/* Page cache replacement: new page already charged? */\n\tif (newpage->mem_cgroup)\n\t\treturn;\n\n\t/* Swapcache readahead pages can get replaced before being charged */\n\tmemcg = oldpage->mem_cgroup;\n\tif (!memcg)\n\t\treturn;\n\n\t/* Force-charge the new page. The old one will be freed soon */\n\tcompound = PageTransHuge(newpage);\n\tnr_pages = compound ? hpage_nr_pages(newpage) : 1;\n\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\tcommit_charge(newpage, memcg, false);\n\n\tlocal_irq_save(flags);\n\tmem_cgroup_charge_statistics(memcg, newpage, compound, nr_pages);\n\tmemcg_check_events(memcg, newpage);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 6194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_check_events",
          "args": [
            "memcg",
            "newpage"
          ],
          "line": 6193
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_check_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "781-803",
          "snippet": "static void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_charge_statistics",
          "args": [
            "memcg",
            "newpage",
            "compound",
            "nr_pages"
          ],
          "line": 6192
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_charge_statistics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "689-719",
          "snippet": "static void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t bool compound, int nr_pages)\n{\n\t/*\n\t * Here, RSS means 'mapped anon' and anon's SwapCache. Shmem/tmpfs is\n\t * counted as CACHE even if it's on ANON LRU.\n\t */\n\tif (PageAnon(page))\n\t\t__mod_memcg_state(memcg, MEMCG_RSS, nr_pages);\n\telse {\n\t\t__mod_memcg_state(memcg, MEMCG_CACHE, nr_pages);\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_memcg_state(memcg, NR_SHMEM, nr_pages);\n\t}\n\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t__mod_memcg_state(memcg, MEMCG_RSS_HUGE, nr_pages);\n\t}\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__count_memcg_events(memcg, PGPGIN, 1);\n\telse {\n\t\t__count_memcg_events(memcg, PGPGOUT, 1);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat_cpu->nr_page_events, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t bool compound, int nr_pages)\n{\n\t/*\n\t * Here, RSS means 'mapped anon' and anon's SwapCache. Shmem/tmpfs is\n\t * counted as CACHE even if it's on ANON LRU.\n\t */\n\tif (PageAnon(page))\n\t\t__mod_memcg_state(memcg, MEMCG_RSS, nr_pages);\n\telse {\n\t\t__mod_memcg_state(memcg, MEMCG_CACHE, nr_pages);\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_memcg_state(memcg, NR_SHMEM, nr_pages);\n\t}\n\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t__mod_memcg_state(memcg, MEMCG_RSS_HUGE, nr_pages);\n\t}\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__count_memcg_events(memcg, PGPGIN, 1);\n\telse {\n\t\t__count_memcg_events(memcg, PGPGOUT, 1);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat_cpu->nr_page_events, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 6191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_charge",
          "args": [
            "newpage",
            "memcg",
            "false"
          ],
          "line": 6189
        },
        "resolved": true,
        "details": {
          "function_name": "commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2361-2393",
          "snippet": "static void commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t  bool lrucare)\n{\n\tint isolated;\n\n\tVM_BUG_ON_PAGE(page->mem_cgroup, page);\n\n\t/*\n\t * In some cases, SwapCache and FUSE(splice_buf->radixtree), the page\n\t * may already be on some other mem_cgroup's LRU.  Take care of it.\n\t */\n\tif (lrucare)\n\t\tlock_page_lru(page, &isolated);\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point:\n\t *\n\t * - the page is uncharged\n\t *\n\t * - the page is off-LRU\n\t *\n\t * - an anonymous fault has exclusive page access, except for\n\t *   a locked page table\n\t *\n\t * - a page cache insertion, a swapin fault, or a migration\n\t *   have the page locked\n\t */\n\tpage->mem_cgroup = memcg;\n\n\tif (lrucare)\n\t\tunlock_page_lru(page, isolated);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t  bool lrucare)\n{\n\tint isolated;\n\n\tVM_BUG_ON_PAGE(page->mem_cgroup, page);\n\n\t/*\n\t * In some cases, SwapCache and FUSE(splice_buf->radixtree), the page\n\t * may already be on some other mem_cgroup's LRU.  Take care of it.\n\t */\n\tif (lrucare)\n\t\tlock_page_lru(page, &isolated);\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point:\n\t *\n\t * - the page is uncharged\n\t *\n\t * - the page is off-LRU\n\t *\n\t * - an anonymous fault has exclusive page access, except for\n\t *   a locked page table\n\t *\n\t * - a page cache insertion, a swapin fault, or a migration\n\t *   have the page locked\n\t */\n\tpage->mem_cgroup = memcg;\n\n\tif (lrucare)\n\t\tunlock_page_lru(page, isolated);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_get_many",
          "args": [
            "&memcg->css",
            "nr_pages"
          ],
          "line": 6187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_charge",
          "args": [
            "&memcg->memsw",
            "nr_pages"
          ],
          "line": 6186
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "72-88",
          "snippet": "void page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 6185
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "newpage"
          ],
          "line": 6182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "newpage"
          ],
          "line": 6181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 6168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTransHuge(oldpage) != PageTransHuge(newpage)",
            "newpage"
          ],
          "line": 6165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "newpage"
          ],
          "line": 6165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "oldpage"
          ],
          "line": 6165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageAnon(oldpage) != PageAnon(newpage)",
            "newpage"
          ],
          "line": 6164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "newpage"
          ],
          "line": 6164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "oldpage"
          ],
          "line": 6164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(newpage)",
            "newpage"
          ],
          "line": 6163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "newpage"
          ],
          "line": 6163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(oldpage)",
            "oldpage"
          ],
          "line": 6162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "oldpage"
          ],
          "line": 6162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_migrate(struct page *oldpage, struct page *newpage)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned int nr_pages;\n\tbool compound;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageLocked(oldpage), oldpage);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageAnon(oldpage) != PageAnon(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageTransHuge(oldpage) != PageTransHuge(newpage),\n\t\t       newpage);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\t/* Page cache replacement: new page already charged? */\n\tif (newpage->mem_cgroup)\n\t\treturn;\n\n\t/* Swapcache readahead pages can get replaced before being charged */\n\tmemcg = oldpage->mem_cgroup;\n\tif (!memcg)\n\t\treturn;\n\n\t/* Force-charge the new page. The old one will be freed soon */\n\tcompound = PageTransHuge(newpage);\n\tnr_pages = compound ? hpage_nr_pages(newpage) : 1;\n\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\tcommit_charge(newpage, memcg, false);\n\n\tlocal_irq_save(flags);\n\tmem_cgroup_charge_statistics(memcg, newpage, compound, nr_pages);\n\tmemcg_check_events(memcg, newpage);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "mem_cgroup_uncharge_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6136-6143",
    "snippet": "void mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uncharge_list",
          "args": [
            "page_list"
          ],
          "line": 6142
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6136-6143",
          "snippet": "void mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "page_list"
          ],
          "line": 6141
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 6138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}"
  },
  {
    "function_name": "mem_cgroup_uncharge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6113-6127",
    "snippet": "void mem_cgroup_uncharge(struct page *page)\n{\n\tstruct uncharge_gather ug;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\t/* Don't touch page->lru of any random page, pre-check: */\n\tif (!page->mem_cgroup)\n\t\treturn;\n\n\tuncharge_gather_clear(&ug);\n\tuncharge_page(page, &ug);\n\tuncharge_batch(&ug);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uncharge_batch",
          "args": [
            "&ug"
          ],
          "line": 6126
        },
        "resolved": true,
        "details": {
          "function_name": "uncharge_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6006-6032",
          "snippet": "static void uncharge_batch(const struct uncharge_gather *ug)\n{\n\tunsigned long nr_pages = ug->nr_anon + ug->nr_file + ug->nr_kmem;\n\tunsigned long flags;\n\n\tif (!mem_cgroup_is_root(ug->memcg)) {\n\t\tpage_counter_uncharge(&ug->memcg->memory, nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&ug->memcg->memsw, nr_pages);\n\t\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && ug->nr_kmem)\n\t\t\tpage_counter_uncharge(&ug->memcg->kmem, ug->nr_kmem);\n\t\tmemcg_oom_recover(ug->memcg);\n\t}\n\n\tlocal_irq_save(flags);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS, -ug->nr_anon);\n\t__mod_memcg_state(ug->memcg, MEMCG_CACHE, -ug->nr_file);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS_HUGE, -ug->nr_huge);\n\t__mod_memcg_state(ug->memcg, NR_SHMEM, -ug->nr_shmem);\n\t__count_memcg_events(ug->memcg, PGPGOUT, ug->pgpgout);\n\t__this_cpu_add(ug->memcg->stat_cpu->nr_page_events, nr_pages);\n\tmemcg_check_events(ug->memcg, ug->dummy_page);\n\tlocal_irq_restore(flags);\n\n\tif (!mem_cgroup_is_root(ug->memcg))\n\t\tcss_put_many(&ug->memcg->css, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic void uncharge_batch(const struct uncharge_gather *ug)\n{\n\tunsigned long nr_pages = ug->nr_anon + ug->nr_file + ug->nr_kmem;\n\tunsigned long flags;\n\n\tif (!mem_cgroup_is_root(ug->memcg)) {\n\t\tpage_counter_uncharge(&ug->memcg->memory, nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&ug->memcg->memsw, nr_pages);\n\t\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && ug->nr_kmem)\n\t\t\tpage_counter_uncharge(&ug->memcg->kmem, ug->nr_kmem);\n\t\tmemcg_oom_recover(ug->memcg);\n\t}\n\n\tlocal_irq_save(flags);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS, -ug->nr_anon);\n\t__mod_memcg_state(ug->memcg, MEMCG_CACHE, -ug->nr_file);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS_HUGE, -ug->nr_huge);\n\t__mod_memcg_state(ug->memcg, NR_SHMEM, -ug->nr_shmem);\n\t__count_memcg_events(ug->memcg, PGPGOUT, ug->pgpgout);\n\t__this_cpu_add(ug->memcg->stat_cpu->nr_page_events, nr_pages);\n\tmemcg_check_events(ug->memcg, ug->dummy_page);\n\tlocal_irq_restore(flags);\n\n\tif (!mem_cgroup_is_root(ug->memcg))\n\t\tcss_put_many(&ug->memcg->css, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uncharge_page",
          "args": [
            "page",
            "&ug"
          ],
          "line": 6125
        },
        "resolved": true,
        "details": {
          "function_name": "uncharge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6034-6079",
          "snippet": "static void uncharge_page(struct page *page, struct uncharge_gather *ug)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page) && !is_zone_device_page(page) &&\n\t\t\t!PageHWPoison(page) , page);\n\n\tif (!page->mem_cgroup)\n\t\treturn;\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point, we have fully\n\t * exclusive access to the page.\n\t */\n\n\tif (ug->memcg != page->mem_cgroup) {\n\t\tif (ug->memcg) {\n\t\t\tuncharge_batch(ug);\n\t\t\tuncharge_gather_clear(ug);\n\t\t}\n\t\tug->memcg = page->mem_cgroup;\n\t}\n\n\tif (!PageKmemcg(page)) {\n\t\tunsigned int nr_pages = 1;\n\n\t\tif (PageTransHuge(page)) {\n\t\t\tnr_pages <<= compound_order(page);\n\t\t\tug->nr_huge += nr_pages;\n\t\t}\n\t\tif (PageAnon(page))\n\t\t\tug->nr_anon += nr_pages;\n\t\telse {\n\t\t\tug->nr_file += nr_pages;\n\t\t\tif (PageSwapBacked(page))\n\t\t\t\tug->nr_shmem += nr_pages;\n\t\t}\n\t\tug->pgpgout++;\n\t} else {\n\t\tug->nr_kmem += 1 << compound_order(page);\n\t\t__ClearPageKmemcg(page);\n\t}\n\n\tug->dummy_page = page;\n\tpage->mem_cgroup = NULL;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void uncharge_page(struct page *page, struct uncharge_gather *ug)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page) && !is_zone_device_page(page) &&\n\t\t\t!PageHWPoison(page) , page);\n\n\tif (!page->mem_cgroup)\n\t\treturn;\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point, we have fully\n\t * exclusive access to the page.\n\t */\n\n\tif (ug->memcg != page->mem_cgroup) {\n\t\tif (ug->memcg) {\n\t\t\tuncharge_batch(ug);\n\t\t\tuncharge_gather_clear(ug);\n\t\t}\n\t\tug->memcg = page->mem_cgroup;\n\t}\n\n\tif (!PageKmemcg(page)) {\n\t\tunsigned int nr_pages = 1;\n\n\t\tif (PageTransHuge(page)) {\n\t\t\tnr_pages <<= compound_order(page);\n\t\t\tug->nr_huge += nr_pages;\n\t\t}\n\t\tif (PageAnon(page))\n\t\t\tug->nr_anon += nr_pages;\n\t\telse {\n\t\t\tug->nr_file += nr_pages;\n\t\t\tif (PageSwapBacked(page))\n\t\t\t\tug->nr_shmem += nr_pages;\n\t\t}\n\t\tug->pgpgout++;\n\t} else {\n\t\tug->nr_kmem += 1 << compound_order(page);\n\t\t__ClearPageKmemcg(page);\n\t}\n\n\tug->dummy_page = page;\n\tpage->mem_cgroup = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uncharge_gather_clear",
          "args": [
            "&ug"
          ],
          "line": 6124
        },
        "resolved": true,
        "details": {
          "function_name": "uncharge_gather_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6001-6004",
          "snippet": "static inline void uncharge_gather_clear(struct uncharge_gather *ug)\n{\n\tmemset(ug, 0, sizeof(*ug));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic inline void uncharge_gather_clear(struct uncharge_gather *ug)\n{\n\tmemset(ug, 0, sizeof(*ug));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 6117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_uncharge(struct page *page)\n{\n\tstruct uncharge_gather ug;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\t/* Don't touch page->lru of any random page, pre-check: */\n\tif (!page->mem_cgroup)\n\t\treturn;\n\n\tuncharge_gather_clear(&ug);\n\tuncharge_page(page, &ug);\n\tuncharge_batch(&ug);\n}"
  },
  {
    "function_name": "uncharge_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6081-6104",
    "snippet": "static void uncharge_list(struct list_head *page_list)\n{\n\tstruct uncharge_gather ug;\n\tstruct list_head *next;\n\n\tuncharge_gather_clear(&ug);\n\n\t/*\n\t * Note that the list can be a single page->lru; hence the\n\t * do-while loop instead of a simple list_for_each_entry().\n\t */\n\tnext = page_list->next;\n\tdo {\n\t\tstruct page *page;\n\n\t\tpage = list_entry(next, struct page, lru);\n\t\tnext = page->lru.next;\n\n\t\tuncharge_page(page, &ug);\n\t} while (next != page_list);\n\n\tif (ug.memcg)\n\t\tuncharge_batch(&ug);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uncharge_batch",
          "args": [
            "&ug"
          ],
          "line": 6103
        },
        "resolved": true,
        "details": {
          "function_name": "uncharge_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6006-6032",
          "snippet": "static void uncharge_batch(const struct uncharge_gather *ug)\n{\n\tunsigned long nr_pages = ug->nr_anon + ug->nr_file + ug->nr_kmem;\n\tunsigned long flags;\n\n\tif (!mem_cgroup_is_root(ug->memcg)) {\n\t\tpage_counter_uncharge(&ug->memcg->memory, nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&ug->memcg->memsw, nr_pages);\n\t\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && ug->nr_kmem)\n\t\t\tpage_counter_uncharge(&ug->memcg->kmem, ug->nr_kmem);\n\t\tmemcg_oom_recover(ug->memcg);\n\t}\n\n\tlocal_irq_save(flags);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS, -ug->nr_anon);\n\t__mod_memcg_state(ug->memcg, MEMCG_CACHE, -ug->nr_file);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS_HUGE, -ug->nr_huge);\n\t__mod_memcg_state(ug->memcg, NR_SHMEM, -ug->nr_shmem);\n\t__count_memcg_events(ug->memcg, PGPGOUT, ug->pgpgout);\n\t__this_cpu_add(ug->memcg->stat_cpu->nr_page_events, nr_pages);\n\tmemcg_check_events(ug->memcg, ug->dummy_page);\n\tlocal_irq_restore(flags);\n\n\tif (!mem_cgroup_is_root(ug->memcg))\n\t\tcss_put_many(&ug->memcg->css, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic void uncharge_batch(const struct uncharge_gather *ug)\n{\n\tunsigned long nr_pages = ug->nr_anon + ug->nr_file + ug->nr_kmem;\n\tunsigned long flags;\n\n\tif (!mem_cgroup_is_root(ug->memcg)) {\n\t\tpage_counter_uncharge(&ug->memcg->memory, nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&ug->memcg->memsw, nr_pages);\n\t\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && ug->nr_kmem)\n\t\t\tpage_counter_uncharge(&ug->memcg->kmem, ug->nr_kmem);\n\t\tmemcg_oom_recover(ug->memcg);\n\t}\n\n\tlocal_irq_save(flags);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS, -ug->nr_anon);\n\t__mod_memcg_state(ug->memcg, MEMCG_CACHE, -ug->nr_file);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS_HUGE, -ug->nr_huge);\n\t__mod_memcg_state(ug->memcg, NR_SHMEM, -ug->nr_shmem);\n\t__count_memcg_events(ug->memcg, PGPGOUT, ug->pgpgout);\n\t__this_cpu_add(ug->memcg->stat_cpu->nr_page_events, nr_pages);\n\tmemcg_check_events(ug->memcg, ug->dummy_page);\n\tlocal_irq_restore(flags);\n\n\tif (!mem_cgroup_is_root(ug->memcg))\n\t\tcss_put_many(&ug->memcg->css, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uncharge_page",
          "args": [
            "page",
            "&ug"
          ],
          "line": 6099
        },
        "resolved": true,
        "details": {
          "function_name": "uncharge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6034-6079",
          "snippet": "static void uncharge_page(struct page *page, struct uncharge_gather *ug)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page) && !is_zone_device_page(page) &&\n\t\t\t!PageHWPoison(page) , page);\n\n\tif (!page->mem_cgroup)\n\t\treturn;\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point, we have fully\n\t * exclusive access to the page.\n\t */\n\n\tif (ug->memcg != page->mem_cgroup) {\n\t\tif (ug->memcg) {\n\t\t\tuncharge_batch(ug);\n\t\t\tuncharge_gather_clear(ug);\n\t\t}\n\t\tug->memcg = page->mem_cgroup;\n\t}\n\n\tif (!PageKmemcg(page)) {\n\t\tunsigned int nr_pages = 1;\n\n\t\tif (PageTransHuge(page)) {\n\t\t\tnr_pages <<= compound_order(page);\n\t\t\tug->nr_huge += nr_pages;\n\t\t}\n\t\tif (PageAnon(page))\n\t\t\tug->nr_anon += nr_pages;\n\t\telse {\n\t\t\tug->nr_file += nr_pages;\n\t\t\tif (PageSwapBacked(page))\n\t\t\t\tug->nr_shmem += nr_pages;\n\t\t}\n\t\tug->pgpgout++;\n\t} else {\n\t\tug->nr_kmem += 1 << compound_order(page);\n\t\t__ClearPageKmemcg(page);\n\t}\n\n\tug->dummy_page = page;\n\tpage->mem_cgroup = NULL;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void uncharge_page(struct page *page, struct uncharge_gather *ug)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page) && !is_zone_device_page(page) &&\n\t\t\t!PageHWPoison(page) , page);\n\n\tif (!page->mem_cgroup)\n\t\treturn;\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point, we have fully\n\t * exclusive access to the page.\n\t */\n\n\tif (ug->memcg != page->mem_cgroup) {\n\t\tif (ug->memcg) {\n\t\t\tuncharge_batch(ug);\n\t\t\tuncharge_gather_clear(ug);\n\t\t}\n\t\tug->memcg = page->mem_cgroup;\n\t}\n\n\tif (!PageKmemcg(page)) {\n\t\tunsigned int nr_pages = 1;\n\n\t\tif (PageTransHuge(page)) {\n\t\t\tnr_pages <<= compound_order(page);\n\t\t\tug->nr_huge += nr_pages;\n\t\t}\n\t\tif (PageAnon(page))\n\t\t\tug->nr_anon += nr_pages;\n\t\telse {\n\t\t\tug->nr_file += nr_pages;\n\t\t\tif (PageSwapBacked(page))\n\t\t\t\tug->nr_shmem += nr_pages;\n\t\t}\n\t\tug->pgpgout++;\n\t} else {\n\t\tug->nr_kmem += 1 << compound_order(page);\n\t\t__ClearPageKmemcg(page);\n\t}\n\n\tug->dummy_page = page;\n\tpage->mem_cgroup = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structpage",
            "lru"
          ],
          "line": 6096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uncharge_gather_clear",
          "args": [
            "&ug"
          ],
          "line": 6086
        },
        "resolved": true,
        "details": {
          "function_name": "uncharge_gather_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6001-6004",
          "snippet": "static inline void uncharge_gather_clear(struct uncharge_gather *ug)\n{\n\tmemset(ug, 0, sizeof(*ug));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic inline void uncharge_gather_clear(struct uncharge_gather *ug)\n{\n\tmemset(ug, 0, sizeof(*ug));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void uncharge_list(struct list_head *page_list)\n{\n\tstruct uncharge_gather ug;\n\tstruct list_head *next;\n\n\tuncharge_gather_clear(&ug);\n\n\t/*\n\t * Note that the list can be a single page->lru; hence the\n\t * do-while loop instead of a simple list_for_each_entry().\n\t */\n\tnext = page_list->next;\n\tdo {\n\t\tstruct page *page;\n\n\t\tpage = list_entry(next, struct page, lru);\n\t\tnext = page->lru.next;\n\n\t\tuncharge_page(page, &ug);\n\t} while (next != page_list);\n\n\tif (ug.memcg)\n\t\tuncharge_batch(&ug);\n}"
  },
  {
    "function_name": "uncharge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6034-6079",
    "snippet": "static void uncharge_page(struct page *page, struct uncharge_gather *ug)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page) && !is_zone_device_page(page) &&\n\t\t\t!PageHWPoison(page) , page);\n\n\tif (!page->mem_cgroup)\n\t\treturn;\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point, we have fully\n\t * exclusive access to the page.\n\t */\n\n\tif (ug->memcg != page->mem_cgroup) {\n\t\tif (ug->memcg) {\n\t\t\tuncharge_batch(ug);\n\t\t\tuncharge_gather_clear(ug);\n\t\t}\n\t\tug->memcg = page->mem_cgroup;\n\t}\n\n\tif (!PageKmemcg(page)) {\n\t\tunsigned int nr_pages = 1;\n\n\t\tif (PageTransHuge(page)) {\n\t\t\tnr_pages <<= compound_order(page);\n\t\t\tug->nr_huge += nr_pages;\n\t\t}\n\t\tif (PageAnon(page))\n\t\t\tug->nr_anon += nr_pages;\n\t\telse {\n\t\t\tug->nr_file += nr_pages;\n\t\t\tif (PageSwapBacked(page))\n\t\t\t\tug->nr_shmem += nr_pages;\n\t\t}\n\t\tug->pgpgout++;\n\t} else {\n\t\tug->nr_kmem += 1 << compound_order(page);\n\t\t__ClearPageKmemcg(page);\n\t}\n\n\tug->dummy_page = page;\n\tpage->mem_cgroup = NULL;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ClearPageKmemcg",
          "args": [
            "page"
          ],
          "line": 6074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 6073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 6068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 6064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 6061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 6060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKmemcg",
          "args": [
            "page"
          ],
          "line": 6057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uncharge_gather_clear",
          "args": [
            "ug"
          ],
          "line": 6052
        },
        "resolved": true,
        "details": {
          "function_name": "uncharge_gather_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6001-6004",
          "snippet": "static inline void uncharge_gather_clear(struct uncharge_gather *ug)\n{\n\tmemset(ug, 0, sizeof(*ug));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic inline void uncharge_gather_clear(struct uncharge_gather *ug)\n{\n\tmemset(ug, 0, sizeof(*ug));\n}"
        }
      },
      {
        "call_info": {
          "callee": "uncharge_batch",
          "args": [
            "ug"
          ],
          "line": 6051
        },
        "resolved": true,
        "details": {
          "function_name": "uncharge_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6006-6032",
          "snippet": "static void uncharge_batch(const struct uncharge_gather *ug)\n{\n\tunsigned long nr_pages = ug->nr_anon + ug->nr_file + ug->nr_kmem;\n\tunsigned long flags;\n\n\tif (!mem_cgroup_is_root(ug->memcg)) {\n\t\tpage_counter_uncharge(&ug->memcg->memory, nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&ug->memcg->memsw, nr_pages);\n\t\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && ug->nr_kmem)\n\t\t\tpage_counter_uncharge(&ug->memcg->kmem, ug->nr_kmem);\n\t\tmemcg_oom_recover(ug->memcg);\n\t}\n\n\tlocal_irq_save(flags);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS, -ug->nr_anon);\n\t__mod_memcg_state(ug->memcg, MEMCG_CACHE, -ug->nr_file);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS_HUGE, -ug->nr_huge);\n\t__mod_memcg_state(ug->memcg, NR_SHMEM, -ug->nr_shmem);\n\t__count_memcg_events(ug->memcg, PGPGOUT, ug->pgpgout);\n\t__this_cpu_add(ug->memcg->stat_cpu->nr_page_events, nr_pages);\n\tmemcg_check_events(ug->memcg, ug->dummy_page);\n\tlocal_irq_restore(flags);\n\n\tif (!mem_cgroup_is_root(ug->memcg))\n\t\tcss_put_many(&ug->memcg->css, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic void uncharge_batch(const struct uncharge_gather *ug)\n{\n\tunsigned long nr_pages = ug->nr_anon + ug->nr_file + ug->nr_kmem;\n\tunsigned long flags;\n\n\tif (!mem_cgroup_is_root(ug->memcg)) {\n\t\tpage_counter_uncharge(&ug->memcg->memory, nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&ug->memcg->memsw, nr_pages);\n\t\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && ug->nr_kmem)\n\t\t\tpage_counter_uncharge(&ug->memcg->kmem, ug->nr_kmem);\n\t\tmemcg_oom_recover(ug->memcg);\n\t}\n\n\tlocal_irq_save(flags);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS, -ug->nr_anon);\n\t__mod_memcg_state(ug->memcg, MEMCG_CACHE, -ug->nr_file);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS_HUGE, -ug->nr_huge);\n\t__mod_memcg_state(ug->memcg, NR_SHMEM, -ug->nr_shmem);\n\t__count_memcg_events(ug->memcg, PGPGOUT, ug->pgpgout);\n\t__this_cpu_add(ug->memcg->stat_cpu->nr_page_events, nr_pages);\n\tmemcg_check_events(ug->memcg, ug->dummy_page);\n\tlocal_irq_restore(flags);\n\n\tif (!mem_cgroup_is_root(ug->memcg))\n\t\tcss_put_many(&ug->memcg->css, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_count(page) && !is_zone_device_page(page) &&\n\t\t\t!PageHWPoison(page)",
            "page"
          ],
          "line": 6037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 6038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 6037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 6037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 6036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 6036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void uncharge_page(struct page *page, struct uncharge_gather *ug)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page) && !is_zone_device_page(page) &&\n\t\t\t!PageHWPoison(page) , page);\n\n\tif (!page->mem_cgroup)\n\t\treturn;\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point, we have fully\n\t * exclusive access to the page.\n\t */\n\n\tif (ug->memcg != page->mem_cgroup) {\n\t\tif (ug->memcg) {\n\t\t\tuncharge_batch(ug);\n\t\t\tuncharge_gather_clear(ug);\n\t\t}\n\t\tug->memcg = page->mem_cgroup;\n\t}\n\n\tif (!PageKmemcg(page)) {\n\t\tunsigned int nr_pages = 1;\n\n\t\tif (PageTransHuge(page)) {\n\t\t\tnr_pages <<= compound_order(page);\n\t\t\tug->nr_huge += nr_pages;\n\t\t}\n\t\tif (PageAnon(page))\n\t\t\tug->nr_anon += nr_pages;\n\t\telse {\n\t\t\tug->nr_file += nr_pages;\n\t\t\tif (PageSwapBacked(page))\n\t\t\t\tug->nr_shmem += nr_pages;\n\t\t}\n\t\tug->pgpgout++;\n\t} else {\n\t\tug->nr_kmem += 1 << compound_order(page);\n\t\t__ClearPageKmemcg(page);\n\t}\n\n\tug->dummy_page = page;\n\tpage->mem_cgroup = NULL;\n}"
  },
  {
    "function_name": "uncharge_batch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6006-6032",
    "snippet": "static void uncharge_batch(const struct uncharge_gather *ug)\n{\n\tunsigned long nr_pages = ug->nr_anon + ug->nr_file + ug->nr_kmem;\n\tunsigned long flags;\n\n\tif (!mem_cgroup_is_root(ug->memcg)) {\n\t\tpage_counter_uncharge(&ug->memcg->memory, nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&ug->memcg->memsw, nr_pages);\n\t\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && ug->nr_kmem)\n\t\t\tpage_counter_uncharge(&ug->memcg->kmem, ug->nr_kmem);\n\t\tmemcg_oom_recover(ug->memcg);\n\t}\n\n\tlocal_irq_save(flags);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS, -ug->nr_anon);\n\t__mod_memcg_state(ug->memcg, MEMCG_CACHE, -ug->nr_file);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS_HUGE, -ug->nr_huge);\n\t__mod_memcg_state(ug->memcg, NR_SHMEM, -ug->nr_shmem);\n\t__count_memcg_events(ug->memcg, PGPGOUT, ug->pgpgout);\n\t__this_cpu_add(ug->memcg->stat_cpu->nr_page_events, nr_pages);\n\tmemcg_check_events(ug->memcg, ug->dummy_page);\n\tlocal_irq_restore(flags);\n\n\tif (!mem_cgroup_is_root(ug->memcg))\n\t\tcss_put_many(&ug->memcg->css, nr_pages);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put_many",
          "args": [
            "&ug->memcg->css",
            "nr_pages"
          ],
          "line": 6031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "ug->memcg"
          ],
          "line": 6030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 6028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_check_events",
          "args": [
            "ug->memcg",
            "ug->dummy_page"
          ],
          "line": 6027
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_check_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "781-803",
          "snippet": "static void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_add",
          "args": [
            "ug->memcg->stat_cpu->nr_page_events",
            "nr_pages"
          ],
          "line": 6026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_memcg_events",
          "args": [
            "ug->memcg",
            "PGPGOUT",
            "ug->pgpgout"
          ],
          "line": 6025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "ug->memcg",
            "NR_SHMEM",
            "-ug->nr_shmem"
          ],
          "line": 6024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "ug->memcg",
            "MEMCG_RSS_HUGE",
            "-ug->nr_huge"
          ],
          "line": 6023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "ug->memcg",
            "MEMCG_CACHE",
            "-ug->nr_file"
          ],
          "line": 6022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "ug->memcg",
            "MEMCG_RSS",
            "-ug->nr_anon"
          ],
          "line": 6021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 6020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_oom_recover",
          "args": [
            "ug->memcg"
          ],
          "line": 6017
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_oom_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1646-1658",
          "snippet": "static void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);\n\nstatic void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_uncharge",
          "args": [
            "&ug->memcg->kmem",
            "ug->nr_kmem"
          ],
          "line": 6016
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "155-161",
          "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 6015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 6013
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "ug->memcg"
          ],
          "line": 6011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic void uncharge_batch(const struct uncharge_gather *ug)\n{\n\tunsigned long nr_pages = ug->nr_anon + ug->nr_file + ug->nr_kmem;\n\tunsigned long flags;\n\n\tif (!mem_cgroup_is_root(ug->memcg)) {\n\t\tpage_counter_uncharge(&ug->memcg->memory, nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&ug->memcg->memsw, nr_pages);\n\t\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && ug->nr_kmem)\n\t\t\tpage_counter_uncharge(&ug->memcg->kmem, ug->nr_kmem);\n\t\tmemcg_oom_recover(ug->memcg);\n\t}\n\n\tlocal_irq_save(flags);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS, -ug->nr_anon);\n\t__mod_memcg_state(ug->memcg, MEMCG_CACHE, -ug->nr_file);\n\t__mod_memcg_state(ug->memcg, MEMCG_RSS_HUGE, -ug->nr_huge);\n\t__mod_memcg_state(ug->memcg, NR_SHMEM, -ug->nr_shmem);\n\t__count_memcg_events(ug->memcg, PGPGOUT, ug->pgpgout);\n\t__this_cpu_add(ug->memcg->stat_cpu->nr_page_events, nr_pages);\n\tmemcg_check_events(ug->memcg, ug->dummy_page);\n\tlocal_irq_restore(flags);\n\n\tif (!mem_cgroup_is_root(ug->memcg))\n\t\tcss_put_many(&ug->memcg->css, nr_pages);\n}"
  },
  {
    "function_name": "uncharge_gather_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "6001-6004",
    "snippet": "static inline void uncharge_gather_clear(struct uncharge_gather *ug)\n{\n\tmemset(ug, 0, sizeof(*ug));\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ug",
            "0",
            "sizeof(*ug)"
          ],
          "line": 6003
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic inline void uncharge_gather_clear(struct uncharge_gather *ug)\n{\n\tmemset(ug, 0, sizeof(*ug));\n}"
  },
  {
    "function_name": "mem_cgroup_cancel_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5972-5988",
    "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancel_charge",
          "args": [
            "memcg",
            "nr_pages"
          ],
          "line": 5987
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2318-2328",
          "snippet": "static void cancel_charge(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn;\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void cancel_charge(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn;\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 5977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 5975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
  },
  {
    "function_name": "mem_cgroup_commit_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5928-5962",
    "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge_swap",
          "args": [
            "entry",
            "nr_pages"
          ],
          "line": 5960
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6495-6517",
          "snippet": "void mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned short id;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tid = swap_cgroup_record(entry, 0, nr_pages);\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_id(id);\n\tif (memcg) {\n\t\tif (!mem_cgroup_is_root(memcg)) {\n\t\t\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\t\t\tpage_counter_uncharge(&memcg->swap, nr_pages);\n\t\t\telse\n\t\t\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\t\t}\n\t\tmod_memcg_state(memcg, MEMCG_SWAP, -nr_pages);\n\t\tmem_cgroup_id_put_many(memcg, nr_pages);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nvoid mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned short id;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tid = swap_cgroup_record(entry, 0, nr_pages);\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_id(id);\n\tif (memcg) {\n\t\tif (!mem_cgroup_is_root(memcg)) {\n\t\t\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\t\t\tpage_counter_uncharge(&memcg->swap, nr_pages);\n\t\t\telse\n\t\t\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\t\t}\n\t\tmod_memcg_state(memcg, MEMCG_SWAP, -nr_pages);\n\t\tmem_cgroup_id_put_many(memcg, nr_pages);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 5954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 5953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 5953
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 5951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_check_events",
          "args": [
            "memcg",
            "page"
          ],
          "line": 5950
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_check_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "781-803",
          "snippet": "static void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_charge_statistics",
          "args": [
            "memcg",
            "page",
            "compound",
            "nr_pages"
          ],
          "line": 5949
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_charge_statistics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "689-719",
          "snippet": "static void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t bool compound, int nr_pages)\n{\n\t/*\n\t * Here, RSS means 'mapped anon' and anon's SwapCache. Shmem/tmpfs is\n\t * counted as CACHE even if it's on ANON LRU.\n\t */\n\tif (PageAnon(page))\n\t\t__mod_memcg_state(memcg, MEMCG_RSS, nr_pages);\n\telse {\n\t\t__mod_memcg_state(memcg, MEMCG_CACHE, nr_pages);\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_memcg_state(memcg, NR_SHMEM, nr_pages);\n\t}\n\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t__mod_memcg_state(memcg, MEMCG_RSS_HUGE, nr_pages);\n\t}\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__count_memcg_events(memcg, PGPGIN, 1);\n\telse {\n\t\t__count_memcg_events(memcg, PGPGOUT, 1);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat_cpu->nr_page_events, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t bool compound, int nr_pages)\n{\n\t/*\n\t * Here, RSS means 'mapped anon' and anon's SwapCache. Shmem/tmpfs is\n\t * counted as CACHE even if it's on ANON LRU.\n\t */\n\tif (PageAnon(page))\n\t\t__mod_memcg_state(memcg, MEMCG_RSS, nr_pages);\n\telse {\n\t\t__mod_memcg_state(memcg, MEMCG_CACHE, nr_pages);\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_memcg_state(memcg, NR_SHMEM, nr_pages);\n\t}\n\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t__mod_memcg_state(memcg, MEMCG_RSS_HUGE, nr_pages);\n\t}\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__count_memcg_events(memcg, PGPGIN, 1);\n\telse {\n\t\t__count_memcg_events(memcg, PGPGOUT, 1);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat_cpu->nr_page_events, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 5948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_charge",
          "args": [
            "page",
            "memcg",
            "lrucare"
          ],
          "line": 5946
        },
        "resolved": true,
        "details": {
          "function_name": "commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2361-2393",
          "snippet": "static void commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t  bool lrucare)\n{\n\tint isolated;\n\n\tVM_BUG_ON_PAGE(page->mem_cgroup, page);\n\n\t/*\n\t * In some cases, SwapCache and FUSE(splice_buf->radixtree), the page\n\t * may already be on some other mem_cgroup's LRU.  Take care of it.\n\t */\n\tif (lrucare)\n\t\tlock_page_lru(page, &isolated);\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point:\n\t *\n\t * - the page is uncharged\n\t *\n\t * - the page is off-LRU\n\t *\n\t * - an anonymous fault has exclusive page access, except for\n\t *   a locked page table\n\t *\n\t * - a page cache insertion, a swapin fault, or a migration\n\t *   have the page locked\n\t */\n\tpage->mem_cgroup = memcg;\n\n\tif (lrucare)\n\t\tunlock_page_lru(page, isolated);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t  bool lrucare)\n{\n\tint isolated;\n\n\tVM_BUG_ON_PAGE(page->mem_cgroup, page);\n\n\t/*\n\t * In some cases, SwapCache and FUSE(splice_buf->radixtree), the page\n\t * may already be on some other mem_cgroup's LRU.  Take care of it.\n\t */\n\tif (lrucare)\n\t\tlock_page_lru(page, &isolated);\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point:\n\t *\n\t * - the page is uncharged\n\t *\n\t * - the page is off-LRU\n\t *\n\t * - an anonymous fault has exclusive page access, except for\n\t *   a locked page table\n\t *\n\t * - a page cache insertion, a swapin fault, or a migration\n\t *   have the page locked\n\t */\n\tpage->mem_cgroup = memcg;\n\n\tif (lrucare)\n\t\tunlock_page_lru(page, isolated);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 5936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page) && !lrucare",
            "page"
          ],
          "line": 5934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 5934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!page->mapping",
            "page"
          ],
          "line": 5933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 5931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
  },
  {
    "function_name": "mem_cgroup_try_charge_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5898-5909",
    "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_throttle_swaprate",
          "args": [
            "memcg",
            "page_to_nid(page)",
            "gfp_mask"
          ],
          "line": 5907
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_throttle_swaprate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3725-3752",
          "snippet": "void mem_cgroup_throttle_swaprate(struct mem_cgroup *memcg, int node,\n\t\t\t\t  gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si, *next;\n\tif (!(gfp_mask & __GFP_IO) || !memcg)\n\t\treturn;\n\n\tif (!blk_cgroup_congested())\n\t\treturn;\n\n\t/*\n\t * We've already scheduled a throttle, avoid taking the global swap\n\t * lock.\n\t */\n\tif (current->throttle_queue)\n\t\treturn;\n\n\tspin_lock(&swap_avail_lock);\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[node],\n\t\t\t\t  avail_lists[node]) {\n\t\tif (si->bdev) {\n\t\t\tblkcg_schedule_throttle(bdev_get_queue(si->bdev),\n\t\t\t\t\t\ttrue);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&swap_avail_lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static struct plist_head *swap_avail_heads;",
            "static DEFINE_SPINLOCK(swap_avail_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic struct plist_head *swap_avail_heads;\nstatic DEFINE_SPINLOCK(swap_avail_lock);\n\nvoid mem_cgroup_throttle_swaprate(struct mem_cgroup *memcg, int node,\n\t\t\t\t  gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si, *next;\n\tif (!(gfp_mask & __GFP_IO) || !memcg)\n\t\treturn;\n\n\tif (!blk_cgroup_congested())\n\t\treturn;\n\n\t/*\n\t * We've already scheduled a throttle, avoid taking the global swap\n\t * lock.\n\t */\n\tif (current->throttle_queue)\n\t\treturn;\n\n\tspin_lock(&swap_avail_lock);\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[node],\n\t\t\t\t  avail_lists[node]) {\n\t\tif (si->bdev) {\n\t\t\tblkcg_schedule_throttle(bdev_get_queue(si->bdev),\n\t\t\t\t\t\ttrue);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&swap_avail_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 5907
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge",
          "args": [
            "page",
            "mm",
            "gfp_mask",
            "memcgp",
            "compound"
          ],
          "line": 5905
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
  },
  {
    "function_name": "mem_cgroup_try_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5852-5896",
    "snippet": "int mem_cgroup_try_charge(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\tint ret = 0;\n\n\tif (mem_cgroup_disabled())\n\t\tgoto out;\n\n\tif (PageSwapCache(page)) {\n\t\t/*\n\t\t * Every swap fault against a single page tries to charge the\n\t\t * page, bail as early as possible.  shmem_unuse() encounters\n\t\t * already charged pages, too.  The USED bit is protected by\n\t\t * the page lock, which serializes swap cache removal, which\n\t\t * in turn serializes uncharging.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tif (compound_head(page)->mem_cgroup)\n\t\t\tgoto out;\n\n\t\tif (do_swap_account) {\n\t\t\tswp_entry_t ent = { .val = page_private(page), };\n\t\t\tunsigned short id = lookup_swap_cgroup_id(ent);\n\n\t\t\trcu_read_lock();\n\t\t\tmemcg = mem_cgroup_from_id(id);\n\t\t\tif (memcg && !css_tryget_online(&memcg->css))\n\t\t\t\tmemcg = NULL;\n\t\t\trcu_read_unlock();\n\t\t}\n\t}\n\n\tif (!memcg)\n\t\tmemcg = get_mem_cgroup_from_mm(mm);\n\n\tret = try_charge(memcg, gfp_mask, nr_pages);\n\n\tcss_put(&memcg->css);\nout:\n\t*memcgp = memcg;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define do_swap_account\t\t0"
    ],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&memcg->css"
          ],
          "line": 5892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_charge",
          "args": [
            "memcg",
            "gfp_mask",
            "nr_pages"
          ],
          "line": 5890
        },
        "resolved": true,
        "details": {
          "function_name": "try_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2147-2316",
          "snippet": "static int try_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t      unsigned int nr_pages)\n{\n\tunsigned int batch = max(MEMCG_CHARGE_BATCH, nr_pages);\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct page_counter *counter;\n\tunsigned long nr_reclaimed;\n\tbool may_swap = true;\n\tbool drained = false;\n\tbool oomed = false;\n\tenum oom_status oom_status;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\nretry:\n\tif (consume_stock(memcg, nr_pages))\n\t\treturn 0;\n\n\tif (!do_memsw_account() ||\n\t    page_counter_try_charge(&memcg->memsw, batch, &counter)) {\n\t\tif (page_counter_try_charge(&memcg->memory, batch, &counter))\n\t\t\tgoto done_restock;\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&memcg->memsw, batch);\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memory);\n\t} else {\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memsw);\n\t\tmay_swap = false;\n\t}\n\n\tif (batch > nr_pages) {\n\t\tbatch = nr_pages;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Unlike in global OOM situations, memcg is not in a physical\n\t * memory shortage.  Allow dying and OOM-killed tasks to\n\t * bypass the last charges so that they can exit quickly and\n\t * free their memory.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current) ||\n\t\t     fatal_signal_pending(current) ||\n\t\t     current->flags & PF_EXITING))\n\t\tgoto force;\n\n\t/*\n\t * Prevent unbounded recursion when reclaim operations need to\n\t * allocate memory. This might exceed the limits temporarily,\n\t * but we prefer facilitating memory reclaim and getting back\n\t * under the limit over triggering OOM kills in these cases.\n\t */\n\tif (unlikely(current->flags & PF_MEMALLOC))\n\t\tgoto force;\n\n\tif (unlikely(task_in_memcg_oom(current)))\n\t\tgoto nomem;\n\n\tif (!gfpflags_allow_blocking(gfp_mask))\n\t\tgoto nomem;\n\n\tmemcg_memory_event(mem_over_limit, MEMCG_MAX);\n\n\tnr_reclaimed = try_to_free_mem_cgroup_pages(mem_over_limit, nr_pages,\n\t\t\t\t\t\t    gfp_mask, may_swap);\n\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\tgoto retry;\n\n\tif (!drained) {\n\t\tdrain_all_stock(mem_over_limit);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nomem;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_reclaimed && nr_pages <= (1 << PAGE_ALLOC_COSTLY_ORDER))\n\t\tgoto retry;\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\tgoto retry;\n\n\tif (nr_retries--)\n\t\tgoto retry;\n\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL && oomed)\n\t\tgoto nomem;\n\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\tgoto force;\n\n\tif (fatal_signal_pending(current))\n\t\tgoto force;\n\n\t/*\n\t * keep retrying as long as the memcg oom killer is able to make\n\t * a forward progress or bypass the charge if the oom killer\n\t * couldn't make any progress.\n\t */\n\toom_status = mem_cgroup_oom(mem_over_limit, gfp_mask,\n\t\t       get_order(nr_pages * PAGE_SIZE));\n\tswitch (oom_status) {\n\tcase OOM_SUCCESS:\n\t\tnr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\toomed = true;\n\t\tgoto retry;\n\tcase OOM_FAILED:\n\t\tgoto force;\n\tdefault:\n\t\tgoto nomem;\n\t}\nnomem:\n\tif (!(gfp_mask & __GFP_NOFAIL))\n\t\treturn -ENOMEM;\nforce:\n\t/*\n\t * The allocation either can't fail or will lead to more memory\n\t * being freed very soon.  Allow memory usage go over the limit\n\t * temporarily by force charging it.\n\t */\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\treturn 0;\n\ndone_restock:\n\tcss_get_many(&memcg->css, batch);\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\n\t/*\n\t * If the hierarchy is above the normal consumption range, schedule\n\t * reclaim on returning to userland.  We can perform reclaim here\n\t * if __GFP_RECLAIM but let's always punt for simplicity and so that\n\t * GFP_KERNEL can consistently be used during reclaim.  @memcg is\n\t * not recorded as it most likely matches current's and won't\n\t * change in the meantime.  As high limit is checked again before\n\t * reclaim, the cost of mismatch is negligible.\n\t */\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) > memcg->high) {\n\t\t\t/* Don't bother a random interrupted task */\n\t\t\tif (in_interrupt()) {\n\t\t\t\tschedule_work(&memcg->high_work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->memcg_nr_pages_over_high += batch;\n\t\t\tset_notify_resume(current);\n\t\t\tbreak;\n\t\t}\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define MEM_CGROUP_RECLAIM_RETRIES\t5"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MEM_CGROUP_RECLAIM_RETRIES\t5\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int try_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t      unsigned int nr_pages)\n{\n\tunsigned int batch = max(MEMCG_CHARGE_BATCH, nr_pages);\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct page_counter *counter;\n\tunsigned long nr_reclaimed;\n\tbool may_swap = true;\n\tbool drained = false;\n\tbool oomed = false;\n\tenum oom_status oom_status;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\nretry:\n\tif (consume_stock(memcg, nr_pages))\n\t\treturn 0;\n\n\tif (!do_memsw_account() ||\n\t    page_counter_try_charge(&memcg->memsw, batch, &counter)) {\n\t\tif (page_counter_try_charge(&memcg->memory, batch, &counter))\n\t\t\tgoto done_restock;\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&memcg->memsw, batch);\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memory);\n\t} else {\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memsw);\n\t\tmay_swap = false;\n\t}\n\n\tif (batch > nr_pages) {\n\t\tbatch = nr_pages;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Unlike in global OOM situations, memcg is not in a physical\n\t * memory shortage.  Allow dying and OOM-killed tasks to\n\t * bypass the last charges so that they can exit quickly and\n\t * free their memory.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current) ||\n\t\t     fatal_signal_pending(current) ||\n\t\t     current->flags & PF_EXITING))\n\t\tgoto force;\n\n\t/*\n\t * Prevent unbounded recursion when reclaim operations need to\n\t * allocate memory. This might exceed the limits temporarily,\n\t * but we prefer facilitating memory reclaim and getting back\n\t * under the limit over triggering OOM kills in these cases.\n\t */\n\tif (unlikely(current->flags & PF_MEMALLOC))\n\t\tgoto force;\n\n\tif (unlikely(task_in_memcg_oom(current)))\n\t\tgoto nomem;\n\n\tif (!gfpflags_allow_blocking(gfp_mask))\n\t\tgoto nomem;\n\n\tmemcg_memory_event(mem_over_limit, MEMCG_MAX);\n\n\tnr_reclaimed = try_to_free_mem_cgroup_pages(mem_over_limit, nr_pages,\n\t\t\t\t\t\t    gfp_mask, may_swap);\n\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\tgoto retry;\n\n\tif (!drained) {\n\t\tdrain_all_stock(mem_over_limit);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nomem;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_reclaimed && nr_pages <= (1 << PAGE_ALLOC_COSTLY_ORDER))\n\t\tgoto retry;\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\tgoto retry;\n\n\tif (nr_retries--)\n\t\tgoto retry;\n\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL && oomed)\n\t\tgoto nomem;\n\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\tgoto force;\n\n\tif (fatal_signal_pending(current))\n\t\tgoto force;\n\n\t/*\n\t * keep retrying as long as the memcg oom killer is able to make\n\t * a forward progress or bypass the charge if the oom killer\n\t * couldn't make any progress.\n\t */\n\toom_status = mem_cgroup_oom(mem_over_limit, gfp_mask,\n\t\t       get_order(nr_pages * PAGE_SIZE));\n\tswitch (oom_status) {\n\tcase OOM_SUCCESS:\n\t\tnr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\toomed = true;\n\t\tgoto retry;\n\tcase OOM_FAILED:\n\t\tgoto force;\n\tdefault:\n\t\tgoto nomem;\n\t}\nnomem:\n\tif (!(gfp_mask & __GFP_NOFAIL))\n\t\treturn -ENOMEM;\nforce:\n\t/*\n\t * The allocation either can't fail or will lead to more memory\n\t * being freed very soon.  Allow memory usage go over the limit\n\t * temporarily by force charging it.\n\t */\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\treturn 0;\n\ndone_restock:\n\tcss_get_many(&memcg->css, batch);\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\n\t/*\n\t * If the hierarchy is above the normal consumption range, schedule\n\t * reclaim on returning to userland.  We can perform reclaim here\n\t * if __GFP_RECLAIM but let's always punt for simplicity and so that\n\t * GFP_KERNEL can consistently be used during reclaim.  @memcg is\n\t * not recorded as it most likely matches current's and won't\n\t * change in the meantime.  As high limit is checked again before\n\t * reclaim, the cost of mismatch is negligible.\n\t */\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) > memcg->high) {\n\t\t\t/* Don't bother a random interrupted task */\n\t\t\tif (in_interrupt()) {\n\t\t\t\tschedule_work(&memcg->high_work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->memcg_nr_pages_over_high += batch;\n\t\t\tset_notify_resume(current);\n\t\t\tbreak;\n\t\t}\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mem_cgroup_from_mm",
          "args": [
            "mm"
          ],
          "line": 5888
        },
        "resolved": true,
        "details": {
          "function_name": "get_mem_cgroup_from_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "827-851",
          "snippet": "struct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdo {\n\t\t/*\n\t\t * Page cache insertions can happen withou an\n\t\t * actual mm context, e.g. during disk probing\n\t\t * on boot, loopback IO, acct() writes etc.\n\t\t */\n\t\tif (unlikely(!mm))\n\t\t\tmemcg = root_mem_cgroup;\n\t\telse {\n\t\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\t\tif (unlikely(!memcg))\n\t\t\t\tmemcg = root_mem_cgroup;\n\t\t}\n\t} while (!css_tryget_online(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdo {\n\t\t/*\n\t\t * Page cache insertions can happen withou an\n\t\t * actual mm context, e.g. during disk probing\n\t\t * on boot, loopback IO, acct() writes etc.\n\t\t */\n\t\tif (unlikely(!mm))\n\t\t\tmemcg = root_mem_cgroup;\n\t\telse {\n\t\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\t\tif (unlikely(!memcg))\n\t\t\t\tmemcg = root_mem_cgroup;\n\t\t}\n\t} while (!css_tryget_online(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "&memcg->css"
          ],
          "line": 5881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_id",
          "args": [
            "id"
          ],
          "line": 5880
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_from_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4331-4335",
          "snippet": "struct mem_cgroup *mem_cgroup_from_id(unsigned short id)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&mem_cgroup_idr, id);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static DEFINE_IDR(mem_cgroup_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\nstatic DEFINE_IDR(mem_cgroup_idr);\n\nstruct mem_cgroup *mem_cgroup_from_id(unsigned short id)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&mem_cgroup_idr, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_swap_cgroup_id",
          "args": [
            "ent"
          ],
          "line": 5877
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_swap_cgroup_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "162-165",
          "snippet": "unsigned short lookup_swap_cgroup_id(swp_entry_t ent)\n{\n\treturn lookup_swap_cgroup(ent, NULL)->id;\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nunsigned short lookup_swap_cgroup_id(swp_entry_t ent)\n{\n\treturn lookup_swap_cgroup(ent, NULL)->id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 5876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 5872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 5871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 5871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 5863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 5860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 5857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\tint ret = 0;\n\n\tif (mem_cgroup_disabled())\n\t\tgoto out;\n\n\tif (PageSwapCache(page)) {\n\t\t/*\n\t\t * Every swap fault against a single page tries to charge the\n\t\t * page, bail as early as possible.  shmem_unuse() encounters\n\t\t * already charged pages, too.  The USED bit is protected by\n\t\t * the page lock, which serializes swap cache removal, which\n\t\t * in turn serializes uncharging.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tif (compound_head(page)->mem_cgroup)\n\t\t\tgoto out;\n\n\t\tif (do_swap_account) {\n\t\t\tswp_entry_t ent = { .val = page_private(page), };\n\t\t\tunsigned short id = lookup_swap_cgroup_id(ent);\n\n\t\t\trcu_read_lock();\n\t\t\tmemcg = mem_cgroup_from_id(id);\n\t\t\tif (memcg && !css_tryget_online(&memcg->css))\n\t\t\t\tmemcg = NULL;\n\t\t\trcu_read_unlock();\n\t\t}\n\t}\n\n\tif (!memcg)\n\t\tmemcg = get_mem_cgroup_from_mm(mm);\n\n\tret = try_charge(memcg, gfp_mask, nr_pages);\n\n\tcss_put(&memcg->css);\nout:\n\t*memcgp = memcg;\n\treturn ret;\n}"
  },
  {
    "function_name": "mem_cgroup_protected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5763-5832",
    "snippet": "enum mem_cgroup_protection mem_cgroup_protected(struct mem_cgroup *root,\n\t\t\t\t\t\tstruct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *parent;\n\tunsigned long emin, parent_emin;\n\tunsigned long elow, parent_elow;\n\tunsigned long usage;\n\n\tif (mem_cgroup_disabled())\n\t\treturn MEMCG_PROT_NONE;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (memcg == root)\n\t\treturn MEMCG_PROT_NONE;\n\n\tusage = page_counter_read(&memcg->memory);\n\tif (!usage)\n\t\treturn MEMCG_PROT_NONE;\n\n\temin = memcg->memory.min;\n\telow = memcg->memory.low;\n\n\tparent = parent_mem_cgroup(memcg);\n\t/* No parent means a non-hierarchical mode on v1 memcg */\n\tif (!parent)\n\t\treturn MEMCG_PROT_NONE;\n\n\tif (parent == root)\n\t\tgoto exit;\n\n\tparent_emin = READ_ONCE(parent->memory.emin);\n\temin = min(emin, parent_emin);\n\tif (emin && parent_emin) {\n\t\tunsigned long min_usage, siblings_min_usage;\n\n\t\tmin_usage = min(usage, memcg->memory.min);\n\t\tsiblings_min_usage = atomic_long_read(\n\t\t\t&parent->memory.children_min_usage);\n\n\t\tif (min_usage && siblings_min_usage)\n\t\t\temin = min(emin, parent_emin * min_usage /\n\t\t\t\t   siblings_min_usage);\n\t}\n\n\tparent_elow = READ_ONCE(parent->memory.elow);\n\telow = min(elow, parent_elow);\n\tif (elow && parent_elow) {\n\t\tunsigned long low_usage, siblings_low_usage;\n\n\t\tlow_usage = min(usage, memcg->memory.low);\n\t\tsiblings_low_usage = atomic_long_read(\n\t\t\t&parent->memory.children_low_usage);\n\n\t\tif (low_usage && siblings_low_usage)\n\t\t\telow = min(elow, parent_elow * low_usage /\n\t\t\t\t   siblings_low_usage);\n\t}\n\nexit:\n\tmemcg->memory.emin = emin;\n\tmemcg->memory.elow = elow;\n\n\tif (usage <= emin)\n\t\treturn MEMCG_PROT_MIN;\n\telse if (usage <= elow)\n\t\treturn MEMCG_PROT_LOW;\n\telse\n\t\treturn MEMCG_PROT_NONE;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "elow",
            "parent_elow * low_usage /\n\t\t\t\t   siblings_low_usage"
          ],
          "line": 5818
        },
        "resolved": true,
        "details": {
          "function_name": "memory_min_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5342-5353",
          "snippet": "static int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&parent->memory.children_low_usage"
          ],
          "line": 5814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "parent->memory.elow"
          ],
          "line": 5808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&parent->memory.children_min_usage"
          ],
          "line": 5800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "parent->memory.emin"
          ],
          "line": 5794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 5786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 5779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 5771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nenum mem_cgroup_protection mem_cgroup_protected(struct mem_cgroup *root,\n\t\t\t\t\t\tstruct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *parent;\n\tunsigned long emin, parent_emin;\n\tunsigned long elow, parent_elow;\n\tunsigned long usage;\n\n\tif (mem_cgroup_disabled())\n\t\treturn MEMCG_PROT_NONE;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (memcg == root)\n\t\treturn MEMCG_PROT_NONE;\n\n\tusage = page_counter_read(&memcg->memory);\n\tif (!usage)\n\t\treturn MEMCG_PROT_NONE;\n\n\temin = memcg->memory.min;\n\telow = memcg->memory.low;\n\n\tparent = parent_mem_cgroup(memcg);\n\t/* No parent means a non-hierarchical mode on v1 memcg */\n\tif (!parent)\n\t\treturn MEMCG_PROT_NONE;\n\n\tif (parent == root)\n\t\tgoto exit;\n\n\tparent_emin = READ_ONCE(parent->memory.emin);\n\temin = min(emin, parent_emin);\n\tif (emin && parent_emin) {\n\t\tunsigned long min_usage, siblings_min_usage;\n\n\t\tmin_usage = min(usage, memcg->memory.min);\n\t\tsiblings_min_usage = atomic_long_read(\n\t\t\t&parent->memory.children_min_usage);\n\n\t\tif (min_usage && siblings_min_usage)\n\t\t\temin = min(emin, parent_emin * min_usage /\n\t\t\t\t   siblings_min_usage);\n\t}\n\n\tparent_elow = READ_ONCE(parent->memory.elow);\n\telow = min(elow, parent_elow);\n\tif (elow && parent_elow) {\n\t\tunsigned long low_usage, siblings_low_usage;\n\n\t\tlow_usage = min(usage, memcg->memory.low);\n\t\tsiblings_low_usage = atomic_long_read(\n\t\t\t&parent->memory.children_low_usage);\n\n\t\tif (low_usage && siblings_low_usage)\n\t\t\telow = min(elow, parent_elow * low_usage /\n\t\t\t\t   siblings_low_usage);\n\t}\n\nexit:\n\tmemcg->memory.emin = emin;\n\tmemcg->memory.elow = elow;\n\n\tif (usage <= emin)\n\t\treturn MEMCG_PROT_MIN;\n\telse if (usage <= elow)\n\t\treturn MEMCG_PROT_LOW;\n\telse\n\t\treturn MEMCG_PROT_NONE;\n}"
  },
  {
    "function_name": "memory_oom_group_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5605-5625",
    "snippet": "static ssize_t memory_oom_group_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tint ret, oom_group;\n\n\tbuf = strstrip(buf);\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tret = kstrtoint(buf, 0, &oom_group);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oom_group != 0 && oom_group != 1)\n\t\treturn -EINVAL;\n\n\tmemcg->oom_group = oom_group;\n\n\treturn nbytes;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "0",
            "&oom_group"
          ],
          "line": 5615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 5611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "of_css(of)"
          ],
          "line": 5608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 5608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic ssize_t memory_oom_group_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tint ret, oom_group;\n\n\tbuf = strstrip(buf);\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tret = kstrtoint(buf, 0, &oom_group);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oom_group != 0 && oom_group != 1)\n\t\treturn -EINVAL;\n\n\tmemcg->oom_group = oom_group;\n\n\treturn nbytes;\n}"
  },
  {
    "function_name": "memory_oom_group_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5596-5603",
    "snippet": "static int memory_oom_group_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tseq_printf(m, \"%d\\n\", memcg->oom_group);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%d\\n\"",
            "memcg->oom_group"
          ],
          "line": 5600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 5598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 5598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_oom_group_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tseq_printf(m, \"%d\\n\", memcg->oom_group);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memory_stat_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5519-5594",
    "snippet": "static int memory_stat_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tstruct accumulated_stats acc;\n\tint i;\n\n\t/*\n\t * Provide statistics on the state of the memory subsystem as\n\t * well as cumulative event counters that show past behavior.\n\t *\n\t * This list is ordered following a combination of these gradients:\n\t * 1) generic big picture -> specifics and details\n\t * 2) reflecting userspace activity -> reflecting kernel heuristics\n\t *\n\t * Current memory state:\n\t */\n\n\tmemset(&acc, 0, sizeof(acc));\n\tacc.stats_size = MEMCG_NR_STAT;\n\tacc.events_size = NR_VM_EVENT_ITEMS;\n\taccumulate_memcg_tree(memcg, &acc);\n\n\tseq_printf(m, \"anon %llu\\n\",\n\t\t   (u64)acc.stat[MEMCG_RSS] * PAGE_SIZE);\n\tseq_printf(m, \"file %llu\\n\",\n\t\t   (u64)acc.stat[MEMCG_CACHE] * PAGE_SIZE);\n\tseq_printf(m, \"kernel_stack %llu\\n\",\n\t\t   (u64)acc.stat[MEMCG_KERNEL_STACK_KB] * 1024);\n\tseq_printf(m, \"slab %llu\\n\",\n\t\t   (u64)(acc.stat[NR_SLAB_RECLAIMABLE] +\n\t\t\t acc.stat[NR_SLAB_UNRECLAIMABLE]) * PAGE_SIZE);\n\tseq_printf(m, \"sock %llu\\n\",\n\t\t   (u64)acc.stat[MEMCG_SOCK] * PAGE_SIZE);\n\n\tseq_printf(m, \"shmem %llu\\n\",\n\t\t   (u64)acc.stat[NR_SHMEM] * PAGE_SIZE);\n\tseq_printf(m, \"file_mapped %llu\\n\",\n\t\t   (u64)acc.stat[NR_FILE_MAPPED] * PAGE_SIZE);\n\tseq_printf(m, \"file_dirty %llu\\n\",\n\t\t   (u64)acc.stat[NR_FILE_DIRTY] * PAGE_SIZE);\n\tseq_printf(m, \"file_writeback %llu\\n\",\n\t\t   (u64)acc.stat[NR_WRITEBACK] * PAGE_SIZE);\n\n\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\tseq_printf(m, \"%s %llu\\n\", mem_cgroup_lru_names[i],\n\t\t\t   (u64)acc.lru_pages[i] * PAGE_SIZE);\n\n\tseq_printf(m, \"slab_reclaimable %llu\\n\",\n\t\t   (u64)acc.stat[NR_SLAB_RECLAIMABLE] * PAGE_SIZE);\n\tseq_printf(m, \"slab_unreclaimable %llu\\n\",\n\t\t   (u64)acc.stat[NR_SLAB_UNRECLAIMABLE] * PAGE_SIZE);\n\n\t/* Accumulated memory events */\n\n\tseq_printf(m, \"pgfault %lu\\n\", acc.events[PGFAULT]);\n\tseq_printf(m, \"pgmajfault %lu\\n\", acc.events[PGMAJFAULT]);\n\n\tseq_printf(m, \"workingset_refault %lu\\n\",\n\t\t   acc.stat[WORKINGSET_REFAULT]);\n\tseq_printf(m, \"workingset_activate %lu\\n\",\n\t\t   acc.stat[WORKINGSET_ACTIVATE]);\n\tseq_printf(m, \"workingset_nodereclaim %lu\\n\",\n\t\t   acc.stat[WORKINGSET_NODERECLAIM]);\n\n\tseq_printf(m, \"pgrefill %lu\\n\", acc.events[PGREFILL]);\n\tseq_printf(m, \"pgscan %lu\\n\", acc.events[PGSCAN_KSWAPD] +\n\t\t   acc.events[PGSCAN_DIRECT]);\n\tseq_printf(m, \"pgsteal %lu\\n\", acc.events[PGSTEAL_KSWAPD] +\n\t\t   acc.events[PGSTEAL_DIRECT]);\n\tseq_printf(m, \"pgactivate %lu\\n\", acc.events[PGACTIVATE]);\n\tseq_printf(m, \"pgdeactivate %lu\\n\", acc.events[PGDEACTIVATE]);\n\tseq_printf(m, \"pglazyfree %lu\\n\", acc.events[PGLAZYFREE]);\n\tseq_printf(m, \"pglazyfreed %lu\\n\", acc.events[PGLAZYFREED]);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *const mem_cgroup_lru_names[] = {\n\t\"inactive_anon\",\n\t\"active_anon\",\n\t\"inactive_file\",\n\t\"active_file\",\n\t\"unevictable\",\n};",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pglazyfreed %lu\\n\"",
            "acc.events[PGLAZYFREED]"
          ],
          "line": 5591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pglazyfree %lu\\n\"",
            "acc.events[PGLAZYFREE]"
          ],
          "line": 5590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pgdeactivate %lu\\n\"",
            "acc.events[PGDEACTIVATE]"
          ],
          "line": 5589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pgactivate %lu\\n\"",
            "acc.events[PGACTIVATE]"
          ],
          "line": 5588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pgsteal %lu\\n\"",
            "acc.events[PGSTEAL_KSWAPD] +\n\t\t   acc.events[PGSTEAL_DIRECT]"
          ],
          "line": 5586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pgscan %lu\\n\"",
            "acc.events[PGSCAN_KSWAPD] +\n\t\t   acc.events[PGSCAN_DIRECT]"
          ],
          "line": 5584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pgrefill %lu\\n\"",
            "acc.events[PGREFILL]"
          ],
          "line": 5583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"workingset_nodereclaim %lu\\n\"",
            "acc.stat[WORKINGSET_NODERECLAIM]"
          ],
          "line": 5580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"workingset_activate %lu\\n\"",
            "acc.stat[WORKINGSET_ACTIVATE]"
          ],
          "line": 5578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"workingset_refault %lu\\n\"",
            "acc.stat[WORKINGSET_REFAULT]"
          ],
          "line": 5576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pgmajfault %lu\\n\"",
            "acc.events[PGMAJFAULT]"
          ],
          "line": 5574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pgfault %lu\\n\"",
            "acc.events[PGFAULT]"
          ],
          "line": 5573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"slab_unreclaimable %llu\\n\"",
            "(u64)acc.stat[NR_SLAB_UNRECLAIMABLE] * PAGE_SIZE"
          ],
          "line": 5568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"slab_reclaimable %llu\\n\"",
            "(u64)acc.stat[NR_SLAB_RECLAIMABLE] * PAGE_SIZE"
          ],
          "line": 5566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s %llu\\n\"",
            "mem_cgroup_lru_names[i]",
            "(u64)acc.lru_pages[i] * PAGE_SIZE"
          ],
          "line": 5563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"file_writeback %llu\\n\"",
            "(u64)acc.stat[NR_WRITEBACK] * PAGE_SIZE"
          ],
          "line": 5559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"file_dirty %llu\\n\"",
            "(u64)acc.stat[NR_FILE_DIRTY] * PAGE_SIZE"
          ],
          "line": 5557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"file_mapped %llu\\n\"",
            "(u64)acc.stat[NR_FILE_MAPPED] * PAGE_SIZE"
          ],
          "line": 5555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"shmem %llu\\n\"",
            "(u64)acc.stat[NR_SHMEM] * PAGE_SIZE"
          ],
          "line": 5553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"sock %llu\\n\"",
            "(u64)acc.stat[MEMCG_SOCK] * PAGE_SIZE"
          ],
          "line": 5550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"slab %llu\\n\"",
            "(u64)(acc.stat[NR_SLAB_RECLAIMABLE] +\n\t\t\t acc.stat[NR_SLAB_UNRECLAIMABLE]) * PAGE_SIZE"
          ],
          "line": 5547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "acc.stat[NR_SLAB_RECLAIMABLE] +\n\t\t\t acc.stat[NR_SLAB_UNRECLAIMABLE]"
          ],
          "line": 5548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"kernel_stack %llu\\n\"",
            "(u64)acc.stat[MEMCG_KERNEL_STACK_KB] * 1024"
          ],
          "line": 5545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"file %llu\\n\"",
            "(u64)acc.stat[MEMCG_CACHE] * PAGE_SIZE"
          ],
          "line": 5543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"anon %llu\\n\"",
            "(u64)acc.stat[MEMCG_RSS] * PAGE_SIZE"
          ],
          "line": 5541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accumulate_memcg_tree",
          "args": [
            "memcg",
            "&acc"
          ],
          "line": 5539
        },
        "resolved": true,
        "details": {
          "function_name": "accumulate_memcg_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2944-2963",
          "snippet": "static void accumulate_memcg_tree(struct mem_cgroup *memcg,\n\t\t\t\t  struct accumulated_stats *acc)\n{\n\tstruct mem_cgroup *mi;\n\tint i;\n\n\tfor_each_mem_cgroup_tree(mi, memcg) {\n\t\tfor (i = 0; i < acc->stats_size; i++)\n\t\t\tacc->stat[i] += memcg_page_state(mi,\n\t\t\t\tacc->stats_array ? acc->stats_array[i] : i);\n\n\t\tfor (i = 0; i < acc->events_size; i++)\n\t\t\tacc->events[i] += memcg_sum_events(mi,\n\t\t\t\tacc->events_array ? acc->events_array[i] : i);\n\n\t\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\t\tacc->lru_pages[i] +=\n\t\t\t\tmem_cgroup_nr_lru_pages(mi, BIT(i));\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void accumulate_memcg_tree(struct mem_cgroup *memcg,\n\t\t\t\t  struct accumulated_stats *acc)\n{\n\tstruct mem_cgroup *mi;\n\tint i;\n\n\tfor_each_mem_cgroup_tree(mi, memcg) {\n\t\tfor (i = 0; i < acc->stats_size; i++)\n\t\t\tacc->stat[i] += memcg_page_state(mi,\n\t\t\t\tacc->stats_array ? acc->stats_array[i] : i);\n\n\t\tfor (i = 0; i < acc->events_size; i++)\n\t\t\tacc->events[i] += memcg_sum_events(mi,\n\t\t\t\tacc->events_array ? acc->events_array[i] : i);\n\n\t\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\t\tacc->lru_pages[i] +=\n\t\t\t\tmem_cgroup_nr_lru_pages(mi, BIT(i));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&acc",
            "0",
            "sizeof(acc)"
          ],
          "line": 5536
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 5521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 5521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic const char *const mem_cgroup_lru_names[] = {\n\t\"inactive_anon\",\n\t\"active_anon\",\n\t\"inactive_file\",\n\t\"active_file\",\n\t\"unevictable\",\n};\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_stat_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tstruct accumulated_stats acc;\n\tint i;\n\n\t/*\n\t * Provide statistics on the state of the memory subsystem as\n\t * well as cumulative event counters that show past behavior.\n\t *\n\t * This list is ordered following a combination of these gradients:\n\t * 1) generic big picture -> specifics and details\n\t * 2) reflecting userspace activity -> reflecting kernel heuristics\n\t *\n\t * Current memory state:\n\t */\n\n\tmemset(&acc, 0, sizeof(acc));\n\tacc.stats_size = MEMCG_NR_STAT;\n\tacc.events_size = NR_VM_EVENT_ITEMS;\n\taccumulate_memcg_tree(memcg, &acc);\n\n\tseq_printf(m, \"anon %llu\\n\",\n\t\t   (u64)acc.stat[MEMCG_RSS] * PAGE_SIZE);\n\tseq_printf(m, \"file %llu\\n\",\n\t\t   (u64)acc.stat[MEMCG_CACHE] * PAGE_SIZE);\n\tseq_printf(m, \"kernel_stack %llu\\n\",\n\t\t   (u64)acc.stat[MEMCG_KERNEL_STACK_KB] * 1024);\n\tseq_printf(m, \"slab %llu\\n\",\n\t\t   (u64)(acc.stat[NR_SLAB_RECLAIMABLE] +\n\t\t\t acc.stat[NR_SLAB_UNRECLAIMABLE]) * PAGE_SIZE);\n\tseq_printf(m, \"sock %llu\\n\",\n\t\t   (u64)acc.stat[MEMCG_SOCK] * PAGE_SIZE);\n\n\tseq_printf(m, \"shmem %llu\\n\",\n\t\t   (u64)acc.stat[NR_SHMEM] * PAGE_SIZE);\n\tseq_printf(m, \"file_mapped %llu\\n\",\n\t\t   (u64)acc.stat[NR_FILE_MAPPED] * PAGE_SIZE);\n\tseq_printf(m, \"file_dirty %llu\\n\",\n\t\t   (u64)acc.stat[NR_FILE_DIRTY] * PAGE_SIZE);\n\tseq_printf(m, \"file_writeback %llu\\n\",\n\t\t   (u64)acc.stat[NR_WRITEBACK] * PAGE_SIZE);\n\n\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\tseq_printf(m, \"%s %llu\\n\", mem_cgroup_lru_names[i],\n\t\t\t   (u64)acc.lru_pages[i] * PAGE_SIZE);\n\n\tseq_printf(m, \"slab_reclaimable %llu\\n\",\n\t\t   (u64)acc.stat[NR_SLAB_RECLAIMABLE] * PAGE_SIZE);\n\tseq_printf(m, \"slab_unreclaimable %llu\\n\",\n\t\t   (u64)acc.stat[NR_SLAB_UNRECLAIMABLE] * PAGE_SIZE);\n\n\t/* Accumulated memory events */\n\n\tseq_printf(m, \"pgfault %lu\\n\", acc.events[PGFAULT]);\n\tseq_printf(m, \"pgmajfault %lu\\n\", acc.events[PGMAJFAULT]);\n\n\tseq_printf(m, \"workingset_refault %lu\\n\",\n\t\t   acc.stat[WORKINGSET_REFAULT]);\n\tseq_printf(m, \"workingset_activate %lu\\n\",\n\t\t   acc.stat[WORKINGSET_ACTIVATE]);\n\tseq_printf(m, \"workingset_nodereclaim %lu\\n\",\n\t\t   acc.stat[WORKINGSET_NODERECLAIM]);\n\n\tseq_printf(m, \"pgrefill %lu\\n\", acc.events[PGREFILL]);\n\tseq_printf(m, \"pgscan %lu\\n\", acc.events[PGSCAN_KSWAPD] +\n\t\t   acc.events[PGSCAN_DIRECT]);\n\tseq_printf(m, \"pgsteal %lu\\n\", acc.events[PGSTEAL_KSWAPD] +\n\t\t   acc.events[PGSTEAL_DIRECT]);\n\tseq_printf(m, \"pgactivate %lu\\n\", acc.events[PGACTIVATE]);\n\tseq_printf(m, \"pgdeactivate %lu\\n\", acc.events[PGDEACTIVATE]);\n\tseq_printf(m, \"pglazyfree %lu\\n\", acc.events[PGLAZYFREE]);\n\tseq_printf(m, \"pglazyfreed %lu\\n\", acc.events[PGLAZYFREED]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memory_events_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5501-5517",
    "snippet": "static int memory_events_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tseq_printf(m, \"low %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_LOW]));\n\tseq_printf(m, \"high %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_HIGH]));\n\tseq_printf(m, \"max %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_MAX]));\n\tseq_printf(m, \"oom %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_OOM]));\n\tseq_printf(m, \"oom_kill %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_OOM_KILL]));\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"oom_kill %lu\\n\"",
            "atomic_long_read(&memcg->memory_events[MEMCG_OOM_KILL])"
          ],
          "line": 5513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&memcg->memory_events[MEMCG_OOM_KILL]"
          ],
          "line": 5514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"oom %lu\\n\"",
            "atomic_long_read(&memcg->memory_events[MEMCG_OOM])"
          ],
          "line": 5511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&memcg->memory_events[MEMCG_OOM]"
          ],
          "line": 5512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"max %lu\\n\"",
            "atomic_long_read(&memcg->memory_events[MEMCG_MAX])"
          ],
          "line": 5509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&memcg->memory_events[MEMCG_MAX]"
          ],
          "line": 5510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"high %lu\\n\"",
            "atomic_long_read(&memcg->memory_events[MEMCG_HIGH])"
          ],
          "line": 5507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&memcg->memory_events[MEMCG_HIGH]"
          ],
          "line": 5508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"low %lu\\n\"",
            "atomic_long_read(&memcg->memory_events[MEMCG_LOW])"
          ],
          "line": 5505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&memcg->memory_events[MEMCG_LOW]"
          ],
          "line": 5506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 5503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 5503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_events_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tseq_printf(m, \"low %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_LOW]));\n\tseq_printf(m, \"high %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_HIGH]));\n\tseq_printf(m, \"max %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_MAX]));\n\tseq_printf(m, \"oom %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_OOM]));\n\tseq_printf(m, \"oom_kill %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_OOM_KILL]));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memory_max_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5452-5499",
    "snippet": "static ssize_t memory_max_write(struct kernfs_open_file *of,\n\t\t\t\tchar *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned int nr_reclaims = MEM_CGROUP_RECLAIM_RETRIES;\n\tbool drained = false;\n\tunsigned long max;\n\tint err;\n\n\tbuf = strstrip(buf);\n\terr = page_counter_memparse(buf, \"max\", &max);\n\tif (err)\n\t\treturn err;\n\n\txchg(&memcg->memory.max, max);\n\n\tfor (;;) {\n\t\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\n\t\tif (nr_pages <= max)\n\t\t\tbreak;\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!drained) {\n\t\t\tdrain_all_stock(memcg);\n\t\t\tdrained = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nr_reclaims) {\n\t\t\tif (!try_to_free_mem_cgroup_pages(memcg, nr_pages - max,\n\t\t\t\t\t\t\t  GFP_KERNEL, true))\n\t\t\t\tnr_reclaims--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemcg_memory_event(memcg, MEMCG_OOM);\n\t\tif (!mem_cgroup_out_of_memory(memcg, GFP_KERNEL, 0))\n\t\t\tbreak;\n\t}\n\n\tmemcg_wb_domain_size_changed(memcg);\n\treturn nbytes;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define MEM_CGROUP_RECLAIM_RETRIES\t5"
    ],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_wb_domain_size_changed",
          "args": [
            "memcg"
          ],
          "line": 5497
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_wb_domain_size_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3906-3908",
          "snippet": "static void memcg_wb_domain_size_changed(struct mem_cgroup *memcg)\n{\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_wb_domain_size_changed(struct mem_cgroup *memcg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_out_of_memory",
          "args": [
            "memcg",
            "GFP_KERNEL",
            "0"
          ],
          "line": 5493
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_out_of_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1373-1389",
          "snippet": "static bool mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t\t\t     int order)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = NULL,\n\t\t.nodemask = NULL,\n\t\t.memcg = memcg,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tbool ret;\n\n\tmutex_lock(&oom_lock);\n\tret = out_of_memory(&oc);\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic bool mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t\t\t     int order)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = NULL,\n\t\t.nodemask = NULL,\n\t\t.memcg = memcg,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tbool ret;\n\n\tmutex_lock(&oom_lock);\n\tret = out_of_memory(&oc);\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_memory_event",
          "args": [
            "memcg",
            "MEMCG_OOM"
          ],
          "line": 5492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_free_mem_cgroup_pages",
          "args": [
            "memcg",
            "nr_pages - max",
            "GFP_KERNEL",
            "true"
          ],
          "line": 5486
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_mem_cgroup_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3311-3358",
          "snippet": "unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_all_stock",
          "args": [
            "memcg"
          ],
          "line": 5480
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2028-2063",
          "snippet": "static void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define FLUSHING_CACHED_CHARGE\t0"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);",
            "static DEFINE_MUTEX(percpu_charge_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define FLUSHING_CACHED_CHARGE\t0\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\nstatic DEFINE_MUTEX(percpu_charge_mutex);\n\nstatic void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 5474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 5469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&memcg->memory.max",
            "max"
          ],
          "line": 5466
        },
        "resolved": true,
        "details": {
          "function_name": "page_cpupid_xchg_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "100-114",
          "snippet": "int page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_memparse",
          "args": [
            "buf",
            "\"max\"",
            "&max"
          ],
          "line": 5462
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "248-266",
          "snippet": "int page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "of_css(of)"
          ],
          "line": 5455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 5455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MEM_CGROUP_RECLAIM_RETRIES\t5\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic ssize_t memory_max_write(struct kernfs_open_file *of,\n\t\t\t\tchar *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned int nr_reclaims = MEM_CGROUP_RECLAIM_RETRIES;\n\tbool drained = false;\n\tunsigned long max;\n\tint err;\n\n\tbuf = strstrip(buf);\n\terr = page_counter_memparse(buf, \"max\", &max);\n\tif (err)\n\t\treturn err;\n\n\txchg(&memcg->memory.max, max);\n\n\tfor (;;) {\n\t\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\n\t\tif (nr_pages <= max)\n\t\t\tbreak;\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!drained) {\n\t\t\tdrain_all_stock(memcg);\n\t\t\tdrained = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nr_reclaims) {\n\t\t\tif (!try_to_free_mem_cgroup_pages(memcg, nr_pages - max,\n\t\t\t\t\t\t\t  GFP_KERNEL, true))\n\t\t\t\tnr_reclaims--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemcg_memory_event(memcg, MEMCG_OOM);\n\t\tif (!mem_cgroup_out_of_memory(memcg, GFP_KERNEL, 0))\n\t\t\tbreak;\n\t}\n\n\tmemcg_wb_domain_size_changed(memcg);\n\treturn nbytes;\n}"
  },
  {
    "function_name": "memory_max_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5439-5450",
    "snippet": "static int memory_max_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long max = READ_ONCE(memcg->memory.max);\n\n\tif (max == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)max * PAGE_SIZE);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%llu\\n\"",
            "(u64)max * PAGE_SIZE"
          ],
          "line": 5447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"max\\n\""
          ],
          "line": 5445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "memcg->memory.max"
          ],
          "line": 5442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 5441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 5441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_max_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long max = READ_ONCE(memcg->memory.max);\n\n\tif (max == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)max * PAGE_SIZE);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memory_high_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5415-5437",
    "snippet": "static ssize_t memory_high_write(struct kernfs_open_file *of,\n\t\t\t\t char *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned long nr_pages;\n\tunsigned long high;\n\tint err;\n\n\tbuf = strstrip(buf);\n\terr = page_counter_memparse(buf, \"max\", &high);\n\tif (err)\n\t\treturn err;\n\n\tmemcg->high = high;\n\n\tnr_pages = page_counter_read(&memcg->memory);\n\tif (nr_pages > high)\n\t\ttry_to_free_mem_cgroup_pages(memcg, nr_pages - high,\n\t\t\t\t\t     GFP_KERNEL, true);\n\n\tmemcg_wb_domain_size_changed(memcg);\n\treturn nbytes;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_wb_domain_size_changed",
          "args": [
            "memcg"
          ],
          "line": 5435
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_wb_domain_size_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3906-3908",
          "snippet": "static void memcg_wb_domain_size_changed(struct mem_cgroup *memcg)\n{\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_wb_domain_size_changed(struct mem_cgroup *memcg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_mem_cgroup_pages",
          "args": [
            "memcg",
            "nr_pages - high",
            "GFP_KERNEL",
            "true"
          ],
          "line": 5432
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_mem_cgroup_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3311-3358",
          "snippet": "unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 5430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_memparse",
          "args": [
            "buf",
            "\"max\"",
            "&high"
          ],
          "line": 5424
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "248-266",
          "snippet": "int page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 5423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "of_css(of)"
          ],
          "line": 5418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 5418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic ssize_t memory_high_write(struct kernfs_open_file *of,\n\t\t\t\t char *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned long nr_pages;\n\tunsigned long high;\n\tint err;\n\n\tbuf = strstrip(buf);\n\terr = page_counter_memparse(buf, \"max\", &high);\n\tif (err)\n\t\treturn err;\n\n\tmemcg->high = high;\n\n\tnr_pages = page_counter_read(&memcg->memory);\n\tif (nr_pages > high)\n\t\ttry_to_free_mem_cgroup_pages(memcg, nr_pages - high,\n\t\t\t\t\t     GFP_KERNEL, true);\n\n\tmemcg_wb_domain_size_changed(memcg);\n\treturn nbytes;\n}"
  },
  {
    "function_name": "memory_high_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5402-5413",
    "snippet": "static int memory_high_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long high = READ_ONCE(memcg->high);\n\n\tif (high == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)high * PAGE_SIZE);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%llu\\n\"",
            "(u64)high * PAGE_SIZE"
          ],
          "line": 5410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"max\\n\""
          ],
          "line": 5408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "memcg->high"
          ],
          "line": 5405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 5404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 5404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_high_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long high = READ_ONCE(memcg->high);\n\n\tif (high == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)high * PAGE_SIZE);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memory_low_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5385-5400",
    "snippet": "static ssize_t memory_low_write(struct kernfs_open_file *of,\n\t\t\t\tchar *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned long low;\n\tint err;\n\n\tbuf = strstrip(buf);\n\terr = page_counter_memparse(buf, \"max\", &low);\n\tif (err)\n\t\treturn err;\n\n\tpage_counter_set_low(&memcg->memory, low);\n\n\treturn nbytes;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_set_low",
          "args": [
            "&memcg->memory",
            "low"
          ],
          "line": 5397
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "229-237",
          "snippet": "void page_counter_set_low(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->low = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_set_low(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->low = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_memparse",
          "args": [
            "buf",
            "\"max\"",
            "&low"
          ],
          "line": 5393
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "248-266",
          "snippet": "int page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 5392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "of_css(of)"
          ],
          "line": 5388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 5388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic ssize_t memory_low_write(struct kernfs_open_file *of,\n\t\t\t\tchar *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned long low;\n\tint err;\n\n\tbuf = strstrip(buf);\n\terr = page_counter_memparse(buf, \"max\", &low);\n\tif (err)\n\t\treturn err;\n\n\tpage_counter_set_low(&memcg->memory, low);\n\n\treturn nbytes;\n}"
  },
  {
    "function_name": "memory_low_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5372-5383",
    "snippet": "static int memory_low_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long low = READ_ONCE(memcg->memory.low);\n\n\tif (low == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)low * PAGE_SIZE);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%llu\\n\"",
            "(u64)low * PAGE_SIZE"
          ],
          "line": 5380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"max\\n\""
          ],
          "line": 5378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "memcg->memory.low"
          ],
          "line": 5375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 5374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 5374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_low_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long low = READ_ONCE(memcg->memory.low);\n\n\tif (low == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)low * PAGE_SIZE);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memory_min_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5355-5370",
    "snippet": "static ssize_t memory_min_write(struct kernfs_open_file *of,\n\t\t\t\tchar *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned long min;\n\tint err;\n\n\tbuf = strstrip(buf);\n\terr = page_counter_memparse(buf, \"max\", &min);\n\tif (err)\n\t\treturn err;\n\n\tpage_counter_set_min(&memcg->memory, min);\n\n\treturn nbytes;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_set_min",
          "args": [
            "&memcg->memory",
            "min"
          ],
          "line": 5367
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "212-220",
          "snippet": "void page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->min = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->min = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_memparse",
          "args": [
            "buf",
            "\"max\"",
            "&min"
          ],
          "line": 5363
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "248-266",
          "snippet": "int page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 5362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "of_css(of)"
          ],
          "line": 5358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 5358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic ssize_t memory_min_write(struct kernfs_open_file *of,\n\t\t\t\tchar *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned long min;\n\tint err;\n\n\tbuf = strstrip(buf);\n\terr = page_counter_memparse(buf, \"max\", &min);\n\tif (err)\n\t\treturn err;\n\n\tpage_counter_set_min(&memcg->memory, min);\n\n\treturn nbytes;\n}"
  },
  {
    "function_name": "memory_min_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5342-5353",
    "snippet": "static int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%llu\\n\"",
            "(u64)min * PAGE_SIZE"
          ],
          "line": 5350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"max\\n\""
          ],
          "line": 5348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "memcg->memory.min"
          ],
          "line": 5345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 5344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 5344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memory_current_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5334-5340",
    "snippet": "static u64 memory_current_read(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\treturn (u64)page_counter_read(&memcg->memory) * PAGE_SIZE;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 5339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 5337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic u64 memory_current_read(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\treturn (u64)page_counter_read(&memcg->memory) * PAGE_SIZE;\n}"
  },
  {
    "function_name": "mem_cgroup_bind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5321-5332",
    "snippet": "static void mem_cgroup_bind(struct cgroup_subsys_state *root_css)\n{\n\t/*\n\t * use_hierarchy is forced on the default hierarchy.  cgroup core\n\t * guarantees that @root doesn't have any children, so turning it\n\t * on for the root memcg is enough.\n\t */\n\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\troot_mem_cgroup->use_hierarchy = true;\n\telse\n\t\troot_mem_cgroup->use_hierarchy = false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 5328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic void mem_cgroup_bind(struct cgroup_subsys_state *root_css)\n{\n\t/*\n\t * use_hierarchy is forced on the default hierarchy.  cgroup core\n\t * guarantees that @root doesn't have any children, so turning it\n\t * on for the root memcg is enough.\n\t */\n\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\troot_mem_cgroup->use_hierarchy = true;\n\telse\n\t\troot_mem_cgroup->use_hierarchy = false;\n}"
  },
  {
    "function_name": "mem_cgroup_move_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5311-5313",
    "snippet": "static void mem_cgroup_move_task(void)\n{\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_move_task(void)\n{\n}"
  },
  {
    "function_name": "mem_cgroup_cancel_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5308-5310",
    "snippet": "static void mem_cgroup_cancel_attach(struct cgroup_taskset *tset)\n{\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void mem_cgroup_cancel_attach(struct cgroup_taskset *tset)\n{\n}"
  },
  {
    "function_name": "mem_cgroup_can_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5304-5307",
    "snippet": "static int mem_cgroup_can_attach(struct cgroup_taskset *tset)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic int mem_cgroup_can_attach(struct cgroup_taskset *tset)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_move_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5296-5302",
    "snippet": "static void mem_cgroup_move_task(void)\n{\n\tif (mc.to) {\n\t\tmem_cgroup_move_charge();\n\t\tmem_cgroup_clear_mc();\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_clear_mc",
          "args": [],
          "line": 5300
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_clear_mc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5051-5068",
          "snippet": "static void mem_cgroup_clear_mc(void)\n{\n\tstruct mm_struct *mm = mc.mm;\n\n\t/*\n\t * we must clear moving_task before waking up waiters at the end of\n\t * task migration.\n\t */\n\tmc.moving_task = NULL;\n\t__mem_cgroup_clear_mc();\n\tspin_lock(&mc.lock);\n\tmc.from = NULL;\n\tmc.to = NULL;\n\tmc.mm = NULL;\n\tspin_unlock(&mc.lock);\n\n\tmmput(mm);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic void mem_cgroup_clear_mc(void)\n{\n\tstruct mm_struct *mm = mc.mm;\n\n\t/*\n\t * we must clear moving_task before waking up waiters at the end of\n\t * task migration.\n\t */\n\tmc.moving_task = NULL;\n\t__mem_cgroup_clear_mc();\n\tspin_lock(&mc.lock);\n\tmc.from = NULL;\n\tmc.to = NULL;\n\tmc.mm = NULL;\n\tspin_unlock(&mc.lock);\n\n\tmmput(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_move_charge",
          "args": [],
          "line": 5299
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_move_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5258-5294",
          "snippet": "static void mem_cgroup_move_charge(void)\n{\n\tstruct mm_walk mem_cgroup_move_charge_walk = {\n\t\t.pmd_entry = mem_cgroup_move_charge_pte_range,\n\t\t.mm = mc.mm,\n\t};\n\n\tlru_add_drain_all();\n\t/*\n\t * Signal lock_page_memcg() to take the memcg's move_lock\n\t * while we're moving its pages to another memcg. Then wait\n\t * for already started RCU-only updates to finish.\n\t */\n\tatomic_inc(&mc.from->moving_account);\n\tsynchronize_rcu();\nretry:\n\tif (unlikely(!down_read_trylock(&mc.mm->mmap_sem))) {\n\t\t/*\n\t\t * Someone who are holding the mmap_sem might be waiting in\n\t\t * waitq. So we cancel all extra charges, wake up all waiters,\n\t\t * and retry. Because we cancel precharges, we might not be able\n\t\t * to move enough charges, but moving charge is a best-effort\n\t\t * feature anyway, so it wouldn't be a big problem.\n\t\t */\n\t\t__mem_cgroup_clear_mc();\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\t/*\n\t * When we have consumed all precharges and failed in doing\n\t * additional charge, the page walk just aborts.\n\t */\n\twalk_page_range(0, mc.mm->highest_vm_end, &mem_cgroup_move_charge_walk);\n\n\tup_read(&mc.mm->mmap_sem);\n\tatomic_dec(&mc.from->moving_account);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic void mem_cgroup_move_charge(void)\n{\n\tstruct mm_walk mem_cgroup_move_charge_walk = {\n\t\t.pmd_entry = mem_cgroup_move_charge_pte_range,\n\t\t.mm = mc.mm,\n\t};\n\n\tlru_add_drain_all();\n\t/*\n\t * Signal lock_page_memcg() to take the memcg's move_lock\n\t * while we're moving its pages to another memcg. Then wait\n\t * for already started RCU-only updates to finish.\n\t */\n\tatomic_inc(&mc.from->moving_account);\n\tsynchronize_rcu();\nretry:\n\tif (unlikely(!down_read_trylock(&mc.mm->mmap_sem))) {\n\t\t/*\n\t\t * Someone who are holding the mmap_sem might be waiting in\n\t\t * waitq. So we cancel all extra charges, wake up all waiters,\n\t\t * and retry. Because we cancel precharges, we might not be able\n\t\t * to move enough charges, but moving charge is a best-effort\n\t\t * feature anyway, so it wouldn't be a big problem.\n\t\t */\n\t\t__mem_cgroup_clear_mc();\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\t/*\n\t * When we have consumed all precharges and failed in doing\n\t * additional charge, the page walk just aborts.\n\t */\n\twalk_page_range(0, mc.mm->highest_vm_end, &mem_cgroup_move_charge_walk);\n\n\tup_read(&mc.mm->mmap_sem);\n\tatomic_dec(&mc.from->moving_account);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\n\nstatic void mem_cgroup_move_task(void)\n{\n\tif (mc.to) {\n\t\tmem_cgroup_move_charge();\n\t\tmem_cgroup_clear_mc();\n\t}\n}"
  },
  {
    "function_name": "mem_cgroup_move_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5258-5294",
    "snippet": "static void mem_cgroup_move_charge(void)\n{\n\tstruct mm_walk mem_cgroup_move_charge_walk = {\n\t\t.pmd_entry = mem_cgroup_move_charge_pte_range,\n\t\t.mm = mc.mm,\n\t};\n\n\tlru_add_drain_all();\n\t/*\n\t * Signal lock_page_memcg() to take the memcg's move_lock\n\t * while we're moving its pages to another memcg. Then wait\n\t * for already started RCU-only updates to finish.\n\t */\n\tatomic_inc(&mc.from->moving_account);\n\tsynchronize_rcu();\nretry:\n\tif (unlikely(!down_read_trylock(&mc.mm->mmap_sem))) {\n\t\t/*\n\t\t * Someone who are holding the mmap_sem might be waiting in\n\t\t * waitq. So we cancel all extra charges, wake up all waiters,\n\t\t * and retry. Because we cancel precharges, we might not be able\n\t\t * to move enough charges, but moving charge is a best-effort\n\t\t * feature anyway, so it wouldn't be a big problem.\n\t\t */\n\t\t__mem_cgroup_clear_mc();\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\t/*\n\t * When we have consumed all precharges and failed in doing\n\t * additional charge, the page walk just aborts.\n\t */\n\twalk_page_range(0, mc.mm->highest_vm_end, &mem_cgroup_move_charge_walk);\n\n\tup_read(&mc.mm->mmap_sem);\n\tatomic_dec(&mc.from->moving_account);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&mc.from->moving_account"
          ],
          "line": 5293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mc.mm->mmap_sem"
          ],
          "line": 5292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "0",
            "mc.mm->highest_vm_end",
            "&mem_cgroup_move_charge_walk"
          ],
          "line": 5290
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "293-340",
          "snippet": "int walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 5283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_clear_mc",
          "args": [],
          "line": 5282
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_clear_mc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5008-5049",
          "snippet": "static void __mem_cgroup_clear_mc(void)\n{\n\tstruct mem_cgroup *from = mc.from;\n\tstruct mem_cgroup *to = mc.to;\n\n\t/* we must uncharge all the leftover precharges from mc.to */\n\tif (mc.precharge) {\n\t\tcancel_charge(mc.to, mc.precharge);\n\t\tmc.precharge = 0;\n\t}\n\t/*\n\t * we didn't uncharge from mc.from at mem_cgroup_move_account(), so\n\t * we must uncharge here.\n\t */\n\tif (mc.moved_charge) {\n\t\tcancel_charge(mc.from, mc.moved_charge);\n\t\tmc.moved_charge = 0;\n\t}\n\t/* we must fixup refcnts and charges */\n\tif (mc.moved_swap) {\n\t\t/* uncharge swap account from the old cgroup */\n\t\tif (!mem_cgroup_is_root(mc.from))\n\t\t\tpage_counter_uncharge(&mc.from->memsw, mc.moved_swap);\n\n\t\tmem_cgroup_id_put_many(mc.from, mc.moved_swap);\n\n\t\t/*\n\t\t * we charged both to->memory and to->memsw, so we\n\t\t * should uncharge to->memory.\n\t\t */\n\t\tif (!mem_cgroup_is_root(mc.to))\n\t\t\tpage_counter_uncharge(&mc.to->memory, mc.moved_swap);\n\n\t\tmem_cgroup_id_get_many(mc.to, mc.moved_swap);\n\t\tcss_put_many(&mc.to->css, mc.moved_swap);\n\n\t\tmc.moved_swap = 0;\n\t}\n\tmemcg_oom_recover(from);\n\tmemcg_oom_recover(to);\n\twake_up_all(&mc.waitq);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_clear_mc(void)\n{\n\tstruct mem_cgroup *from = mc.from;\n\tstruct mem_cgroup *to = mc.to;\n\n\t/* we must uncharge all the leftover precharges from mc.to */\n\tif (mc.precharge) {\n\t\tcancel_charge(mc.to, mc.precharge);\n\t\tmc.precharge = 0;\n\t}\n\t/*\n\t * we didn't uncharge from mc.from at mem_cgroup_move_account(), so\n\t * we must uncharge here.\n\t */\n\tif (mc.moved_charge) {\n\t\tcancel_charge(mc.from, mc.moved_charge);\n\t\tmc.moved_charge = 0;\n\t}\n\t/* we must fixup refcnts and charges */\n\tif (mc.moved_swap) {\n\t\t/* uncharge swap account from the old cgroup */\n\t\tif (!mem_cgroup_is_root(mc.from))\n\t\t\tpage_counter_uncharge(&mc.from->memsw, mc.moved_swap);\n\n\t\tmem_cgroup_id_put_many(mc.from, mc.moved_swap);\n\n\t\t/*\n\t\t * we charged both to->memory and to->memsw, so we\n\t\t * should uncharge to->memory.\n\t\t */\n\t\tif (!mem_cgroup_is_root(mc.to))\n\t\t\tpage_counter_uncharge(&mc.to->memory, mc.moved_swap);\n\n\t\tmem_cgroup_id_get_many(mc.to, mc.moved_swap);\n\t\tcss_put_many(&mc.to->css, mc.moved_swap);\n\n\t\tmc.moved_swap = 0;\n\t}\n\tmemcg_oom_recover(from);\n\tmemcg_oom_recover(to);\n\twake_up_all(&mc.waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!down_read_trylock(&mc.mm->mmap_sem)"
          ],
          "line": 5274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&mc.mm->mmap_sem"
          ],
          "line": 5274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 5272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&mc.from->moving_account"
          ],
          "line": 5271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 5265
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic void mem_cgroup_move_charge(void)\n{\n\tstruct mm_walk mem_cgroup_move_charge_walk = {\n\t\t.pmd_entry = mem_cgroup_move_charge_pte_range,\n\t\t.mm = mc.mm,\n\t};\n\n\tlru_add_drain_all();\n\t/*\n\t * Signal lock_page_memcg() to take the memcg's move_lock\n\t * while we're moving its pages to another memcg. Then wait\n\t * for already started RCU-only updates to finish.\n\t */\n\tatomic_inc(&mc.from->moving_account);\n\tsynchronize_rcu();\nretry:\n\tif (unlikely(!down_read_trylock(&mc.mm->mmap_sem))) {\n\t\t/*\n\t\t * Someone who are holding the mmap_sem might be waiting in\n\t\t * waitq. So we cancel all extra charges, wake up all waiters,\n\t\t * and retry. Because we cancel precharges, we might not be able\n\t\t * to move enough charges, but moving charge is a best-effort\n\t\t * feature anyway, so it wouldn't be a big problem.\n\t\t */\n\t\t__mem_cgroup_clear_mc();\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\t/*\n\t * When we have consumed all precharges and failed in doing\n\t * additional charge, the page walk just aborts.\n\t */\n\twalk_page_range(0, mc.mm->highest_vm_end, &mem_cgroup_move_charge_walk);\n\n\tup_read(&mc.mm->mmap_sem);\n\tatomic_dec(&mc.from->moving_account);\n}"
  },
  {
    "function_name": "mem_cgroup_move_charge_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5146-5256",
    "snippet": "static int mem_cgroup_move_charge_pte_range(pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tint ret = 0;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tenum mc_target_type target_type;\n\tunion mc_target target;\n\tstruct page *page;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tif (mc.precharge < HPAGE_PMD_NR) {\n\t\t\tspin_unlock(ptl);\n\t\t\treturn 0;\n\t\t}\n\t\ttarget_type = get_mctgt_type_thp(vma, addr, *pmd, &target);\n\t\tif (target_type == MC_TARGET_PAGE) {\n\t\t\tpage = target.page;\n\t\t\tif (!isolate_lru_page(page)) {\n\t\t\t\tif (!mem_cgroup_move_account(page, true,\n\t\t\t\t\t\t\t     mc.from, mc.to)) {\n\t\t\t\t\tmc.precharge -= HPAGE_PMD_NR;\n\t\t\t\t\tmc.moved_charge += HPAGE_PMD_NR;\n\t\t\t\t}\n\t\t\t\tputback_lru_page(page);\n\t\t\t}\n\t\t\tput_page(page);\n\t\t} else if (target_type == MC_TARGET_DEVICE) {\n\t\t\tpage = target.page;\n\t\t\tif (!mem_cgroup_move_account(page, true,\n\t\t\t\t\t\t     mc.from, mc.to)) {\n\t\t\t\tmc.precharge -= HPAGE_PMD_NR;\n\t\t\t\tmc.moved_charge += HPAGE_PMD_NR;\n\t\t\t}\n\t\t\tput_page(page);\n\t\t}\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\nretry:\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tpte_t ptent = *(pte++);\n\t\tbool device = false;\n\t\tswp_entry_t ent;\n\n\t\tif (!mc.precharge)\n\t\t\tbreak;\n\n\t\tswitch (get_mctgt_type(vma, addr, ptent, &target)) {\n\t\tcase MC_TARGET_DEVICE:\n\t\t\tdevice = true;\n\t\t\t/* fall through */\n\t\tcase MC_TARGET_PAGE:\n\t\t\tpage = target.page;\n\t\t\t/*\n\t\t\t * We can have a part of the split pmd here. Moving it\n\t\t\t * can be done but it would be too convoluted so simply\n\t\t\t * ignore such a partial THP and keep it in original\n\t\t\t * memcg. There should be somebody mapping the head.\n\t\t\t */\n\t\t\tif (PageTransCompound(page))\n\t\t\t\tgoto put;\n\t\t\tif (!device && isolate_lru_page(page))\n\t\t\t\tgoto put;\n\t\t\tif (!mem_cgroup_move_account(page, false,\n\t\t\t\t\t\tmc.from, mc.to)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we uncharge from mc.from later. */\n\t\t\t\tmc.moved_charge++;\n\t\t\t}\n\t\t\tif (!device)\n\t\t\t\tputback_lru_page(page);\nput:\t\t\t/* get_mctgt_type() gets the page */\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\tcase MC_TARGET_SWAP:\n\t\t\tent = target.ent;\n\t\t\tif (!mem_cgroup_move_swap_account(ent, mc.from, mc.to)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we fixup refcnts and charges later. */\n\t\t\t\tmc.moved_swap++;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\tif (addr != end) {\n\t\t/*\n\t\t * We have consumed all precharges we got in can_attach().\n\t\t * We try charge one by one, but don't do any additional\n\t\t * charges to mc.to if we have failed in charge once in attach()\n\t\t * phase.\n\t\t */\n\t\tret = mem_cgroup_do_precharge(1);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_do_precharge",
          "args": [
            "1"
          ],
          "line": 5250
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_do_precharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4613-4633",
          "snippet": "static int mem_cgroup_do_precharge(unsigned long count)\n{\n\tint ret;\n\n\t/* Try a single bulk charge without reclaim first, kswapd may wake */\n\tret = try_charge(mc.to, GFP_KERNEL & ~__GFP_DIRECT_RECLAIM, count);\n\tif (!ret) {\n\t\tmc.precharge += count;\n\t\treturn ret;\n\t}\n\n\t/* Try charges one by one with reclaim, but do not retry */\n\twhile (count--) {\n\t\tret = try_charge(mc.to, GFP_KERNEL | __GFP_NORETRY, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmc.precharge++;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\n\nstatic int mem_cgroup_do_precharge(unsigned long count)\n{\n\tint ret;\n\n\t/* Try a single bulk charge without reclaim first, kswapd may wake */\n\tret = try_charge(mc.to, GFP_KERNEL & ~__GFP_DIRECT_RECLAIM, count);\n\tif (!ret) {\n\t\tmc.precharge += count;\n\t\treturn ret;\n\t}\n\n\t/* Try charges one by one with reclaim, but do not retry */\n\twhile (count--) {\n\t\tret = try_charge(mc.to, GFP_KERNEL | __GFP_NORETRY, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmc.precharge++;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 5241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte - 1",
            "ptl"
          ],
          "line": 5240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_move_swap_account",
          "args": [
            "ent",
            "mc.from",
            "mc.to"
          ],
          "line": 5230
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_move_swap_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2691-2695",
          "snippet": "static inline int mem_cgroup_move_swap_account(swp_entry_t entry,\n\t\t\t\tstruct mem_cgroup *from, struct mem_cgroup *to)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic inline int mem_cgroup_move_swap_account(swp_entry_t entry,\n\t\t\t\tstruct mem_cgroup *from, struct mem_cgroup *to)\n{\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 5226
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 5224
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_move_account",
          "args": [
            "page",
            "false",
            "mc.from",
            "mc.to"
          ],
          "line": 5217
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_move_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4758-4834",
          "snippet": "static int mem_cgroup_move_account(struct page *page,\n\t\t\t\t   bool compound,\n\t\t\t\t   struct mem_cgroup *from,\n\t\t\t\t   struct mem_cgroup *to)\n{\n\tunsigned long flags;\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\tint ret;\n\tbool anon;\n\n\tVM_BUG_ON(from == to);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON(compound && !PageTransHuge(page));\n\n\t/*\n\t * Prevent mem_cgroup_migrate() from looking at\n\t * page->mem_cgroup of its source page while we change it.\n\t */\n\tret = -EBUSY;\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (page->mem_cgroup != from)\n\t\tgoto out_unlock;\n\n\tanon = PageAnon(page);\n\n\tspin_lock_irqsave(&from->move_lock, flags);\n\n\tif (!anon && page_mapped(page)) {\n\t\t__mod_memcg_state(from, NR_FILE_MAPPED, -nr_pages);\n\t\t__mod_memcg_state(to, NR_FILE_MAPPED, nr_pages);\n\t}\n\n\t/*\n\t * move_lock grabbed above and caller set from->moving_account, so\n\t * mod_memcg_page_state will serialize updates to PageDirty.\n\t * So mapping should be stable for dirty pages.\n\t */\n\tif (!anon && PageDirty(page)) {\n\t\tstruct address_space *mapping = page_mapping(page);\n\n\t\tif (mapping_cap_account_dirty(mapping)) {\n\t\t\t__mod_memcg_state(from, NR_FILE_DIRTY, -nr_pages);\n\t\t\t__mod_memcg_state(to, NR_FILE_DIRTY, nr_pages);\n\t\t}\n\t}\n\n\tif (PageWriteback(page)) {\n\t\t__mod_memcg_state(from, NR_WRITEBACK, -nr_pages);\n\t\t__mod_memcg_state(to, NR_WRITEBACK, nr_pages);\n\t}\n\n\t/*\n\t * It is safe to change page->mem_cgroup here because the page\n\t * is referenced, charged, and isolated - we can't race with\n\t * uncharging, charging, migration, or LRU putback.\n\t */\n\n\t/* caller should have done css_get */\n\tpage->mem_cgroup = to;\n\tspin_unlock_irqrestore(&from->move_lock, flags);\n\n\tret = 0;\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(to, page, compound, nr_pages);\n\tmemcg_check_events(to, page);\n\tmem_cgroup_charge_statistics(from, page, compound, -nr_pages);\n\tmemcg_check_events(from, page);\n\tlocal_irq_enable();\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic int mem_cgroup_move_account(struct page *page,\n\t\t\t\t   bool compound,\n\t\t\t\t   struct mem_cgroup *from,\n\t\t\t\t   struct mem_cgroup *to)\n{\n\tunsigned long flags;\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\tint ret;\n\tbool anon;\n\n\tVM_BUG_ON(from == to);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON(compound && !PageTransHuge(page));\n\n\t/*\n\t * Prevent mem_cgroup_migrate() from looking at\n\t * page->mem_cgroup of its source page while we change it.\n\t */\n\tret = -EBUSY;\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (page->mem_cgroup != from)\n\t\tgoto out_unlock;\n\n\tanon = PageAnon(page);\n\n\tspin_lock_irqsave(&from->move_lock, flags);\n\n\tif (!anon && page_mapped(page)) {\n\t\t__mod_memcg_state(from, NR_FILE_MAPPED, -nr_pages);\n\t\t__mod_memcg_state(to, NR_FILE_MAPPED, nr_pages);\n\t}\n\n\t/*\n\t * move_lock grabbed above and caller set from->moving_account, so\n\t * mod_memcg_page_state will serialize updates to PageDirty.\n\t * So mapping should be stable for dirty pages.\n\t */\n\tif (!anon && PageDirty(page)) {\n\t\tstruct address_space *mapping = page_mapping(page);\n\n\t\tif (mapping_cap_account_dirty(mapping)) {\n\t\t\t__mod_memcg_state(from, NR_FILE_DIRTY, -nr_pages);\n\t\t\t__mod_memcg_state(to, NR_FILE_DIRTY, nr_pages);\n\t\t}\n\t}\n\n\tif (PageWriteback(page)) {\n\t\t__mod_memcg_state(from, NR_WRITEBACK, -nr_pages);\n\t\t__mod_memcg_state(to, NR_WRITEBACK, nr_pages);\n\t}\n\n\t/*\n\t * It is safe to change page->mem_cgroup here because the page\n\t * is referenced, charged, and isolated - we can't race with\n\t * uncharging, charging, migration, or LRU putback.\n\t */\n\n\t/* caller should have done css_get */\n\tpage->mem_cgroup = to;\n\tspin_unlock_irqrestore(&from->move_lock, flags);\n\n\tret = 0;\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(to, page, compound, nr_pages);\n\tmemcg_check_events(to, page);\n\tmem_cgroup_charge_statistics(from, page, compound, -nr_pages);\n\tmemcg_check_events(from, page);\n\tlocal_irq_enable();\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "page"
          ],
          "line": 5215
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 5213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mctgt_type",
          "args": [
            "vma",
            "addr",
            "ptent",
            "&target"
          ],
          "line": 5201
        },
        "resolved": true,
        "details": {
          "function_name": "get_mctgt_type_thp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4939-4943",
          "snippet": "static inline enum mc_target_type get_mctgt_type_thp(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t pmd, union mc_target *target)\n{\n\treturn MC_TARGET_NONE;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic inline enum mc_target_type get_mctgt_type_thp(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t pmd, union mc_target *target)\n{\n\treturn MC_TARGET_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 5192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 5189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 5185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 5161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge_lock",
          "args": [
            "pmd",
            "vma"
          ],
          "line": 5158
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_trans_huge_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1957-1966",
          "snippet": "spinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic int mem_cgroup_move_charge_pte_range(pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tint ret = 0;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tenum mc_target_type target_type;\n\tunion mc_target target;\n\tstruct page *page;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tif (mc.precharge < HPAGE_PMD_NR) {\n\t\t\tspin_unlock(ptl);\n\t\t\treturn 0;\n\t\t}\n\t\ttarget_type = get_mctgt_type_thp(vma, addr, *pmd, &target);\n\t\tif (target_type == MC_TARGET_PAGE) {\n\t\t\tpage = target.page;\n\t\t\tif (!isolate_lru_page(page)) {\n\t\t\t\tif (!mem_cgroup_move_account(page, true,\n\t\t\t\t\t\t\t     mc.from, mc.to)) {\n\t\t\t\t\tmc.precharge -= HPAGE_PMD_NR;\n\t\t\t\t\tmc.moved_charge += HPAGE_PMD_NR;\n\t\t\t\t}\n\t\t\t\tputback_lru_page(page);\n\t\t\t}\n\t\t\tput_page(page);\n\t\t} else if (target_type == MC_TARGET_DEVICE) {\n\t\t\tpage = target.page;\n\t\t\tif (!mem_cgroup_move_account(page, true,\n\t\t\t\t\t\t     mc.from, mc.to)) {\n\t\t\t\tmc.precharge -= HPAGE_PMD_NR;\n\t\t\t\tmc.moved_charge += HPAGE_PMD_NR;\n\t\t\t}\n\t\t\tput_page(page);\n\t\t}\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\nretry:\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tpte_t ptent = *(pte++);\n\t\tbool device = false;\n\t\tswp_entry_t ent;\n\n\t\tif (!mc.precharge)\n\t\t\tbreak;\n\n\t\tswitch (get_mctgt_type(vma, addr, ptent, &target)) {\n\t\tcase MC_TARGET_DEVICE:\n\t\t\tdevice = true;\n\t\t\t/* fall through */\n\t\tcase MC_TARGET_PAGE:\n\t\t\tpage = target.page;\n\t\t\t/*\n\t\t\t * We can have a part of the split pmd here. Moving it\n\t\t\t * can be done but it would be too convoluted so simply\n\t\t\t * ignore such a partial THP and keep it in original\n\t\t\t * memcg. There should be somebody mapping the head.\n\t\t\t */\n\t\t\tif (PageTransCompound(page))\n\t\t\t\tgoto put;\n\t\t\tif (!device && isolate_lru_page(page))\n\t\t\t\tgoto put;\n\t\t\tif (!mem_cgroup_move_account(page, false,\n\t\t\t\t\t\tmc.from, mc.to)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we uncharge from mc.from later. */\n\t\t\t\tmc.moved_charge++;\n\t\t\t}\n\t\t\tif (!device)\n\t\t\t\tputback_lru_page(page);\nput:\t\t\t/* get_mctgt_type() gets the page */\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\tcase MC_TARGET_SWAP:\n\t\t\tent = target.ent;\n\t\t\tif (!mem_cgroup_move_swap_account(ent, mc.from, mc.to)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we fixup refcnts and charges later. */\n\t\t\t\tmc.moved_swap++;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\tif (addr != end) {\n\t\t/*\n\t\t * We have consumed all precharges we got in can_attach().\n\t\t * We try charge one by one, but don't do any additional\n\t\t * charges to mc.to if we have failed in charge once in attach()\n\t\t * phase.\n\t\t */\n\t\tret = mem_cgroup_do_precharge(1);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mem_cgroup_cancel_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5140-5144",
    "snippet": "static void mem_cgroup_cancel_attach(struct cgroup_taskset *tset)\n{\n\tif (mc.to)\n\t\tmem_cgroup_clear_mc();\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_clear_mc",
          "args": [],
          "line": 5143
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_clear_mc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5051-5068",
          "snippet": "static void mem_cgroup_clear_mc(void)\n{\n\tstruct mm_struct *mm = mc.mm;\n\n\t/*\n\t * we must clear moving_task before waking up waiters at the end of\n\t * task migration.\n\t */\n\tmc.moving_task = NULL;\n\t__mem_cgroup_clear_mc();\n\tspin_lock(&mc.lock);\n\tmc.from = NULL;\n\tmc.to = NULL;\n\tmc.mm = NULL;\n\tspin_unlock(&mc.lock);\n\n\tmmput(mm);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic void mem_cgroup_clear_mc(void)\n{\n\tstruct mm_struct *mm = mc.mm;\n\n\t/*\n\t * we must clear moving_task before waking up waiters at the end of\n\t * task migration.\n\t */\n\tmc.moving_task = NULL;\n\t__mem_cgroup_clear_mc();\n\tspin_lock(&mc.lock);\n\tmc.from = NULL;\n\tmc.to = NULL;\n\tmc.mm = NULL;\n\tspin_unlock(&mc.lock);\n\n\tmmput(mm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic void mem_cgroup_cancel_attach(struct cgroup_taskset *tset)\n{\n\tif (mc.to)\n\t\tmem_cgroup_clear_mc();\n}"
  },
  {
    "function_name": "mem_cgroup_can_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5070-5138",
    "snippet": "static int mem_cgroup_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct mem_cgroup *memcg = NULL; /* unneeded init to make gcc happy */\n\tstruct mem_cgroup *from;\n\tstruct task_struct *leader, *p;\n\tstruct mm_struct *mm;\n\tunsigned long move_flags;\n\tint ret = 0;\n\n\t/* charge immigration isn't supported on the default hierarchy */\n\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn 0;\n\n\t/*\n\t * Multi-process migrations only happen on the default hierarchy\n\t * where charge immigration is not used.  Perform charge\n\t * immigration if @tset contains a leader and whine if there are\n\t * multiple.\n\t */\n\tp = NULL;\n\tcgroup_taskset_for_each_leader(leader, css, tset) {\n\t\tWARN_ON_ONCE(p);\n\t\tp = leader;\n\t\tmemcg = mem_cgroup_from_css(css);\n\t}\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * We are now commited to this value whatever it is. Changes in this\n\t * tunable will only affect upcoming migrations, not the current one.\n\t * So we need to save it, and keep it going.\n\t */\n\tmove_flags = READ_ONCE(memcg->move_charge_at_immigrate);\n\tif (!move_flags)\n\t\treturn 0;\n\n\tfrom = mem_cgroup_from_task(p);\n\n\tVM_BUG_ON(from == memcg);\n\n\tmm = get_task_mm(p);\n\tif (!mm)\n\t\treturn 0;\n\t/* We move charges only when we move a owner of the mm */\n\tif (mm->owner == p) {\n\t\tVM_BUG_ON(mc.from);\n\t\tVM_BUG_ON(mc.to);\n\t\tVM_BUG_ON(mc.precharge);\n\t\tVM_BUG_ON(mc.moved_charge);\n\t\tVM_BUG_ON(mc.moved_swap);\n\n\t\tspin_lock(&mc.lock);\n\t\tmc.mm = mm;\n\t\tmc.from = from;\n\t\tmc.to = memcg;\n\t\tmc.flags = move_flags;\n\t\tspin_unlock(&mc.lock);\n\t\t/* We set mc.moving_task later */\n\n\t\tret = mem_cgroup_precharge_mc(mm);\n\t\tif (ret)\n\t\t\tmem_cgroup_clear_mc();\n\t} else {\n\t\tmmput(mm);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 5135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_clear_mc",
          "args": [],
          "line": 5133
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_clear_mc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5051-5068",
          "snippet": "static void mem_cgroup_clear_mc(void)\n{\n\tstruct mm_struct *mm = mc.mm;\n\n\t/*\n\t * we must clear moving_task before waking up waiters at the end of\n\t * task migration.\n\t */\n\tmc.moving_task = NULL;\n\t__mem_cgroup_clear_mc();\n\tspin_lock(&mc.lock);\n\tmc.from = NULL;\n\tmc.to = NULL;\n\tmc.mm = NULL;\n\tspin_unlock(&mc.lock);\n\n\tmmput(mm);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic void mem_cgroup_clear_mc(void)\n{\n\tstruct mm_struct *mm = mc.mm;\n\n\t/*\n\t * we must clear moving_task before waking up waiters at the end of\n\t * task migration.\n\t */\n\tmc.moving_task = NULL;\n\t__mem_cgroup_clear_mc();\n\tspin_lock(&mc.lock);\n\tmc.from = NULL;\n\tmc.to = NULL;\n\tmc.mm = NULL;\n\tspin_unlock(&mc.lock);\n\n\tmmput(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_precharge_mc",
          "args": [
            "mm"
          ],
          "line": 5131
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_precharge_mc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4998-5005",
          "snippet": "static int mem_cgroup_precharge_mc(struct mm_struct *mm)\n{\n\tunsigned long precharge = mem_cgroup_count_precharge(mm);\n\n\tVM_BUG_ON(mc.moving_task);\n\tmc.moving_task = current;\n\treturn mem_cgroup_do_precharge(precharge);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic int mem_cgroup_precharge_mc(struct mm_struct *mm)\n{\n\tunsigned long precharge = mem_cgroup_count_precharge(mm);\n\n\tVM_BUG_ON(mc.moving_task);\n\tmc.moving_task = current;\n\treturn mem_cgroup_do_precharge(precharge);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mc.lock"
          ],
          "line": 5128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mc.lock"
          ],
          "line": 5123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "mc.moved_swap"
          ],
          "line": 5121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "mc.moved_charge"
          ],
          "line": 5120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "mc.precharge"
          ],
          "line": 5119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "mc.to"
          ],
          "line": 5118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "mc.from"
          ],
          "line": 5117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "p"
          ],
          "line": 5112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "from == memcg"
          ],
          "line": 5110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_task",
          "args": [
            "p"
          ],
          "line": 5108
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_from_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "805-816",
          "snippet": "struct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "memcg->move_charge_at_immigrate"
          ],
          "line": 5104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 5094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "p"
          ],
          "line": 5092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_for_each_leader",
          "args": [
            "leader",
            "css",
            "tset"
          ],
          "line": 5091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 5081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic int mem_cgroup_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct mem_cgroup *memcg = NULL; /* unneeded init to make gcc happy */\n\tstruct mem_cgroup *from;\n\tstruct task_struct *leader, *p;\n\tstruct mm_struct *mm;\n\tunsigned long move_flags;\n\tint ret = 0;\n\n\t/* charge immigration isn't supported on the default hierarchy */\n\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn 0;\n\n\t/*\n\t * Multi-process migrations only happen on the default hierarchy\n\t * where charge immigration is not used.  Perform charge\n\t * immigration if @tset contains a leader and whine if there are\n\t * multiple.\n\t */\n\tp = NULL;\n\tcgroup_taskset_for_each_leader(leader, css, tset) {\n\t\tWARN_ON_ONCE(p);\n\t\tp = leader;\n\t\tmemcg = mem_cgroup_from_css(css);\n\t}\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * We are now commited to this value whatever it is. Changes in this\n\t * tunable will only affect upcoming migrations, not the current one.\n\t * So we need to save it, and keep it going.\n\t */\n\tmove_flags = READ_ONCE(memcg->move_charge_at_immigrate);\n\tif (!move_flags)\n\t\treturn 0;\n\n\tfrom = mem_cgroup_from_task(p);\n\n\tVM_BUG_ON(from == memcg);\n\n\tmm = get_task_mm(p);\n\tif (!mm)\n\t\treturn 0;\n\t/* We move charges only when we move a owner of the mm */\n\tif (mm->owner == p) {\n\t\tVM_BUG_ON(mc.from);\n\t\tVM_BUG_ON(mc.to);\n\t\tVM_BUG_ON(mc.precharge);\n\t\tVM_BUG_ON(mc.moved_charge);\n\t\tVM_BUG_ON(mc.moved_swap);\n\n\t\tspin_lock(&mc.lock);\n\t\tmc.mm = mm;\n\t\tmc.from = from;\n\t\tmc.to = memcg;\n\t\tmc.flags = move_flags;\n\t\tspin_unlock(&mc.lock);\n\t\t/* We set mc.moving_task later */\n\n\t\tret = mem_cgroup_precharge_mc(mm);\n\t\tif (ret)\n\t\t\tmem_cgroup_clear_mc();\n\t} else {\n\t\tmmput(mm);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "mem_cgroup_clear_mc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5051-5068",
    "snippet": "static void mem_cgroup_clear_mc(void)\n{\n\tstruct mm_struct *mm = mc.mm;\n\n\t/*\n\t * we must clear moving_task before waking up waiters at the end of\n\t * task migration.\n\t */\n\tmc.moving_task = NULL;\n\t__mem_cgroup_clear_mc();\n\tspin_lock(&mc.lock);\n\tmc.from = NULL;\n\tmc.to = NULL;\n\tmc.mm = NULL;\n\tspin_unlock(&mc.lock);\n\n\tmmput(mm);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 5067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mc.lock"
          ],
          "line": 5065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mc.lock"
          ],
          "line": 5061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_clear_mc",
          "args": [],
          "line": 5060
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_clear_mc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5008-5049",
          "snippet": "static void __mem_cgroup_clear_mc(void)\n{\n\tstruct mem_cgroup *from = mc.from;\n\tstruct mem_cgroup *to = mc.to;\n\n\t/* we must uncharge all the leftover precharges from mc.to */\n\tif (mc.precharge) {\n\t\tcancel_charge(mc.to, mc.precharge);\n\t\tmc.precharge = 0;\n\t}\n\t/*\n\t * we didn't uncharge from mc.from at mem_cgroup_move_account(), so\n\t * we must uncharge here.\n\t */\n\tif (mc.moved_charge) {\n\t\tcancel_charge(mc.from, mc.moved_charge);\n\t\tmc.moved_charge = 0;\n\t}\n\t/* we must fixup refcnts and charges */\n\tif (mc.moved_swap) {\n\t\t/* uncharge swap account from the old cgroup */\n\t\tif (!mem_cgroup_is_root(mc.from))\n\t\t\tpage_counter_uncharge(&mc.from->memsw, mc.moved_swap);\n\n\t\tmem_cgroup_id_put_many(mc.from, mc.moved_swap);\n\n\t\t/*\n\t\t * we charged both to->memory and to->memsw, so we\n\t\t * should uncharge to->memory.\n\t\t */\n\t\tif (!mem_cgroup_is_root(mc.to))\n\t\t\tpage_counter_uncharge(&mc.to->memory, mc.moved_swap);\n\n\t\tmem_cgroup_id_get_many(mc.to, mc.moved_swap);\n\t\tcss_put_many(&mc.to->css, mc.moved_swap);\n\n\t\tmc.moved_swap = 0;\n\t}\n\tmemcg_oom_recover(from);\n\tmemcg_oom_recover(to);\n\twake_up_all(&mc.waitq);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_clear_mc(void)\n{\n\tstruct mem_cgroup *from = mc.from;\n\tstruct mem_cgroup *to = mc.to;\n\n\t/* we must uncharge all the leftover precharges from mc.to */\n\tif (mc.precharge) {\n\t\tcancel_charge(mc.to, mc.precharge);\n\t\tmc.precharge = 0;\n\t}\n\t/*\n\t * we didn't uncharge from mc.from at mem_cgroup_move_account(), so\n\t * we must uncharge here.\n\t */\n\tif (mc.moved_charge) {\n\t\tcancel_charge(mc.from, mc.moved_charge);\n\t\tmc.moved_charge = 0;\n\t}\n\t/* we must fixup refcnts and charges */\n\tif (mc.moved_swap) {\n\t\t/* uncharge swap account from the old cgroup */\n\t\tif (!mem_cgroup_is_root(mc.from))\n\t\t\tpage_counter_uncharge(&mc.from->memsw, mc.moved_swap);\n\n\t\tmem_cgroup_id_put_many(mc.from, mc.moved_swap);\n\n\t\t/*\n\t\t * we charged both to->memory and to->memsw, so we\n\t\t * should uncharge to->memory.\n\t\t */\n\t\tif (!mem_cgroup_is_root(mc.to))\n\t\t\tpage_counter_uncharge(&mc.to->memory, mc.moved_swap);\n\n\t\tmem_cgroup_id_get_many(mc.to, mc.moved_swap);\n\t\tcss_put_many(&mc.to->css, mc.moved_swap);\n\n\t\tmc.moved_swap = 0;\n\t}\n\tmemcg_oom_recover(from);\n\tmemcg_oom_recover(to);\n\twake_up_all(&mc.waitq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic void mem_cgroup_clear_mc(void)\n{\n\tstruct mm_struct *mm = mc.mm;\n\n\t/*\n\t * we must clear moving_task before waking up waiters at the end of\n\t * task migration.\n\t */\n\tmc.moving_task = NULL;\n\t__mem_cgroup_clear_mc();\n\tspin_lock(&mc.lock);\n\tmc.from = NULL;\n\tmc.to = NULL;\n\tmc.mm = NULL;\n\tspin_unlock(&mc.lock);\n\n\tmmput(mm);\n}"
  },
  {
    "function_name": "__mem_cgroup_clear_mc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "5008-5049",
    "snippet": "static void __mem_cgroup_clear_mc(void)\n{\n\tstruct mem_cgroup *from = mc.from;\n\tstruct mem_cgroup *to = mc.to;\n\n\t/* we must uncharge all the leftover precharges from mc.to */\n\tif (mc.precharge) {\n\t\tcancel_charge(mc.to, mc.precharge);\n\t\tmc.precharge = 0;\n\t}\n\t/*\n\t * we didn't uncharge from mc.from at mem_cgroup_move_account(), so\n\t * we must uncharge here.\n\t */\n\tif (mc.moved_charge) {\n\t\tcancel_charge(mc.from, mc.moved_charge);\n\t\tmc.moved_charge = 0;\n\t}\n\t/* we must fixup refcnts and charges */\n\tif (mc.moved_swap) {\n\t\t/* uncharge swap account from the old cgroup */\n\t\tif (!mem_cgroup_is_root(mc.from))\n\t\t\tpage_counter_uncharge(&mc.from->memsw, mc.moved_swap);\n\n\t\tmem_cgroup_id_put_many(mc.from, mc.moved_swap);\n\n\t\t/*\n\t\t * we charged both to->memory and to->memsw, so we\n\t\t * should uncharge to->memory.\n\t\t */\n\t\tif (!mem_cgroup_is_root(mc.to))\n\t\t\tpage_counter_uncharge(&mc.to->memory, mc.moved_swap);\n\n\t\tmem_cgroup_id_get_many(mc.to, mc.moved_swap);\n\t\tcss_put_many(&mc.to->css, mc.moved_swap);\n\n\t\tmc.moved_swap = 0;\n\t}\n\tmemcg_oom_recover(from);\n\tmemcg_oom_recover(to);\n\twake_up_all(&mc.waitq);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&mc.waitq"
          ],
          "line": 5048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_oom_recover",
          "args": [
            "to"
          ],
          "line": 5047
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_oom_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1646-1658",
          "snippet": "static void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);\n\nstatic void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_put_many",
          "args": [
            "&mc.to->css",
            "mc.moved_swap"
          ],
          "line": 5042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id_get_many",
          "args": [
            "mc.to",
            "mc.moved_swap"
          ],
          "line": 5041
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_get_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4300-4303",
          "snippet": "static void mem_cgroup_id_get_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\trefcount_add(n, &memcg->id.ref);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_id_get_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\trefcount_add(n, &memcg->id.ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_uncharge",
          "args": [
            "&mc.to->memory",
            "mc.moved_swap"
          ],
          "line": 5039
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "155-161",
          "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "mc.to"
          ],
          "line": 5038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id_put_many",
          "args": [
            "mc.from",
            "mc.moved_swap"
          ],
          "line": 5032
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_put_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4305-4313",
          "snippet": "static void mem_cgroup_id_put_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\tif (refcount_sub_and_test(n, &memcg->id.ref)) {\n\t\tmem_cgroup_id_remove(memcg);\n\n\t\t/* Memcg ID pins CSS */\n\t\tcss_put(&memcg->css);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_id_put_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\tif (refcount_sub_and_test(n, &memcg->id.ref)) {\n\t\tmem_cgroup_id_remove(memcg);\n\n\t\t/* Memcg ID pins CSS */\n\t\tcss_put(&memcg->css);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "mc.from"
          ],
          "line": 5029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_charge",
          "args": [
            "mc.from",
            "mc.moved_charge"
          ],
          "line": 5023
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2318-2328",
          "snippet": "static void cancel_charge(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn;\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void cancel_charge(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn;\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_clear_mc(void)\n{\n\tstruct mem_cgroup *from = mc.from;\n\tstruct mem_cgroup *to = mc.to;\n\n\t/* we must uncharge all the leftover precharges from mc.to */\n\tif (mc.precharge) {\n\t\tcancel_charge(mc.to, mc.precharge);\n\t\tmc.precharge = 0;\n\t}\n\t/*\n\t * we didn't uncharge from mc.from at mem_cgroup_move_account(), so\n\t * we must uncharge here.\n\t */\n\tif (mc.moved_charge) {\n\t\tcancel_charge(mc.from, mc.moved_charge);\n\t\tmc.moved_charge = 0;\n\t}\n\t/* we must fixup refcnts and charges */\n\tif (mc.moved_swap) {\n\t\t/* uncharge swap account from the old cgroup */\n\t\tif (!mem_cgroup_is_root(mc.from))\n\t\t\tpage_counter_uncharge(&mc.from->memsw, mc.moved_swap);\n\n\t\tmem_cgroup_id_put_many(mc.from, mc.moved_swap);\n\n\t\t/*\n\t\t * we charged both to->memory and to->memsw, so we\n\t\t * should uncharge to->memory.\n\t\t */\n\t\tif (!mem_cgroup_is_root(mc.to))\n\t\t\tpage_counter_uncharge(&mc.to->memory, mc.moved_swap);\n\n\t\tmem_cgroup_id_get_many(mc.to, mc.moved_swap);\n\t\tcss_put_many(&mc.to->css, mc.moved_swap);\n\n\t\tmc.moved_swap = 0;\n\t}\n\tmemcg_oom_recover(from);\n\tmemcg_oom_recover(to);\n\twake_up_all(&mc.waitq);\n}"
  },
  {
    "function_name": "mem_cgroup_precharge_mc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4998-5005",
    "snippet": "static int mem_cgroup_precharge_mc(struct mm_struct *mm)\n{\n\tunsigned long precharge = mem_cgroup_count_precharge(mm);\n\n\tVM_BUG_ON(mc.moving_task);\n\tmc.moving_task = current;\n\treturn mem_cgroup_do_precharge(precharge);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_do_precharge",
          "args": [
            "precharge"
          ],
          "line": 5004
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_do_precharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4613-4633",
          "snippet": "static int mem_cgroup_do_precharge(unsigned long count)\n{\n\tint ret;\n\n\t/* Try a single bulk charge without reclaim first, kswapd may wake */\n\tret = try_charge(mc.to, GFP_KERNEL & ~__GFP_DIRECT_RECLAIM, count);\n\tif (!ret) {\n\t\tmc.precharge += count;\n\t\treturn ret;\n\t}\n\n\t/* Try charges one by one with reclaim, but do not retry */\n\twhile (count--) {\n\t\tret = try_charge(mc.to, GFP_KERNEL | __GFP_NORETRY, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmc.precharge++;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\n\nstatic int mem_cgroup_do_precharge(unsigned long count)\n{\n\tint ret;\n\n\t/* Try a single bulk charge without reclaim first, kswapd may wake */\n\tret = try_charge(mc.to, GFP_KERNEL & ~__GFP_DIRECT_RECLAIM, count);\n\tif (!ret) {\n\t\tmc.precharge += count;\n\t\treturn ret;\n\t}\n\n\t/* Try charges one by one with reclaim, but do not retry */\n\twhile (count--) {\n\t\tret = try_charge(mc.to, GFP_KERNEL | __GFP_NORETRY, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmc.precharge++;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "mc.moving_task"
          ],
          "line": 5002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_count_precharge",
          "args": [
            "mm"
          ],
          "line": 5000
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_count_precharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4979-4996",
          "snippet": "static unsigned long mem_cgroup_count_precharge(struct mm_struct *mm)\n{\n\tunsigned long precharge;\n\n\tstruct mm_walk mem_cgroup_count_precharge_walk = {\n\t\t.pmd_entry = mem_cgroup_count_precharge_pte_range,\n\t\t.mm = mm,\n\t};\n\tdown_read(&mm->mmap_sem);\n\twalk_page_range(0, mm->highest_vm_end,\n\t\t\t&mem_cgroup_count_precharge_walk);\n\tup_read(&mm->mmap_sem);\n\n\tprecharge = mc.precharge;\n\tmc.precharge = 0;\n\n\treturn precharge;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic unsigned long mem_cgroup_count_precharge(struct mm_struct *mm)\n{\n\tunsigned long precharge;\n\n\tstruct mm_walk mem_cgroup_count_precharge_walk = {\n\t\t.pmd_entry = mem_cgroup_count_precharge_pte_range,\n\t\t.mm = mm,\n\t};\n\tdown_read(&mm->mmap_sem);\n\twalk_page_range(0, mm->highest_vm_end,\n\t\t\t&mem_cgroup_count_precharge_walk);\n\tup_read(&mm->mmap_sem);\n\n\tprecharge = mc.precharge;\n\tmc.precharge = 0;\n\n\treturn precharge;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic int mem_cgroup_precharge_mc(struct mm_struct *mm)\n{\n\tunsigned long precharge = mem_cgroup_count_precharge(mm);\n\n\tVM_BUG_ON(mc.moving_task);\n\tmc.moving_task = current;\n\treturn mem_cgroup_do_precharge(precharge);\n}"
  },
  {
    "function_name": "mem_cgroup_count_precharge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4979-4996",
    "snippet": "static unsigned long mem_cgroup_count_precharge(struct mm_struct *mm)\n{\n\tunsigned long precharge;\n\n\tstruct mm_walk mem_cgroup_count_precharge_walk = {\n\t\t.pmd_entry = mem_cgroup_count_precharge_pte_range,\n\t\t.mm = mm,\n\t};\n\tdown_read(&mm->mmap_sem);\n\twalk_page_range(0, mm->highest_vm_end,\n\t\t\t&mem_cgroup_count_precharge_walk);\n\tup_read(&mm->mmap_sem);\n\n\tprecharge = mc.precharge;\n\tmc.precharge = 0;\n\n\treturn precharge;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 4990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "0",
            "mm->highest_vm_end",
            "&mem_cgroup_count_precharge_walk"
          ],
          "line": 4988
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "293-340",
          "snippet": "int walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 4987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic unsigned long mem_cgroup_count_precharge(struct mm_struct *mm)\n{\n\tunsigned long precharge;\n\n\tstruct mm_walk mem_cgroup_count_precharge_walk = {\n\t\t.pmd_entry = mem_cgroup_count_precharge_pte_range,\n\t\t.mm = mm,\n\t};\n\tdown_read(&mm->mmap_sem);\n\twalk_page_range(0, mm->highest_vm_end,\n\t\t\t&mem_cgroup_count_precharge_walk);\n\tup_read(&mm->mmap_sem);\n\n\tprecharge = mc.precharge;\n\tmc.precharge = 0;\n\n\treturn precharge;\n}"
  },
  {
    "function_name": "mem_cgroup_count_precharge_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4946-4977",
    "snippet": "static int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,\n\t\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\t/*\n\t\t * Note their can not be MC_TARGET_DEVICE for now as we do not\n\t\t * support transparent huge page with MEMORY_DEVICE_PUBLIC or\n\t\t * MEMORY_DEVICE_PRIVATE but this might change.\n\t\t */\n\t\tif (get_mctgt_type_thp(vma, addr, *pmd, NULL) == MC_TARGET_PAGE)\n\t\t\tmc.precharge += HPAGE_PMD_NR;\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tif (get_mctgt_type(vma, addr, *pte, NULL))\n\t\t\tmc.precharge++;\t/* increment precharge temporarily */\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte - 1",
            "ptl"
          ],
          "line": 4973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mctgt_type",
          "args": [
            "vma",
            "addr",
            "*pte",
            "NULL"
          ],
          "line": 4971
        },
        "resolved": true,
        "details": {
          "function_name": "get_mctgt_type_thp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4939-4943",
          "snippet": "static inline enum mc_target_type get_mctgt_type_thp(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t pmd, union mc_target *target)\n{\n\treturn MC_TARGET_NONE;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic inline enum mc_target_type get_mctgt_type_thp(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t pmd, union mc_target *target)\n{\n\treturn MC_TARGET_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 4969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 4967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge_lock",
          "args": [
            "pmd",
            "vma"
          ],
          "line": 4954
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_trans_huge_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1957-1966",
          "snippet": "spinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,\n\t\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\t/*\n\t\t * Note their can not be MC_TARGET_DEVICE for now as we do not\n\t\t * support transparent huge page with MEMORY_DEVICE_PUBLIC or\n\t\t * MEMORY_DEVICE_PRIVATE but this might change.\n\t\t */\n\t\tif (get_mctgt_type_thp(vma, addr, *pmd, NULL) == MC_TARGET_PAGE)\n\t\t\tmc.precharge += HPAGE_PMD_NR;\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tif (get_mctgt_type(vma, addr, *pte, NULL))\n\t\t\tmc.precharge++;\t/* increment precharge temporarily */\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_mctgt_type_thp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4939-4943",
    "snippet": "static inline enum mc_target_type get_mctgt_type_thp(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t pmd, union mc_target *target)\n{\n\treturn MC_TARGET_NONE;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic inline enum mc_target_type get_mctgt_type_thp(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t pmd, union mc_target *target)\n{\n\treturn MC_TARGET_NONE;\n}"
  },
  {
    "function_name": "get_mctgt_type_thp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4914-4937",
    "snippet": "static enum mc_target_type get_mctgt_type_thp(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t pmd, union mc_target *target)\n{\n\tstruct page *page = NULL;\n\tenum mc_target_type ret = MC_TARGET_NONE;\n\n\tif (unlikely(is_swap_pmd(pmd))) {\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(pmd));\n\t\treturn ret;\n\t}\n\tpage = pmd_page(pmd);\n\tVM_BUG_ON_PAGE(!page || !PageHead(page), page);\n\tif (!(mc.flags & MOVE_ANON))\n\t\treturn ret;\n\tif (page->mem_cgroup == mc.from) {\n\t\tret = MC_TARGET_PAGE;\n\t\tif (target) {\n\t\t\tget_page(page);\n\t\t\ttarget->page = page;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define MOVE_ANON\t0x1U"
    ],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 4932
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!page || !PageHead(page)",
            "page"
          ],
          "line": 4926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 4926
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "pmd"
          ],
          "line": 4925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(pmd)"
          ],
          "line": 4921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "pmd"
          ],
          "line": 4922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thp_migration_supported",
          "args": [],
          "line": 4921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_swap_pmd(pmd)"
          ],
          "line": 4920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pmd",
          "args": [
            "pmd"
          ],
          "line": 4920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MOVE_ANON\t0x1U\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic enum mc_target_type get_mctgt_type_thp(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t pmd, union mc_target *target)\n{\n\tstruct page *page = NULL;\n\tenum mc_target_type ret = MC_TARGET_NONE;\n\n\tif (unlikely(is_swap_pmd(pmd))) {\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(pmd));\n\t\treturn ret;\n\t}\n\tpage = pmd_page(pmd);\n\tVM_BUG_ON_PAGE(!page || !PageHead(page), page);\n\tif (!(mc.flags & MOVE_ANON))\n\t\treturn ret;\n\tif (page->mem_cgroup == mc.from) {\n\t\tret = MC_TARGET_PAGE;\n\t\tif (target) {\n\t\t\tget_page(page);\n\t\t\ttarget->page = page;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "get_mctgt_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4862-4906",
    "snippet": "static enum mc_target_type get_mctgt_type(struct vm_area_struct *vma,\n\t\tunsigned long addr, pte_t ptent, union mc_target *target)\n{\n\tstruct page *page = NULL;\n\tenum mc_target_type ret = MC_TARGET_NONE;\n\tswp_entry_t ent = { .val = 0 };\n\n\tif (pte_present(ptent))\n\t\tpage = mc_handle_present_pte(vma, addr, ptent);\n\telse if (is_swap_pte(ptent))\n\t\tpage = mc_handle_swap_pte(vma, ptent, &ent);\n\telse if (pte_none(ptent))\n\t\tpage = mc_handle_file_pte(vma, addr, ptent, &ent);\n\n\tif (!page && !ent.val)\n\t\treturn ret;\n\tif (page) {\n\t\t/*\n\t\t * Do only loose check w/o serialization.\n\t\t * mem_cgroup_move_account() checks the page is valid or\n\t\t * not under LRU exclusion.\n\t\t */\n\t\tif (page->mem_cgroup == mc.from) {\n\t\t\tret = MC_TARGET_PAGE;\n\t\t\tif (is_device_private_page(page) ||\n\t\t\t    is_device_public_page(page))\n\t\t\t\tret = MC_TARGET_DEVICE;\n\t\t\tif (target)\n\t\t\t\ttarget->page = page;\n\t\t}\n\t\tif (!ret || !target)\n\t\t\tput_page(page);\n\t}\n\t/*\n\t * There is a swap entry and a page doesn't exist or isn't charged.\n\t * But we cannot move a tail-page in a THP.\n\t */\n\tif (ent.val && !ret && (!page || !PageTransCompound(page)) &&\n\t    mem_cgroup_id(mc.from) == lookup_swap_cgroup_id(ent)) {\n\t\tret = MC_TARGET_SWAP;\n\t\tif (target)\n\t\t\ttarget->ent = ent;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_swap_cgroup_id",
          "args": [
            "ent"
          ],
          "line": 4900
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_swap_cgroup_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "162-165",
          "snippet": "unsigned short lookup_swap_cgroup_id(swp_entry_t ent)\n{\n\treturn lookup_swap_cgroup(ent, NULL)->id;\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nunsigned short lookup_swap_cgroup_id(swp_entry_t ent)\n{\n\treturn lookup_swap_cgroup(ent, NULL)->id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id",
          "args": [
            "mc.from"
          ],
          "line": 4900
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_get_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6356-6372",
          "snippet": "static struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 4899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 4893
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_device_public_page",
          "args": [
            "page"
          ],
          "line": 4887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_page",
          "args": [
            "page"
          ],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mc_handle_file_pte",
          "args": [
            "vma",
            "addr",
            "ptent",
            "&ent"
          ],
          "line": 4874
        },
        "resolved": true,
        "details": {
          "function_name": "mc_handle_file_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4711-4744",
          "snippet": "static struct page *mc_handle_file_pte(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, pte_t ptent, swp_entry_t *entry)\n{\n\tstruct page *page = NULL;\n\tstruct address_space *mapping;\n\tpgoff_t pgoff;\n\n\tif (!vma->vm_file) /* anonymous vma */\n\t\treturn NULL;\n\tif (!(mc.flags & MOVE_FILE))\n\t\treturn NULL;\n\n\tmapping = vma->vm_file->f_mapping;\n\tpgoff = linear_page_index(vma, addr);\n\n\t/* page is moved even if it's not RSS of this task(page-faulted). */\n#ifdef CONFIG_SWAP\n\t/* shmem/tmpfs may report page out on swap: account for that too. */\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tif (do_memsw_account())\n\t\t\t\t*entry = swp;\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define MOVE_FILE\t0x2U"
          ],
          "globals_used": [
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MOVE_FILE\t0x2U\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic struct page *mc_handle_file_pte(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, pte_t ptent, swp_entry_t *entry)\n{\n\tstruct page *page = NULL;\n\tstruct address_space *mapping;\n\tpgoff_t pgoff;\n\n\tif (!vma->vm_file) /* anonymous vma */\n\t\treturn NULL;\n\tif (!(mc.flags & MOVE_FILE))\n\t\treturn NULL;\n\n\tmapping = vma->vm_file->f_mapping;\n\tpgoff = linear_page_index(vma, addr);\n\n\t/* page is moved even if it's not RSS of this task(page-faulted). */\n#ifdef CONFIG_SWAP\n\t/* shmem/tmpfs may report page out on swap: account for that too. */\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tif (do_memsw_account())\n\t\t\t\t*entry = swp;\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "ptent"
          ],
          "line": 4873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mc_handle_swap_pte",
          "args": [
            "vma",
            "ptent",
            "&ent"
          ],
          "line": 4872
        },
        "resolved": true,
        "details": {
          "function_name": "mc_handle_swap_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4704-4708",
          "snippet": "static struct page *mc_handle_swap_pte(struct vm_area_struct *vma,\n\t\t\tpte_t ptent, swp_entry_t *entry)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic struct page *mc_handle_swap_pte(struct vm_area_struct *vma,\n\t\t\tpte_t ptent, swp_entry_t *entry)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "ptent"
          ],
          "line": 4871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mc_handle_present_pte",
          "args": [
            "vma",
            "addr",
            "ptent"
          ],
          "line": 4870
        },
        "resolved": true,
        "details": {
          "function_name": "mc_handle_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4647-4665",
          "snippet": "static struct page *mc_handle_present_pte(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr, pte_t ptent)\n{\n\tstruct page *page = _vm_normal_page(vma, addr, ptent, true);\n\n\tif (!page || !page_mapped(page))\n\t\treturn NULL;\n\tif (PageAnon(page)) {\n\t\tif (!(mc.flags & MOVE_ANON))\n\t\t\treturn NULL;\n\t} else {\n\t\tif (!(mc.flags & MOVE_FILE))\n\t\t\treturn NULL;\n\t}\n\tif (!get_page_unless_zero(page))\n\t\treturn NULL;\n\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define MOVE_FILE\t0x2U",
            "#define MOVE_ANON\t0x1U"
          ],
          "globals_used": [
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MOVE_FILE\t0x2U\n#define MOVE_ANON\t0x1U\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic struct page *mc_handle_present_pte(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr, pte_t ptent)\n{\n\tstruct page *page = _vm_normal_page(vma, addr, ptent, true);\n\n\tif (!page || !page_mapped(page))\n\t\treturn NULL;\n\tif (PageAnon(page)) {\n\t\tif (!(mc.flags & MOVE_ANON))\n\t\t\treturn NULL;\n\t} else {\n\t\tif (!(mc.flags & MOVE_FILE))\n\t\t\treturn NULL;\n\t}\n\tif (!get_page_unless_zero(page))\n\t\treturn NULL;\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "ptent"
          ],
          "line": 4869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic enum mc_target_type get_mctgt_type(struct vm_area_struct *vma,\n\t\tunsigned long addr, pte_t ptent, union mc_target *target)\n{\n\tstruct page *page = NULL;\n\tenum mc_target_type ret = MC_TARGET_NONE;\n\tswp_entry_t ent = { .val = 0 };\n\n\tif (pte_present(ptent))\n\t\tpage = mc_handle_present_pte(vma, addr, ptent);\n\telse if (is_swap_pte(ptent))\n\t\tpage = mc_handle_swap_pte(vma, ptent, &ent);\n\telse if (pte_none(ptent))\n\t\tpage = mc_handle_file_pte(vma, addr, ptent, &ent);\n\n\tif (!page && !ent.val)\n\t\treturn ret;\n\tif (page) {\n\t\t/*\n\t\t * Do only loose check w/o serialization.\n\t\t * mem_cgroup_move_account() checks the page is valid or\n\t\t * not under LRU exclusion.\n\t\t */\n\t\tif (page->mem_cgroup == mc.from) {\n\t\t\tret = MC_TARGET_PAGE;\n\t\t\tif (is_device_private_page(page) ||\n\t\t\t    is_device_public_page(page))\n\t\t\t\tret = MC_TARGET_DEVICE;\n\t\t\tif (target)\n\t\t\t\ttarget->page = page;\n\t\t}\n\t\tif (!ret || !target)\n\t\t\tput_page(page);\n\t}\n\t/*\n\t * There is a swap entry and a page doesn't exist or isn't charged.\n\t * But we cannot move a tail-page in a THP.\n\t */\n\tif (ent.val && !ret && (!page || !PageTransCompound(page)) &&\n\t    mem_cgroup_id(mc.from) == lookup_swap_cgroup_id(ent)) {\n\t\tret = MC_TARGET_SWAP;\n\t\tif (target)\n\t\t\ttarget->ent = ent;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "mem_cgroup_move_account",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4758-4834",
    "snippet": "static int mem_cgroup_move_account(struct page *page,\n\t\t\t\t   bool compound,\n\t\t\t\t   struct mem_cgroup *from,\n\t\t\t\t   struct mem_cgroup *to)\n{\n\tunsigned long flags;\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\tint ret;\n\tbool anon;\n\n\tVM_BUG_ON(from == to);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON(compound && !PageTransHuge(page));\n\n\t/*\n\t * Prevent mem_cgroup_migrate() from looking at\n\t * page->mem_cgroup of its source page while we change it.\n\t */\n\tret = -EBUSY;\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (page->mem_cgroup != from)\n\t\tgoto out_unlock;\n\n\tanon = PageAnon(page);\n\n\tspin_lock_irqsave(&from->move_lock, flags);\n\n\tif (!anon && page_mapped(page)) {\n\t\t__mod_memcg_state(from, NR_FILE_MAPPED, -nr_pages);\n\t\t__mod_memcg_state(to, NR_FILE_MAPPED, nr_pages);\n\t}\n\n\t/*\n\t * move_lock grabbed above and caller set from->moving_account, so\n\t * mod_memcg_page_state will serialize updates to PageDirty.\n\t * So mapping should be stable for dirty pages.\n\t */\n\tif (!anon && PageDirty(page)) {\n\t\tstruct address_space *mapping = page_mapping(page);\n\n\t\tif (mapping_cap_account_dirty(mapping)) {\n\t\t\t__mod_memcg_state(from, NR_FILE_DIRTY, -nr_pages);\n\t\t\t__mod_memcg_state(to, NR_FILE_DIRTY, nr_pages);\n\t\t}\n\t}\n\n\tif (PageWriteback(page)) {\n\t\t__mod_memcg_state(from, NR_WRITEBACK, -nr_pages);\n\t\t__mod_memcg_state(to, NR_WRITEBACK, nr_pages);\n\t}\n\n\t/*\n\t * It is safe to change page->mem_cgroup here because the page\n\t * is referenced, charged, and isolated - we can't race with\n\t * uncharging, charging, migration, or LRU putback.\n\t */\n\n\t/* caller should have done css_get */\n\tpage->mem_cgroup = to;\n\tspin_unlock_irqrestore(&from->move_lock, flags);\n\n\tret = 0;\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(to, page, compound, nr_pages);\n\tmemcg_check_events(to, page);\n\tmem_cgroup_charge_statistics(from, page, compound, -nr_pages);\n\tmemcg_check_events(from, page);\n\tlocal_irq_enable();\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 4831
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 4829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_check_events",
          "args": [
            "from",
            "page"
          ],
          "line": 4828
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_check_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "781-803",
          "snippet": "static void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_charge_statistics",
          "args": [
            "from",
            "page",
            "compound",
            "-nr_pages"
          ],
          "line": 4827
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_charge_statistics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "689-719",
          "snippet": "static void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t bool compound, int nr_pages)\n{\n\t/*\n\t * Here, RSS means 'mapped anon' and anon's SwapCache. Shmem/tmpfs is\n\t * counted as CACHE even if it's on ANON LRU.\n\t */\n\tif (PageAnon(page))\n\t\t__mod_memcg_state(memcg, MEMCG_RSS, nr_pages);\n\telse {\n\t\t__mod_memcg_state(memcg, MEMCG_CACHE, nr_pages);\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_memcg_state(memcg, NR_SHMEM, nr_pages);\n\t}\n\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t__mod_memcg_state(memcg, MEMCG_RSS_HUGE, nr_pages);\n\t}\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__count_memcg_events(memcg, PGPGIN, 1);\n\telse {\n\t\t__count_memcg_events(memcg, PGPGOUT, 1);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat_cpu->nr_page_events, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t bool compound, int nr_pages)\n{\n\t/*\n\t * Here, RSS means 'mapped anon' and anon's SwapCache. Shmem/tmpfs is\n\t * counted as CACHE even if it's on ANON LRU.\n\t */\n\tif (PageAnon(page))\n\t\t__mod_memcg_state(memcg, MEMCG_RSS, nr_pages);\n\telse {\n\t\t__mod_memcg_state(memcg, MEMCG_CACHE, nr_pages);\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_memcg_state(memcg, NR_SHMEM, nr_pages);\n\t}\n\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t__mod_memcg_state(memcg, MEMCG_RSS_HUGE, nr_pages);\n\t}\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__count_memcg_events(memcg, PGPGIN, 1);\n\telse {\n\t\t__count_memcg_events(memcg, PGPGOUT, 1);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat_cpu->nr_page_events, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 4824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&from->move_lock",
            "flags"
          ],
          "line": 4820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "to",
            "NR_WRITEBACK",
            "nr_pages"
          ],
          "line": 4809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "from",
            "NR_WRITEBACK",
            "-nr_pages"
          ],
          "line": 4808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 4807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "to",
            "NR_FILE_DIRTY",
            "nr_pages"
          ],
          "line": 4803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "from",
            "NR_FILE_DIRTY",
            "-nr_pages"
          ],
          "line": 4802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_cap_account_dirty",
          "args": [
            "mapping"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 4799
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "to",
            "NR_FILE_MAPPED",
            "nr_pages"
          ],
          "line": 4790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "from",
            "NR_FILE_MAPPED",
            "-nr_pages"
          ],
          "line": 4789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 4788
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&from->move_lock",
            "flags"
          ],
          "line": 4786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 4777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "compound && !PageTransHuge(page)"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 4769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 4769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "from == to"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 4764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic int mem_cgroup_move_account(struct page *page,\n\t\t\t\t   bool compound,\n\t\t\t\t   struct mem_cgroup *from,\n\t\t\t\t   struct mem_cgroup *to)\n{\n\tunsigned long flags;\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\tint ret;\n\tbool anon;\n\n\tVM_BUG_ON(from == to);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON(compound && !PageTransHuge(page));\n\n\t/*\n\t * Prevent mem_cgroup_migrate() from looking at\n\t * page->mem_cgroup of its source page while we change it.\n\t */\n\tret = -EBUSY;\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (page->mem_cgroup != from)\n\t\tgoto out_unlock;\n\n\tanon = PageAnon(page);\n\n\tspin_lock_irqsave(&from->move_lock, flags);\n\n\tif (!anon && page_mapped(page)) {\n\t\t__mod_memcg_state(from, NR_FILE_MAPPED, -nr_pages);\n\t\t__mod_memcg_state(to, NR_FILE_MAPPED, nr_pages);\n\t}\n\n\t/*\n\t * move_lock grabbed above and caller set from->moving_account, so\n\t * mod_memcg_page_state will serialize updates to PageDirty.\n\t * So mapping should be stable for dirty pages.\n\t */\n\tif (!anon && PageDirty(page)) {\n\t\tstruct address_space *mapping = page_mapping(page);\n\n\t\tif (mapping_cap_account_dirty(mapping)) {\n\t\t\t__mod_memcg_state(from, NR_FILE_DIRTY, -nr_pages);\n\t\t\t__mod_memcg_state(to, NR_FILE_DIRTY, nr_pages);\n\t\t}\n\t}\n\n\tif (PageWriteback(page)) {\n\t\t__mod_memcg_state(from, NR_WRITEBACK, -nr_pages);\n\t\t__mod_memcg_state(to, NR_WRITEBACK, nr_pages);\n\t}\n\n\t/*\n\t * It is safe to change page->mem_cgroup here because the page\n\t * is referenced, charged, and isolated - we can't race with\n\t * uncharging, charging, migration, or LRU putback.\n\t */\n\n\t/* caller should have done css_get */\n\tpage->mem_cgroup = to;\n\tspin_unlock_irqrestore(&from->move_lock, flags);\n\n\tret = 0;\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(to, page, compound, nr_pages);\n\tmemcg_check_events(to, page);\n\tmem_cgroup_charge_statistics(from, page, compound, -nr_pages);\n\tmemcg_check_events(from, page);\n\tlocal_irq_enable();\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "mc_handle_file_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4711-4744",
    "snippet": "static struct page *mc_handle_file_pte(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, pte_t ptent, swp_entry_t *entry)\n{\n\tstruct page *page = NULL;\n\tstruct address_space *mapping;\n\tpgoff_t pgoff;\n\n\tif (!vma->vm_file) /* anonymous vma */\n\t\treturn NULL;\n\tif (!(mc.flags & MOVE_FILE))\n\t\treturn NULL;\n\n\tmapping = vma->vm_file->f_mapping;\n\tpgoff = linear_page_index(vma, addr);\n\n\t/* page is moved even if it's not RSS of this task(page-faulted). */\n#ifdef CONFIG_SWAP\n\t/* shmem/tmpfs may report page out on swap: account for that too. */\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tif (do_memsw_account())\n\t\t\t\t*entry = swp;\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define MOVE_FILE\t0x2U"
    ],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "pgoff"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "pgoff"
          ],
          "line": 4739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "swap_address_space(swp)",
            "swp_offset(swp)"
          ],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "swp"
          ],
          "line": 4736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_address_space",
          "args": [
            "swp"
          ],
          "line": 4735
        },
        "resolved": true,
        "details": {
          "function_name": "exit_swap_address_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "602-611",
          "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 4733
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_to_swp_entry",
          "args": [
            "page"
          ],
          "line": 4732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_entry",
          "args": [
            "mapping",
            "pgoff"
          ],
          "line": 4730
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1407-1448",
          "snippet": "struct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shmem_mapping",
          "args": [
            "mapping"
          ],
          "line": 4729
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "2195-2198",
          "snippet": "bool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nbool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "addr"
          ],
          "line": 4724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MOVE_FILE\t0x2U\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic struct page *mc_handle_file_pte(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, pte_t ptent, swp_entry_t *entry)\n{\n\tstruct page *page = NULL;\n\tstruct address_space *mapping;\n\tpgoff_t pgoff;\n\n\tif (!vma->vm_file) /* anonymous vma */\n\t\treturn NULL;\n\tif (!(mc.flags & MOVE_FILE))\n\t\treturn NULL;\n\n\tmapping = vma->vm_file->f_mapping;\n\tpgoff = linear_page_index(vma, addr);\n\n\t/* page is moved even if it's not RSS of this task(page-faulted). */\n#ifdef CONFIG_SWAP\n\t/* shmem/tmpfs may report page out on swap: account for that too. */\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tif (do_memsw_account())\n\t\t\t\t*entry = swp;\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\treturn page;\n}"
  },
  {
    "function_name": "mc_handle_swap_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4704-4708",
    "snippet": "static struct page *mc_handle_swap_pte(struct vm_area_struct *vma,\n\t\t\tpte_t ptent, swp_entry_t *entry)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic struct page *mc_handle_swap_pte(struct vm_area_struct *vma,\n\t\t\tpte_t ptent, swp_entry_t *entry)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "mc_handle_swap_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4668-4702",
    "snippet": "static struct page *mc_handle_swap_pte(struct vm_area_struct *vma,\n\t\t\tpte_t ptent, swp_entry_t *entry)\n{\n\tstruct page *page = NULL;\n\tswp_entry_t ent = pte_to_swp_entry(ptent);\n\n\tif (!(mc.flags & MOVE_ANON) || non_swap_entry(ent))\n\t\treturn NULL;\n\n\t/*\n\t * Handle MEMORY_DEVICE_PRIVATE which are ZONE_DEVICE page belonging to\n\t * a device and because they are not accessible by CPU they are store\n\t * as special swap entry in the CPU page table.\n\t */\n\tif (is_device_private_entry(ent)) {\n\t\tpage = device_private_entry_to_page(ent);\n\t\t/*\n\t\t * MEMORY_DEVICE_PRIVATE means ZONE_DEVICE page and which have\n\t\t * a refcount of 1 when free (unlike normal page)\n\t\t */\n\t\tif (!page_ref_add_unless(page, 1, 1))\n\t\t\treturn NULL;\n\t\treturn page;\n\t}\n\n\t/*\n\t * Because lookup_swap_cache() updates some statistics counter,\n\t * we call find_get_page() with swapper_space directly.\n\t */\n\tpage = find_get_page(swap_address_space(ent), swp_offset(ent));\n\tif (do_memsw_account())\n\t\tentry->val = ent.val;\n\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define MOVE_ANON\t0x1U"
    ],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 4698
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "swap_address_space(ent)",
            "swp_offset(ent)"
          ],
          "line": 4697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "ent"
          ],
          "line": 4697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_address_space",
          "args": [
            "ent"
          ],
          "line": 4697
        },
        "resolved": true,
        "details": {
          "function_name": "exit_swap_address_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "602-611",
          "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_ref_add_unless",
          "args": [
            "page",
            "1",
            "1"
          ],
          "line": 4688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_private_entry_to_page",
          "args": [
            "ent"
          ],
          "line": 4683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_entry",
          "args": [
            "ent"
          ],
          "line": 4682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "ent"
          ],
          "line": 4674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "ptent"
          ],
          "line": 4672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MOVE_ANON\t0x1U\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic struct page *mc_handle_swap_pte(struct vm_area_struct *vma,\n\t\t\tpte_t ptent, swp_entry_t *entry)\n{\n\tstruct page *page = NULL;\n\tswp_entry_t ent = pte_to_swp_entry(ptent);\n\n\tif (!(mc.flags & MOVE_ANON) || non_swap_entry(ent))\n\t\treturn NULL;\n\n\t/*\n\t * Handle MEMORY_DEVICE_PRIVATE which are ZONE_DEVICE page belonging to\n\t * a device and because they are not accessible by CPU they are store\n\t * as special swap entry in the CPU page table.\n\t */\n\tif (is_device_private_entry(ent)) {\n\t\tpage = device_private_entry_to_page(ent);\n\t\t/*\n\t\t * MEMORY_DEVICE_PRIVATE means ZONE_DEVICE page and which have\n\t\t * a refcount of 1 when free (unlike normal page)\n\t\t */\n\t\tif (!page_ref_add_unless(page, 1, 1))\n\t\t\treturn NULL;\n\t\treturn page;\n\t}\n\n\t/*\n\t * Because lookup_swap_cache() updates some statistics counter,\n\t * we call find_get_page() with swapper_space directly.\n\t */\n\tpage = find_get_page(swap_address_space(ent), swp_offset(ent));\n\tif (do_memsw_account())\n\t\tentry->val = ent.val;\n\n\treturn page;\n}"
  },
  {
    "function_name": "mc_handle_present_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4647-4665",
    "snippet": "static struct page *mc_handle_present_pte(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr, pte_t ptent)\n{\n\tstruct page *page = _vm_normal_page(vma, addr, ptent, true);\n\n\tif (!page || !page_mapped(page))\n\t\treturn NULL;\n\tif (PageAnon(page)) {\n\t\tif (!(mc.flags & MOVE_ANON))\n\t\t\treturn NULL;\n\t} else {\n\t\tif (!(mc.flags & MOVE_FILE))\n\t\t\treturn NULL;\n\t}\n\tif (!get_page_unless_zero(page))\n\t\treturn NULL;\n\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define MOVE_FILE\t0x2U",
      "#define MOVE_ANON\t0x1U"
    ],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 4661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 4654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 4652
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_vm_normal_page",
          "args": [
            "vma",
            "addr",
            "ptent",
            "true"
          ],
          "line": 4650
        },
        "resolved": true,
        "details": {
          "function_name": "_vm_normal_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "572-648",
          "snippet": "struct page *_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     pte_t pte, bool with_public_device)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_ops && vma->vm_ops->find_special_page)\n\t\t\treturn vma->vm_ops->find_special_page(vma, addr);\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (is_zero_pfn(pfn))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Device public pages are special pages (they are ZONE_DEVICE\n\t\t * pages but different from persistent memory). They behave\n\t\t * allmost like normal pages. The difference is that they are\n\t\t * not on the lru and thus should never be involve with any-\n\t\t * thing that involve lru manipulation (mlock, numa balancing,\n\t\t * ...).\n\t\t *\n\t\t * This is why we still want to return NULL for such page from\n\t\t * vm_normal_page() so that we do not have to special case all\n\t\t * call site of vm_normal_page().\n\t\t */\n\t\tif (likely(pfn <= highest_memmap_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t\tif (is_device_public_page(page)) {\n\t\t\t\tif (with_public_device)\n\t\t\t\t\treturn page;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (pte_devmap(pte))\n\t\t\treturn NULL;\n\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !CONFIG_ARCH_HAS_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     pte_t pte, bool with_public_device)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_ops && vma->vm_ops->find_special_page)\n\t\t\treturn vma->vm_ops->find_special_page(vma, addr);\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (is_zero_pfn(pfn))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Device public pages are special pages (they are ZONE_DEVICE\n\t\t * pages but different from persistent memory). They behave\n\t\t * allmost like normal pages. The difference is that they are\n\t\t * not on the lru and thus should never be involve with any-\n\t\t * thing that involve lru manipulation (mlock, numa balancing,\n\t\t * ...).\n\t\t *\n\t\t * This is why we still want to return NULL for such page from\n\t\t * vm_normal_page() so that we do not have to special case all\n\t\t * call site of vm_normal_page().\n\t\t */\n\t\tif (likely(pfn <= highest_memmap_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t\tif (is_device_public_page(page)) {\n\t\t\t\tif (with_public_device)\n\t\t\t\t\treturn page;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (pte_devmap(pte))\n\t\t\treturn NULL;\n\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !CONFIG_ARCH_HAS_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MOVE_FILE\t0x2U\n#define MOVE_ANON\t0x1U\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic struct page *mc_handle_present_pte(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr, pte_t ptent)\n{\n\tstruct page *page = _vm_normal_page(vma, addr, ptent, true);\n\n\tif (!page || !page_mapped(page))\n\t\treturn NULL;\n\tif (PageAnon(page)) {\n\t\tif (!(mc.flags & MOVE_ANON))\n\t\t\treturn NULL;\n\t} else {\n\t\tif (!(mc.flags & MOVE_FILE))\n\t\t\treturn NULL;\n\t}\n\tif (!get_page_unless_zero(page))\n\t\treturn NULL;\n\n\treturn page;\n}"
  },
  {
    "function_name": "mem_cgroup_do_precharge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4613-4633",
    "snippet": "static int mem_cgroup_do_precharge(unsigned long count)\n{\n\tint ret;\n\n\t/* Try a single bulk charge without reclaim first, kswapd may wake */\n\tret = try_charge(mc.to, GFP_KERNEL & ~__GFP_DIRECT_RECLAIM, count);\n\tif (!ret) {\n\t\tmc.precharge += count;\n\t\treturn ret;\n\t}\n\n\t/* Try charges one by one with reclaim, but do not retry */\n\twhile (count--) {\n\t\tret = try_charge(mc.to, GFP_KERNEL | __GFP_NORETRY, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmc.precharge++;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_charge",
          "args": [
            "mc.to",
            "GFP_KERNEL | __GFP_NORETRY",
            "1"
          ],
          "line": 4626
        },
        "resolved": true,
        "details": {
          "function_name": "try_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2147-2316",
          "snippet": "static int try_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t      unsigned int nr_pages)\n{\n\tunsigned int batch = max(MEMCG_CHARGE_BATCH, nr_pages);\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct page_counter *counter;\n\tunsigned long nr_reclaimed;\n\tbool may_swap = true;\n\tbool drained = false;\n\tbool oomed = false;\n\tenum oom_status oom_status;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\nretry:\n\tif (consume_stock(memcg, nr_pages))\n\t\treturn 0;\n\n\tif (!do_memsw_account() ||\n\t    page_counter_try_charge(&memcg->memsw, batch, &counter)) {\n\t\tif (page_counter_try_charge(&memcg->memory, batch, &counter))\n\t\t\tgoto done_restock;\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&memcg->memsw, batch);\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memory);\n\t} else {\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memsw);\n\t\tmay_swap = false;\n\t}\n\n\tif (batch > nr_pages) {\n\t\tbatch = nr_pages;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Unlike in global OOM situations, memcg is not in a physical\n\t * memory shortage.  Allow dying and OOM-killed tasks to\n\t * bypass the last charges so that they can exit quickly and\n\t * free their memory.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current) ||\n\t\t     fatal_signal_pending(current) ||\n\t\t     current->flags & PF_EXITING))\n\t\tgoto force;\n\n\t/*\n\t * Prevent unbounded recursion when reclaim operations need to\n\t * allocate memory. This might exceed the limits temporarily,\n\t * but we prefer facilitating memory reclaim and getting back\n\t * under the limit over triggering OOM kills in these cases.\n\t */\n\tif (unlikely(current->flags & PF_MEMALLOC))\n\t\tgoto force;\n\n\tif (unlikely(task_in_memcg_oom(current)))\n\t\tgoto nomem;\n\n\tif (!gfpflags_allow_blocking(gfp_mask))\n\t\tgoto nomem;\n\n\tmemcg_memory_event(mem_over_limit, MEMCG_MAX);\n\n\tnr_reclaimed = try_to_free_mem_cgroup_pages(mem_over_limit, nr_pages,\n\t\t\t\t\t\t    gfp_mask, may_swap);\n\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\tgoto retry;\n\n\tif (!drained) {\n\t\tdrain_all_stock(mem_over_limit);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nomem;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_reclaimed && nr_pages <= (1 << PAGE_ALLOC_COSTLY_ORDER))\n\t\tgoto retry;\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\tgoto retry;\n\n\tif (nr_retries--)\n\t\tgoto retry;\n\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL && oomed)\n\t\tgoto nomem;\n\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\tgoto force;\n\n\tif (fatal_signal_pending(current))\n\t\tgoto force;\n\n\t/*\n\t * keep retrying as long as the memcg oom killer is able to make\n\t * a forward progress or bypass the charge if the oom killer\n\t * couldn't make any progress.\n\t */\n\toom_status = mem_cgroup_oom(mem_over_limit, gfp_mask,\n\t\t       get_order(nr_pages * PAGE_SIZE));\n\tswitch (oom_status) {\n\tcase OOM_SUCCESS:\n\t\tnr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\toomed = true;\n\t\tgoto retry;\n\tcase OOM_FAILED:\n\t\tgoto force;\n\tdefault:\n\t\tgoto nomem;\n\t}\nnomem:\n\tif (!(gfp_mask & __GFP_NOFAIL))\n\t\treturn -ENOMEM;\nforce:\n\t/*\n\t * The allocation either can't fail or will lead to more memory\n\t * being freed very soon.  Allow memory usage go over the limit\n\t * temporarily by force charging it.\n\t */\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\treturn 0;\n\ndone_restock:\n\tcss_get_many(&memcg->css, batch);\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\n\t/*\n\t * If the hierarchy is above the normal consumption range, schedule\n\t * reclaim on returning to userland.  We can perform reclaim here\n\t * if __GFP_RECLAIM but let's always punt for simplicity and so that\n\t * GFP_KERNEL can consistently be used during reclaim.  @memcg is\n\t * not recorded as it most likely matches current's and won't\n\t * change in the meantime.  As high limit is checked again before\n\t * reclaim, the cost of mismatch is negligible.\n\t */\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) > memcg->high) {\n\t\t\t/* Don't bother a random interrupted task */\n\t\t\tif (in_interrupt()) {\n\t\t\t\tschedule_work(&memcg->high_work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->memcg_nr_pages_over_high += batch;\n\t\t\tset_notify_resume(current);\n\t\t\tbreak;\n\t\t}\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define MEM_CGROUP_RECLAIM_RETRIES\t5"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MEM_CGROUP_RECLAIM_RETRIES\t5\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int try_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t      unsigned int nr_pages)\n{\n\tunsigned int batch = max(MEMCG_CHARGE_BATCH, nr_pages);\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct page_counter *counter;\n\tunsigned long nr_reclaimed;\n\tbool may_swap = true;\n\tbool drained = false;\n\tbool oomed = false;\n\tenum oom_status oom_status;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\nretry:\n\tif (consume_stock(memcg, nr_pages))\n\t\treturn 0;\n\n\tif (!do_memsw_account() ||\n\t    page_counter_try_charge(&memcg->memsw, batch, &counter)) {\n\t\tif (page_counter_try_charge(&memcg->memory, batch, &counter))\n\t\t\tgoto done_restock;\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&memcg->memsw, batch);\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memory);\n\t} else {\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memsw);\n\t\tmay_swap = false;\n\t}\n\n\tif (batch > nr_pages) {\n\t\tbatch = nr_pages;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Unlike in global OOM situations, memcg is not in a physical\n\t * memory shortage.  Allow dying and OOM-killed tasks to\n\t * bypass the last charges so that they can exit quickly and\n\t * free their memory.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current) ||\n\t\t     fatal_signal_pending(current) ||\n\t\t     current->flags & PF_EXITING))\n\t\tgoto force;\n\n\t/*\n\t * Prevent unbounded recursion when reclaim operations need to\n\t * allocate memory. This might exceed the limits temporarily,\n\t * but we prefer facilitating memory reclaim and getting back\n\t * under the limit over triggering OOM kills in these cases.\n\t */\n\tif (unlikely(current->flags & PF_MEMALLOC))\n\t\tgoto force;\n\n\tif (unlikely(task_in_memcg_oom(current)))\n\t\tgoto nomem;\n\n\tif (!gfpflags_allow_blocking(gfp_mask))\n\t\tgoto nomem;\n\n\tmemcg_memory_event(mem_over_limit, MEMCG_MAX);\n\n\tnr_reclaimed = try_to_free_mem_cgroup_pages(mem_over_limit, nr_pages,\n\t\t\t\t\t\t    gfp_mask, may_swap);\n\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\tgoto retry;\n\n\tif (!drained) {\n\t\tdrain_all_stock(mem_over_limit);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nomem;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_reclaimed && nr_pages <= (1 << PAGE_ALLOC_COSTLY_ORDER))\n\t\tgoto retry;\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\tgoto retry;\n\n\tif (nr_retries--)\n\t\tgoto retry;\n\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL && oomed)\n\t\tgoto nomem;\n\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\tgoto force;\n\n\tif (fatal_signal_pending(current))\n\t\tgoto force;\n\n\t/*\n\t * keep retrying as long as the memcg oom killer is able to make\n\t * a forward progress or bypass the charge if the oom killer\n\t * couldn't make any progress.\n\t */\n\toom_status = mem_cgroup_oom(mem_over_limit, gfp_mask,\n\t\t       get_order(nr_pages * PAGE_SIZE));\n\tswitch (oom_status) {\n\tcase OOM_SUCCESS:\n\t\tnr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\toomed = true;\n\t\tgoto retry;\n\tcase OOM_FAILED:\n\t\tgoto force;\n\tdefault:\n\t\tgoto nomem;\n\t}\nnomem:\n\tif (!(gfp_mask & __GFP_NOFAIL))\n\t\treturn -ENOMEM;\nforce:\n\t/*\n\t * The allocation either can't fail or will lead to more memory\n\t * being freed very soon.  Allow memory usage go over the limit\n\t * temporarily by force charging it.\n\t */\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\treturn 0;\n\ndone_restock:\n\tcss_get_many(&memcg->css, batch);\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\n\t/*\n\t * If the hierarchy is above the normal consumption range, schedule\n\t * reclaim on returning to userland.  We can perform reclaim here\n\t * if __GFP_RECLAIM but let's always punt for simplicity and so that\n\t * GFP_KERNEL can consistently be used during reclaim.  @memcg is\n\t * not recorded as it most likely matches current's and won't\n\t * change in the meantime.  As high limit is checked again before\n\t * reclaim, the cost of mismatch is negligible.\n\t */\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) > memcg->high) {\n\t\t\t/* Don't bother a random interrupted task */\n\t\t\tif (in_interrupt()) {\n\t\t\t\tschedule_work(&memcg->high_work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->memcg_nr_pages_over_high += batch;\n\t\t\tset_notify_resume(current);\n\t\t\tbreak;\n\t\t}\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\n\nstatic int mem_cgroup_do_precharge(unsigned long count)\n{\n\tint ret;\n\n\t/* Try a single bulk charge without reclaim first, kswapd may wake */\n\tret = try_charge(mc.to, GFP_KERNEL & ~__GFP_DIRECT_RECLAIM, count);\n\tif (!ret) {\n\t\tmc.precharge += count;\n\t\treturn ret;\n\t}\n\n\t/* Try charges one by one with reclaim, but do not retry */\n\twhile (count--) {\n\t\tret = try_charge(mc.to, GFP_KERNEL | __GFP_NORETRY, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmc.precharge++;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_css_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4595-4609",
    "snippet": "static void mem_cgroup_css_reset(struct cgroup_subsys_state *css)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tpage_counter_set_max(&memcg->memory, PAGE_COUNTER_MAX);\n\tpage_counter_set_max(&memcg->swap, PAGE_COUNTER_MAX);\n\tpage_counter_set_max(&memcg->memsw, PAGE_COUNTER_MAX);\n\tpage_counter_set_max(&memcg->kmem, PAGE_COUNTER_MAX);\n\tpage_counter_set_max(&memcg->tcpmem, PAGE_COUNTER_MAX);\n\tpage_counter_set_min(&memcg->memory, 0);\n\tpage_counter_set_low(&memcg->memory, 0);\n\tmemcg->high = PAGE_COUNTER_MAX;\n\tmemcg->soft_limit = PAGE_COUNTER_MAX;\n\tmemcg_wb_domain_size_changed(memcg);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_wb_domain_size_changed",
          "args": [
            "memcg"
          ],
          "line": 4608
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_wb_domain_size_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3906-3908",
          "snippet": "static void memcg_wb_domain_size_changed(struct mem_cgroup *memcg)\n{\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_wb_domain_size_changed(struct mem_cgroup *memcg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_set_low",
          "args": [
            "&memcg->memory",
            "0"
          ],
          "line": 4605
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "229-237",
          "snippet": "void page_counter_set_low(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->low = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_set_low(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->low = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_set_min",
          "args": [
            "&memcg->memory",
            "0"
          ],
          "line": 4604
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "212-220",
          "snippet": "void page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->min = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->min = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_set_max",
          "args": [
            "&memcg->tcpmem",
            "PAGE_COUNTER_MAX"
          ],
          "line": 4603
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "173-203",
          "snippet": "int page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 4597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_css_reset(struct cgroup_subsys_state *css)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tpage_counter_set_max(&memcg->memory, PAGE_COUNTER_MAX);\n\tpage_counter_set_max(&memcg->swap, PAGE_COUNTER_MAX);\n\tpage_counter_set_max(&memcg->memsw, PAGE_COUNTER_MAX);\n\tpage_counter_set_max(&memcg->kmem, PAGE_COUNTER_MAX);\n\tpage_counter_set_max(&memcg->tcpmem, PAGE_COUNTER_MAX);\n\tpage_counter_set_min(&memcg->memory, 0);\n\tpage_counter_set_low(&memcg->memory, 0);\n\tmemcg->high = PAGE_COUNTER_MAX;\n\tmemcg->soft_limit = PAGE_COUNTER_MAX;\n\tmemcg_wb_domain_size_changed(memcg);\n}"
  },
  {
    "function_name": "mem_cgroup_css_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4564-4580",
    "snippet": "static void mem_cgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys) && !cgroup_memory_nosocket)\n\t\tstatic_branch_dec(&memcg_sockets_enabled_key);\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && memcg->tcpmem_active)\n\t\tstatic_branch_dec(&memcg_sockets_enabled_key);\n\n\tvmpressure_cleanup(&memcg->vmpressure);\n\tcancel_work_sync(&memcg->high_work);\n\tmem_cgroup_remove_from_trees(memcg);\n\tmemcg_free_shrinker_maps(memcg);\n\tmemcg_free_kmem(memcg);\n\tmem_cgroup_free(memcg);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "static bool cgroup_memory_nosocket;",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_free",
          "args": [
            "memcg"
          ],
          "line": 4579
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4391-4395",
          "snippet": "static void mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tmemcg_wb_domain_exit(memcg);\n\t__mem_cgroup_free(memcg);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tmemcg_wb_domain_exit(memcg);\n\t__mem_cgroup_free(memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_free_kmem",
          "args": [
            "memcg"
          ],
          "line": 4578
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_free_kmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3135-3137",
          "snippet": "static void memcg_free_kmem(struct mem_cgroup *memcg)\n{\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_free_kmem(struct mem_cgroup *memcg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_free_shrinker_maps",
          "args": [
            "memcg"
          ],
          "line": 4577
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_free_shrinker_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "445-445",
          "snippet": "static void memcg_free_shrinker_maps(struct mem_cgroup *memcg) { }",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_free_shrinker_maps(struct mem_cgroup *memcg) { }"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_remove_from_trees",
          "args": [
            "memcg"
          ],
          "line": 4576
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_remove_from_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "633-645",
          "snippet": "static void mem_cgroup_remove_from_trees(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_tree_per_node *mctz;\n\tstruct mem_cgroup_per_node *mz;\n\tint nid;\n\n\tfor_each_node(nid) {\n\t\tmz = mem_cgroup_nodeinfo(memcg, nid);\n\t\tmctz = soft_limit_tree_node(nid);\n\t\tif (mctz)\n\t\t\tmem_cgroup_remove_exceeded(mz, mctz);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_remove_from_trees(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_tree_per_node *mctz;\n\tstruct mem_cgroup_per_node *mz;\n\tint nid;\n\n\tfor_each_node(nid) {\n\t\tmz = mem_cgroup_nodeinfo(memcg, nid);\n\t\tmctz = soft_limit_tree_node(nid);\n\t\tif (mctz)\n\t\t\tmem_cgroup_remove_exceeded(mz, mctz);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&memcg->high_work"
          ],
          "line": 4575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmpressure_cleanup",
          "args": [
            "&memcg->vmpressure"
          ],
          "line": 4574
        },
        "resolved": true,
        "details": {
          "function_name": "vmpressure_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
          "lines": "465-472",
          "snippet": "void vmpressure_cleanup(struct vmpressure *vmpr)\n{\n\t/*\n\t * Make sure there is no pending work before eventfd infrastructure\n\t * goes away.\n\t */\n\tflush_work(&vmpr->work);\n}",
          "includes": [
            "#include <linux/vmpressure.h>",
            "#include <linux/printk.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nvoid vmpressure_cleanup(struct vmpressure *vmpr)\n{\n\t/*\n\t * Make sure there is no pending work before eventfd infrastructure\n\t * goes away.\n\t */\n\tflush_work(&vmpr->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_dec",
          "args": [
            "&memcg_sockets_enabled_key"
          ],
          "line": 4572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 4571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_dec",
          "args": [
            "&memcg_sockets_enabled_key"
          ],
          "line": 4569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 4568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic bool cgroup_memory_nosocket;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic void mem_cgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys) && !cgroup_memory_nosocket)\n\t\tstatic_branch_dec(&memcg_sockets_enabled_key);\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) && memcg->tcpmem_active)\n\t\tstatic_branch_dec(&memcg_sockets_enabled_key);\n\n\tvmpressure_cleanup(&memcg->vmpressure);\n\tcancel_work_sync(&memcg->high_work);\n\tmem_cgroup_remove_from_trees(memcg);\n\tmemcg_free_shrinker_maps(memcg);\n\tmemcg_free_kmem(memcg);\n\tmem_cgroup_free(memcg);\n}"
  },
  {
    "function_name": "mem_cgroup_css_released",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4557-4562",
    "snippet": "static void mem_cgroup_css_released(struct cgroup_subsys_state *css)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tinvalidate_reclaim_iterators(memcg);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_reclaim_iterators",
          "args": [
            "memcg"
          ],
          "line": 4561
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_reclaim_iterators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1034-1052",
          "snippet": "static void invalidate_reclaim_iterators(struct mem_cgroup *dead_memcg)\n{\n\tstruct mem_cgroup *memcg = dead_memcg;\n\tstruct mem_cgroup_reclaim_iter *iter;\n\tstruct mem_cgroup_per_node *mz;\n\tint nid;\n\tint i;\n\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tfor_each_node(nid) {\n\t\t\tmz = mem_cgroup_nodeinfo(memcg, nid);\n\t\t\tfor (i = 0; i <= DEF_PRIORITY; i++) {\n\t\t\t\titer = &mz->iter[i];\n\t\t\t\tcmpxchg(&iter->position,\n\t\t\t\t\tdead_memcg, NULL);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void invalidate_reclaim_iterators(struct mem_cgroup *dead_memcg)\n{\n\tstruct mem_cgroup *memcg = dead_memcg;\n\tstruct mem_cgroup_reclaim_iter *iter;\n\tstruct mem_cgroup_per_node *mz;\n\tint nid;\n\tint i;\n\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tfor_each_node(nid) {\n\t\t\tmz = mem_cgroup_nodeinfo(memcg, nid);\n\t\t\tfor (i = 0; i <= DEF_PRIORITY; i++) {\n\t\t\t\titer = &mz->iter[i];\n\t\t\t\tcmpxchg(&iter->position,\n\t\t\t\t\tdead_memcg, NULL);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 4559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_css_released(struct cgroup_subsys_state *css)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tinvalidate_reclaim_iterators(memcg);\n}"
  },
  {
    "function_name": "mem_cgroup_css_offline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4529-4555",
    "snippet": "static void mem_cgroup_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\tstruct mem_cgroup_event *event, *tmp;\n\n\t/*\n\t * Unregister events and notify userspace.\n\t * Notify userspace about cgroup removing only after rmdir of cgroup\n\t * directory to avoid race between userspace and kernelspace.\n\t */\n\tspin_lock(&memcg->event_list_lock);\n\tlist_for_each_entry_safe(event, tmp, &memcg->event_list, list) {\n\t\tlist_del_init(&event->list);\n\t\tschedule_work(&event->remove);\n\t}\n\tspin_unlock(&memcg->event_list_lock);\n\n\tpage_counter_set_min(&memcg->memory, 0);\n\tpage_counter_set_low(&memcg->memory, 0);\n\n\tmemcg_offline_kmem(memcg);\n\twb_memcg_offline(memcg);\n\n\tdrain_all_stock(memcg);\n\n\tmem_cgroup_id_put(memcg);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_id_put",
          "args": [
            "memcg"
          ],
          "line": 4554
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4320-4323",
          "snippet": "static inline void mem_cgroup_id_put(struct mem_cgroup *memcg)\n{\n\tmem_cgroup_id_put_many(memcg, 1);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic inline void mem_cgroup_id_put(struct mem_cgroup *memcg)\n{\n\tmem_cgroup_id_put_many(memcg, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_all_stock",
          "args": [
            "memcg"
          ],
          "line": 4552
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2028-2063",
          "snippet": "static void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define FLUSHING_CACHED_CHARGE\t0"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);",
            "static DEFINE_MUTEX(percpu_charge_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define FLUSHING_CACHED_CHARGE\t0\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\nstatic DEFINE_MUTEX(percpu_charge_mutex);\n\nstatic void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_memcg_offline",
          "args": [
            "memcg"
          ],
          "line": 4550
        },
        "resolved": true,
        "details": {
          "function_name": "wb_memcg_offline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/backing-dev.c",
          "lines": "733-743",
          "snippet": "void wb_memcg_offline(struct mem_cgroup *memcg)\n{\n\tstruct list_head *memcg_cgwb_list = &memcg->cgwb_list;\n\tstruct bdi_writeback *wb, *next;\n\n\tspin_lock_irq(&cgwb_lock);\n\tlist_for_each_entry_safe(wb, next, memcg_cgwb_list, memcg_node)\n\t\tcgwb_kill(wb);\n\tmemcg_cgwb_list->next = NULL;\t/* prevent new wb's */\n\tspin_unlock_irq(&cgwb_lock);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <trace/events/writeback.h>",
            "#include <linux/device.h>",
            "#include <linux/writeback.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/wait.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgwb_remove_from_bdi_list(struct bdi_writeback *wb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <trace/events/writeback.h>\n#include <linux/device.h>\n#include <linux/writeback.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/wait.h>\n\nstatic void cgwb_remove_from_bdi_list(struct bdi_writeback *wb);\n\nvoid wb_memcg_offline(struct mem_cgroup *memcg)\n{\n\tstruct list_head *memcg_cgwb_list = &memcg->cgwb_list;\n\tstruct bdi_writeback *wb, *next;\n\n\tspin_lock_irq(&cgwb_lock);\n\tlist_for_each_entry_safe(wb, next, memcg_cgwb_list, memcg_node)\n\t\tcgwb_kill(wb);\n\tmemcg_cgwb_list->next = NULL;\t/* prevent new wb's */\n\tspin_unlock_irq(&cgwb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_offline_kmem",
          "args": [
            "memcg"
          ],
          "line": 4549
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_offline_kmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3132-3134",
          "snippet": "static void memcg_offline_kmem(struct mem_cgroup *memcg)\n{\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_offline_kmem(struct mem_cgroup *memcg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_set_low",
          "args": [
            "&memcg->memory",
            "0"
          ],
          "line": 4547
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "229-237",
          "snippet": "void page_counter_set_low(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->low = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_set_low(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->low = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_set_min",
          "args": [
            "&memcg->memory",
            "0"
          ],
          "line": 4546
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "212-220",
          "snippet": "void page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->min = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->min = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&memcg->event_list_lock"
          ],
          "line": 4544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&event->remove"
          ],
          "line": 4542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&event->list"
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "event",
            "tmp",
            "&memcg->event_list",
            "list"
          ],
          "line": 4540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&memcg->event_list_lock"
          ],
          "line": 4539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 4531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\tstruct mem_cgroup_event *event, *tmp;\n\n\t/*\n\t * Unregister events and notify userspace.\n\t * Notify userspace about cgroup removing only after rmdir of cgroup\n\t * directory to avoid race between userspace and kernelspace.\n\t */\n\tspin_lock(&memcg->event_list_lock);\n\tlist_for_each_entry_safe(event, tmp, &memcg->event_list, list) {\n\t\tlist_del_init(&event->list);\n\t\tschedule_work(&event->remove);\n\t}\n\tspin_unlock(&memcg->event_list_lock);\n\n\tpage_counter_set_min(&memcg->memory, 0);\n\tpage_counter_set_low(&memcg->memory, 0);\n\n\tmemcg_offline_kmem(memcg);\n\twb_memcg_offline(memcg);\n\n\tdrain_all_stock(memcg);\n\n\tmem_cgroup_id_put(memcg);\n}"
  },
  {
    "function_name": "mem_cgroup_css_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4509-4527",
    "snippet": "static int mem_cgroup_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\t/*\n\t * A memcg must be visible for memcg_expand_shrinker_maps()\n\t * by the time the maps are allocated. So, we allocate maps\n\t * here, when for_each_mem_cgroup() can't skip it.\n\t */\n\tif (memcg_alloc_shrinker_maps(memcg)) {\n\t\tmem_cgroup_id_remove(memcg);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Online state pins memcg ID, memcg ID pins CSS */\n\trefcount_set(&memcg->id.ref, 1);\n\tcss_get(css);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "css"
          ],
          "line": 4525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&memcg->id.ref",
            "1"
          ],
          "line": 4524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id_remove",
          "args": [
            "memcg"
          ],
          "line": 4519
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4292-4298",
          "snippet": "static void mem_cgroup_id_remove(struct mem_cgroup *memcg)\n{\n\tif (memcg->id.id > 0) {\n\t\tidr_remove(&mem_cgroup_idr, memcg->id.id);\n\t\tmemcg->id.id = 0;\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_IDR(mem_cgroup_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_IDR(mem_cgroup_idr);\n\nstatic void mem_cgroup_id_remove(struct mem_cgroup *memcg)\n{\n\tif (memcg->id.id > 0) {\n\t\tidr_remove(&mem_cgroup_idr, memcg->id.id);\n\t\tmemcg->id.id = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_alloc_shrinker_maps",
          "args": [
            "memcg"
          ],
          "line": 4518
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_alloc_shrinker_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "441-444",
          "snippet": "static int memcg_alloc_shrinker_maps(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_alloc_shrinker_maps(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 4511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int mem_cgroup_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\t/*\n\t * A memcg must be visible for memcg_expand_shrinker_maps()\n\t * by the time the maps are allocated. So, we allocate maps\n\t * here, when for_each_mem_cgroup() can't skip it.\n\t */\n\tif (memcg_alloc_shrinker_maps(memcg)) {\n\t\tmem_cgroup_id_remove(memcg);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Online state pins memcg ID, memcg ID pins CSS */\n\trefcount_set(&memcg->id.ref, 1);\n\tcss_get(css);\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_css_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4450-4507",
    "snippet": "static struct cgroup_subsys_state * __ref\nmem_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct mem_cgroup *parent = mem_cgroup_from_css(parent_css);\n\tstruct mem_cgroup *memcg;\n\tlong error = -ENOMEM;\n\n\tmemcg = mem_cgroup_alloc();\n\tif (!memcg)\n\t\treturn ERR_PTR(error);\n\n\tmemcg->high = PAGE_COUNTER_MAX;\n\tmemcg->soft_limit = PAGE_COUNTER_MAX;\n\tif (parent) {\n\t\tmemcg->swappiness = mem_cgroup_swappiness(parent);\n\t\tmemcg->oom_kill_disable = parent->oom_kill_disable;\n\t}\n\tif (parent && parent->use_hierarchy) {\n\t\tmemcg->use_hierarchy = true;\n\t\tpage_counter_init(&memcg->memory, &parent->memory);\n\t\tpage_counter_init(&memcg->swap, &parent->swap);\n\t\tpage_counter_init(&memcg->memsw, &parent->memsw);\n\t\tpage_counter_init(&memcg->kmem, &parent->kmem);\n\t\tpage_counter_init(&memcg->tcpmem, &parent->tcpmem);\n\t} else {\n\t\tpage_counter_init(&memcg->memory, NULL);\n\t\tpage_counter_init(&memcg->swap, NULL);\n\t\tpage_counter_init(&memcg->memsw, NULL);\n\t\tpage_counter_init(&memcg->kmem, NULL);\n\t\tpage_counter_init(&memcg->tcpmem, NULL);\n\t\t/*\n\t\t * Deeper hierachy with use_hierarchy == false doesn't make\n\t\t * much sense so let cgroup subsystem know about this\n\t\t * unfortunate state in our controller.\n\t\t */\n\t\tif (parent != root_mem_cgroup)\n\t\t\tmemory_cgrp_subsys.broken_hierarchy = true;\n\t}\n\n\t/* The following stuff does not apply to the root */\n\tif (!parent) {\n\t\troot_mem_cgroup = memcg;\n\t\treturn &memcg->css;\n\t}\n\n\terror = memcg_online_kmem(memcg);\n\tif (error)\n\t\tgoto fail;\n\n\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys) && !cgroup_memory_nosocket)\n\t\tstatic_branch_inc(&memcg_sockets_enabled_key);\n\n\treturn &memcg->css;\nfail:\n\tmem_cgroup_id_remove(memcg);\n\tmem_cgroup_free(memcg);\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "struct mem_cgroup *root_mem_cgroup",
      "static bool cgroup_memory_nosocket;",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_free",
          "args": [
            "memcg"
          ],
          "line": 4505
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4391-4395",
          "snippet": "static void mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tmemcg_wb_domain_exit(memcg);\n\t__mem_cgroup_free(memcg);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tmemcg_wb_domain_exit(memcg);\n\t__mem_cgroup_free(memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id_remove",
          "args": [
            "memcg"
          ],
          "line": 4504
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4292-4298",
          "snippet": "static void mem_cgroup_id_remove(struct mem_cgroup *memcg)\n{\n\tif (memcg->id.id > 0) {\n\t\tidr_remove(&mem_cgroup_idr, memcg->id.id);\n\t\tmemcg->id.id = 0;\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_IDR(mem_cgroup_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_IDR(mem_cgroup_idr);\n\nstatic void mem_cgroup_id_remove(struct mem_cgroup *memcg)\n{\n\tif (memcg->id.id > 0) {\n\t\tidr_remove(&mem_cgroup_idr, memcg->id.id);\n\t\tmemcg->id.id = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&memcg_sockets_enabled_key"
          ],
          "line": 4500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_online_kmem",
          "args": [
            "memcg"
          ],
          "line": 4495
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_online_kmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3128-3131",
          "snippet": "static int memcg_online_kmem(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_online_kmem(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_init",
          "args": [
            "&memcg->tcpmem",
            "NULL"
          ],
          "line": 4479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_init",
          "args": [
            "&memcg->kmem",
            "NULL"
          ],
          "line": 4478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_init",
          "args": [
            "&memcg->memsw",
            "NULL"
          ],
          "line": 4477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_init",
          "args": [
            "&memcg->swap",
            "NULL"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_init",
          "args": [
            "&memcg->memory",
            "NULL"
          ],
          "line": 4475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_init",
          "args": [
            "&memcg->tcpmem",
            "&parent->tcpmem"
          ],
          "line": 4473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_init",
          "args": [
            "&memcg->kmem",
            "&parent->kmem"
          ],
          "line": 4472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_init",
          "args": [
            "&memcg->memsw",
            "&parent->memsw"
          ],
          "line": 4471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_init",
          "args": [
            "&memcg->swap",
            "&parent->swap"
          ],
          "line": 4470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_init",
          "args": [
            "&memcg->memory",
            "&parent->memory"
          ],
          "line": 4469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_swappiness",
          "args": [
            "parent"
          ],
          "line": 4464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 4459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_alloc",
          "args": [],
          "line": 4457
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4397-4448",
          "snippet": "static struct mem_cgroup *mem_cgroup_alloc(void)\n{\n\tstruct mem_cgroup *memcg;\n\tsize_t size;\n\tint node;\n\n\tsize = sizeof(struct mem_cgroup);\n\tsize += nr_node_ids * sizeof(struct mem_cgroup_per_node *);\n\n\tmemcg = kzalloc(size, GFP_KERNEL);\n\tif (!memcg)\n\t\treturn NULL;\n\n\tmemcg->id.id = idr_alloc(&mem_cgroup_idr, NULL,\n\t\t\t\t 1, MEM_CGROUP_ID_MAX,\n\t\t\t\t GFP_KERNEL);\n\tif (memcg->id.id < 0)\n\t\tgoto fail;\n\n\tmemcg->stat_cpu = alloc_percpu(struct mem_cgroup_stat_cpu);\n\tif (!memcg->stat_cpu)\n\t\tgoto fail;\n\n\tfor_each_node(node)\n\t\tif (alloc_mem_cgroup_per_node_info(memcg, node))\n\t\t\tgoto fail;\n\n\tif (memcg_wb_domain_init(memcg, GFP_KERNEL))\n\t\tgoto fail;\n\n\tINIT_WORK(&memcg->high_work, high_work_func);\n\tmemcg->last_scanned_node = MAX_NUMNODES;\n\tINIT_LIST_HEAD(&memcg->oom_notify);\n\tmutex_init(&memcg->thresholds_lock);\n\tspin_lock_init(&memcg->move_lock);\n\tvmpressure_init(&memcg->vmpressure);\n\tINIT_LIST_HEAD(&memcg->event_list);\n\tspin_lock_init(&memcg->event_list_lock);\n\tmemcg->socket_pressure = jiffies;\n#ifdef CONFIG_MEMCG_KMEM\n\tmemcg->kmemcg_id = -1;\n#endif\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tINIT_LIST_HEAD(&memcg->cgwb_list);\n#endif\n\tidr_replace(&mem_cgroup_idr, memcg, memcg->id.id);\n\treturn memcg;\nfail:\n\tmem_cgroup_id_remove(memcg);\n\t__mem_cgroup_free(memcg);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_IDR(mem_cgroup_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_IDR(mem_cgroup_idr);\n\nstatic struct mem_cgroup *mem_cgroup_alloc(void)\n{\n\tstruct mem_cgroup *memcg;\n\tsize_t size;\n\tint node;\n\n\tsize = sizeof(struct mem_cgroup);\n\tsize += nr_node_ids * sizeof(struct mem_cgroup_per_node *);\n\n\tmemcg = kzalloc(size, GFP_KERNEL);\n\tif (!memcg)\n\t\treturn NULL;\n\n\tmemcg->id.id = idr_alloc(&mem_cgroup_idr, NULL,\n\t\t\t\t 1, MEM_CGROUP_ID_MAX,\n\t\t\t\t GFP_KERNEL);\n\tif (memcg->id.id < 0)\n\t\tgoto fail;\n\n\tmemcg->stat_cpu = alloc_percpu(struct mem_cgroup_stat_cpu);\n\tif (!memcg->stat_cpu)\n\t\tgoto fail;\n\n\tfor_each_node(node)\n\t\tif (alloc_mem_cgroup_per_node_info(memcg, node))\n\t\t\tgoto fail;\n\n\tif (memcg_wb_domain_init(memcg, GFP_KERNEL))\n\t\tgoto fail;\n\n\tINIT_WORK(&memcg->high_work, high_work_func);\n\tmemcg->last_scanned_node = MAX_NUMNODES;\n\tINIT_LIST_HEAD(&memcg->oom_notify);\n\tmutex_init(&memcg->thresholds_lock);\n\tspin_lock_init(&memcg->move_lock);\n\tvmpressure_init(&memcg->vmpressure);\n\tINIT_LIST_HEAD(&memcg->event_list);\n\tspin_lock_init(&memcg->event_list_lock);\n\tmemcg->socket_pressure = jiffies;\n#ifdef CONFIG_MEMCG_KMEM\n\tmemcg->kmemcg_id = -1;\n#endif\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tINIT_LIST_HEAD(&memcg->cgwb_list);\n#endif\n\tidr_replace(&mem_cgroup_idr, memcg, memcg->id.id);\n\treturn memcg;\nfail:\n\tmem_cgroup_id_remove(memcg);\n\t__mem_cgroup_free(memcg);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "parent_css"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic bool cgroup_memory_nosocket;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic struct cgroup_subsys_state * __ref\nmem_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct mem_cgroup *parent = mem_cgroup_from_css(parent_css);\n\tstruct mem_cgroup *memcg;\n\tlong error = -ENOMEM;\n\n\tmemcg = mem_cgroup_alloc();\n\tif (!memcg)\n\t\treturn ERR_PTR(error);\n\n\tmemcg->high = PAGE_COUNTER_MAX;\n\tmemcg->soft_limit = PAGE_COUNTER_MAX;\n\tif (parent) {\n\t\tmemcg->swappiness = mem_cgroup_swappiness(parent);\n\t\tmemcg->oom_kill_disable = parent->oom_kill_disable;\n\t}\n\tif (parent && parent->use_hierarchy) {\n\t\tmemcg->use_hierarchy = true;\n\t\tpage_counter_init(&memcg->memory, &parent->memory);\n\t\tpage_counter_init(&memcg->swap, &parent->swap);\n\t\tpage_counter_init(&memcg->memsw, &parent->memsw);\n\t\tpage_counter_init(&memcg->kmem, &parent->kmem);\n\t\tpage_counter_init(&memcg->tcpmem, &parent->tcpmem);\n\t} else {\n\t\tpage_counter_init(&memcg->memory, NULL);\n\t\tpage_counter_init(&memcg->swap, NULL);\n\t\tpage_counter_init(&memcg->memsw, NULL);\n\t\tpage_counter_init(&memcg->kmem, NULL);\n\t\tpage_counter_init(&memcg->tcpmem, NULL);\n\t\t/*\n\t\t * Deeper hierachy with use_hierarchy == false doesn't make\n\t\t * much sense so let cgroup subsystem know about this\n\t\t * unfortunate state in our controller.\n\t\t */\n\t\tif (parent != root_mem_cgroup)\n\t\t\tmemory_cgrp_subsys.broken_hierarchy = true;\n\t}\n\n\t/* The following stuff does not apply to the root */\n\tif (!parent) {\n\t\troot_mem_cgroup = memcg;\n\t\treturn &memcg->css;\n\t}\n\n\terror = memcg_online_kmem(memcg);\n\tif (error)\n\t\tgoto fail;\n\n\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys) && !cgroup_memory_nosocket)\n\t\tstatic_branch_inc(&memcg_sockets_enabled_key);\n\n\treturn &memcg->css;\nfail:\n\tmem_cgroup_id_remove(memcg);\n\tmem_cgroup_free(memcg);\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "mem_cgroup_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4397-4448",
    "snippet": "static struct mem_cgroup *mem_cgroup_alloc(void)\n{\n\tstruct mem_cgroup *memcg;\n\tsize_t size;\n\tint node;\n\n\tsize = sizeof(struct mem_cgroup);\n\tsize += nr_node_ids * sizeof(struct mem_cgroup_per_node *);\n\n\tmemcg = kzalloc(size, GFP_KERNEL);\n\tif (!memcg)\n\t\treturn NULL;\n\n\tmemcg->id.id = idr_alloc(&mem_cgroup_idr, NULL,\n\t\t\t\t 1, MEM_CGROUP_ID_MAX,\n\t\t\t\t GFP_KERNEL);\n\tif (memcg->id.id < 0)\n\t\tgoto fail;\n\n\tmemcg->stat_cpu = alloc_percpu(struct mem_cgroup_stat_cpu);\n\tif (!memcg->stat_cpu)\n\t\tgoto fail;\n\n\tfor_each_node(node)\n\t\tif (alloc_mem_cgroup_per_node_info(memcg, node))\n\t\t\tgoto fail;\n\n\tif (memcg_wb_domain_init(memcg, GFP_KERNEL))\n\t\tgoto fail;\n\n\tINIT_WORK(&memcg->high_work, high_work_func);\n\tmemcg->last_scanned_node = MAX_NUMNODES;\n\tINIT_LIST_HEAD(&memcg->oom_notify);\n\tmutex_init(&memcg->thresholds_lock);\n\tspin_lock_init(&memcg->move_lock);\n\tvmpressure_init(&memcg->vmpressure);\n\tINIT_LIST_HEAD(&memcg->event_list);\n\tspin_lock_init(&memcg->event_list_lock);\n\tmemcg->socket_pressure = jiffies;\n#ifdef CONFIG_MEMCG_KMEM\n\tmemcg->kmemcg_id = -1;\n#endif\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tINIT_LIST_HEAD(&memcg->cgwb_list);\n#endif\n\tidr_replace(&mem_cgroup_idr, memcg, memcg->id.id);\n\treturn memcg;\nfail:\n\tmem_cgroup_id_remove(memcg);\n\t__mem_cgroup_free(memcg);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_IDR(mem_cgroup_idr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mem_cgroup_free",
          "args": [
            "memcg"
          ],
          "line": 4446
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4381-4389",
          "snippet": "static void __mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tfor_each_node(node)\n\t\tfree_mem_cgroup_per_node_info(memcg, node);\n\tfree_percpu(memcg->stat_cpu);\n\tkfree(memcg);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tfor_each_node(node)\n\t\tfree_mem_cgroup_per_node_info(memcg, node);\n\tfree_percpu(memcg->stat_cpu);\n\tkfree(memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id_remove",
          "args": [
            "memcg"
          ],
          "line": 4445
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4292-4298",
          "snippet": "static void mem_cgroup_id_remove(struct mem_cgroup *memcg)\n{\n\tif (memcg->id.id > 0) {\n\t\tidr_remove(&mem_cgroup_idr, memcg->id.id);\n\t\tmemcg->id.id = 0;\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_IDR(mem_cgroup_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_IDR(mem_cgroup_idr);\n\nstatic void mem_cgroup_id_remove(struct mem_cgroup *memcg)\n{\n\tif (memcg->id.id > 0) {\n\t\tidr_remove(&mem_cgroup_idr, memcg->id.id);\n\t\tmemcg->id.id = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_replace",
          "args": [
            "&mem_cgroup_idr",
            "memcg",
            "memcg->id.id"
          ],
          "line": 4442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&memcg->cgwb_list"
          ],
          "line": 4440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&memcg->event_list_lock"
          ],
          "line": 4434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&memcg->event_list"
          ],
          "line": 4433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmpressure_init",
          "args": [
            "&memcg->vmpressure"
          ],
          "line": 4432
        },
        "resolved": true,
        "details": {
          "function_name": "vmpressure_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
          "lines": "450-456",
          "snippet": "void vmpressure_init(struct vmpressure *vmpr)\n{\n\tspin_lock_init(&vmpr->sr_lock);\n\tmutex_init(&vmpr->events_lock);\n\tINIT_LIST_HEAD(&vmpr->events);\n\tINIT_WORK(&vmpr->work, vmpressure_work_fn);\n}",
          "includes": [
            "#include <linux/vmpressure.h>",
            "#include <linux/printk.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nvoid vmpressure_init(struct vmpressure *vmpr)\n{\n\tspin_lock_init(&vmpr->sr_lock);\n\tmutex_init(&vmpr->events_lock);\n\tINIT_LIST_HEAD(&vmpr->events);\n\tINIT_WORK(&vmpr->work, vmpressure_work_fn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&memcg->move_lock"
          ],
          "line": 4431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&memcg->thresholds_lock"
          ],
          "line": 4430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&memcg->oom_notify"
          ],
          "line": 4429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&memcg->high_work",
            "high_work_func"
          ],
          "line": 4427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_wb_domain_init",
          "args": [
            "memcg",
            "GFP_KERNEL"
          ],
          "line": 4424
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_wb_domain_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3897-3900",
          "snippet": "static int memcg_wb_domain_init(struct mem_cgroup *memcg, gfp_t gfp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_wb_domain_init(struct mem_cgroup *memcg, gfp_t gfp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structmem_cgroup_stat_cpu"
          ],
          "line": 4416
        },
        "resolved": true,
        "details": {
          "function_name": "early_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "941-950",
          "snippet": "static void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\n\nstatic void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "&mem_cgroup_idr",
            "NULL",
            "1",
            "MEM_CGROUP_ID_MAX",
            "GFP_KERNEL"
          ],
          "line": 4410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 4406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_IDR(mem_cgroup_idr);\n\nstatic struct mem_cgroup *mem_cgroup_alloc(void)\n{\n\tstruct mem_cgroup *memcg;\n\tsize_t size;\n\tint node;\n\n\tsize = sizeof(struct mem_cgroup);\n\tsize += nr_node_ids * sizeof(struct mem_cgroup_per_node *);\n\n\tmemcg = kzalloc(size, GFP_KERNEL);\n\tif (!memcg)\n\t\treturn NULL;\n\n\tmemcg->id.id = idr_alloc(&mem_cgroup_idr, NULL,\n\t\t\t\t 1, MEM_CGROUP_ID_MAX,\n\t\t\t\t GFP_KERNEL);\n\tif (memcg->id.id < 0)\n\t\tgoto fail;\n\n\tmemcg->stat_cpu = alloc_percpu(struct mem_cgroup_stat_cpu);\n\tif (!memcg->stat_cpu)\n\t\tgoto fail;\n\n\tfor_each_node(node)\n\t\tif (alloc_mem_cgroup_per_node_info(memcg, node))\n\t\t\tgoto fail;\n\n\tif (memcg_wb_domain_init(memcg, GFP_KERNEL))\n\t\tgoto fail;\n\n\tINIT_WORK(&memcg->high_work, high_work_func);\n\tmemcg->last_scanned_node = MAX_NUMNODES;\n\tINIT_LIST_HEAD(&memcg->oom_notify);\n\tmutex_init(&memcg->thresholds_lock);\n\tspin_lock_init(&memcg->move_lock);\n\tvmpressure_init(&memcg->vmpressure);\n\tINIT_LIST_HEAD(&memcg->event_list);\n\tspin_lock_init(&memcg->event_list_lock);\n\tmemcg->socket_pressure = jiffies;\n#ifdef CONFIG_MEMCG_KMEM\n\tmemcg->kmemcg_id = -1;\n#endif\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tINIT_LIST_HEAD(&memcg->cgwb_list);\n#endif\n\tidr_replace(&mem_cgroup_idr, memcg, memcg->id.id);\n\treturn memcg;\nfail:\n\tmem_cgroup_id_remove(memcg);\n\t__mem_cgroup_free(memcg);\n\treturn NULL;\n}"
  },
  {
    "function_name": "mem_cgroup_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4391-4395",
    "snippet": "static void mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tmemcg_wb_domain_exit(memcg);\n\t__mem_cgroup_free(memcg);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mem_cgroup_free",
          "args": [
            "memcg"
          ],
          "line": 4394
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4381-4389",
          "snippet": "static void __mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tfor_each_node(node)\n\t\tfree_mem_cgroup_per_node_info(memcg, node);\n\tfree_percpu(memcg->stat_cpu);\n\tkfree(memcg);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tfor_each_node(node)\n\t\tfree_mem_cgroup_per_node_info(memcg, node);\n\tfree_percpu(memcg->stat_cpu);\n\tkfree(memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_wb_domain_exit",
          "args": [
            "memcg"
          ],
          "line": 4393
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_wb_domain_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3902-3904",
          "snippet": "static void memcg_wb_domain_exit(struct mem_cgroup *memcg)\n{\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_wb_domain_exit(struct mem_cgroup *memcg)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tmemcg_wb_domain_exit(memcg);\n\t__mem_cgroup_free(memcg);\n}"
  },
  {
    "function_name": "__mem_cgroup_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4381-4389",
    "snippet": "static void __mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tfor_each_node(node)\n\t\tfree_mem_cgroup_per_node_info(memcg, node);\n\tfree_percpu(memcg->stat_cpu);\n\tkfree(memcg);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "memcg"
          ],
          "line": 4388
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "memcg->stat_cpu"
          ],
          "line": 4387
        },
        "resolved": true,
        "details": {
          "function_name": "free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1718-1753",
          "snippet": "void free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_size",
            "int pcpu_nr_slots",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static struct page *pcpu_addr_to_page(void *addr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nvoid free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tfor_each_node(node)\n\t\tfree_mem_cgroup_per_node_info(memcg, node);\n\tfree_percpu(memcg->stat_cpu);\n\tkfree(memcg);\n}"
  },
  {
    "function_name": "free_mem_cgroup_per_node_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4370-4379",
    "snippet": "static void free_mem_cgroup_per_node_info(struct mem_cgroup *memcg, int node)\n{\n\tstruct mem_cgroup_per_node *pn = memcg->nodeinfo[node];\n\n\tif (!pn)\n\t\treturn;\n\n\tfree_percpu(pn->lruvec_stat_cpu);\n\tkfree(pn);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pn"
          ],
          "line": 4378
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "pn->lruvec_stat_cpu"
          ],
          "line": 4377
        },
        "resolved": true,
        "details": {
          "function_name": "free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1718-1753",
          "snippet": "void free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_size",
            "int pcpu_nr_slots",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static struct page *pcpu_addr_to_page(void *addr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nvoid free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void free_mem_cgroup_per_node_info(struct mem_cgroup *memcg, int node)\n{\n\tstruct mem_cgroup_per_node *pn = memcg->nodeinfo[node];\n\n\tif (!pn)\n\t\treturn;\n\n\tfree_percpu(pn->lruvec_stat_cpu);\n\tkfree(pn);\n}"
  },
  {
    "function_name": "alloc_mem_cgroup_per_node_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4337-4368",
    "snippet": "static int alloc_mem_cgroup_per_node_info(struct mem_cgroup *memcg, int node)\n{\n\tstruct mem_cgroup_per_node *pn;\n\tint tmp = node;\n\t/*\n\t * This routine is called against possible nodes.\n\t * But it's BUG to call kmalloc() against offline node.\n\t *\n\t * TODO: this routine can waste much memory for nodes which will\n\t *       never be onlined. It's better to use memory hotplug callback\n\t *       function.\n\t */\n\tif (!node_state(node, N_NORMAL_MEMORY))\n\t\ttmp = -1;\n\tpn = kzalloc_node(sizeof(*pn), GFP_KERNEL, tmp);\n\tif (!pn)\n\t\treturn 1;\n\n\tpn->lruvec_stat_cpu = alloc_percpu(struct lruvec_stat);\n\tif (!pn->lruvec_stat_cpu) {\n\t\tkfree(pn);\n\t\treturn 1;\n\t}\n\n\tlruvec_init(&pn->lruvec);\n\tpn->usage_in_excess = 0;\n\tpn->on_tree = false;\n\tpn->memcg = memcg;\n\n\tmemcg->nodeinfo[node] = pn;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lruvec_init",
          "args": [
            "&pn->lruvec"
          ],
          "line": 4361
        },
        "resolved": true,
        "details": {
          "function_name": "lruvec_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "89-97",
          "snippet": "void lruvec_init(struct lruvec *lruvec)\n{\n\tenum lru_list lru;\n\n\tmemset(lruvec, 0, sizeof(struct lruvec));\n\n\tfor_each_lru(lru)\n\t\tINIT_LIST_HEAD(&lruvec->lists[lru]);\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid lruvec_init(struct lruvec *lruvec)\n{\n\tenum lru_list lru;\n\n\tmemset(lruvec, 0, sizeof(struct lruvec));\n\n\tfor_each_lru(lru)\n\t\tINIT_LIST_HEAD(&lruvec->lists[lru]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pn"
          ],
          "line": 4357
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structlruvec_stat"
          ],
          "line": 4355
        },
        "resolved": true,
        "details": {
          "function_name": "early_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "941-950",
          "snippet": "static void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\n\nstatic void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*pn)",
            "GFP_KERNEL",
            "tmp"
          ],
          "line": 4351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_state",
          "args": [
            "node",
            "N_NORMAL_MEMORY"
          ],
          "line": 4349
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "634-641",
          "snippet": "void inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int alloc_mem_cgroup_per_node_info(struct mem_cgroup *memcg, int node)\n{\n\tstruct mem_cgroup_per_node *pn;\n\tint tmp = node;\n\t/*\n\t * This routine is called against possible nodes.\n\t * But it's BUG to call kmalloc() against offline node.\n\t *\n\t * TODO: this routine can waste much memory for nodes which will\n\t *       never be onlined. It's better to use memory hotplug callback\n\t *       function.\n\t */\n\tif (!node_state(node, N_NORMAL_MEMORY))\n\t\ttmp = -1;\n\tpn = kzalloc_node(sizeof(*pn), GFP_KERNEL, tmp);\n\tif (!pn)\n\t\treturn 1;\n\n\tpn->lruvec_stat_cpu = alloc_percpu(struct lruvec_stat);\n\tif (!pn->lruvec_stat_cpu) {\n\t\tkfree(pn);\n\t\treturn 1;\n\t}\n\n\tlruvec_init(&pn->lruvec);\n\tpn->usage_in_excess = 0;\n\tpn->on_tree = false;\n\tpn->memcg = memcg;\n\n\tmemcg->nodeinfo[node] = pn;\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_from_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4331-4335",
    "snippet": "struct mem_cgroup *mem_cgroup_from_id(unsigned short id)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&mem_cgroup_idr, id);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static DEFINE_IDR(mem_cgroup_idr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&mem_cgroup_idr",
            "id"
          ],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\nstatic DEFINE_IDR(mem_cgroup_idr);\n\nstruct mem_cgroup *mem_cgroup_from_id(unsigned short id)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&mem_cgroup_idr, id);\n}"
  },
  {
    "function_name": "mem_cgroup_id_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4320-4323",
    "snippet": "static inline void mem_cgroup_id_put(struct mem_cgroup *memcg)\n{\n\tmem_cgroup_id_put_many(memcg, 1);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_id_put_many",
          "args": [
            "memcg",
            "1"
          ],
          "line": 4322
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_put_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4305-4313",
          "snippet": "static void mem_cgroup_id_put_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\tif (refcount_sub_and_test(n, &memcg->id.ref)) {\n\t\tmem_cgroup_id_remove(memcg);\n\n\t\t/* Memcg ID pins CSS */\n\t\tcss_put(&memcg->css);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_id_put_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\tif (refcount_sub_and_test(n, &memcg->id.ref)) {\n\t\tmem_cgroup_id_remove(memcg);\n\n\t\t/* Memcg ID pins CSS */\n\t\tcss_put(&memcg->css);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic inline void mem_cgroup_id_put(struct mem_cgroup *memcg)\n{\n\tmem_cgroup_id_put_many(memcg, 1);\n}"
  },
  {
    "function_name": "mem_cgroup_id_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4315-4318",
    "snippet": "static inline void mem_cgroup_id_get(struct mem_cgroup *memcg)\n{\n\tmem_cgroup_id_get_many(memcg, 1);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_id_get_many",
          "args": [
            "memcg",
            "1"
          ],
          "line": 4317
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_get_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4300-4303",
          "snippet": "static void mem_cgroup_id_get_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\trefcount_add(n, &memcg->id.ref);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_id_get_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\trefcount_add(n, &memcg->id.ref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic inline void mem_cgroup_id_get(struct mem_cgroup *memcg)\n{\n\tmem_cgroup_id_get_many(memcg, 1);\n}"
  },
  {
    "function_name": "mem_cgroup_id_put_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4305-4313",
    "snippet": "static void mem_cgroup_id_put_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\tif (refcount_sub_and_test(n, &memcg->id.ref)) {\n\t\tmem_cgroup_id_remove(memcg);\n\n\t\t/* Memcg ID pins CSS */\n\t\tcss_put(&memcg->css);\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&memcg->css"
          ],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id_remove",
          "args": [
            "memcg"
          ],
          "line": 4308
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4292-4298",
          "snippet": "static void mem_cgroup_id_remove(struct mem_cgroup *memcg)\n{\n\tif (memcg->id.id > 0) {\n\t\tidr_remove(&mem_cgroup_idr, memcg->id.id);\n\t\tmemcg->id.id = 0;\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_IDR(mem_cgroup_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_IDR(mem_cgroup_idr);\n\nstatic void mem_cgroup_id_remove(struct mem_cgroup *memcg)\n{\n\tif (memcg->id.id > 0) {\n\t\tidr_remove(&mem_cgroup_idr, memcg->id.id);\n\t\tmemcg->id.id = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_sub_and_test",
          "args": [
            "n",
            "&memcg->id.ref"
          ],
          "line": 4307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_id_put_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\tif (refcount_sub_and_test(n, &memcg->id.ref)) {\n\t\tmem_cgroup_id_remove(memcg);\n\n\t\t/* Memcg ID pins CSS */\n\t\tcss_put(&memcg->css);\n\t}\n}"
  },
  {
    "function_name": "mem_cgroup_id_get_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4300-4303",
    "snippet": "static void mem_cgroup_id_get_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\trefcount_add(n, &memcg->id.ref);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_add",
          "args": [
            "n",
            "&memcg->id.ref"
          ],
          "line": 4302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_id_get_many(struct mem_cgroup *memcg, unsigned int n)\n{\n\trefcount_add(n, &memcg->id.ref);\n}"
  },
  {
    "function_name": "mem_cgroup_id_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4292-4298",
    "snippet": "static void mem_cgroup_id_remove(struct mem_cgroup *memcg)\n{\n\tif (memcg->id.id > 0) {\n\t\tidr_remove(&mem_cgroup_idr, memcg->id.id);\n\t\tmemcg->id.id = 0;\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_IDR(mem_cgroup_idr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&mem_cgroup_idr",
            "memcg->id.id"
          ],
          "line": 4295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_IDR(mem_cgroup_idr);\n\nstatic void mem_cgroup_id_remove(struct mem_cgroup *memcg)\n{\n\tif (memcg->id.id > 0) {\n\t\tidr_remove(&mem_cgroup_idr, memcg->id.id);\n\t\tmemcg->id.id = 0;\n\t}\n}"
  },
  {
    "function_name": "memcg_write_event_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "4004-4133",
    "snippet": "static ssize_t memcg_write_event_control(struct kernfs_open_file *of,\n\t\t\t\t\t char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup_subsys_state *css = of_css(of);\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\tstruct mem_cgroup_event *event;\n\tstruct cgroup_subsys_state *cfile_css;\n\tunsigned int efd, cfd;\n\tstruct fd efile;\n\tstruct fd cfile;\n\tconst char *name;\n\tchar *endp;\n\tint ret;\n\n\tbuf = strstrip(buf);\n\n\tefd = simple_strtoul(buf, &endp, 10);\n\tif (*endp != ' ')\n\t\treturn -EINVAL;\n\tbuf = endp + 1;\n\n\tcfd = simple_strtoul(buf, &endp, 10);\n\tif ((*endp != ' ') && (*endp != '\\0'))\n\t\treturn -EINVAL;\n\tbuf = endp + 1;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tevent->memcg = memcg;\n\tINIT_LIST_HEAD(&event->list);\n\tinit_poll_funcptr(&event->pt, memcg_event_ptable_queue_proc);\n\tinit_waitqueue_func_entry(&event->wait, memcg_event_wake);\n\tINIT_WORK(&event->remove, memcg_event_remove);\n\n\tefile = fdget(efd);\n\tif (!efile.file) {\n\t\tret = -EBADF;\n\t\tgoto out_kfree;\n\t}\n\n\tevent->eventfd = eventfd_ctx_fileget(efile.file);\n\tif (IS_ERR(event->eventfd)) {\n\t\tret = PTR_ERR(event->eventfd);\n\t\tgoto out_put_efile;\n\t}\n\n\tcfile = fdget(cfd);\n\tif (!cfile.file) {\n\t\tret = -EBADF;\n\t\tgoto out_put_eventfd;\n\t}\n\n\t/* the process need read permission on control file */\n\t/* AV: shouldn't we check that it's been opened for read instead? */\n\tret = inode_permission(file_inode(cfile.file), MAY_READ);\n\tif (ret < 0)\n\t\tgoto out_put_cfile;\n\n\t/*\n\t * Determine the event callbacks and set them in @event.  This used\n\t * to be done via struct cftype but cgroup core no longer knows\n\t * about these events.  The following is crude but the whole thing\n\t * is for compatibility anyway.\n\t *\n\t * DO NOT ADD NEW FILES.\n\t */\n\tname = cfile.file->f_path.dentry->d_name.name;\n\n\tif (!strcmp(name, \"memory.usage_in_bytes\")) {\n\t\tevent->register_event = mem_cgroup_usage_register_event;\n\t\tevent->unregister_event = mem_cgroup_usage_unregister_event;\n\t} else if (!strcmp(name, \"memory.oom_control\")) {\n\t\tevent->register_event = mem_cgroup_oom_register_event;\n\t\tevent->unregister_event = mem_cgroup_oom_unregister_event;\n\t} else if (!strcmp(name, \"memory.pressure_level\")) {\n\t\tevent->register_event = vmpressure_register_event;\n\t\tevent->unregister_event = vmpressure_unregister_event;\n\t} else if (!strcmp(name, \"memory.memsw.usage_in_bytes\")) {\n\t\tevent->register_event = memsw_cgroup_usage_register_event;\n\t\tevent->unregister_event = memsw_cgroup_usage_unregister_event;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out_put_cfile;\n\t}\n\n\t/*\n\t * Verify @cfile should belong to @css.  Also, remaining events are\n\t * automatically removed on cgroup destruction but the removal is\n\t * asynchronous, so take an extra ref on @css.\n\t */\n\tcfile_css = css_tryget_online_from_dir(cfile.file->f_path.dentry->d_parent,\n\t\t\t\t\t       &memory_cgrp_subsys);\n\tret = -EINVAL;\n\tif (IS_ERR(cfile_css))\n\t\tgoto out_put_cfile;\n\tif (cfile_css != css) {\n\t\tcss_put(cfile_css);\n\t\tgoto out_put_cfile;\n\t}\n\n\tret = event->register_event(memcg, event->eventfd, buf);\n\tif (ret)\n\t\tgoto out_put_css;\n\n\tvfs_poll(efile.file, &event->pt);\n\n\tspin_lock(&memcg->event_list_lock);\n\tlist_add(&event->list, &memcg->event_list);\n\tspin_unlock(&memcg->event_list_lock);\n\n\tfdput(cfile);\n\tfdput(efile);\n\n\treturn nbytes;\n\nout_put_css:\n\tcss_put(css);\nout_put_cfile:\n\tfdput(cfile);\nout_put_eventfd:\n\teventfd_ctx_put(event->eventfd);\nout_put_efile:\n\tfdput(efile);\nout_kfree:\n\tkfree(event);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 4130
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "efile"
          ],
          "line": 4128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_put",
          "args": [
            "event->eventfd"
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "cfile"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "css"
          ],
          "line": 4122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "efile"
          ],
          "line": 4117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "cfile"
          ],
          "line": 4116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&memcg->event_list_lock"
          ],
          "line": 4114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&event->list",
            "&memcg->event_list"
          ],
          "line": 4113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&memcg->event_list_lock"
          ],
          "line": 4112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_poll",
          "args": [
            "efile.file",
            "&event->pt"
          ],
          "line": 4110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event->register_event",
          "args": [
            "memcg",
            "event->eventfd",
            "buf"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "cfile_css"
          ],
          "line": 4102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cfile_css"
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online_from_dir",
          "args": [
            "cfile.file->f_path.dentry->d_parent",
            "&memory_cgrp_subsys"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"memory.memsw.usage_in_bytes\""
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"memory.pressure_level\""
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"memory.oom_control\""
          ],
          "line": 4077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"memory.usage_in_bytes\""
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "file_inode(cfile.file)",
            "MAY_READ"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "cfile.file"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "cfd"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "event->eventfd"
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "event->eventfd"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_fileget",
          "args": [
            "efile.file"
          ],
          "line": 4046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "efd"
          ],
          "line": 4040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&event->remove",
            "memcg_event_remove"
          ],
          "line": 4038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_func_entry",
          "args": [
            "&event->wait",
            "memcg_event_wake"
          ],
          "line": 4037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_poll_funcptr",
          "args": [
            "&event->pt",
            "memcg_event_ptable_queue_proc"
          ],
          "line": 4036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&event->list"
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*event)",
            "GFP_KERNEL"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "buf",
            "&endp",
            "10"
          ],
          "line": 4025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "buf",
            "&endp",
            "10"
          ],
          "line": 4020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 4007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic ssize_t memcg_write_event_control(struct kernfs_open_file *of,\n\t\t\t\t\t char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup_subsys_state *css = of_css(of);\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\tstruct mem_cgroup_event *event;\n\tstruct cgroup_subsys_state *cfile_css;\n\tunsigned int efd, cfd;\n\tstruct fd efile;\n\tstruct fd cfile;\n\tconst char *name;\n\tchar *endp;\n\tint ret;\n\n\tbuf = strstrip(buf);\n\n\tefd = simple_strtoul(buf, &endp, 10);\n\tif (*endp != ' ')\n\t\treturn -EINVAL;\n\tbuf = endp + 1;\n\n\tcfd = simple_strtoul(buf, &endp, 10);\n\tif ((*endp != ' ') && (*endp != '\\0'))\n\t\treturn -EINVAL;\n\tbuf = endp + 1;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tevent->memcg = memcg;\n\tINIT_LIST_HEAD(&event->list);\n\tinit_poll_funcptr(&event->pt, memcg_event_ptable_queue_proc);\n\tinit_waitqueue_func_entry(&event->wait, memcg_event_wake);\n\tINIT_WORK(&event->remove, memcg_event_remove);\n\n\tefile = fdget(efd);\n\tif (!efile.file) {\n\t\tret = -EBADF;\n\t\tgoto out_kfree;\n\t}\n\n\tevent->eventfd = eventfd_ctx_fileget(efile.file);\n\tif (IS_ERR(event->eventfd)) {\n\t\tret = PTR_ERR(event->eventfd);\n\t\tgoto out_put_efile;\n\t}\n\n\tcfile = fdget(cfd);\n\tif (!cfile.file) {\n\t\tret = -EBADF;\n\t\tgoto out_put_eventfd;\n\t}\n\n\t/* the process need read permission on control file */\n\t/* AV: shouldn't we check that it's been opened for read instead? */\n\tret = inode_permission(file_inode(cfile.file), MAY_READ);\n\tif (ret < 0)\n\t\tgoto out_put_cfile;\n\n\t/*\n\t * Determine the event callbacks and set them in @event.  This used\n\t * to be done via struct cftype but cgroup core no longer knows\n\t * about these events.  The following is crude but the whole thing\n\t * is for compatibility anyway.\n\t *\n\t * DO NOT ADD NEW FILES.\n\t */\n\tname = cfile.file->f_path.dentry->d_name.name;\n\n\tif (!strcmp(name, \"memory.usage_in_bytes\")) {\n\t\tevent->register_event = mem_cgroup_usage_register_event;\n\t\tevent->unregister_event = mem_cgroup_usage_unregister_event;\n\t} else if (!strcmp(name, \"memory.oom_control\")) {\n\t\tevent->register_event = mem_cgroup_oom_register_event;\n\t\tevent->unregister_event = mem_cgroup_oom_unregister_event;\n\t} else if (!strcmp(name, \"memory.pressure_level\")) {\n\t\tevent->register_event = vmpressure_register_event;\n\t\tevent->unregister_event = vmpressure_unregister_event;\n\t} else if (!strcmp(name, \"memory.memsw.usage_in_bytes\")) {\n\t\tevent->register_event = memsw_cgroup_usage_register_event;\n\t\tevent->unregister_event = memsw_cgroup_usage_unregister_event;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out_put_cfile;\n\t}\n\n\t/*\n\t * Verify @cfile should belong to @css.  Also, remaining events are\n\t * automatically removed on cgroup destruction but the removal is\n\t * asynchronous, so take an extra ref on @css.\n\t */\n\tcfile_css = css_tryget_online_from_dir(cfile.file->f_path.dentry->d_parent,\n\t\t\t\t\t       &memory_cgrp_subsys);\n\tret = -EINVAL;\n\tif (IS_ERR(cfile_css))\n\t\tgoto out_put_cfile;\n\tif (cfile_css != css) {\n\t\tcss_put(cfile_css);\n\t\tgoto out_put_cfile;\n\t}\n\n\tret = event->register_event(memcg, event->eventfd, buf);\n\tif (ret)\n\t\tgoto out_put_css;\n\n\tvfs_poll(efile.file, &event->pt);\n\n\tspin_lock(&memcg->event_list_lock);\n\tlist_add(&event->list, &memcg->event_list);\n\tspin_unlock(&memcg->event_list_lock);\n\n\tfdput(cfile);\n\tfdput(efile);\n\n\treturn nbytes;\n\nout_put_css:\n\tcss_put(css);\nout_put_cfile:\n\tfdput(cfile);\nout_put_eventfd:\n\teventfd_ctx_put(event->eventfd);\nout_put_efile:\n\tfdput(efile);\nout_kfree:\n\tkfree(event);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "memcg_event_ptable_queue_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3986-3994",
    "snippet": "static void memcg_event_ptable_queue_proc(struct file *file,\n\t\twait_queue_head_t *wqh, poll_table *pt)\n{\n\tstruct mem_cgroup_event *event =\n\t\tcontainer_of(pt, struct mem_cgroup_event, pt);\n\n\tevent->wqh = wqh;\n\tadd_wait_queue(wqh, &event->wait);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "wqh",
            "&event->wait"
          ],
          "line": 3993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "pt",
            "structmem_cgroup_event",
            "pt"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void memcg_event_ptable_queue_proc(struct file *file,\n\t\twait_queue_head_t *wqh, poll_table *pt)\n{\n\tstruct mem_cgroup_event *event =\n\t\tcontainer_of(pt, struct mem_cgroup_event, pt);\n\n\tevent->wqh = wqh;\n\tadd_wait_queue(wqh, &event->wait);\n}"
  },
  {
    "function_name": "memcg_event_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3953-3984",
    "snippet": "static int memcg_event_wake(wait_queue_entry_t *wait, unsigned mode,\n\t\t\t    int sync, void *key)\n{\n\tstruct mem_cgroup_event *event =\n\t\tcontainer_of(wait, struct mem_cgroup_event, wait);\n\tstruct mem_cgroup *memcg = event->memcg;\n\t__poll_t flags = key_to_poll(key);\n\n\tif (flags & EPOLLHUP) {\n\t\t/*\n\t\t * If the event has been detached at cgroup removal, we\n\t\t * can simply return knowing the other side will cleanup\n\t\t * for us.\n\t\t *\n\t\t * We can't race against event freeing since the other\n\t\t * side will require wqh->lock via remove_wait_queue(),\n\t\t * which we hold.\n\t\t */\n\t\tspin_lock(&memcg->event_list_lock);\n\t\tif (!list_empty(&event->list)) {\n\t\t\tlist_del_init(&event->list);\n\t\t\t/*\n\t\t\t * We are in atomic context, but cgroup_event_remove()\n\t\t\t * may sleep, so we have to call it in workqueue.\n\t\t\t */\n\t\t\tschedule_work(&event->remove);\n\t\t}\n\t\tspin_unlock(&memcg->event_list_lock);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&memcg->event_list_lock"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&event->remove"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&event->list"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&event->list"
          ],
          "line": 3972
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&memcg->event_list_lock"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_to_poll",
          "args": [
            "key"
          ],
          "line": 3959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structmem_cgroup_event",
            "wait"
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_event_wake(wait_queue_entry_t *wait, unsigned mode,\n\t\t\t    int sync, void *key)\n{\n\tstruct mem_cgroup_event *event =\n\t\tcontainer_of(wait, struct mem_cgroup_event, wait);\n\tstruct mem_cgroup *memcg = event->memcg;\n\t__poll_t flags = key_to_poll(key);\n\n\tif (flags & EPOLLHUP) {\n\t\t/*\n\t\t * If the event has been detached at cgroup removal, we\n\t\t * can simply return knowing the other side will cleanup\n\t\t * for us.\n\t\t *\n\t\t * We can't race against event freeing since the other\n\t\t * side will require wqh->lock via remove_wait_queue(),\n\t\t * which we hold.\n\t\t */\n\t\tspin_lock(&memcg->event_list_lock);\n\t\tif (!list_empty(&event->list)) {\n\t\t\tlist_del_init(&event->list);\n\t\t\t/*\n\t\t\t * We are in atomic context, but cgroup_event_remove()\n\t\t\t * may sleep, so we have to call it in workqueue.\n\t\t\t */\n\t\t\tschedule_work(&event->remove);\n\t\t}\n\t\tspin_unlock(&memcg->event_list_lock);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_event_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3930-3946",
    "snippet": "static void memcg_event_remove(struct work_struct *work)\n{\n\tstruct mem_cgroup_event *event =\n\t\tcontainer_of(work, struct mem_cgroup_event, remove);\n\tstruct mem_cgroup *memcg = event->memcg;\n\n\tremove_wait_queue(event->wqh, &event->wait);\n\n\tevent->unregister_event(memcg, event->eventfd);\n\n\t/* Notify userspace the event is going away. */\n\teventfd_signal(event->eventfd, 1);\n\n\teventfd_ctx_put(event->eventfd);\n\tkfree(event);\n\tcss_put(&memcg->css);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&memcg->css"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_put",
          "args": [
            "event->eventfd"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_signal",
          "args": [
            "event->eventfd",
            "1"
          ],
          "line": 3941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event->unregister_event",
          "args": [
            "memcg",
            "event->eventfd"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "event->wqh",
            "&event->wait"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structmem_cgroup_event",
            "remove"
          ],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_event_remove(struct work_struct *work)\n{\n\tstruct mem_cgroup_event *event =\n\t\tcontainer_of(work, struct mem_cgroup_event, remove);\n\tstruct mem_cgroup *memcg = event->memcg;\n\n\tremove_wait_queue(event->wqh, &event->wait);\n\n\tevent->unregister_event(memcg, event->eventfd);\n\n\t/* Notify userspace the event is going away. */\n\teventfd_signal(event->eventfd, 1);\n\n\teventfd_ctx_put(event->eventfd);\n\tkfree(event);\n\tcss_put(&memcg->css);\n}"
  },
  {
    "function_name": "memcg_wb_domain_size_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3906-3908",
    "snippet": "static void memcg_wb_domain_size_changed(struct mem_cgroup *memcg)\n{\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_wb_domain_size_changed(struct mem_cgroup *memcg)\n{\n}"
  },
  {
    "function_name": "memcg_wb_domain_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3902-3904",
    "snippet": "static void memcg_wb_domain_exit(struct mem_cgroup *memcg)\n{\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_wb_domain_exit(struct mem_cgroup *memcg)\n{\n}"
  },
  {
    "function_name": "memcg_wb_domain_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3897-3900",
    "snippet": "static int memcg_wb_domain_init(struct mem_cgroup *memcg, gfp_t gfp)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_wb_domain_init(struct mem_cgroup *memcg, gfp_t gfp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_wb_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3871-3893",
    "snippet": "void mem_cgroup_wb_stats(struct bdi_writeback *wb, unsigned long *pfilepages,\n\t\t\t unsigned long *pheadroom, unsigned long *pdirty,\n\t\t\t unsigned long *pwriteback)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(wb->memcg_css);\n\tstruct mem_cgroup *parent;\n\n\t*pdirty = memcg_page_state(memcg, NR_FILE_DIRTY);\n\n\t/* this should eventually include NR_UNSTABLE_NFS */\n\t*pwriteback = memcg_page_state(memcg, NR_WRITEBACK);\n\t*pfilepages = mem_cgroup_nr_lru_pages(memcg, (1 << LRU_INACTIVE_FILE) |\n\t\t\t\t\t\t     (1 << LRU_ACTIVE_FILE));\n\t*pheadroom = PAGE_COUNTER_MAX;\n\n\twhile ((parent = parent_mem_cgroup(memcg))) {\n\t\tunsigned long ceiling = min(memcg->memory.max, memcg->high);\n\t\tunsigned long used = page_counter_read(&memcg->memory);\n\n\t\t*pheadroom = min(*pheadroom, ceiling - min(ceiling, used));\n\t\tmemcg = parent;\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "*pheadroom",
            "ceiling - min(ceiling, used)"
          ],
          "line": 3890
        },
        "resolved": true,
        "details": {
          "function_name": "memory_min_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5342-5353",
          "snippet": "static int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 3886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nr_lru_pages",
          "args": [
            "memcg",
            "(1 << LRU_INACTIVE_FILE) |\n\t\t\t\t\t\t     (1 << LRU_ACTIVE_FILE)"
          ],
          "line": 3882
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_nr_lru_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "738-747",
          "snippet": "static unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_page_state",
          "args": [
            "memcg",
            "NR_WRITEBACK"
          ],
          "line": 3881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_page_state",
          "args": [
            "memcg",
            "NR_FILE_DIRTY"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "wb->memcg_css"
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_wb_stats(struct bdi_writeback *wb, unsigned long *pfilepages,\n\t\t\t unsigned long *pheadroom, unsigned long *pdirty,\n\t\t\t unsigned long *pwriteback)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(wb->memcg_css);\n\tstruct mem_cgroup *parent;\n\n\t*pdirty = memcg_page_state(memcg, NR_FILE_DIRTY);\n\n\t/* this should eventually include NR_UNSTABLE_NFS */\n\t*pwriteback = memcg_page_state(memcg, NR_WRITEBACK);\n\t*pfilepages = mem_cgroup_nr_lru_pages(memcg, (1 << LRU_INACTIVE_FILE) |\n\t\t\t\t\t\t     (1 << LRU_ACTIVE_FILE));\n\t*pheadroom = PAGE_COUNTER_MAX;\n\n\twhile ((parent = parent_mem_cgroup(memcg))) {\n\t\tunsigned long ceiling = min(memcg->memory.max, memcg->high);\n\t\tunsigned long used = page_counter_read(&memcg->memory);\n\n\t\t*pheadroom = min(*pheadroom, ceiling - min(ceiling, used));\n\t\tmemcg = parent;\n\t}\n}"
  },
  {
    "function_name": "mem_cgroup_wb_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3843-3851",
    "snippet": "struct wb_domain *mem_cgroup_wb_domain(struct bdi_writeback *wb)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(wb->memcg_css);\n\n\tif (!memcg->css.parent)\n\t\treturn NULL;\n\n\treturn &memcg->cgwb_domain;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "wb->memcg_css"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct wb_domain *mem_cgroup_wb_domain(struct bdi_writeback *wb)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(wb->memcg_css);\n\n\tif (!memcg->css.parent)\n\t\treturn NULL;\n\n\treturn &memcg->cgwb_domain;\n}"
  },
  {
    "function_name": "memcg_wb_domain_size_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3838-3841",
    "snippet": "static void memcg_wb_domain_size_changed(struct mem_cgroup *memcg)\n{\n\twb_domain_size_changed(&memcg->cgwb_domain);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_domain_size_changed",
          "args": [
            "&memcg->cgwb_domain"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_wb_domain_size_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3906-3908",
          "snippet": "static void memcg_wb_domain_size_changed(struct mem_cgroup *memcg)\n{\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_wb_domain_size_changed(struct mem_cgroup *memcg)\n{\n\twb_domain_size_changed(&memcg->cgwb_domain);\n}"
  },
  {
    "function_name": "memcg_wb_domain_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3833-3836",
    "snippet": "static void memcg_wb_domain_exit(struct mem_cgroup *memcg)\n{\n\twb_domain_exit(&memcg->cgwb_domain);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_domain_exit",
          "args": [
            "&memcg->cgwb_domain"
          ],
          "line": 3835
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_wb_domain_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3902-3904",
          "snippet": "static void memcg_wb_domain_exit(struct mem_cgroup *memcg)\n{\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_wb_domain_exit(struct mem_cgroup *memcg)\n{\n\twb_domain_exit(&memcg->cgwb_domain);\n}"
  },
  {
    "function_name": "memcg_wb_domain_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3828-3831",
    "snippet": "static int memcg_wb_domain_init(struct mem_cgroup *memcg, gfp_t gfp)\n{\n\treturn wb_domain_init(&memcg->cgwb_domain, gfp);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_domain_init",
          "args": [
            "&memcg->cgwb_domain",
            "gfp"
          ],
          "line": 3830
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_wb_domain_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3897-3900",
          "snippet": "static int memcg_wb_domain_init(struct mem_cgroup *memcg, gfp_t gfp)\n{\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_wb_domain_init(struct mem_cgroup *memcg, gfp_t gfp)\n{\n\treturn wb_domain_init(&memcg->cgwb_domain, gfp);\n}"
  },
  {
    "function_name": "mem_cgroup_oom_control_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3810-3824",
    "snippet": "static int mem_cgroup_oom_control_write(struct cgroup_subsys_state *css,\n\tstruct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\t/* cannot set to root cgroup and only 0 and 1 are allowed */\n\tif (!css->parent || !((val == 0) || (val == 1)))\n\t\treturn -EINVAL;\n\n\tmemcg->oom_kill_disable = val;\n\tif (!val)\n\t\tmemcg_oom_recover(memcg);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_oom_recover",
          "args": [
            "memcg"
          ],
          "line": 3821
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_oom_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1646-1658",
          "snippet": "static void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);\n\nstatic void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int mem_cgroup_oom_control_write(struct cgroup_subsys_state *css,\n\tstruct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\t/* cannot set to root cgroup and only 0 and 1 are allowed */\n\tif (!css->parent || !((val == 0) || (val == 1)))\n\t\treturn -EINVAL;\n\n\tmemcg->oom_kill_disable = val;\n\tif (!val)\n\t\tmemcg_oom_recover(memcg);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_oom_control_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3799-3808",
    "snippet": "static int mem_cgroup_oom_control_read(struct seq_file *sf, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(sf));\n\n\tseq_printf(sf, \"oom_kill_disable %d\\n\", memcg->oom_kill_disable);\n\tseq_printf(sf, \"under_oom %d\\n\", (bool)memcg->under_oom);\n\tseq_printf(sf, \"oom_kill %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_OOM_KILL]));\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"oom_kill %lu\\n\"",
            "atomic_long_read(&memcg->memory_events[MEMCG_OOM_KILL])"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&memcg->memory_events[MEMCG_OOM_KILL]"
          ],
          "line": 3806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"under_oom %d\\n\"",
            "(bool)memcg->under_oom"
          ],
          "line": 3804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"oom_kill_disable %d\\n\"",
            "memcg->oom_kill_disable"
          ],
          "line": 3803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(sf)"
          ],
          "line": 3801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 3801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int mem_cgroup_oom_control_read(struct seq_file *sf, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(sf));\n\n\tseq_printf(sf, \"oom_kill_disable %d\\n\", memcg->oom_kill_disable);\n\tseq_printf(sf, \"under_oom %d\\n\", (bool)memcg->under_oom);\n\tseq_printf(sf, \"oom_kill %lu\\n\",\n\t\t   atomic_long_read(&memcg->memory_events[MEMCG_OOM_KILL]));\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_oom_unregister_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3782-3797",
    "snippet": "static void mem_cgroup_oom_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup_eventfd_list *ev, *tmp;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tlist_for_each_entry_safe(ev, tmp, &memcg->oom_notify, list) {\n\t\tif (ev->eventfd == eventfd) {\n\t\t\tlist_del(&ev->list);\n\t\t\tkfree(ev);\n\t\t}\n\t}\n\n\tspin_unlock(&memcg_oom_lock);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_SPINLOCK(memcg_oom_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ev"
          ],
          "line": 3792
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ev->list"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ev",
            "tmp",
            "&memcg->oom_notify",
            "list"
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic void mem_cgroup_oom_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup_eventfd_list *ev, *tmp;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tlist_for_each_entry_safe(ev, tmp, &memcg->oom_notify, list) {\n\t\tif (ev->eventfd == eventfd) {\n\t\t\tlist_del(&ev->list);\n\t\t\tkfree(ev);\n\t\t}\n\t}\n\n\tspin_unlock(&memcg_oom_lock);\n}"
  },
  {
    "function_name": "mem_cgroup_oom_register_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3760-3780",
    "snippet": "static int mem_cgroup_oom_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args)\n{\n\tstruct mem_cgroup_eventfd_list *event;\n\n\tevent = kmalloc(sizeof(*event),\tGFP_KERNEL);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tevent->eventfd = eventfd;\n\tlist_add(&event->list, &memcg->oom_notify);\n\n\t/* already in OOM ? */\n\tif (memcg->under_oom)\n\t\teventfd_signal(eventfd, 1);\n\tspin_unlock(&memcg_oom_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_SPINLOCK(memcg_oom_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_signal",
          "args": [
            "eventfd",
            "1"
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&event->list",
            "&memcg->oom_notify"
          ],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 3769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*event)",
            "GFP_KERNEL"
          ],
          "line": 3765
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic int mem_cgroup_oom_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args)\n{\n\tstruct mem_cgroup_eventfd_list *event;\n\n\tevent = kmalloc(sizeof(*event),\tGFP_KERNEL);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tevent->eventfd = eventfd;\n\tlist_add(&event->list, &memcg->oom_notify);\n\n\t/* already in OOM ? */\n\tif (memcg->under_oom)\n\t\teventfd_signal(eventfd, 1);\n\tspin_unlock(&memcg_oom_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memsw_cgroup_usage_unregister_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3754-3758",
    "snippet": "static void memsw_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEMSWAP);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mem_cgroup_usage_unregister_event",
          "args": [
            "memcg",
            "eventfd",
            "_MEMSWAP"
          ],
          "line": 3757
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_usage_unregister_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3669-3746",
          "snippet": "static void __mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long usage;\n\tint i, j, size;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\tif (!thresholds->primary)\n\t\tgoto unlock;\n\n\t/* Check if a threshold crossed before removing */\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\t/* Calculate new number of threshold */\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\n\tnew = thresholds->spare;\n\n\t/* Set thresholds array to NULL if we don't have thresholds */\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\n\tnew->size = size;\n\n\t/* Copy thresholds and find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used\n\t\t\t * until rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\n\nswap_buffers:\n\t/* Swap primary and spare array */\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\n\t/* If all events are unregistered, free the spare array */\n\tif (!new) {\n\t\tkfree(thresholds->spare);\n\t\tthresholds->spare = NULL;\n\t}\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long usage;\n\tint i, j, size;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\tif (!thresholds->primary)\n\t\tgoto unlock;\n\n\t/* Check if a threshold crossed before removing */\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\t/* Calculate new number of threshold */\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\n\tnew = thresholds->spare;\n\n\t/* Set thresholds array to NULL if we don't have thresholds */\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\n\tnew->size = size;\n\n\t/* Copy thresholds and find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used\n\t\t\t * until rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\n\nswap_buffers:\n\t/* Swap primary and spare array */\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\n\t/* If all events are unregistered, free the spare array */\n\tif (!new) {\n\t\tkfree(thresholds->spare);\n\t\tthresholds->spare = NULL;\n\t}\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memsw_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEMSWAP);\n}"
  },
  {
    "function_name": "mem_cgroup_usage_unregister_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3748-3752",
    "snippet": "static void mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEM);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mem_cgroup_usage_unregister_event",
          "args": [
            "memcg",
            "eventfd",
            "_MEM"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_usage_unregister_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3669-3746",
          "snippet": "static void __mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long usage;\n\tint i, j, size;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\tif (!thresholds->primary)\n\t\tgoto unlock;\n\n\t/* Check if a threshold crossed before removing */\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\t/* Calculate new number of threshold */\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\n\tnew = thresholds->spare;\n\n\t/* Set thresholds array to NULL if we don't have thresholds */\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\n\tnew->size = size;\n\n\t/* Copy thresholds and find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used\n\t\t\t * until rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\n\nswap_buffers:\n\t/* Swap primary and spare array */\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\n\t/* If all events are unregistered, free the spare array */\n\tif (!new) {\n\t\tkfree(thresholds->spare);\n\t\tthresholds->spare = NULL;\n\t}\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long usage;\n\tint i, j, size;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\tif (!thresholds->primary)\n\t\tgoto unlock;\n\n\t/* Check if a threshold crossed before removing */\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\t/* Calculate new number of threshold */\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\n\tnew = thresholds->spare;\n\n\t/* Set thresholds array to NULL if we don't have thresholds */\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\n\tnew->size = size;\n\n\t/* Copy thresholds and find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used\n\t\t\t * until rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\n\nswap_buffers:\n\t/* Swap primary and spare array */\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\n\t/* If all events are unregistered, free the spare array */\n\tif (!new) {\n\t\tkfree(thresholds->spare);\n\t\tthresholds->spare = NULL;\n\t}\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEM);\n}"
  },
  {
    "function_name": "__mem_cgroup_usage_unregister_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3669-3746",
    "snippet": "static void __mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long usage;\n\tint i, j, size;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\tif (!thresholds->primary)\n\t\tgoto unlock;\n\n\t/* Check if a threshold crossed before removing */\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\t/* Calculate new number of threshold */\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\n\tnew = thresholds->spare;\n\n\t/* Set thresholds array to NULL if we don't have thresholds */\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\n\tnew->size = size;\n\n\t/* Copy thresholds and find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used\n\t\t\t * until rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\n\nswap_buffers:\n\t/* Swap primary and spare array */\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\n\t/* If all events are unregistered, free the spare array */\n\tif (!new) {\n\t\tkfree(thresholds->spare);\n\t\tthresholds->spare = NULL;\n\t}\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&memcg->thresholds_lock"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "thresholds->spare"
          ],
          "line": 3741
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "thresholds->primary",
            "new"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_threshold",
          "args": [
            "memcg",
            "type == _MEMSWAP"
          ],
          "line": 3692
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_threshold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3478-3527",
          "snippet": "static void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)\n{\n\tstruct mem_cgroup_threshold_ary *t;\n\tunsigned long usage;\n\tint i;\n\n\trcu_read_lock();\n\tif (!swap)\n\t\tt = rcu_dereference(memcg->thresholds.primary);\n\telse\n\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);\n\n\tif (!t)\n\t\tgoto unlock;\n\n\tusage = mem_cgroup_usage(memcg, swap);\n\n\t/*\n\t * current_threshold points to threshold just below or equal to usage.\n\t * If it's not true, a threshold was crossed after last\n\t * call of __mem_cgroup_threshold().\n\t */\n\ti = t->current_threshold;\n\n\t/*\n\t * Iterate backward over array of thresholds starting from\n\t * current_threshold and check if a threshold is crossed.\n\t * If none of thresholds below usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* i = current_threshold + 1 */\n\ti++;\n\n\t/*\n\t * Iterate forward over array of thresholds starting from\n\t * current_threshold+1 and check if a threshold is crossed.\n\t * If none of thresholds above usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* Update current_threshold */\n\tt->current_threshold = i - 1;\nunlock:\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)\n{\n\tstruct mem_cgroup_threshold_ary *t;\n\tunsigned long usage;\n\tint i;\n\n\trcu_read_lock();\n\tif (!swap)\n\t\tt = rcu_dereference(memcg->thresholds.primary);\n\telse\n\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);\n\n\tif (!t)\n\t\tgoto unlock;\n\n\tusage = mem_cgroup_usage(memcg, swap);\n\n\t/*\n\t * current_threshold points to threshold just below or equal to usage.\n\t * If it's not true, a threshold was crossed after last\n\t * call of __mem_cgroup_threshold().\n\t */\n\ti = t->current_threshold;\n\n\t/*\n\t * Iterate backward over array of thresholds starting from\n\t * current_threshold and check if a threshold is crossed.\n\t * If none of thresholds below usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* i = current_threshold + 1 */\n\ti++;\n\n\t/*\n\t * Iterate forward over array of thresholds starting from\n\t * current_threshold+1 and check if a threshold is crossed.\n\t * If none of thresholds above usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* Update current_threshold */\n\tt->current_threshold = i - 1;\nunlock:\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_usage",
          "args": [
            "memcg",
            "true"
          ],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_usage_unregister_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3748-3752",
          "snippet": "static void mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEM);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&memcg->thresholds_lock"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long usage;\n\tint i, j, size;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\tif (!thresholds->primary)\n\t\tgoto unlock;\n\n\t/* Check if a threshold crossed before removing */\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\t/* Calculate new number of threshold */\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\n\tnew = thresholds->spare;\n\n\t/* Set thresholds array to NULL if we don't have thresholds */\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\n\tnew->size = size;\n\n\t/* Copy thresholds and find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used\n\t\t\t * until rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\n\nswap_buffers:\n\t/* Swap primary and spare array */\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\n\t/* If all events are unregistered, free the spare array */\n\tif (!new) {\n\t\tkfree(thresholds->spare);\n\t\tthresholds->spare = NULL;\n\t}\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n}"
  },
  {
    "function_name": "memsw_cgroup_usage_register_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3663-3667",
    "snippet": "static int memsw_cgroup_usage_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args)\n{\n\treturn __mem_cgroup_usage_register_event(memcg, eventfd, args, _MEMSWAP);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mem_cgroup_usage_register_event",
          "args": [
            "memcg",
            "eventfd",
            "args",
            "_MEMSWAP"
          ],
          "line": 3666
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_usage_register_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3575-3655",
          "snippet": "static int __mem_cgroup_usage_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long threshold;\n\tunsigned long usage;\n\tint i, size, ret;\n\n\tret = page_counter_memparse(args, \"-1\", &threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\t/* Check if a threshold crossed before adding a new one */\n\tif (thresholds->primary)\n\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;\n\n\t/* Allocate memory for new array of thresholds */\n\tnew = kmalloc(sizeof(*new) + size * sizeof(struct mem_cgroup_threshold),\n\t\t\tGFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tnew->size = size;\n\n\t/* Copy thresholds (if any) to new array */\n\tif (thresholds->primary) {\n\t\tmemcpy(new->entries, thresholds->primary->entries, (size - 1) *\n\t\t\t\tsizeof(struct mem_cgroup_threshold));\n\t}\n\n\t/* Add new threshold */\n\tnew->entries[size - 1].eventfd = eventfd;\n\tnew->entries[size - 1].threshold = threshold;\n\n\t/* Sort thresholds. Registering of new threshold isn't time-critical */\n\tsort(new->entries, size, sizeof(struct mem_cgroup_threshold),\n\t\t\tcompare_thresholds, NULL);\n\n\t/* Find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0; i < size; i++) {\n\t\tif (new->entries[i].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used until\n\t\t\t * rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\t/* Free old spare buffer and save old primary buffer as spare */\n\tkfree(thresholds->spare);\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int __mem_cgroup_usage_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long threshold;\n\tunsigned long usage;\n\tint i, size, ret;\n\n\tret = page_counter_memparse(args, \"-1\", &threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\t/* Check if a threshold crossed before adding a new one */\n\tif (thresholds->primary)\n\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;\n\n\t/* Allocate memory for new array of thresholds */\n\tnew = kmalloc(sizeof(*new) + size * sizeof(struct mem_cgroup_threshold),\n\t\t\tGFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tnew->size = size;\n\n\t/* Copy thresholds (if any) to new array */\n\tif (thresholds->primary) {\n\t\tmemcpy(new->entries, thresholds->primary->entries, (size - 1) *\n\t\t\t\tsizeof(struct mem_cgroup_threshold));\n\t}\n\n\t/* Add new threshold */\n\tnew->entries[size - 1].eventfd = eventfd;\n\tnew->entries[size - 1].threshold = threshold;\n\n\t/* Sort thresholds. Registering of new threshold isn't time-critical */\n\tsort(new->entries, size, sizeof(struct mem_cgroup_threshold),\n\t\t\tcompare_thresholds, NULL);\n\n\t/* Find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0; i < size; i++) {\n\t\tif (new->entries[i].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used until\n\t\t\t * rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\t/* Free old spare buffer and save old primary buffer as spare */\n\tkfree(thresholds->spare);\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memsw_cgroup_usage_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args)\n{\n\treturn __mem_cgroup_usage_register_event(memcg, eventfd, args, _MEMSWAP);\n}"
  },
  {
    "function_name": "mem_cgroup_usage_register_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3657-3661",
    "snippet": "static int mem_cgroup_usage_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args)\n{\n\treturn __mem_cgroup_usage_register_event(memcg, eventfd, args, _MEM);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mem_cgroup_usage_register_event",
          "args": [
            "memcg",
            "eventfd",
            "args",
            "_MEM"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_usage_register_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3575-3655",
          "snippet": "static int __mem_cgroup_usage_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long threshold;\n\tunsigned long usage;\n\tint i, size, ret;\n\n\tret = page_counter_memparse(args, \"-1\", &threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\t/* Check if a threshold crossed before adding a new one */\n\tif (thresholds->primary)\n\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;\n\n\t/* Allocate memory for new array of thresholds */\n\tnew = kmalloc(sizeof(*new) + size * sizeof(struct mem_cgroup_threshold),\n\t\t\tGFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tnew->size = size;\n\n\t/* Copy thresholds (if any) to new array */\n\tif (thresholds->primary) {\n\t\tmemcpy(new->entries, thresholds->primary->entries, (size - 1) *\n\t\t\t\tsizeof(struct mem_cgroup_threshold));\n\t}\n\n\t/* Add new threshold */\n\tnew->entries[size - 1].eventfd = eventfd;\n\tnew->entries[size - 1].threshold = threshold;\n\n\t/* Sort thresholds. Registering of new threshold isn't time-critical */\n\tsort(new->entries, size, sizeof(struct mem_cgroup_threshold),\n\t\t\tcompare_thresholds, NULL);\n\n\t/* Find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0; i < size; i++) {\n\t\tif (new->entries[i].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used until\n\t\t\t * rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\t/* Free old spare buffer and save old primary buffer as spare */\n\tkfree(thresholds->spare);\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int __mem_cgroup_usage_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long threshold;\n\tunsigned long usage;\n\tint i, size, ret;\n\n\tret = page_counter_memparse(args, \"-1\", &threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\t/* Check if a threshold crossed before adding a new one */\n\tif (thresholds->primary)\n\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;\n\n\t/* Allocate memory for new array of thresholds */\n\tnew = kmalloc(sizeof(*new) + size * sizeof(struct mem_cgroup_threshold),\n\t\t\tGFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tnew->size = size;\n\n\t/* Copy thresholds (if any) to new array */\n\tif (thresholds->primary) {\n\t\tmemcpy(new->entries, thresholds->primary->entries, (size - 1) *\n\t\t\t\tsizeof(struct mem_cgroup_threshold));\n\t}\n\n\t/* Add new threshold */\n\tnew->entries[size - 1].eventfd = eventfd;\n\tnew->entries[size - 1].threshold = threshold;\n\n\t/* Sort thresholds. Registering of new threshold isn't time-critical */\n\tsort(new->entries, size, sizeof(struct mem_cgroup_threshold),\n\t\t\tcompare_thresholds, NULL);\n\n\t/* Find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0; i < size; i++) {\n\t\tif (new->entries[i].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used until\n\t\t\t * rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\t/* Free old spare buffer and save old primary buffer as spare */\n\tkfree(thresholds->spare);\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int mem_cgroup_usage_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args)\n{\n\treturn __mem_cgroup_usage_register_event(memcg, eventfd, args, _MEM);\n}"
  },
  {
    "function_name": "__mem_cgroup_usage_register_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3575-3655",
    "snippet": "static int __mem_cgroup_usage_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long threshold;\n\tunsigned long usage;\n\tint i, size, ret;\n\n\tret = page_counter_memparse(args, \"-1\", &threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\t/* Check if a threshold crossed before adding a new one */\n\tif (thresholds->primary)\n\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;\n\n\t/* Allocate memory for new array of thresholds */\n\tnew = kmalloc(sizeof(*new) + size * sizeof(struct mem_cgroup_threshold),\n\t\t\tGFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tnew->size = size;\n\n\t/* Copy thresholds (if any) to new array */\n\tif (thresholds->primary) {\n\t\tmemcpy(new->entries, thresholds->primary->entries, (size - 1) *\n\t\t\t\tsizeof(struct mem_cgroup_threshold));\n\t}\n\n\t/* Add new threshold */\n\tnew->entries[size - 1].eventfd = eventfd;\n\tnew->entries[size - 1].threshold = threshold;\n\n\t/* Sort thresholds. Registering of new threshold isn't time-critical */\n\tsort(new->entries, size, sizeof(struct mem_cgroup_threshold),\n\t\t\tcompare_thresholds, NULL);\n\n\t/* Find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0; i < size; i++) {\n\t\tif (new->entries[i].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used until\n\t\t\t * rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\t/* Free old spare buffer and save old primary buffer as spare */\n\tkfree(thresholds->spare);\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&memcg->thresholds_lock"
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "thresholds->primary",
            "new"
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "thresholds->spare"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "new->entries",
            "size",
            "sizeof(struct mem_cgroup_threshold)",
            "compare_thresholds",
            "NULL"
          ],
          "line": 3625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new->entries",
            "thresholds->primary->entries",
            "(size - 1) *\n\t\t\t\tsizeof(struct mem_cgroup_threshold)"
          ],
          "line": 3616
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*new) + size * sizeof(struct mem_cgroup_threshold)",
            "GFP_KERNEL"
          ],
          "line": 3606
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_threshold",
          "args": [
            "memcg",
            "type == _MEMSWAP"
          ],
          "line": 3601
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_threshold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3478-3527",
          "snippet": "static void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)\n{\n\tstruct mem_cgroup_threshold_ary *t;\n\tunsigned long usage;\n\tint i;\n\n\trcu_read_lock();\n\tif (!swap)\n\t\tt = rcu_dereference(memcg->thresholds.primary);\n\telse\n\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);\n\n\tif (!t)\n\t\tgoto unlock;\n\n\tusage = mem_cgroup_usage(memcg, swap);\n\n\t/*\n\t * current_threshold points to threshold just below or equal to usage.\n\t * If it's not true, a threshold was crossed after last\n\t * call of __mem_cgroup_threshold().\n\t */\n\ti = t->current_threshold;\n\n\t/*\n\t * Iterate backward over array of thresholds starting from\n\t * current_threshold and check if a threshold is crossed.\n\t * If none of thresholds below usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* i = current_threshold + 1 */\n\ti++;\n\n\t/*\n\t * Iterate forward over array of thresholds starting from\n\t * current_threshold+1 and check if a threshold is crossed.\n\t * If none of thresholds above usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* Update current_threshold */\n\tt->current_threshold = i - 1;\nunlock:\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)\n{\n\tstruct mem_cgroup_threshold_ary *t;\n\tunsigned long usage;\n\tint i;\n\n\trcu_read_lock();\n\tif (!swap)\n\t\tt = rcu_dereference(memcg->thresholds.primary);\n\telse\n\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);\n\n\tif (!t)\n\t\tgoto unlock;\n\n\tusage = mem_cgroup_usage(memcg, swap);\n\n\t/*\n\t * current_threshold points to threshold just below or equal to usage.\n\t * If it's not true, a threshold was crossed after last\n\t * call of __mem_cgroup_threshold().\n\t */\n\ti = t->current_threshold;\n\n\t/*\n\t * Iterate backward over array of thresholds starting from\n\t * current_threshold and check if a threshold is crossed.\n\t * If none of thresholds below usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* i = current_threshold + 1 */\n\ti++;\n\n\t/*\n\t * Iterate forward over array of thresholds starting from\n\t * current_threshold+1 and check if a threshold is crossed.\n\t * If none of thresholds above usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* Update current_threshold */\n\tt->current_threshold = i - 1;\nunlock:\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_usage",
          "args": [
            "memcg",
            "true"
          ],
          "line": 3595
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_usage_unregister_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3748-3752",
          "snippet": "static void mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEM);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&memcg->thresholds_lock"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_memparse",
          "args": [
            "args",
            "\"-1\"",
            "&threshold"
          ],
          "line": 3584
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "248-266",
          "snippet": "int page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int __mem_cgroup_usage_register_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd, const char *args, enum res_type type)\n{\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long threshold;\n\tunsigned long usage;\n\tint i, size, ret;\n\n\tret = page_counter_memparse(args, \"-1\", &threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\t/* Check if a threshold crossed before adding a new one */\n\tif (thresholds->primary)\n\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;\n\n\t/* Allocate memory for new array of thresholds */\n\tnew = kmalloc(sizeof(*new) + size * sizeof(struct mem_cgroup_threshold),\n\t\t\tGFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tnew->size = size;\n\n\t/* Copy thresholds (if any) to new array */\n\tif (thresholds->primary) {\n\t\tmemcpy(new->entries, thresholds->primary->entries, (size - 1) *\n\t\t\t\tsizeof(struct mem_cgroup_threshold));\n\t}\n\n\t/* Add new threshold */\n\tnew->entries[size - 1].eventfd = eventfd;\n\tnew->entries[size - 1].threshold = threshold;\n\n\t/* Sort thresholds. Registering of new threshold isn't time-critical */\n\tsort(new->entries, size, sizeof(struct mem_cgroup_threshold),\n\t\t\tcompare_thresholds, NULL);\n\n\t/* Find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0; i < size; i++) {\n\t\tif (new->entries[i].threshold <= usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used until\n\t\t\t * rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\t/* Free old spare buffer and save old primary buffer as spare */\n\tkfree(thresholds->spare);\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mem_cgroup_oom_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3567-3573",
    "snippet": "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tmem_cgroup_oom_notify_cb(iter);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_oom_notify_cb",
          "args": [
            "iter"
          ],
          "line": 3572
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_oom_notify_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3554-3565",
          "snippet": "static int mem_cgroup_oom_notify_cb(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_eventfd_list *ev;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tlist_for_each_entry(ev, &memcg->oom_notify, list)\n\t\teventfd_signal(ev->eventfd, 1);\n\n\tspin_unlock(&memcg_oom_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_SPINLOCK(memcg_oom_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic int mem_cgroup_oom_notify_cb(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_eventfd_list *ev;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tlist_for_each_entry(ev, &memcg->oom_notify, list)\n\t\teventfd_signal(ev->eventfd, 1);\n\n\tspin_unlock(&memcg_oom_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "iter",
            "memcg"
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tmem_cgroup_oom_notify_cb(iter);\n}"
  },
  {
    "function_name": "mem_cgroup_oom_notify_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3554-3565",
    "snippet": "static int mem_cgroup_oom_notify_cb(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_eventfd_list *ev;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tlist_for_each_entry(ev, &memcg->oom_notify, list)\n\t\teventfd_signal(ev->eventfd, 1);\n\n\tspin_unlock(&memcg_oom_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_SPINLOCK(memcg_oom_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 3563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_signal",
          "args": [
            "ev->eventfd",
            "1"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ev",
            "&memcg->oom_notify",
            "list"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic int mem_cgroup_oom_notify_cb(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_eventfd_list *ev;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tlist_for_each_entry(ev, &memcg->oom_notify, list)\n\t\teventfd_signal(ev->eventfd, 1);\n\n\tspin_unlock(&memcg_oom_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "compare_thresholds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3540-3552",
    "snippet": "static int compare_thresholds(const void *a, const void *b)\n{\n\tconst struct mem_cgroup_threshold *_a = a;\n\tconst struct mem_cgroup_threshold *_b = b;\n\n\tif (_a->threshold > _b->threshold)\n\t\treturn 1;\n\n\tif (_a->threshold < _b->threshold)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic int compare_thresholds(const void *a, const void *b)\n{\n\tconst struct mem_cgroup_threshold *_a = a;\n\tconst struct mem_cgroup_threshold *_b = b;\n\n\tif (_a->threshold > _b->threshold)\n\t\treturn 1;\n\n\tif (_a->threshold < _b->threshold)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_threshold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3529-3538",
    "snippet": "static void mem_cgroup_threshold(struct mem_cgroup *memcg)\n{\n\twhile (memcg) {\n\t\t__mem_cgroup_threshold(memcg, false);\n\t\tif (do_memsw_account())\n\t\t\t__mem_cgroup_threshold(memcg, true);\n\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 3536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_threshold",
          "args": [
            "memcg",
            "true"
          ],
          "line": 3534
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_threshold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3478-3527",
          "snippet": "static void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)\n{\n\tstruct mem_cgroup_threshold_ary *t;\n\tunsigned long usage;\n\tint i;\n\n\trcu_read_lock();\n\tif (!swap)\n\t\tt = rcu_dereference(memcg->thresholds.primary);\n\telse\n\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);\n\n\tif (!t)\n\t\tgoto unlock;\n\n\tusage = mem_cgroup_usage(memcg, swap);\n\n\t/*\n\t * current_threshold points to threshold just below or equal to usage.\n\t * If it's not true, a threshold was crossed after last\n\t * call of __mem_cgroup_threshold().\n\t */\n\ti = t->current_threshold;\n\n\t/*\n\t * Iterate backward over array of thresholds starting from\n\t * current_threshold and check if a threshold is crossed.\n\t * If none of thresholds below usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* i = current_threshold + 1 */\n\ti++;\n\n\t/*\n\t * Iterate forward over array of thresholds starting from\n\t * current_threshold+1 and check if a threshold is crossed.\n\t * If none of thresholds above usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* Update current_threshold */\n\tt->current_threshold = i - 1;\nunlock:\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)\n{\n\tstruct mem_cgroup_threshold_ary *t;\n\tunsigned long usage;\n\tint i;\n\n\trcu_read_lock();\n\tif (!swap)\n\t\tt = rcu_dereference(memcg->thresholds.primary);\n\telse\n\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);\n\n\tif (!t)\n\t\tgoto unlock;\n\n\tusage = mem_cgroup_usage(memcg, swap);\n\n\t/*\n\t * current_threshold points to threshold just below or equal to usage.\n\t * If it's not true, a threshold was crossed after last\n\t * call of __mem_cgroup_threshold().\n\t */\n\ti = t->current_threshold;\n\n\t/*\n\t * Iterate backward over array of thresholds starting from\n\t * current_threshold and check if a threshold is crossed.\n\t * If none of thresholds below usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* i = current_threshold + 1 */\n\ti++;\n\n\t/*\n\t * Iterate forward over array of thresholds starting from\n\t * current_threshold+1 and check if a threshold is crossed.\n\t * If none of thresholds above usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* Update current_threshold */\n\tt->current_threshold = i - 1;\nunlock:\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 3533
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg)\n{\n\twhile (memcg) {\n\t\t__mem_cgroup_threshold(memcg, false);\n\t\tif (do_memsw_account())\n\t\t\t__mem_cgroup_threshold(memcg, true);\n\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t}\n}"
  },
  {
    "function_name": "__mem_cgroup_threshold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3478-3527",
    "snippet": "static void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)\n{\n\tstruct mem_cgroup_threshold_ary *t;\n\tunsigned long usage;\n\tint i;\n\n\trcu_read_lock();\n\tif (!swap)\n\t\tt = rcu_dereference(memcg->thresholds.primary);\n\telse\n\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);\n\n\tif (!t)\n\t\tgoto unlock;\n\n\tusage = mem_cgroup_usage(memcg, swap);\n\n\t/*\n\t * current_threshold points to threshold just below or equal to usage.\n\t * If it's not true, a threshold was crossed after last\n\t * call of __mem_cgroup_threshold().\n\t */\n\ti = t->current_threshold;\n\n\t/*\n\t * Iterate backward over array of thresholds starting from\n\t * current_threshold and check if a threshold is crossed.\n\t * If none of thresholds below usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* i = current_threshold + 1 */\n\ti++;\n\n\t/*\n\t * Iterate forward over array of thresholds starting from\n\t * current_threshold+1 and check if a threshold is crossed.\n\t * If none of thresholds above usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* Update current_threshold */\n\tt->current_threshold = i - 1;\nunlock:\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_signal",
          "args": [
            "t->entries[i].eventfd",
            "1"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "t->entries[i].threshold <= usage"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_signal",
          "args": [
            "t->entries[i].eventfd",
            "1"
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "t->entries[i].threshold > usage"
          ],
          "line": 3508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_usage",
          "args": [
            "memcg",
            "swap"
          ],
          "line": 3493
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_usage_unregister_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3748-3752",
          "snippet": "static void mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEM);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "memcg->memsw_thresholds.primary"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "memcg->thresholds.primary"
          ],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)\n{\n\tstruct mem_cgroup_threshold_ary *t;\n\tunsigned long usage;\n\tint i;\n\n\trcu_read_lock();\n\tif (!swap)\n\t\tt = rcu_dereference(memcg->thresholds.primary);\n\telse\n\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);\n\n\tif (!t)\n\t\tgoto unlock;\n\n\tusage = mem_cgroup_usage(memcg, swap);\n\n\t/*\n\t * current_threshold points to threshold just below or equal to usage.\n\t * If it's not true, a threshold was crossed after last\n\t * call of __mem_cgroup_threshold().\n\t */\n\ti = t->current_threshold;\n\n\t/*\n\t * Iterate backward over array of thresholds starting from\n\t * current_threshold and check if a threshold is crossed.\n\t * If none of thresholds below usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* i = current_threshold + 1 */\n\ti++;\n\n\t/*\n\t * Iterate forward over array of thresholds starting from\n\t * current_threshold+1 and check if a threshold is crossed.\n\t * If none of thresholds above usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* Update current_threshold */\n\tt->current_threshold = i - 1;\nunlock:\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "mem_cgroup_swappiness_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3462-3476",
    "snippet": "static int mem_cgroup_swappiness_write(struct cgroup_subsys_state *css,\n\t\t\t\t       struct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tif (val > 100)\n\t\treturn -EINVAL;\n\n\tif (css->parent)\n\t\tmemcg->swappiness = val;\n\telse\n\t\tvm_swappiness = val;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int mem_cgroup_swappiness_write(struct cgroup_subsys_state *css,\n\t\t\t\t       struct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tif (val > 100)\n\t\treturn -EINVAL;\n\n\tif (css->parent)\n\t\tmemcg->swappiness = val;\n\telse\n\t\tvm_swappiness = val;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_swappiness_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3454-3460",
    "snippet": "static u64 mem_cgroup_swappiness_read(struct cgroup_subsys_state *css,\n\t\t\t\t      struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\treturn mem_cgroup_swappiness(memcg);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_swappiness",
          "args": [
            "memcg"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 3457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic u64 mem_cgroup_swappiness_read(struct cgroup_subsys_state *css,\n\t\t\t\t      struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\treturn mem_cgroup_swappiness(memcg);\n}"
  },
  {
    "function_name": "memcg_stat_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3366-3452",
    "snippet": "static int memcg_stat_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long memory, memsw;\n\tstruct mem_cgroup *mi;\n\tunsigned int i;\n\tstruct accumulated_stats acc;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(memcg1_stat_names) != ARRAY_SIZE(memcg1_stats));\n\tBUILD_BUG_ON(ARRAY_SIZE(mem_cgroup_lru_names) != NR_LRU_LISTS);\n\n\tfor (i = 0; i < ARRAY_SIZE(memcg1_stats); i++) {\n\t\tif (memcg1_stats[i] == MEMCG_SWAP && !do_memsw_account())\n\t\t\tcontinue;\n\t\tseq_printf(m, \"%s %lu\\n\", memcg1_stat_names[i],\n\t\t\t   memcg_page_state(memcg, memcg1_stats[i]) *\n\t\t\t   PAGE_SIZE);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(memcg1_events); i++)\n\t\tseq_printf(m, \"%s %lu\\n\", memcg1_event_names[i],\n\t\t\t   memcg_sum_events(memcg, memcg1_events[i]));\n\n\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\tseq_printf(m, \"%s %lu\\n\", mem_cgroup_lru_names[i],\n\t\t\t   mem_cgroup_nr_lru_pages(memcg, BIT(i)) * PAGE_SIZE);\n\n\t/* Hierarchical information */\n\tmemory = memsw = PAGE_COUNTER_MAX;\n\tfor (mi = memcg; mi; mi = parent_mem_cgroup(mi)) {\n\t\tmemory = min(memory, mi->memory.max);\n\t\tmemsw = min(memsw, mi->memsw.max);\n\t}\n\tseq_printf(m, \"hierarchical_memory_limit %llu\\n\",\n\t\t   (u64)memory * PAGE_SIZE);\n\tif (do_memsw_account())\n\t\tseq_printf(m, \"hierarchical_memsw_limit %llu\\n\",\n\t\t\t   (u64)memsw * PAGE_SIZE);\n\n\tmemset(&acc, 0, sizeof(acc));\n\tacc.stats_size = ARRAY_SIZE(memcg1_stats);\n\tacc.stats_array = memcg1_stats;\n\tacc.events_size = ARRAY_SIZE(memcg1_events);\n\tacc.events_array = memcg1_events;\n\taccumulate_memcg_tree(memcg, &acc);\n\n\tfor (i = 0; i < ARRAY_SIZE(memcg1_stats); i++) {\n\t\tif (memcg1_stats[i] == MEMCG_SWAP && !do_memsw_account())\n\t\t\tcontinue;\n\t\tseq_printf(m, \"total_%s %llu\\n\", memcg1_stat_names[i],\n\t\t\t   (u64)acc.stat[i] * PAGE_SIZE);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(memcg1_events); i++)\n\t\tseq_printf(m, \"total_%s %llu\\n\", memcg1_event_names[i],\n\t\t\t   (u64)acc.events[i]);\n\n\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\tseq_printf(m, \"total_%s %llu\\n\", mem_cgroup_lru_names[i],\n\t\t\t   (u64)acc.lru_pages[i] * PAGE_SIZE);\n\n#ifdef CONFIG_DEBUG_VM\n\t{\n\t\tpg_data_t *pgdat;\n\t\tstruct mem_cgroup_per_node *mz;\n\t\tstruct zone_reclaim_stat *rstat;\n\t\tunsigned long recent_rotated[2] = {0, 0};\n\t\tunsigned long recent_scanned[2] = {0, 0};\n\n\t\tfor_each_online_pgdat(pgdat) {\n\t\t\tmz = mem_cgroup_nodeinfo(memcg, pgdat->node_id);\n\t\t\trstat = &mz->lruvec.reclaim_stat;\n\n\t\t\trecent_rotated[0] += rstat->recent_rotated[0];\n\t\t\trecent_rotated[1] += rstat->recent_rotated[1];\n\t\t\trecent_scanned[0] += rstat->recent_scanned[0];\n\t\t\trecent_scanned[1] += rstat->recent_scanned[1];\n\t\t}\n\t\tseq_printf(m, \"recent_rotated_anon %lu\\n\", recent_rotated[0]);\n\t\tseq_printf(m, \"recent_rotated_file %lu\\n\", recent_rotated[1]);\n\t\tseq_printf(m, \"recent_scanned_anon %lu\\n\", recent_scanned[0]);\n\t\tseq_printf(m, \"recent_scanned_file %lu\\n\", recent_scanned[1]);\n\t}\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *const mem_cgroup_lru_names[] = {\n\t\"inactive_anon\",\n\t\"active_anon\",\n\t\"inactive_file\",\n\t\"active_file\",\n\t\"unevictable\",\n};",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static const unsigned int memcg1_stats[] = {\n\tMEMCG_CACHE,\n\tMEMCG_RSS,\n\tMEMCG_RSS_HUGE,\n\tNR_SHMEM,\n\tNR_FILE_MAPPED,\n\tNR_FILE_DIRTY,\n\tNR_WRITEBACK,\n\tMEMCG_SWAP,\n};",
      "static const char *const memcg1_stat_names[] = {\n\t\"cache\",\n\t\"rss\",\n\t\"rss_huge\",\n\t\"shmem\",\n\t\"mapped_file\",\n\t\"dirty\",\n\t\"writeback\",\n\t\"swap\",\n};",
      "static const unsigned int memcg1_events[] = {\n\tPGPGIN,\n\tPGPGOUT,\n\tPGFAULT,\n\tPGMAJFAULT,\n};",
      "static const char *const memcg1_event_names[] = {\n\t\"pgpgin\",\n\t\"pgpgout\",\n\t\"pgfault\",\n\t\"pgmajfault\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"recent_scanned_file %lu\\n\"",
            "recent_scanned[1]"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"recent_scanned_anon %lu\\n\"",
            "recent_scanned[0]"
          ],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"recent_rotated_file %lu\\n\"",
            "recent_rotated[1]"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"recent_rotated_anon %lu\\n\"",
            "recent_rotated[0]"
          ],
          "line": 3444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nodeinfo",
          "args": [
            "memcg",
            "pgdat->node_id"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"total_%s %llu\\n\"",
            "mem_cgroup_lru_names[i]",
            "(u64)acc.lru_pages[i] * PAGE_SIZE"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"total_%s %llu\\n\"",
            "memcg1_event_names[i]",
            "(u64)acc.events[i]"
          ],
          "line": 3420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "memcg1_events"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"total_%s %llu\\n\"",
            "memcg1_stat_names[i]",
            "(u64)acc.stat[i] * PAGE_SIZE"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 3413
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "memcg1_stats"
          ],
          "line": 3412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accumulate_memcg_tree",
          "args": [
            "memcg",
            "&acc"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "accumulate_memcg_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2944-2963",
          "snippet": "static void accumulate_memcg_tree(struct mem_cgroup *memcg,\n\t\t\t\t  struct accumulated_stats *acc)\n{\n\tstruct mem_cgroup *mi;\n\tint i;\n\n\tfor_each_mem_cgroup_tree(mi, memcg) {\n\t\tfor (i = 0; i < acc->stats_size; i++)\n\t\t\tacc->stat[i] += memcg_page_state(mi,\n\t\t\t\tacc->stats_array ? acc->stats_array[i] : i);\n\n\t\tfor (i = 0; i < acc->events_size; i++)\n\t\t\tacc->events[i] += memcg_sum_events(mi,\n\t\t\t\tacc->events_array ? acc->events_array[i] : i);\n\n\t\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\t\tacc->lru_pages[i] +=\n\t\t\t\tmem_cgroup_nr_lru_pages(mi, BIT(i));\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void accumulate_memcg_tree(struct mem_cgroup *memcg,\n\t\t\t\t  struct accumulated_stats *acc)\n{\n\tstruct mem_cgroup *mi;\n\tint i;\n\n\tfor_each_mem_cgroup_tree(mi, memcg) {\n\t\tfor (i = 0; i < acc->stats_size; i++)\n\t\t\tacc->stat[i] += memcg_page_state(mi,\n\t\t\t\tacc->stats_array ? acc->stats_array[i] : i);\n\n\t\tfor (i = 0; i < acc->events_size; i++)\n\t\t\tacc->events[i] += memcg_sum_events(mi,\n\t\t\t\tacc->events_array ? acc->events_array[i] : i);\n\n\t\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\t\tacc->lru_pages[i] +=\n\t\t\t\tmem_cgroup_nr_lru_pages(mi, BIT(i));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "memcg1_events"
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "memcg1_stats"
          ],
          "line": 3406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&acc",
            "0",
            "sizeof(acc)"
          ],
          "line": 3405
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"hierarchical_memsw_limit %llu\\n\"",
            "(u64)memsw * PAGE_SIZE"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"hierarchical_memory_limit %llu\\n\"",
            "(u64)memory * PAGE_SIZE"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "memsw",
            "mi->memsw.max"
          ],
          "line": 3397
        },
        "resolved": true,
        "details": {
          "function_name": "memory_min_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5342-5353",
          "snippet": "static int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "mi"
          ],
          "line": 3395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s %lu\\n\"",
            "mem_cgroup_lru_names[i]",
            "mem_cgroup_nr_lru_pages(memcg, BIT(i)) * PAGE_SIZE"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nr_lru_pages",
          "args": [
            "memcg",
            "BIT(i)"
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_nr_lru_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "738-747",
          "snippet": "static unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "i"
          ],
          "line": 3391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s %lu\\n\"",
            "memcg1_event_names[i]",
            "memcg_sum_events(memcg, memcg1_events[i])"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_sum_events",
          "args": [
            "memcg",
            "memcg1_events[i]"
          ],
          "line": 3387
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_sum_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "683-687",
          "snippet": "static unsigned long memcg_sum_events(struct mem_cgroup *memcg,\n\t\t\t\t      int event)\n{\n\treturn atomic_long_read(&memcg->events[event]);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long memcg_sum_events(struct mem_cgroup *memcg,\n\t\t\t\t      int event)\n{\n\treturn atomic_long_read(&memcg->events[event]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "memcg1_events"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s %lu\\n\"",
            "memcg1_stat_names[i]",
            "memcg_page_state(memcg, memcg1_stats[i]) *\n\t\t\t   PAGE_SIZE"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_page_state",
          "args": [
            "memcg",
            "memcg1_stats[i]"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "memcg1_stats"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ARRAY_SIZE(mem_cgroup_lru_names) != NR_LRU_LISTS"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mem_cgroup_lru_names"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ARRAY_SIZE(memcg1_stat_names) != ARRAY_SIZE(memcg1_stats)"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "memcg1_stats"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "memcg1_stat_names"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic const char *const mem_cgroup_lru_names[] = {\n\t\"inactive_anon\",\n\t\"active_anon\",\n\t\"inactive_file\",\n\t\"active_file\",\n\t\"unevictable\",\n};\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic const unsigned int memcg1_stats[] = {\n\tMEMCG_CACHE,\n\tMEMCG_RSS,\n\tMEMCG_RSS_HUGE,\n\tNR_SHMEM,\n\tNR_FILE_MAPPED,\n\tNR_FILE_DIRTY,\n\tNR_WRITEBACK,\n\tMEMCG_SWAP,\n};\nstatic const char *const memcg1_stat_names[] = {\n\t\"cache\",\n\t\"rss\",\n\t\"rss_huge\",\n\t\"shmem\",\n\t\"mapped_file\",\n\t\"dirty\",\n\t\"writeback\",\n\t\"swap\",\n};\nstatic const unsigned int memcg1_events[] = {\n\tPGPGIN,\n\tPGPGOUT,\n\tPGFAULT,\n\tPGMAJFAULT,\n};\nstatic const char *const memcg1_event_names[] = {\n\t\"pgpgin\",\n\t\"pgpgout\",\n\t\"pgfault\",\n\t\"pgmajfault\",\n};\n\nstatic int memcg_stat_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long memory, memsw;\n\tstruct mem_cgroup *mi;\n\tunsigned int i;\n\tstruct accumulated_stats acc;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(memcg1_stat_names) != ARRAY_SIZE(memcg1_stats));\n\tBUILD_BUG_ON(ARRAY_SIZE(mem_cgroup_lru_names) != NR_LRU_LISTS);\n\n\tfor (i = 0; i < ARRAY_SIZE(memcg1_stats); i++) {\n\t\tif (memcg1_stats[i] == MEMCG_SWAP && !do_memsw_account())\n\t\t\tcontinue;\n\t\tseq_printf(m, \"%s %lu\\n\", memcg1_stat_names[i],\n\t\t\t   memcg_page_state(memcg, memcg1_stats[i]) *\n\t\t\t   PAGE_SIZE);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(memcg1_events); i++)\n\t\tseq_printf(m, \"%s %lu\\n\", memcg1_event_names[i],\n\t\t\t   memcg_sum_events(memcg, memcg1_events[i]));\n\n\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\tseq_printf(m, \"%s %lu\\n\", mem_cgroup_lru_names[i],\n\t\t\t   mem_cgroup_nr_lru_pages(memcg, BIT(i)) * PAGE_SIZE);\n\n\t/* Hierarchical information */\n\tmemory = memsw = PAGE_COUNTER_MAX;\n\tfor (mi = memcg; mi; mi = parent_mem_cgroup(mi)) {\n\t\tmemory = min(memory, mi->memory.max);\n\t\tmemsw = min(memsw, mi->memsw.max);\n\t}\n\tseq_printf(m, \"hierarchical_memory_limit %llu\\n\",\n\t\t   (u64)memory * PAGE_SIZE);\n\tif (do_memsw_account())\n\t\tseq_printf(m, \"hierarchical_memsw_limit %llu\\n\",\n\t\t\t   (u64)memsw * PAGE_SIZE);\n\n\tmemset(&acc, 0, sizeof(acc));\n\tacc.stats_size = ARRAY_SIZE(memcg1_stats);\n\tacc.stats_array = memcg1_stats;\n\tacc.events_size = ARRAY_SIZE(memcg1_events);\n\tacc.events_array = memcg1_events;\n\taccumulate_memcg_tree(memcg, &acc);\n\n\tfor (i = 0; i < ARRAY_SIZE(memcg1_stats); i++) {\n\t\tif (memcg1_stats[i] == MEMCG_SWAP && !do_memsw_account())\n\t\t\tcontinue;\n\t\tseq_printf(m, \"total_%s %llu\\n\", memcg1_stat_names[i],\n\t\t\t   (u64)acc.stat[i] * PAGE_SIZE);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(memcg1_events); i++)\n\t\tseq_printf(m, \"total_%s %llu\\n\", memcg1_event_names[i],\n\t\t\t   (u64)acc.events[i]);\n\n\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\tseq_printf(m, \"total_%s %llu\\n\", mem_cgroup_lru_names[i],\n\t\t\t   (u64)acc.lru_pages[i] * PAGE_SIZE);\n\n#ifdef CONFIG_DEBUG_VM\n\t{\n\t\tpg_data_t *pgdat;\n\t\tstruct mem_cgroup_per_node *mz;\n\t\tstruct zone_reclaim_stat *rstat;\n\t\tunsigned long recent_rotated[2] = {0, 0};\n\t\tunsigned long recent_scanned[2] = {0, 0};\n\n\t\tfor_each_online_pgdat(pgdat) {\n\t\t\tmz = mem_cgroup_nodeinfo(memcg, pgdat->node_id);\n\t\t\trstat = &mz->lruvec.reclaim_stat;\n\n\t\t\trecent_rotated[0] += rstat->recent_rotated[0];\n\t\t\trecent_rotated[1] += rstat->recent_rotated[1];\n\t\t\trecent_scanned[0] += rstat->recent_scanned[0];\n\t\t\trecent_scanned[1] += rstat->recent_scanned[1];\n\t\t}\n\t\tseq_printf(m, \"recent_rotated_anon %lu\\n\", recent_rotated[0]);\n\t\tseq_printf(m, \"recent_rotated_file %lu\\n\", recent_rotated[1]);\n\t\tseq_printf(m, \"recent_scanned_anon %lu\\n\", recent_scanned[0]);\n\t\tseq_printf(m, \"recent_scanned_file %lu\\n\", recent_scanned[1]);\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_numa_stat_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3301-3348",
    "snippet": "static int memcg_numa_stat_show(struct seq_file *m, void *v)\n{\n\tstruct numa_stat {\n\t\tconst char *name;\n\t\tunsigned int lru_mask;\n\t};\n\n\tstatic const struct numa_stat stats[] = {\n\t\t{ \"total\", LRU_ALL },\n\t\t{ \"file\", LRU_ALL_FILE },\n\t\t{ \"anon\", LRU_ALL_ANON },\n\t\t{ \"unevictable\", BIT(LRU_UNEVICTABLE) },\n\t};\n\tconst struct numa_stat *stat;\n\tint nid;\n\tunsigned long nr;\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tfor (stat = stats; stat < stats + ARRAY_SIZE(stats); stat++) {\n\t\tnr = mem_cgroup_nr_lru_pages(memcg, stat->lru_mask);\n\t\tseq_printf(m, \"%s=%lu\", stat->name, nr);\n\t\tfor_each_node_state(nid, N_MEMORY) {\n\t\t\tnr = mem_cgroup_node_nr_lru_pages(memcg, nid,\n\t\t\t\t\t\t\t  stat->lru_mask);\n\t\t\tseq_printf(m, \" N%d=%lu\", nid, nr);\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n\n\tfor (stat = stats; stat < stats + ARRAY_SIZE(stats); stat++) {\n\t\tstruct mem_cgroup *iter;\n\n\t\tnr = 0;\n\t\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\t\tnr += mem_cgroup_nr_lru_pages(iter, stat->lru_mask);\n\t\tseq_printf(m, \"hierarchical_%s=%lu\", stat->name, nr);\n\t\tfor_each_node_state(nid, N_MEMORY) {\n\t\t\tnr = 0;\n\t\t\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\t\t\tnr += mem_cgroup_node_nr_lru_pages(\n\t\t\t\t\titer, nid, stat->lru_mask);\n\t\t\tseq_printf(m, \" N%d=%lu\", nid, nr);\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" N%d=%lu\"",
            "nid",
            "nr"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_node_nr_lru_pages",
          "args": [
            "iter",
            "nid",
            "stat->lru_mask"
          ],
          "line": 3340
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_node_nr_lru_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "721-736",
          "snippet": "unsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   int nid, unsigned int lru_mask)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(NODE_DATA(nid), memcg);\n\tunsigned long nr = 0;\n\tenum lru_list lru;\n\n\tVM_BUG_ON((unsigned)nid >= nr_node_ids);\n\n\tfor_each_lru(lru) {\n\t\tif (!(BIT(lru) & lru_mask))\n\t\t\tcontinue;\n\t\tnr += mem_cgroup_get_lru_size(lruvec, lru);\n\t}\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nunsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   int nid, unsigned int lru_mask)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(NODE_DATA(nid), memcg);\n\tunsigned long nr = 0;\n\tenum lru_list lru;\n\n\tVM_BUG_ON((unsigned)nid >= nr_node_ids);\n\n\tfor_each_lru(lru) {\n\t\tif (!(BIT(lru) & lru_mask))\n\t\t\tcontinue;\n\t\tnr += mem_cgroup_get_lru_size(lruvec, lru);\n\t}\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "iter",
            "memcg"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 3337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"hierarchical_%s=%lu\"",
            "stat->name",
            "nr"
          ],
          "line": 3336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nr_lru_pages",
          "args": [
            "iter",
            "stat->lru_mask"
          ],
          "line": 3335
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_nr_lru_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "738-747",
          "snippet": "static unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "iter",
            "memcg"
          ],
          "line": 3334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "stats"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 3327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" N%d=%lu\"",
            "nid",
            "nr"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s=%lu\"",
            "stat->name",
            "nr"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "stats"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "LRU_UNEVICTABLE"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_numa_stat_show(struct seq_file *m, void *v)\n{\n\tstruct numa_stat {\n\t\tconst char *name;\n\t\tunsigned int lru_mask;\n\t};\n\n\tstatic const struct numa_stat stats[] = {\n\t\t{ \"total\", LRU_ALL },\n\t\t{ \"file\", LRU_ALL_FILE },\n\t\t{ \"anon\", LRU_ALL_ANON },\n\t\t{ \"unevictable\", BIT(LRU_UNEVICTABLE) },\n\t};\n\tconst struct numa_stat *stat;\n\tint nid;\n\tunsigned long nr;\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tfor (stat = stats; stat < stats + ARRAY_SIZE(stats); stat++) {\n\t\tnr = mem_cgroup_nr_lru_pages(memcg, stat->lru_mask);\n\t\tseq_printf(m, \"%s=%lu\", stat->name, nr);\n\t\tfor_each_node_state(nid, N_MEMORY) {\n\t\t\tnr = mem_cgroup_node_nr_lru_pages(memcg, nid,\n\t\t\t\t\t\t\t  stat->lru_mask);\n\t\t\tseq_printf(m, \" N%d=%lu\", nid, nr);\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n\n\tfor (stat = stats; stat < stats + ARRAY_SIZE(stats); stat++) {\n\t\tstruct mem_cgroup *iter;\n\n\t\tnr = 0;\n\t\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\t\tnr += mem_cgroup_nr_lru_pages(iter, stat->lru_mask);\n\t\tseq_printf(m, \"hierarchical_%s=%lu\", stat->name, nr);\n\t\tfor_each_node_state(nid, N_MEMORY) {\n\t\t\tnr = 0;\n\t\t\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\t\t\tnr += mem_cgroup_node_nr_lru_pages(\n\t\t\t\t\titer, nid, stat->lru_mask);\n\t\t\tseq_printf(m, \" N%d=%lu\", nid, nr);\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_move_charge_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3293-3297",
    "snippet": "static int mem_cgroup_move_charge_write(struct cgroup_subsys_state *css,\n\t\t\t\t\tstruct cftype *cft, u64 val)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic int mem_cgroup_move_charge_write(struct cgroup_subsys_state *css,\n\t\t\t\t\tstruct cftype *cft, u64 val)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "mem_cgroup_move_charge_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3275-3291",
    "snippet": "static int mem_cgroup_move_charge_write(struct cgroup_subsys_state *css,\n\t\t\t\t\tstruct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tif (val & ~MOVE_MASK)\n\t\treturn -EINVAL;\n\n\t/*\n\t * No kind of locking is needed in here, because ->can_attach() will\n\t * check this value once in the beginning of the process, and then carry\n\t * on with stale data. This means that changes to this value will only\n\t * affect task migrations starting after the change.\n\t */\n\tmemcg->move_charge_at_immigrate = val;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define MOVE_MASK\t(MOVE_ANON | MOVE_FILE)"
    ],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MOVE_MASK\t(MOVE_ANON | MOVE_FILE)\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int mem_cgroup_move_charge_write(struct cgroup_subsys_state *css,\n\t\t\t\t\tstruct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tif (val & ~MOVE_MASK)\n\t\treturn -EINVAL;\n\n\t/*\n\t * No kind of locking is needed in here, because ->can_attach() will\n\t * check this value once in the beginning of the process, and then carry\n\t * on with stale data. This means that changes to this value will only\n\t * affect task migrations starting after the change.\n\t */\n\tmemcg->move_charge_at_immigrate = val;\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_move_charge_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3268-3272",
    "snippet": "static u64 mem_cgroup_move_charge_read(struct cgroup_subsys_state *css,\n\t\t\t\t\tstruct cftype *cft)\n{\n\treturn mem_cgroup_from_css(css)->move_charge_at_immigrate;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic u64 mem_cgroup_move_charge_read(struct cgroup_subsys_state *css,\n\t\t\t\t\tstruct cftype *cft)\n{\n\treturn mem_cgroup_from_css(css)->move_charge_at_immigrate;\n}"
  },
  {
    "function_name": "mem_cgroup_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3231-3266",
    "snippet": "static ssize_t mem_cgroup_reset(struct kernfs_open_file *of, char *buf,\n\t\t\t\tsize_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tstruct page_counter *counter;\n\n\tswitch (MEMFILE_TYPE(of_cft(of)->private)) {\n\tcase _MEM:\n\t\tcounter = &memcg->memory;\n\t\tbreak;\n\tcase _MEMSWAP:\n\t\tcounter = &memcg->memsw;\n\t\tbreak;\n\tcase _KMEM:\n\t\tcounter = &memcg->kmem;\n\t\tbreak;\n\tcase _TCP:\n\t\tcounter = &memcg->tcpmem;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {\n\tcase RES_MAX_USAGE:\n\t\tpage_counter_reset_watermark(counter);\n\t\tbreak;\n\tcase RES_FAILCNT:\n\t\tcounter->failcnt = 0;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn nbytes;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_reset_watermark",
          "args": [
            "counter"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_ATTR",
          "args": [
            "of_cft(of)->private"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_TYPE",
          "args": [
            "of_cft(of)->private"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "of_css(of)"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic ssize_t mem_cgroup_reset(struct kernfs_open_file *of, char *buf,\n\t\t\t\tsize_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tstruct page_counter *counter;\n\n\tswitch (MEMFILE_TYPE(of_cft(of)->private)) {\n\tcase _MEM:\n\t\tcounter = &memcg->memory;\n\t\tbreak;\n\tcase _MEMSWAP:\n\t\tcounter = &memcg->memsw;\n\t\tbreak;\n\tcase _KMEM:\n\t\tcounter = &memcg->kmem;\n\t\tbreak;\n\tcase _TCP:\n\t\tcounter = &memcg->tcpmem;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {\n\tcase RES_MAX_USAGE:\n\t\tpage_counter_reset_watermark(counter);\n\t\tbreak;\n\tcase RES_FAILCNT:\n\t\tcounter->failcnt = 0;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn nbytes;\n}"
  },
  {
    "function_name": "mem_cgroup_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3190-3229",
    "snippet": "static ssize_t mem_cgroup_write(struct kernfs_open_file *of,\n\t\t\t\tchar *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned long nr_pages;\n\tint ret;\n\n\tbuf = strstrip(buf);\n\tret = page_counter_memparse(buf, \"-1\", &nr_pages);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {\n\tcase RES_LIMIT:\n\t\tif (mem_cgroup_is_root(memcg)) { /* Can't set limit on root */\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (MEMFILE_TYPE(of_cft(of)->private)) {\n\t\tcase _MEM:\n\t\t\tret = mem_cgroup_resize_max(memcg, nr_pages, false);\n\t\t\tbreak;\n\t\tcase _MEMSWAP:\n\t\t\tret = mem_cgroup_resize_max(memcg, nr_pages, true);\n\t\t\tbreak;\n\t\tcase _KMEM:\n\t\t\tret = memcg_update_kmem_max(memcg, nr_pages);\n\t\t\tbreak;\n\t\tcase _TCP:\n\t\t\tret = memcg_update_tcp_max(memcg, nr_pages);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase RES_SOFT_LIMIT:\n\t\tmemcg->soft_limit = nr_pages;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\treturn ret ?: nbytes;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_update_tcp_max",
          "args": [
            "memcg",
            "nr_pages"
          ],
          "line": 3219
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_update_tcp_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3151-3184",
          "snippet": "static int memcg_update_tcp_max(struct mem_cgroup *memcg, unsigned long max)\n{\n\tint ret;\n\n\tmutex_lock(&memcg_max_mutex);\n\n\tret = page_counter_set_max(&memcg->tcpmem, max);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!memcg->tcpmem_active) {\n\t\t/*\n\t\t * The active flag needs to be written after the static_key\n\t\t * update. This is what guarantees that the socket activation\n\t\t * function is the last one to run. See mem_cgroup_sk_alloc()\n\t\t * for details, and note that we don't mark any socket as\n\t\t * belonging to this memcg until that flag is up.\n\t\t *\n\t\t * We need to do this, because static_keys will span multiple\n\t\t * sites, but we can't control their order. If we mark a socket\n\t\t * as accounted, but the accounting functions are not patched in\n\t\t * yet, we'll lose accounting.\n\t\t *\n\t\t * We never race with the readers in mem_cgroup_sk_alloc(),\n\t\t * because when this value change, the code to process it is not\n\t\t * patched in yet.\n\t\t */\n\t\tstatic_branch_inc(&memcg_sockets_enabled_key);\n\t\tmemcg->tcpmem_active = true;\n\t}\nout:\n\tmutex_unlock(&memcg_max_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_MUTEX(memcg_max_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_MUTEX(memcg_max_mutex);\n\nstatic int memcg_update_tcp_max(struct mem_cgroup *memcg, unsigned long max)\n{\n\tint ret;\n\n\tmutex_lock(&memcg_max_mutex);\n\n\tret = page_counter_set_max(&memcg->tcpmem, max);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!memcg->tcpmem_active) {\n\t\t/*\n\t\t * The active flag needs to be written after the static_key\n\t\t * update. This is what guarantees that the socket activation\n\t\t * function is the last one to run. See mem_cgroup_sk_alloc()\n\t\t * for details, and note that we don't mark any socket as\n\t\t * belonging to this memcg until that flag is up.\n\t\t *\n\t\t * We need to do this, because static_keys will span multiple\n\t\t * sites, but we can't control their order. If we mark a socket\n\t\t * as accounted, but the accounting functions are not patched in\n\t\t * yet, we'll lose accounting.\n\t\t *\n\t\t * We never race with the readers in mem_cgroup_sk_alloc(),\n\t\t * because when this value change, the code to process it is not\n\t\t * patched in yet.\n\t\t */\n\t\tstatic_branch_inc(&memcg_sockets_enabled_key);\n\t\tmemcg->tcpmem_active = true;\n\t}\nout:\n\tmutex_unlock(&memcg_max_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_update_kmem_max",
          "args": [
            "memcg",
            "nr_pages"
          ],
          "line": 3216
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_update_kmem_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3140-3149",
          "snippet": "static int memcg_update_kmem_max(struct mem_cgroup *memcg,\n\t\t\t\t unsigned long max)\n{\n\tint ret;\n\n\tmutex_lock(&memcg_max_mutex);\n\tret = page_counter_set_max(&memcg->kmem, max);\n\tmutex_unlock(&memcg_max_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_MUTEX(memcg_max_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_MUTEX(memcg_max_mutex);\n\nstatic int memcg_update_kmem_max(struct mem_cgroup *memcg,\n\t\t\t\t unsigned long max)\n{\n\tint ret;\n\n\tmutex_lock(&memcg_max_mutex);\n\tret = page_counter_set_max(&memcg->kmem, max);\n\tmutex_unlock(&memcg_max_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_resize_max",
          "args": [
            "memcg",
            "nr_pages",
            "true"
          ],
          "line": 3213
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_resize_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2700-2752",
          "snippet": "static int mem_cgroup_resize_max(struct mem_cgroup *memcg,\n\t\t\t\t unsigned long max, bool memsw)\n{\n\tbool enlarge = false;\n\tbool drained = false;\n\tint ret;\n\tbool limits_invariant;\n\tstruct page_counter *counter = memsw ? &memcg->memsw : &memcg->memory;\n\n\tdo {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&memcg_max_mutex);\n\t\t/*\n\t\t * Make sure that the new limit (memsw or memory limit) doesn't\n\t\t * break our basic invariant rule memory.max <= memsw.max.\n\t\t */\n\t\tlimits_invariant = memsw ? max >= memcg->memory.max :\n\t\t\t\t\t   max <= memcg->memsw.max;\n\t\tif (!limits_invariant) {\n\t\t\tmutex_unlock(&memcg_max_mutex);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (max > counter->max)\n\t\t\tenlarge = true;\n\t\tret = page_counter_set_max(counter, max);\n\t\tmutex_unlock(&memcg_max_mutex);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tif (!drained) {\n\t\t\tdrain_all_stock(memcg);\n\t\t\tdrained = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!try_to_free_mem_cgroup_pages(memcg, 1,\n\t\t\t\t\tGFP_KERNEL, !memsw)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t} while (true);\n\n\tif (!ret && enlarge)\n\t\tmemcg_oom_recover(memcg);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_MUTEX(memcg_max_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_MUTEX(memcg_max_mutex);\n\nstatic int mem_cgroup_resize_max(struct mem_cgroup *memcg,\n\t\t\t\t unsigned long max, bool memsw)\n{\n\tbool enlarge = false;\n\tbool drained = false;\n\tint ret;\n\tbool limits_invariant;\n\tstruct page_counter *counter = memsw ? &memcg->memsw : &memcg->memory;\n\n\tdo {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&memcg_max_mutex);\n\t\t/*\n\t\t * Make sure that the new limit (memsw or memory limit) doesn't\n\t\t * break our basic invariant rule memory.max <= memsw.max.\n\t\t */\n\t\tlimits_invariant = memsw ? max >= memcg->memory.max :\n\t\t\t\t\t   max <= memcg->memsw.max;\n\t\tif (!limits_invariant) {\n\t\t\tmutex_unlock(&memcg_max_mutex);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (max > counter->max)\n\t\t\tenlarge = true;\n\t\tret = page_counter_set_max(counter, max);\n\t\tmutex_unlock(&memcg_max_mutex);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tif (!drained) {\n\t\t\tdrain_all_stock(memcg);\n\t\t\tdrained = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!try_to_free_mem_cgroup_pages(memcg, 1,\n\t\t\t\t\tGFP_KERNEL, !memsw)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t} while (true);\n\n\tif (!ret && enlarge)\n\t\tmemcg_oom_recover(memcg);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MEMFILE_TYPE",
          "args": [
            "of_cft(of)->private"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_ATTR",
          "args": [
            "of_cft(of)->private"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_memparse",
          "args": [
            "buf",
            "\"-1\"",
            "&nr_pages"
          ],
          "line": 3198
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "248-266",
          "snippet": "int page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 3197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "of_css(of)"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic ssize_t mem_cgroup_write(struct kernfs_open_file *of,\n\t\t\t\tchar *buf, size_t nbytes, loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\tunsigned long nr_pages;\n\tint ret;\n\n\tbuf = strstrip(buf);\n\tret = page_counter_memparse(buf, \"-1\", &nr_pages);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {\n\tcase RES_LIMIT:\n\t\tif (mem_cgroup_is_root(memcg)) { /* Can't set limit on root */\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (MEMFILE_TYPE(of_cft(of)->private)) {\n\t\tcase _MEM:\n\t\t\tret = mem_cgroup_resize_max(memcg, nr_pages, false);\n\t\t\tbreak;\n\t\tcase _MEMSWAP:\n\t\t\tret = mem_cgroup_resize_max(memcg, nr_pages, true);\n\t\t\tbreak;\n\t\tcase _KMEM:\n\t\t\tret = memcg_update_kmem_max(memcg, nr_pages);\n\t\t\tbreak;\n\t\tcase _TCP:\n\t\t\tret = memcg_update_tcp_max(memcg, nr_pages);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase RES_SOFT_LIMIT:\n\t\tmemcg->soft_limit = nr_pages;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\treturn ret ?: nbytes;\n}"
  },
  {
    "function_name": "memcg_update_tcp_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3151-3184",
    "snippet": "static int memcg_update_tcp_max(struct mem_cgroup *memcg, unsigned long max)\n{\n\tint ret;\n\n\tmutex_lock(&memcg_max_mutex);\n\n\tret = page_counter_set_max(&memcg->tcpmem, max);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!memcg->tcpmem_active) {\n\t\t/*\n\t\t * The active flag needs to be written after the static_key\n\t\t * update. This is what guarantees that the socket activation\n\t\t * function is the last one to run. See mem_cgroup_sk_alloc()\n\t\t * for details, and note that we don't mark any socket as\n\t\t * belonging to this memcg until that flag is up.\n\t\t *\n\t\t * We need to do this, because static_keys will span multiple\n\t\t * sites, but we can't control their order. If we mark a socket\n\t\t * as accounted, but the accounting functions are not patched in\n\t\t * yet, we'll lose accounting.\n\t\t *\n\t\t * We never race with the readers in mem_cgroup_sk_alloc(),\n\t\t * because when this value change, the code to process it is not\n\t\t * patched in yet.\n\t\t */\n\t\tstatic_branch_inc(&memcg_sockets_enabled_key);\n\t\tmemcg->tcpmem_active = true;\n\t}\nout:\n\tmutex_unlock(&memcg_max_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_MUTEX(memcg_max_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&memcg_max_mutex"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&memcg_sockets_enabled_key"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_set_max",
          "args": [
            "&memcg->tcpmem",
            "max"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "173-203",
          "snippet": "int page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&memcg_max_mutex"
          ],
          "line": 3155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_MUTEX(memcg_max_mutex);\n\nstatic int memcg_update_tcp_max(struct mem_cgroup *memcg, unsigned long max)\n{\n\tint ret;\n\n\tmutex_lock(&memcg_max_mutex);\n\n\tret = page_counter_set_max(&memcg->tcpmem, max);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!memcg->tcpmem_active) {\n\t\t/*\n\t\t * The active flag needs to be written after the static_key\n\t\t * update. This is what guarantees that the socket activation\n\t\t * function is the last one to run. See mem_cgroup_sk_alloc()\n\t\t * for details, and note that we don't mark any socket as\n\t\t * belonging to this memcg until that flag is up.\n\t\t *\n\t\t * We need to do this, because static_keys will span multiple\n\t\t * sites, but we can't control their order. If we mark a socket\n\t\t * as accounted, but the accounting functions are not patched in\n\t\t * yet, we'll lose accounting.\n\t\t *\n\t\t * We never race with the readers in mem_cgroup_sk_alloc(),\n\t\t * because when this value change, the code to process it is not\n\t\t * patched in yet.\n\t\t */\n\t\tstatic_branch_inc(&memcg_sockets_enabled_key);\n\t\tmemcg->tcpmem_active = true;\n\t}\nout:\n\tmutex_unlock(&memcg_max_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "memcg_update_kmem_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3140-3149",
    "snippet": "static int memcg_update_kmem_max(struct mem_cgroup *memcg,\n\t\t\t\t unsigned long max)\n{\n\tint ret;\n\n\tmutex_lock(&memcg_max_mutex);\n\tret = page_counter_set_max(&memcg->kmem, max);\n\tmutex_unlock(&memcg_max_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_MUTEX(memcg_max_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&memcg_max_mutex"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_set_max",
          "args": [
            "&memcg->kmem",
            "max"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "173-203",
          "snippet": "int page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&memcg_max_mutex"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_MUTEX(memcg_max_mutex);\n\nstatic int memcg_update_kmem_max(struct mem_cgroup *memcg,\n\t\t\t\t unsigned long max)\n{\n\tint ret;\n\n\tmutex_lock(&memcg_max_mutex);\n\tret = page_counter_set_max(&memcg->kmem, max);\n\tmutex_unlock(&memcg_max_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "memcg_free_kmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3135-3137",
    "snippet": "static void memcg_free_kmem(struct mem_cgroup *memcg)\n{\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_free_kmem(struct mem_cgroup *memcg)\n{\n}"
  },
  {
    "function_name": "memcg_offline_kmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3132-3134",
    "snippet": "static void memcg_offline_kmem(struct mem_cgroup *memcg)\n{\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_offline_kmem(struct mem_cgroup *memcg)\n{\n}"
  },
  {
    "function_name": "memcg_online_kmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3128-3131",
    "snippet": "static int memcg_online_kmem(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_online_kmem(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_free_kmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3115-3126",
    "snippet": "static void memcg_free_kmem(struct mem_cgroup *memcg)\n{\n\t/* css_alloc() failed, offlining didn't happen */\n\tif (unlikely(memcg->kmem_state == KMEM_ONLINE))\n\t\tmemcg_offline_kmem(memcg);\n\n\tif (memcg->kmem_state == KMEM_ALLOCATED) {\n\t\tmemcg_destroy_kmem_caches(memcg);\n\t\tstatic_branch_dec(&memcg_kmem_enabled_key);\n\t\tWARN_ON(page_counter_read(&memcg->kmem));\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page_counter_read(&memcg->kmem)"
          ],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->kmem"
          ],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_dec",
          "args": [
            "&memcg_kmem_enabled_key"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_destroy_kmem_caches",
          "args": [
            "memcg"
          ],
          "line": 3122
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_destroy_kmem_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "758-778",
          "snippet": "void memcg_destroy_kmem_caches(struct mem_cgroup *memcg)\n{\n\tstruct kmem_cache *s, *s2;\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry_safe(s, s2, &memcg->kmem_caches,\n\t\t\t\t memcg_params.kmem_caches_node) {\n\t\t/*\n\t\t * The cgroup is about to be freed and therefore has no charges\n\t\t * left. Hence, all its caches must be empty by now.\n\t\t */\n\t\tBUG_ON(shutdown_cache(s));\n\t}\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid memcg_destroy_kmem_caches(struct mem_cgroup *memcg)\n{\n\tstruct kmem_cache *s, *s2;\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry_safe(s, s2, &memcg->kmem_caches,\n\t\t\t\t memcg_params.kmem_caches_node) {\n\t\t/*\n\t\t * The cgroup is about to be freed and therefore has no charges\n\t\t * left. Hence, all its caches must be empty by now.\n\t\t */\n\t\tBUG_ON(shutdown_cache(s));\n\t}\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_offline_kmem",
          "args": [
            "memcg"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_offline_kmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3132-3134",
          "snippet": "static void memcg_offline_kmem(struct mem_cgroup *memcg)\n{\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_offline_kmem(struct mem_cgroup *memcg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "memcg->kmem_state == KMEM_ONLINE"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_free_kmem(struct mem_cgroup *memcg)\n{\n\t/* css_alloc() failed, offlining didn't happen */\n\tif (unlikely(memcg->kmem_state == KMEM_ONLINE))\n\t\tmemcg_offline_kmem(memcg);\n\n\tif (memcg->kmem_state == KMEM_ALLOCATED) {\n\t\tmemcg_destroy_kmem_caches(memcg);\n\t\tstatic_branch_dec(&memcg_kmem_enabled_key);\n\t\tWARN_ON(page_counter_read(&memcg->kmem));\n\t}\n}"
  },
  {
    "function_name": "memcg_offline_kmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3067-3113",
    "snippet": "static void memcg_offline_kmem(struct mem_cgroup *memcg)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct mem_cgroup *parent, *child;\n\tint kmemcg_id;\n\n\tif (memcg->kmem_state != KMEM_ONLINE)\n\t\treturn;\n\t/*\n\t * Clear the online state before clearing memcg_caches array\n\t * entries. The slab_mutex in memcg_deactivate_kmem_caches()\n\t * guarantees that no cache will be created for this cgroup\n\t * after we are done (see memcg_create_kmem_cache()).\n\t */\n\tmemcg->kmem_state = KMEM_ALLOCATED;\n\n\tmemcg_deactivate_kmem_caches(memcg);\n\n\tkmemcg_id = memcg->kmemcg_id;\n\tBUG_ON(kmemcg_id < 0);\n\n\tparent = parent_mem_cgroup(memcg);\n\tif (!parent)\n\t\tparent = root_mem_cgroup;\n\n\t/*\n\t * Change kmemcg_id of this cgroup and all its descendants to the\n\t * parent's id, and then move all entries from this cgroup's list_lrus\n\t * to ones of the parent. After we have finished, all list_lrus\n\t * corresponding to this cgroup are guaranteed to remain empty. The\n\t * ordering is imposed by list_lru_node->lock taken by\n\t * memcg_drain_all_list_lrus().\n\t */\n\trcu_read_lock(); /* can be called from css_free w/o cgroup_mutex */\n\tcss_for_each_descendant_pre(css, &memcg->css) {\n\t\tchild = mem_cgroup_from_css(css);\n\t\tBUG_ON(child->kmemcg_id != kmemcg_id);\n\t\tchild->kmemcg_id = parent->kmemcg_id;\n\t\tif (!memcg->use_hierarchy)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tmemcg_drain_all_list_lrus(kmemcg_id, parent);\n\n\tmemcg_free_cache_id(kmemcg_id);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_free_cache_id",
          "args": [
            "kmemcg_id"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_free_cache_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2436-2439",
          "snippet": "static void memcg_free_cache_id(int id)\n{\n\tida_simple_remove(&memcg_cache_ida, id);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void memcg_free_cache_id(int id)\n{\n\tida_simple_remove(&memcg_cache_ida, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_drain_all_list_lrus",
          "args": [
            "kmemcg_id",
            "parent"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_drain_all_list_lrus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "580-588",
          "snippet": "void memcg_drain_all_list_lrus(int src_idx, struct mem_cgroup *dst_memcg)\n{\n\tstruct list_lru *lru;\n\n\tmutex_lock(&list_lrus_mutex);\n\tlist_for_each_entry(lru, &list_lrus, list)\n\t\tmemcg_drain_list_lru(lru, src_idx, dst_memcg);\n\tmutex_unlock(&list_lrus_mutex);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid memcg_drain_all_list_lrus(int src_idx, struct mem_cgroup *dst_memcg)\n{\n\tstruct list_lru *lru;\n\n\tmutex_lock(&list_lrus_mutex);\n\tlist_for_each_entry(lru, &list_lrus, list)\n\t\tmemcg_drain_list_lru(lru, src_idx, dst_memcg);\n\tmutex_unlock(&list_lrus_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "child->kmemcg_id != kmemcg_id"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 3102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "&memcg->css"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "kmemcg_id < 0"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_deactivate_kmem_caches",
          "args": [
            "memcg"
          ],
          "line": 3083
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_deactivate_kmem_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "730-756",
          "snippet": "void memcg_deactivate_kmem_caches(struct mem_cgroup *memcg)\n{\n\tint idx;\n\tstruct memcg_cache_array *arr;\n\tstruct kmem_cache *s, *c;\n\n\tidx = memcg_cache_id(memcg);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_root_caches, root_caches_node) {\n\t\tarr = rcu_dereference_protected(s->memcg_params.memcg_caches,\n\t\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\t\tc = arr->entries[idx];\n\t\tif (!c)\n\t\t\tcontinue;\n\n\t\t__kmemcg_cache_deactivate(c);\n\t\tarr->entries[idx] = NULL;\n\t}\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid memcg_deactivate_kmem_caches(struct mem_cgroup *memcg)\n{\n\tint idx;\n\tstruct memcg_cache_array *arr;\n\tstruct kmem_cache *s, *c;\n\n\tidx = memcg_cache_id(memcg);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_root_caches, root_caches_node) {\n\t\tarr = rcu_dereference_protected(s->memcg_params.memcg_caches,\n\t\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\t\tc = arr->entries[idx];\n\t\tif (!c)\n\t\t\tcontinue;\n\n\t\t__kmemcg_cache_deactivate(c);\n\t\tarr->entries[idx] = NULL;\n\t}\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_offline_kmem(struct mem_cgroup *memcg)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct mem_cgroup *parent, *child;\n\tint kmemcg_id;\n\n\tif (memcg->kmem_state != KMEM_ONLINE)\n\t\treturn;\n\t/*\n\t * Clear the online state before clearing memcg_caches array\n\t * entries. The slab_mutex in memcg_deactivate_kmem_caches()\n\t * guarantees that no cache will be created for this cgroup\n\t * after we are done (see memcg_create_kmem_cache()).\n\t */\n\tmemcg->kmem_state = KMEM_ALLOCATED;\n\n\tmemcg_deactivate_kmem_caches(memcg);\n\n\tkmemcg_id = memcg->kmemcg_id;\n\tBUG_ON(kmemcg_id < 0);\n\n\tparent = parent_mem_cgroup(memcg);\n\tif (!parent)\n\t\tparent = root_mem_cgroup;\n\n\t/*\n\t * Change kmemcg_id of this cgroup and all its descendants to the\n\t * parent's id, and then move all entries from this cgroup's list_lrus\n\t * to ones of the parent. After we have finished, all list_lrus\n\t * corresponding to this cgroup are guaranteed to remain empty. The\n\t * ordering is imposed by list_lru_node->lock taken by\n\t * memcg_drain_all_list_lrus().\n\t */\n\trcu_read_lock(); /* can be called from css_free w/o cgroup_mutex */\n\tcss_for_each_descendant_pre(css, &memcg->css) {\n\t\tchild = mem_cgroup_from_css(css);\n\t\tBUG_ON(child->kmemcg_id != kmemcg_id);\n\t\tchild->kmemcg_id = parent->kmemcg_id;\n\t\tif (!memcg->use_hierarchy)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tmemcg_drain_all_list_lrus(kmemcg_id, parent);\n\n\tmemcg_free_cache_id(kmemcg_id);\n}"
  },
  {
    "function_name": "memcg_online_kmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "3039-3065",
    "snippet": "static int memcg_online_kmem(struct mem_cgroup *memcg)\n{\n\tint memcg_id;\n\n\tif (cgroup_memory_nokmem)\n\t\treturn 0;\n\n\tBUG_ON(memcg->kmemcg_id >= 0);\n\tBUG_ON(memcg->kmem_state);\n\n\tmemcg_id = memcg_alloc_cache_id();\n\tif (memcg_id < 0)\n\t\treturn memcg_id;\n\n\tstatic_branch_inc(&memcg_kmem_enabled_key);\n\t/*\n\t * A memory cgroup is considered kmem-online as soon as it gets\n\t * kmemcg_id. Setting the id after enabling static branching will\n\t * guarantee no one starts accounting before all call sites are\n\t * patched.\n\t */\n\tmemcg->kmemcg_id = memcg_id;\n\tmemcg->kmem_state = KMEM_ONLINE;\n\tINIT_LIST_HEAD(&memcg->kmem_caches);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool cgroup_memory_nokmem;",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&memcg->kmem_caches"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&memcg_kmem_enabled_key"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_alloc_cache_id",
          "args": [],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_alloc_cache_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2396-2434",
          "snippet": "static int memcg_alloc_cache_id(void)\n{\n\tint id, size;\n\tint err;\n\n\tid = ida_simple_get(&memcg_cache_ida,\n\t\t\t    0, MEMCG_CACHES_MAX_SIZE, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\tif (id < memcg_nr_cache_ids)\n\t\treturn id;\n\n\t/*\n\t * There's no space for the new id in memcg_caches arrays,\n\t * so we have to grow them.\n\t */\n\tdown_write(&memcg_cache_ids_sem);\n\n\tsize = 2 * (id + 1);\n\tif (size < MEMCG_CACHES_MIN_SIZE)\n\t\tsize = MEMCG_CACHES_MIN_SIZE;\n\telse if (size > MEMCG_CACHES_MAX_SIZE)\n\t\tsize = MEMCG_CACHES_MAX_SIZE;\n\n\terr = memcg_update_all_caches(size);\n\tif (!err)\n\t\terr = memcg_update_all_list_lrus(size);\n\tif (!err)\n\t\tmemcg_nr_cache_ids = size;\n\n\tup_write(&memcg_cache_ids_sem);\n\n\tif (err) {\n\t\tida_simple_remove(&memcg_cache_ida, id);\n\t\treturn err;\n\t}\n\treturn id;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define MEMCG_CACHES_MAX_SIZE MEM_CGROUP_ID_MAX",
            "#define MEMCG_CACHES_MIN_SIZE 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MEMCG_CACHES_MAX_SIZE MEM_CGROUP_ID_MAX\n#define MEMCG_CACHES_MIN_SIZE 4\n\nstatic int memcg_alloc_cache_id(void)\n{\n\tint id, size;\n\tint err;\n\n\tid = ida_simple_get(&memcg_cache_ida,\n\t\t\t    0, MEMCG_CACHES_MAX_SIZE, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\tif (id < memcg_nr_cache_ids)\n\t\treturn id;\n\n\t/*\n\t * There's no space for the new id in memcg_caches arrays,\n\t * so we have to grow them.\n\t */\n\tdown_write(&memcg_cache_ids_sem);\n\n\tsize = 2 * (id + 1);\n\tif (size < MEMCG_CACHES_MIN_SIZE)\n\t\tsize = MEMCG_CACHES_MIN_SIZE;\n\telse if (size > MEMCG_CACHES_MAX_SIZE)\n\t\tsize = MEMCG_CACHES_MAX_SIZE;\n\n\terr = memcg_update_all_caches(size);\n\tif (!err)\n\t\terr = memcg_update_all_list_lrus(size);\n\tif (!err)\n\t\tmemcg_nr_cache_ids = size;\n\n\tup_write(&memcg_cache_ids_sem);\n\n\tif (err) {\n\t\tida_simple_remove(&memcg_cache_ida, id);\n\t\treturn err;\n\t}\n\treturn id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "memcg->kmem_state"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "memcg->kmemcg_id >= 0"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic bool cgroup_memory_nokmem;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_online_kmem(struct mem_cgroup *memcg)\n{\n\tint memcg_id;\n\n\tif (cgroup_memory_nokmem)\n\t\treturn 0;\n\n\tBUG_ON(memcg->kmemcg_id >= 0);\n\tBUG_ON(memcg->kmem_state);\n\n\tmemcg_id = memcg_alloc_cache_id();\n\tif (memcg_id < 0)\n\t\treturn memcg_id;\n\n\tstatic_branch_inc(&memcg_kmem_enabled_key);\n\t/*\n\t * A memory cgroup is considered kmem-online as soon as it gets\n\t * kmemcg_id. Setting the id after enabling static branching will\n\t * guarantee no one starts accounting before all call sites are\n\t * patched.\n\t */\n\tmemcg->kmemcg_id = memcg_id;\n\tmemcg->kmem_state = KMEM_ONLINE;\n\tINIT_LIST_HEAD(&memcg->kmem_caches);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_read_u64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2995-3036",
    "snippet": "static u64 mem_cgroup_read_u64(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\tstruct page_counter *counter;\n\n\tswitch (MEMFILE_TYPE(cft->private)) {\n\tcase _MEM:\n\t\tcounter = &memcg->memory;\n\t\tbreak;\n\tcase _MEMSWAP:\n\t\tcounter = &memcg->memsw;\n\t\tbreak;\n\tcase _KMEM:\n\t\tcounter = &memcg->kmem;\n\t\tbreak;\n\tcase _TCP:\n\t\tcounter = &memcg->tcpmem;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tswitch (MEMFILE_ATTR(cft->private)) {\n\tcase RES_USAGE:\n\t\tif (counter == &memcg->memory)\n\t\t\treturn (u64)mem_cgroup_usage(memcg, false) * PAGE_SIZE;\n\t\tif (counter == &memcg->memsw)\n\t\t\treturn (u64)mem_cgroup_usage(memcg, true) * PAGE_SIZE;\n\t\treturn (u64)page_counter_read(counter) * PAGE_SIZE;\n\tcase RES_LIMIT:\n\t\treturn (u64)counter->max * PAGE_SIZE;\n\tcase RES_MAX_USAGE:\n\t\treturn (u64)counter->watermark * PAGE_SIZE;\n\tcase RES_FAILCNT:\n\t\treturn counter->failcnt;\n\tcase RES_SOFT_LIMIT:\n\t\treturn (u64)memcg->soft_limit * PAGE_SIZE;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "counter"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_usage",
          "args": [
            "memcg",
            "true"
          ],
          "line": 3023
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_usage_unregister_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3748-3752",
          "snippet": "static void mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEM);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,\n\tstruct eventfd_ctx *eventfd)\n{\n\treturn __mem_cgroup_usage_unregister_event(memcg, eventfd, _MEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MEMFILE_ATTR",
          "args": [
            "cft->private"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_TYPE",
          "args": [
            "cft->private"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic u64 mem_cgroup_read_u64(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\tstruct page_counter *counter;\n\n\tswitch (MEMFILE_TYPE(cft->private)) {\n\tcase _MEM:\n\t\tcounter = &memcg->memory;\n\t\tbreak;\n\tcase _MEMSWAP:\n\t\tcounter = &memcg->memsw;\n\t\tbreak;\n\tcase _KMEM:\n\t\tcounter = &memcg->kmem;\n\t\tbreak;\n\tcase _TCP:\n\t\tcounter = &memcg->tcpmem;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tswitch (MEMFILE_ATTR(cft->private)) {\n\tcase RES_USAGE:\n\t\tif (counter == &memcg->memory)\n\t\t\treturn (u64)mem_cgroup_usage(memcg, false) * PAGE_SIZE;\n\t\tif (counter == &memcg->memsw)\n\t\t\treturn (u64)mem_cgroup_usage(memcg, true) * PAGE_SIZE;\n\t\treturn (u64)page_counter_read(counter) * PAGE_SIZE;\n\tcase RES_LIMIT:\n\t\treturn (u64)counter->max * PAGE_SIZE;\n\tcase RES_MAX_USAGE:\n\t\treturn (u64)counter->watermark * PAGE_SIZE;\n\tcase RES_FAILCNT:\n\t\treturn counter->failcnt;\n\tcase RES_SOFT_LIMIT:\n\t\treturn (u64)memcg->soft_limit * PAGE_SIZE;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "mem_cgroup_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2965-2985",
    "snippet": "static unsigned long mem_cgroup_usage(struct mem_cgroup *memcg, bool swap)\n{\n\tunsigned long val = 0;\n\n\tif (mem_cgroup_is_root(memcg)) {\n\t\tstruct mem_cgroup *iter;\n\n\t\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\t\tval += memcg_page_state(iter, MEMCG_CACHE);\n\t\t\tval += memcg_page_state(iter, MEMCG_RSS);\n\t\t\tif (swap)\n\t\t\t\tval += memcg_page_state(iter, MEMCG_SWAP);\n\t\t}\n\t} else {\n\t\tif (!swap)\n\t\t\tval = page_counter_read(&memcg->memory);\n\t\telse\n\t\t\tval = page_counter_read(&memcg->memsw);\n\t}\n\treturn val;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memsw"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_page_state",
          "args": [
            "iter",
            "MEMCG_SWAP"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_page_state",
          "args": [
            "iter",
            "MEMCG_RSS"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_page_state",
          "args": [
            "iter",
            "MEMCG_CACHE"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "iter",
            "memcg"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long mem_cgroup_usage(struct mem_cgroup *memcg, bool swap)\n{\n\tunsigned long val = 0;\n\n\tif (mem_cgroup_is_root(memcg)) {\n\t\tstruct mem_cgroup *iter;\n\n\t\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\t\tval += memcg_page_state(iter, MEMCG_CACHE);\n\t\t\tval += memcg_page_state(iter, MEMCG_RSS);\n\t\t\tif (swap)\n\t\t\t\tval += memcg_page_state(iter, MEMCG_SWAP);\n\t\t}\n\t} else {\n\t\tif (!swap)\n\t\t\tval = page_counter_read(&memcg->memory);\n\t\telse\n\t\t\tval = page_counter_read(&memcg->memsw);\n\t}\n\treturn val;\n}"
  },
  {
    "function_name": "accumulate_memcg_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2944-2963",
    "snippet": "static void accumulate_memcg_tree(struct mem_cgroup *memcg,\n\t\t\t\t  struct accumulated_stats *acc)\n{\n\tstruct mem_cgroup *mi;\n\tint i;\n\n\tfor_each_mem_cgroup_tree(mi, memcg) {\n\t\tfor (i = 0; i < acc->stats_size; i++)\n\t\t\tacc->stat[i] += memcg_page_state(mi,\n\t\t\t\tacc->stats_array ? acc->stats_array[i] : i);\n\n\t\tfor (i = 0; i < acc->events_size; i++)\n\t\t\tacc->events[i] += memcg_sum_events(mi,\n\t\t\t\tacc->events_array ? acc->events_array[i] : i);\n\n\t\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\t\tacc->lru_pages[i] +=\n\t\t\t\tmem_cgroup_nr_lru_pages(mi, BIT(i));\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_nr_lru_pages",
          "args": [
            "mi",
            "BIT(i)"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_nr_lru_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "738-747",
          "snippet": "static unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "i"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_sum_events",
          "args": [
            "mi",
            "acc->events_array ? acc->events_array[i] : i"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_sum_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "683-687",
          "snippet": "static unsigned long memcg_sum_events(struct mem_cgroup *memcg,\n\t\t\t\t      int event)\n{\n\treturn atomic_long_read(&memcg->events[event]);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long memcg_sum_events(struct mem_cgroup *memcg,\n\t\t\t\t      int event)\n{\n\treturn atomic_long_read(&memcg->events[event]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_page_state",
          "args": [
            "mi",
            "acc->stats_array ? acc->stats_array[i] : i"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "mi",
            "memcg"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void accumulate_memcg_tree(struct mem_cgroup *memcg,\n\t\t\t\t  struct accumulated_stats *acc)\n{\n\tstruct mem_cgroup *mi;\n\tint i;\n\n\tfor_each_mem_cgroup_tree(mi, memcg) {\n\t\tfor (i = 0; i < acc->stats_size; i++)\n\t\t\tacc->stat[i] += memcg_page_state(mi,\n\t\t\t\tacc->stats_array ? acc->stats_array[i] : i);\n\n\t\tfor (i = 0; i < acc->events_size; i++)\n\t\t\tacc->events[i] += memcg_sum_events(mi,\n\t\t\t\tacc->events_array ? acc->events_array[i] : i);\n\n\t\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\t\tacc->lru_pages[i] +=\n\t\t\t\tmem_cgroup_nr_lru_pages(mi, BIT(i));\n\t}\n}"
  },
  {
    "function_name": "mem_cgroup_hierarchy_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2904-2932",
    "snippet": "static int mem_cgroup_hierarchy_write(struct cgroup_subsys_state *css,\n\t\t\t\t      struct cftype *cft, u64 val)\n{\n\tint retval = 0;\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\tstruct mem_cgroup *parent_memcg = mem_cgroup_from_css(memcg->css.parent);\n\n\tif (memcg->use_hierarchy == val)\n\t\treturn 0;\n\n\t/*\n\t * If parent's use_hierarchy is set, we can't make any modifications\n\t * in the child subtrees. If it is unset, then the change can\n\t * occur, provided the current cgroup has no children.\n\t *\n\t * For the root cgroup, parent_mem is NULL, we allow value to be\n\t * set if there are no children.\n\t */\n\tif ((!parent_memcg || !parent_memcg->use_hierarchy) &&\n\t\t\t\t(val == 1 || val == 0)) {\n\t\tif (!memcg_has_children(memcg))\n\t\t\tmemcg->use_hierarchy = val;\n\t\telse\n\t\t\tretval = -EBUSY;\n\t} else\n\t\tretval = -EINVAL;\n\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_has_children",
          "args": [
            "memcg"
          ],
          "line": 2924
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_has_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2843-2851",
          "snippet": "static inline bool memcg_has_children(struct mem_cgroup *memcg)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = css_next_child(NULL, &memcg->css);\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic inline bool memcg_has_children(struct mem_cgroup *memcg)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = css_next_child(NULL, &memcg->css);\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "memcg->css.parent"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int mem_cgroup_hierarchy_write(struct cgroup_subsys_state *css,\n\t\t\t\t      struct cftype *cft, u64 val)\n{\n\tint retval = 0;\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\tstruct mem_cgroup *parent_memcg = mem_cgroup_from_css(memcg->css.parent);\n\n\tif (memcg->use_hierarchy == val)\n\t\treturn 0;\n\n\t/*\n\t * If parent's use_hierarchy is set, we can't make any modifications\n\t * in the child subtrees. If it is unset, then the change can\n\t * occur, provided the current cgroup has no children.\n\t *\n\t * For the root cgroup, parent_mem is NULL, we allow value to be\n\t * set if there are no children.\n\t */\n\tif ((!parent_memcg || !parent_memcg->use_hierarchy) &&\n\t\t\t\t(val == 1 || val == 0)) {\n\t\tif (!memcg_has_children(memcg))\n\t\t\tmemcg->use_hierarchy = val;\n\t\telse\n\t\t\tretval = -EBUSY;\n\t} else\n\t\tretval = -EINVAL;\n\n\treturn retval;\n}"
  },
  {
    "function_name": "mem_cgroup_hierarchy_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2898-2902",
    "snippet": "static u64 mem_cgroup_hierarchy_read(struct cgroup_subsys_state *css,\n\t\t\t\t     struct cftype *cft)\n{\n\treturn mem_cgroup_from_css(css)->use_hierarchy;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic u64 mem_cgroup_hierarchy_read(struct cgroup_subsys_state *css,\n\t\t\t\t     struct cftype *cft)\n{\n\treturn mem_cgroup_from_css(css)->use_hierarchy;\n}"
  },
  {
    "function_name": "mem_cgroup_force_empty_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2887-2896",
    "snippet": "static ssize_t mem_cgroup_force_empty_write(struct kernfs_open_file *of,\n\t\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t\t    loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn -EINVAL;\n\treturn mem_cgroup_force_empty(memcg) ?: nbytes;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_force_empty",
          "args": [
            "memcg"
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_force_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2858-2885",
          "snippet": "static int mem_cgroup_force_empty(struct mem_cgroup *memcg)\n{\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\n\t/* we call try-to-free pages for make this cgroup empty */\n\tlru_add_drain_all();\n\n\tdrain_all_stock(memcg);\n\n\t/* try to free all pages in this cgroup */\n\twhile (nr_retries && page_counter_read(&memcg->memory)) {\n\t\tint progress;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\n\t\tprogress = try_to_free_mem_cgroup_pages(memcg, 1,\n\t\t\t\t\t\t\tGFP_KERNEL, true);\n\t\tif (!progress) {\n\t\t\tnr_retries--;\n\t\t\t/* maybe some writeback is necessary */\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t}\n\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define MEM_CGROUP_RECLAIM_RETRIES\t5"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MEM_CGROUP_RECLAIM_RETRIES\t5\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int mem_cgroup_force_empty(struct mem_cgroup *memcg)\n{\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\n\t/* we call try-to-free pages for make this cgroup empty */\n\tlru_add_drain_all();\n\n\tdrain_all_stock(memcg);\n\n\t/* try to free all pages in this cgroup */\n\twhile (nr_retries && page_counter_read(&memcg->memory)) {\n\t\tint progress;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\n\t\tprogress = try_to_free_mem_cgroup_pages(memcg, 1,\n\t\t\t\t\t\t\tGFP_KERNEL, true);\n\t\tif (!progress) {\n\t\t\tnr_retries--;\n\t\t\t/* maybe some writeback is necessary */\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "of_css(of)"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic ssize_t mem_cgroup_force_empty_write(struct kernfs_open_file *of,\n\t\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t\t    loff_t off)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn -EINVAL;\n\treturn mem_cgroup_force_empty(memcg) ?: nbytes;\n}"
  },
  {
    "function_name": "mem_cgroup_force_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2858-2885",
    "snippet": "static int mem_cgroup_force_empty(struct mem_cgroup *memcg)\n{\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\n\t/* we call try-to-free pages for make this cgroup empty */\n\tlru_add_drain_all();\n\n\tdrain_all_stock(memcg);\n\n\t/* try to free all pages in this cgroup */\n\twhile (nr_retries && page_counter_read(&memcg->memory)) {\n\t\tint progress;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\n\t\tprogress = try_to_free_mem_cgroup_pages(memcg, 1,\n\t\t\t\t\t\t\tGFP_KERNEL, true);\n\t\tif (!progress) {\n\t\t\tnr_retries--;\n\t\t\t/* maybe some writeback is necessary */\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t}\n\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define MEM_CGROUP_RECLAIM_RETRIES\t5"
    ],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/10"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "congestion_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/backing-dev.c",
          "lines": "1016-1031",
          "snippet": "long congestion_wait(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\n\ttrace_writeback_congestion_wait(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <trace/events/writeback.h>",
            "#include <linux/device.h>",
            "#include <linux/writeback.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/wait.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <trace/events/writeback.h>\n#include <linux/device.h>\n#include <linux/writeback.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/wait.h>\n\nstatic wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};\n\nlong congestion_wait(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\n\ttrace_writeback_congestion_wait(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_mem_cgroup_pages",
          "args": [
            "memcg",
            "1",
            "GFP_KERNEL",
            "true"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_mem_cgroup_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3311-3358",
          "snippet": "unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_all_stock",
          "args": [
            "memcg"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2028-2063",
          "snippet": "static void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define FLUSHING_CACHED_CHARGE\t0"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);",
            "static DEFINE_MUTEX(percpu_charge_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define FLUSHING_CACHED_CHARGE\t0\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\nstatic DEFINE_MUTEX(percpu_charge_mutex);\n\nstatic void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MEM_CGROUP_RECLAIM_RETRIES\t5\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int mem_cgroup_force_empty(struct mem_cgroup *memcg)\n{\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\n\t/* we call try-to-free pages for make this cgroup empty */\n\tlru_add_drain_all();\n\n\tdrain_all_stock(memcg);\n\n\t/* try to free all pages in this cgroup */\n\twhile (nr_retries && page_counter_read(&memcg->memory)) {\n\t\tint progress;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\n\t\tprogress = try_to_free_mem_cgroup_pages(memcg, 1,\n\t\t\t\t\t\t\tGFP_KERNEL, true);\n\t\tif (!progress) {\n\t\t\tnr_retries--;\n\t\t\t/* maybe some writeback is necessary */\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_has_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2843-2851",
    "snippet": "static inline bool memcg_has_children(struct mem_cgroup *memcg)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = css_next_child(NULL, &memcg->css);\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_child",
          "args": [
            "NULL",
            "&memcg->css"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic inline bool memcg_has_children(struct mem_cgroup *memcg)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = css_next_child(NULL, &memcg->css);\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "mem_cgroup_soft_limit_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2754-2835",
    "snippet": "unsigned long mem_cgroup_soft_limit_reclaim(pg_data_t *pgdat, int order,\n\t\t\t\t\t    gfp_t gfp_mask,\n\t\t\t\t\t    unsigned long *total_scanned)\n{\n\tunsigned long nr_reclaimed = 0;\n\tstruct mem_cgroup_per_node *mz, *next_mz = NULL;\n\tunsigned long reclaimed;\n\tint loop = 0;\n\tstruct mem_cgroup_tree_per_node *mctz;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\n\tif (order > 0)\n\t\treturn 0;\n\n\tmctz = soft_limit_tree_node(pgdat->node_id);\n\n\t/*\n\t * Do not even bother to check the largest node if the root\n\t * is empty. Do it lockless to prevent lock bouncing. Races\n\t * are acceptable as soft limit is best effort anyway.\n\t */\n\tif (!mctz || RB_EMPTY_ROOT(&mctz->rb_root))\n\t\treturn 0;\n\n\t/*\n\t * This loop can run a while, specially if mem_cgroup's continuously\n\t * keep exceeding their soft limit and putting the system under\n\t * pressure\n\t */\n\tdo {\n\t\tif (next_mz)\n\t\t\tmz = next_mz;\n\t\telse\n\t\t\tmz = mem_cgroup_largest_soft_limit_node(mctz);\n\t\tif (!mz)\n\t\t\tbreak;\n\n\t\tnr_scanned = 0;\n\t\treclaimed = mem_cgroup_soft_reclaim(mz->memcg, pgdat,\n\t\t\t\t\t\t    gfp_mask, &nr_scanned);\n\t\tnr_reclaimed += reclaimed;\n\t\t*total_scanned += nr_scanned;\n\t\tspin_lock_irq(&mctz->lock);\n\t\t__mem_cgroup_remove_exceeded(mz, mctz);\n\n\t\t/*\n\t\t * If we failed to reclaim anything from this memory cgroup\n\t\t * it is time to move on to the next cgroup\n\t\t */\n\t\tnext_mz = NULL;\n\t\tif (!reclaimed)\n\t\t\tnext_mz = __mem_cgroup_largest_soft_limit_node(mctz);\n\n\t\texcess = soft_limit_excess(mz->memcg);\n\t\t/*\n\t\t * One school of thought says that we should not add\n\t\t * back the node to the tree if reclaim returns 0.\n\t\t * But our reclaim could return 0, simply because due\n\t\t * to priority we are exposing a smaller subset of\n\t\t * memory to reclaim from. Consider this as a longer\n\t\t * term TODO.\n\t\t */\n\t\t/* If excess == 0, no tree ops */\n\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);\n\t\tspin_unlock_irq(&mctz->lock);\n\t\tcss_put(&mz->memcg->css);\n\t\tloop++;\n\t\t/*\n\t\t * Could not reclaim anything and there are no more\n\t\t * mem cgroups to try or we seem to be looping without\n\t\t * reclaiming anything.\n\t\t */\n\t\tif (!nr_reclaimed &&\n\t\t\t(next_mz == NULL ||\n\t\t\tloop > MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS))\n\t\t\tbreak;\n\t} while (!nr_reclaimed);\n\tif (next_mz)\n\t\tcss_put(&next_mz->memcg->css);\n\treturn nr_reclaimed;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define\tMEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS\t2"
    ],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&next_mz->memcg->css"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&mz->memcg->css"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&mctz->lock"
          ],
          "line": 2819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_insert_exceeded",
          "args": [
            "mz",
            "mctz",
            "excess"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_insert_exceeded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "521-559",
          "snippet": "static void __mem_cgroup_insert_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz,\n\t\t\t\t\t unsigned long new_usage_in_excess)\n{\n\tstruct rb_node **p = &mctz->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct mem_cgroup_per_node *mz_node;\n\tbool rightmost = true;\n\n\tif (mz->on_tree)\n\t\treturn;\n\n\tmz->usage_in_excess = new_usage_in_excess;\n\tif (!mz->usage_in_excess)\n\t\treturn;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmz_node = rb_entry(parent, struct mem_cgroup_per_node,\n\t\t\t\t\ttree_node);\n\t\tif (mz->usage_in_excess < mz_node->usage_in_excess) {\n\t\t\tp = &(*p)->rb_left;\n\t\t\trightmost = false;\n\t\t}\n\n\t\t/*\n\t\t * We can't avoid mem cgroups that are over their soft\n\t\t * limit by the same amount\n\t\t */\n\t\telse if (mz->usage_in_excess >= mz_node->usage_in_excess)\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tif (rightmost)\n\t\tmctz->rb_rightmost = &mz->tree_node;\n\n\trb_link_node(&mz->tree_node, parent, p);\n\trb_insert_color(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_insert_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz,\n\t\t\t\t\t unsigned long new_usage_in_excess)\n{\n\tstruct rb_node **p = &mctz->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct mem_cgroup_per_node *mz_node;\n\tbool rightmost = true;\n\n\tif (mz->on_tree)\n\t\treturn;\n\n\tmz->usage_in_excess = new_usage_in_excess;\n\tif (!mz->usage_in_excess)\n\t\treturn;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmz_node = rb_entry(parent, struct mem_cgroup_per_node,\n\t\t\t\t\ttree_node);\n\t\tif (mz->usage_in_excess < mz_node->usage_in_excess) {\n\t\t\tp = &(*p)->rb_left;\n\t\t\trightmost = false;\n\t\t}\n\n\t\t/*\n\t\t * We can't avoid mem cgroups that are over their soft\n\t\t * limit by the same amount\n\t\t */\n\t\telse if (mz->usage_in_excess >= mz_node->usage_in_excess)\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tif (rightmost)\n\t\tmctz->rb_rightmost = &mz->tree_node;\n\n\trb_link_node(&mz->tree_node, parent, p);\n\trb_insert_color(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "soft_limit_excess",
          "args": [
            "mz->memcg"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "soft_limit_excess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "584-594",
          "snippet": "static unsigned long soft_limit_excess(struct mem_cgroup *memcg)\n{\n\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);\n\tunsigned long excess = 0;\n\n\tif (nr_pages > soft_limit)\n\t\texcess = nr_pages - soft_limit;\n\n\treturn excess;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long soft_limit_excess(struct mem_cgroup *memcg)\n{\n\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);\n\tunsigned long excess = 0;\n\n\tif (nr_pages > soft_limit)\n\t\texcess = nr_pages - soft_limit;\n\n\treturn excess;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_largest_soft_limit_node",
          "args": [
            "mctz"
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_largest_soft_limit_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "647-670",
          "snippet": "static struct mem_cgroup_per_node *\n__mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_node *mctz)\n{\n\tstruct mem_cgroup_per_node *mz;\n\nretry:\n\tmz = NULL;\n\tif (!mctz->rb_rightmost)\n\t\tgoto done;\t\t/* Nothing to reclaim from */\n\n\tmz = rb_entry(mctz->rb_rightmost,\n\t\t      struct mem_cgroup_per_node, tree_node);\n\t/*\n\t * Remove the node now but someone else can add it back,\n\t * we will to add it back at the end of reclaim to its correct\n\t * position in the tree.\n\t */\n\t__mem_cgroup_remove_exceeded(mz, mctz);\n\tif (!soft_limit_excess(mz->memcg) ||\n\t    !css_tryget_online(&mz->memcg->css))\n\t\tgoto retry;\ndone:\n\treturn mz;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_per_node *\n__mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_node *mctz)\n{\n\tstruct mem_cgroup_per_node *mz;\n\nretry:\n\tmz = NULL;\n\tif (!mctz->rb_rightmost)\n\t\tgoto done;\t\t/* Nothing to reclaim from */\n\n\tmz = rb_entry(mctz->rb_rightmost,\n\t\t      struct mem_cgroup_per_node, tree_node);\n\t/*\n\t * Remove the node now but someone else can add it back,\n\t * we will to add it back at the end of reclaim to its correct\n\t * position in the tree.\n\t */\n\t__mem_cgroup_remove_exceeded(mz, mctz);\n\tif (!soft_limit_excess(mz->memcg) ||\n\t    !css_tryget_online(&mz->memcg->css))\n\t\tgoto retry;\ndone:\n\treturn mz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_remove_exceeded",
          "args": [
            "mz",
            "mctz"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_remove_exceeded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "561-572",
          "snippet": "static void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\n\tif (&mz->tree_node == mctz->rb_rightmost)\n\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);\n\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\n\tif (&mz->tree_node == mctz->rb_rightmost)\n\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);\n\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&mctz->lock"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_soft_reclaim",
          "args": [
            "mz->memcg",
            "pgdat",
            "gfp_mask",
            "&nr_scanned"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_soft_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1485-1534",
          "snippet": "static int mem_cgroup_soft_reclaim(struct mem_cgroup *root_memcg,\n\t\t\t\t   pg_data_t *pgdat,\n\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t   unsigned long *total_scanned)\n{\n\tstruct mem_cgroup *victim = NULL;\n\tint total = 0;\n\tint loop = 0;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\tstruct mem_cgroup_reclaim_cookie reclaim = {\n\t\t.pgdat = pgdat,\n\t\t.priority = 0,\n\t};\n\n\texcess = soft_limit_excess(root_memcg);\n\n\twhile (1) {\n\t\tvictim = mem_cgroup_iter(root_memcg, victim, &reclaim);\n\t\tif (!victim) {\n\t\t\tloop++;\n\t\t\tif (loop >= 2) {\n\t\t\t\t/*\n\t\t\t\t * If we have not been able to reclaim\n\t\t\t\t * anything, it might because there are\n\t\t\t\t * no reclaimable pages under this hierarchy\n\t\t\t\t */\n\t\t\t\tif (!total)\n\t\t\t\t\tbreak;\n\t\t\t\t/*\n\t\t\t\t * We want to do more targeted reclaim.\n\t\t\t\t * excess >> 2 is not to excessive so as to\n\t\t\t\t * reclaim too much, nor too less that we keep\n\t\t\t\t * coming back to reclaim from this cgroup\n\t\t\t\t */\n\t\t\t\tif (total >= (excess >> 2) ||\n\t\t\t\t\t(loop > MEM_CGROUP_MAX_RECLAIM_LOOPS))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttotal += mem_cgroup_shrink_node(victim, gfp_mask, false,\n\t\t\t\t\tpgdat, &nr_scanned);\n\t\t*total_scanned += nr_scanned;\n\t\tif (!soft_limit_excess(root_memcg))\n\t\t\tbreak;\n\t}\n\tmem_cgroup_iter_break(root_memcg, victim);\n\treturn total;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define\tMEM_CGROUP_MAX_RECLAIM_LOOPS\t\t100"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define\tMEM_CGROUP_MAX_RECLAIM_LOOPS\t\t100\n\nstatic __always_inline struct;\n\nstatic int mem_cgroup_soft_reclaim(struct mem_cgroup *root_memcg,\n\t\t\t\t   pg_data_t *pgdat,\n\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t   unsigned long *total_scanned)\n{\n\tstruct mem_cgroup *victim = NULL;\n\tint total = 0;\n\tint loop = 0;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\tstruct mem_cgroup_reclaim_cookie reclaim = {\n\t\t.pgdat = pgdat,\n\t\t.priority = 0,\n\t};\n\n\texcess = soft_limit_excess(root_memcg);\n\n\twhile (1) {\n\t\tvictim = mem_cgroup_iter(root_memcg, victim, &reclaim);\n\t\tif (!victim) {\n\t\t\tloop++;\n\t\t\tif (loop >= 2) {\n\t\t\t\t/*\n\t\t\t\t * If we have not been able to reclaim\n\t\t\t\t * anything, it might because there are\n\t\t\t\t * no reclaimable pages under this hierarchy\n\t\t\t\t */\n\t\t\t\tif (!total)\n\t\t\t\t\tbreak;\n\t\t\t\t/*\n\t\t\t\t * We want to do more targeted reclaim.\n\t\t\t\t * excess >> 2 is not to excessive so as to\n\t\t\t\t * reclaim too much, nor too less that we keep\n\t\t\t\t * coming back to reclaim from this cgroup\n\t\t\t\t */\n\t\t\t\tif (total >= (excess >> 2) ||\n\t\t\t\t\t(loop > MEM_CGROUP_MAX_RECLAIM_LOOPS))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttotal += mem_cgroup_shrink_node(victim, gfp_mask, false,\n\t\t\t\t\tpgdat, &nr_scanned);\n\t\t*total_scanned += nr_scanned;\n\t\tif (!soft_limit_excess(root_memcg))\n\t\t\tbreak;\n\t}\n\tmem_cgroup_iter_break(root_memcg, victim);\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_largest_soft_limit_node",
          "args": [
            "mctz"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_largest_soft_limit_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "672-681",
          "snippet": "static struct mem_cgroup_per_node *\nmem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_node *mctz)\n{\n\tstruct mem_cgroup_per_node *mz;\n\n\tspin_lock_irq(&mctz->lock);\n\tmz = __mem_cgroup_largest_soft_limit_node(mctz);\n\tspin_unlock_irq(&mctz->lock);\n\treturn mz;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_per_node *\nmem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_node *mctz)\n{\n\tstruct mem_cgroup_per_node *mz;\n\n\tspin_lock_irq(&mctz->lock);\n\tmz = __mem_cgroup_largest_soft_limit_node(mctz);\n\tspin_unlock_irq(&mctz->lock);\n\treturn mz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&mctz->rb_root"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "soft_limit_tree_node",
          "args": [
            "pgdat->node_id"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "soft_limit_tree_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "507-511",
          "snippet": "static struct mem_cgroup_tree_per_node *\nsoft_limit_tree_node(int nid)\n{\n\treturn soft_limit_tree.rb_tree_per_node[nid];\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mem_cgroup_tree soft_limit_tree",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct mem_cgroup_tree soft_limit_tree;\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_tree_per_node *\nsoft_limit_tree_node(int nid)\n{\n\treturn soft_limit_tree.rb_tree_per_node[nid];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define\tMEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS\t2\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nunsigned long mem_cgroup_soft_limit_reclaim(pg_data_t *pgdat, int order,\n\t\t\t\t\t    gfp_t gfp_mask,\n\t\t\t\t\t    unsigned long *total_scanned)\n{\n\tunsigned long nr_reclaimed = 0;\n\tstruct mem_cgroup_per_node *mz, *next_mz = NULL;\n\tunsigned long reclaimed;\n\tint loop = 0;\n\tstruct mem_cgroup_tree_per_node *mctz;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\n\tif (order > 0)\n\t\treturn 0;\n\n\tmctz = soft_limit_tree_node(pgdat->node_id);\n\n\t/*\n\t * Do not even bother to check the largest node if the root\n\t * is empty. Do it lockless to prevent lock bouncing. Races\n\t * are acceptable as soft limit is best effort anyway.\n\t */\n\tif (!mctz || RB_EMPTY_ROOT(&mctz->rb_root))\n\t\treturn 0;\n\n\t/*\n\t * This loop can run a while, specially if mem_cgroup's continuously\n\t * keep exceeding their soft limit and putting the system under\n\t * pressure\n\t */\n\tdo {\n\t\tif (next_mz)\n\t\t\tmz = next_mz;\n\t\telse\n\t\t\tmz = mem_cgroup_largest_soft_limit_node(mctz);\n\t\tif (!mz)\n\t\t\tbreak;\n\n\t\tnr_scanned = 0;\n\t\treclaimed = mem_cgroup_soft_reclaim(mz->memcg, pgdat,\n\t\t\t\t\t\t    gfp_mask, &nr_scanned);\n\t\tnr_reclaimed += reclaimed;\n\t\t*total_scanned += nr_scanned;\n\t\tspin_lock_irq(&mctz->lock);\n\t\t__mem_cgroup_remove_exceeded(mz, mctz);\n\n\t\t/*\n\t\t * If we failed to reclaim anything from this memory cgroup\n\t\t * it is time to move on to the next cgroup\n\t\t */\n\t\tnext_mz = NULL;\n\t\tif (!reclaimed)\n\t\t\tnext_mz = __mem_cgroup_largest_soft_limit_node(mctz);\n\n\t\texcess = soft_limit_excess(mz->memcg);\n\t\t/*\n\t\t * One school of thought says that we should not add\n\t\t * back the node to the tree if reclaim returns 0.\n\t\t * But our reclaim could return 0, simply because due\n\t\t * to priority we are exposing a smaller subset of\n\t\t * memory to reclaim from. Consider this as a longer\n\t\t * term TODO.\n\t\t */\n\t\t/* If excess == 0, no tree ops */\n\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);\n\t\tspin_unlock_irq(&mctz->lock);\n\t\tcss_put(&mz->memcg->css);\n\t\tloop++;\n\t\t/*\n\t\t * Could not reclaim anything and there are no more\n\t\t * mem cgroups to try or we seem to be looping without\n\t\t * reclaiming anything.\n\t\t */\n\t\tif (!nr_reclaimed &&\n\t\t\t(next_mz == NULL ||\n\t\t\tloop > MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS))\n\t\t\tbreak;\n\t} while (!nr_reclaimed);\n\tif (next_mz)\n\t\tcss_put(&next_mz->memcg->css);\n\treturn nr_reclaimed;\n}"
  },
  {
    "function_name": "mem_cgroup_resize_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2700-2752",
    "snippet": "static int mem_cgroup_resize_max(struct mem_cgroup *memcg,\n\t\t\t\t unsigned long max, bool memsw)\n{\n\tbool enlarge = false;\n\tbool drained = false;\n\tint ret;\n\tbool limits_invariant;\n\tstruct page_counter *counter = memsw ? &memcg->memsw : &memcg->memory;\n\n\tdo {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&memcg_max_mutex);\n\t\t/*\n\t\t * Make sure that the new limit (memsw or memory limit) doesn't\n\t\t * break our basic invariant rule memory.max <= memsw.max.\n\t\t */\n\t\tlimits_invariant = memsw ? max >= memcg->memory.max :\n\t\t\t\t\t   max <= memcg->memsw.max;\n\t\tif (!limits_invariant) {\n\t\t\tmutex_unlock(&memcg_max_mutex);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (max > counter->max)\n\t\t\tenlarge = true;\n\t\tret = page_counter_set_max(counter, max);\n\t\tmutex_unlock(&memcg_max_mutex);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tif (!drained) {\n\t\t\tdrain_all_stock(memcg);\n\t\t\tdrained = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!try_to_free_mem_cgroup_pages(memcg, 1,\n\t\t\t\t\tGFP_KERNEL, !memsw)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t} while (true);\n\n\tif (!ret && enlarge)\n\t\tmemcg_oom_recover(memcg);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_MUTEX(memcg_max_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_oom_recover",
          "args": [
            "memcg"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_oom_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1646-1658",
          "snippet": "static void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);\n\nstatic void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_mem_cgroup_pages",
          "args": [
            "memcg",
            "1",
            "GFP_KERNEL",
            "!memsw"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_mem_cgroup_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3311-3358",
          "snippet": "unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_all_stock",
          "args": [
            "memcg"
          ],
          "line": 2736
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2028-2063",
          "snippet": "static void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define FLUSHING_CACHED_CHARGE\t0"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);",
            "static DEFINE_MUTEX(percpu_charge_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define FLUSHING_CACHED_CHARGE\t0\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\nstatic DEFINE_MUTEX(percpu_charge_mutex);\n\nstatic void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&memcg_max_mutex"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_set_max",
          "args": [
            "counter",
            "max"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "173-203",
          "snippet": "int page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&memcg_max_mutex"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&memcg_max_mutex"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_MUTEX(memcg_max_mutex);\n\nstatic int mem_cgroup_resize_max(struct mem_cgroup *memcg,\n\t\t\t\t unsigned long max, bool memsw)\n{\n\tbool enlarge = false;\n\tbool drained = false;\n\tint ret;\n\tbool limits_invariant;\n\tstruct page_counter *counter = memsw ? &memcg->memsw : &memcg->memory;\n\n\tdo {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&memcg_max_mutex);\n\t\t/*\n\t\t * Make sure that the new limit (memsw or memory limit) doesn't\n\t\t * break our basic invariant rule memory.max <= memsw.max.\n\t\t */\n\t\tlimits_invariant = memsw ? max >= memcg->memory.max :\n\t\t\t\t\t   max <= memcg->memsw.max;\n\t\tif (!limits_invariant) {\n\t\t\tmutex_unlock(&memcg_max_mutex);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (max > counter->max)\n\t\t\tenlarge = true;\n\t\tret = page_counter_set_max(counter, max);\n\t\tmutex_unlock(&memcg_max_mutex);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tif (!drained) {\n\t\t\tdrain_all_stock(memcg);\n\t\t\tdrained = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!try_to_free_mem_cgroup_pages(memcg, 1,\n\t\t\t\t\tGFP_KERNEL, !memsw)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t} while (true);\n\n\tif (!ret && enlarge)\n\t\tmemcg_oom_recover(memcg);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mem_cgroup_move_swap_account",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2691-2695",
    "snippet": "static inline int mem_cgroup_move_swap_account(swp_entry_t entry,\n\t\t\t\tstruct mem_cgroup *from, struct mem_cgroup *to)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic inline int mem_cgroup_move_swap_account(swp_entry_t entry,\n\t\t\t\tstruct mem_cgroup *from, struct mem_cgroup *to)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "mem_cgroup_move_swap_account",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2675-2689",
    "snippet": "static int mem_cgroup_move_swap_account(swp_entry_t entry,\n\t\t\t\tstruct mem_cgroup *from, struct mem_cgroup *to)\n{\n\tunsigned short old_id, new_id;\n\n\told_id = mem_cgroup_id(from);\n\tnew_id = mem_cgroup_id(to);\n\n\tif (swap_cgroup_cmpxchg(entry, old_id, new_id) == old_id) {\n\t\tmod_memcg_state(from, MEMCG_SWAP, -1);\n\t\tmod_memcg_state(to, MEMCG_SWAP, 1);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_memcg_state",
          "args": [
            "to",
            "MEMCG_SWAP",
            "1"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_memcg_state",
          "args": [
            "from",
            "MEMCG_SWAP",
            "-1"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_cgroup_cmpxchg",
          "args": [
            "entry",
            "old_id",
            "new_id"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "swap_cgroup_cmpxchg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "97-115",
          "snippet": "unsigned short swap_cgroup_cmpxchg(swp_entry_t ent,\n\t\t\t\t\tunsigned short old, unsigned short new)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned long flags;\n\tunsigned short retval;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\tretval = sc->id;\n\tif (retval == old)\n\t\tsc->id = new;\n\telse\n\t\tretval = 0;\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nunsigned short swap_cgroup_cmpxchg(swp_entry_t ent,\n\t\t\t\t\tunsigned short old, unsigned short new)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned long flags;\n\tunsigned short retval;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\tretval = sc->id;\n\tif (retval == old)\n\t\tsc->id = new;\n\telse\n\t\tretval = 0;\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id",
          "args": [
            "to"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_get_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6356-6372",
          "snippet": "static struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic int mem_cgroup_move_swap_account(swp_entry_t entry,\n\t\t\t\tstruct mem_cgroup *from, struct mem_cgroup *to)\n{\n\tunsigned short old_id, new_id;\n\n\told_id = mem_cgroup_id(from);\n\tnew_id = mem_cgroup_id(to);\n\n\tif (swap_cgroup_cmpxchg(entry, old_id, new_id) == old_id) {\n\t\tmod_memcg_state(from, MEMCG_SWAP, -1);\n\t\tmod_memcg_state(to, MEMCG_SWAP, 1);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "mem_cgroup_split_huge_fixup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2646-2657",
    "snippet": "void mem_cgroup_split_huge_fixup(struct page *head)\n{\n\tint i;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tfor (i = 1; i < HPAGE_PMD_NR; i++)\n\t\thead[i].mem_cgroup = head->mem_cgroup;\n\n\t__mod_memcg_state(head->mem_cgroup, MEMCG_RSS_HUGE, -HPAGE_PMD_NR);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "head->mem_cgroup",
            "MEMCG_RSS_HUGE",
            "-HPAGE_PMD_NR"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_split_huge_fixup(struct page *head)\n{\n\tint i;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tfor (i = 1; i < HPAGE_PMD_NR; i++)\n\t\thead[i].mem_cgroup = head->mem_cgroup;\n\n\t__mod_memcg_state(head->mem_cgroup, MEMCG_RSS_HUGE, -HPAGE_PMD_NR);\n}"
  },
  {
    "function_name": "memcg_kmem_uncharge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2613-2637",
    "snippet": "void memcg_kmem_uncharge(struct page *page, int order)\n{\n\tstruct mem_cgroup *memcg = page->mem_cgroup;\n\tunsigned int nr_pages = 1 << order;\n\n\tif (!memcg)\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(mem_cgroup_is_root(memcg), page);\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\tpage_counter_uncharge(&memcg->kmem, nr_pages);\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tpage->mem_cgroup = NULL;\n\n\t/* slab pages do not have PageKmemcg flag set */\n\tif (PageKmemcg(page))\n\t\t__ClearPageKmemcg(page);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put_many",
          "args": [
            "&memcg->css",
            "nr_pages"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageKmemcg",
          "args": [
            "page"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKmemcg",
          "args": [
            "page"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_uncharge",
          "args": [
            "&memcg->memsw",
            "nr_pages"
          ],
          "line": 2628
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "155-161",
          "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "mem_cgroup_is_root(memcg)",
            "page"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nvoid memcg_kmem_uncharge(struct page *page, int order)\n{\n\tstruct mem_cgroup *memcg = page->mem_cgroup;\n\tunsigned int nr_pages = 1 << order;\n\n\tif (!memcg)\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(mem_cgroup_is_root(memcg), page);\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\tpage_counter_uncharge(&memcg->kmem, nr_pages);\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tpage->mem_cgroup = NULL;\n\n\t/* slab pages do not have PageKmemcg flag set */\n\tif (PageKmemcg(page))\n\t\t__ClearPageKmemcg(page);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}"
  },
  {
    "function_name": "memcg_kmem_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2591-2607",
    "snippet": "int memcg_kmem_charge(struct page *page, gfp_t gfp, int order)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret = 0;\n\n\tif (mem_cgroup_disabled() || memcg_kmem_bypass())\n\t\treturn 0;\n\n\tmemcg = get_mem_cgroup_from_current();\n\tif (!mem_cgroup_is_root(memcg)) {\n\t\tret = memcg_kmem_charge_memcg(page, gfp, order, memcg);\n\t\tif (!ret)\n\t\t\t__SetPageKmemcg(page);\n\t}\n\tcss_put(&memcg->css);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&memcg->css"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageKmemcg",
          "args": [
            "page"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_kmem_charge_memcg",
          "args": [
            "page",
            "gfp",
            "order",
            "memcg"
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_kmem_charge_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2561-2581",
          "snippet": "int memcg_kmem_charge_memcg(struct page *page, gfp_t gfp, int order,\n\t\t\t    struct mem_cgroup *memcg)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page_counter *counter;\n\tint ret;\n\n\tret = try_charge(memcg, gfp, nr_pages);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) &&\n\t    !page_counter_try_charge(&memcg->kmem, nr_pages, &counter)) {\n\t\tcancel_charge(memcg, nr_pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tpage->mem_cgroup = memcg;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nint memcg_kmem_charge_memcg(struct page *page, gfp_t gfp, int order,\n\t\t\t    struct mem_cgroup *memcg)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page_counter *counter;\n\tint ret;\n\n\tret = try_charge(memcg, gfp, nr_pages);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) &&\n\t    !page_counter_try_charge(&memcg->kmem, nr_pages, &counter)) {\n\t\tcancel_charge(memcg, nr_pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tpage->mem_cgroup = memcg;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mem_cgroup_from_current",
          "args": [],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "get_mem_cgroup_from_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "879-891",
          "snippet": "mem_cgroup *get_mem_cgroup_from_current(void)\n{\n\tif (unlikely(current->active_memcg)) {\n\t\tstruct mem_cgroup *memcg = root_mem_cgroup;\n\n\t\trcu_read_lock();\n\t\tif (css_tryget_online(&current->active_memcg->css))\n\t\t\tmemcg = current->active_memcg;\n\t\trcu_read_unlock();\n\t\treturn memcg;\n\t}\n\treturn get_mem_cgroup_from_mm(current->mm);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nmem_cgroup *get_mem_cgroup_from_current(void)\n{\n\tif (unlikely(current->active_memcg)) {\n\t\tstruct mem_cgroup *memcg = root_mem_cgroup;\n\n\t\trcu_read_lock();\n\t\tif (css_tryget_online(&current->active_memcg->css))\n\t\t\tmemcg = current->active_memcg;\n\t\trcu_read_unlock();\n\t\treturn memcg;\n\t}\n\treturn get_mem_cgroup_from_mm(current->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_kmem_bypass",
          "args": [],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_kmem_bypass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2481-2486",
          "snippet": "static inline bool memcg_kmem_bypass(void)\n{\n\tif (in_interrupt() || !current->mm || (current->flags & PF_KTHREAD))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic inline bool memcg_kmem_bypass(void)\n{\n\tif (in_interrupt() || !current->mm || (current->flags & PF_KTHREAD))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint memcg_kmem_charge(struct page *page, gfp_t gfp, int order)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret = 0;\n\n\tif (mem_cgroup_disabled() || memcg_kmem_bypass())\n\t\treturn 0;\n\n\tmemcg = get_mem_cgroup_from_current();\n\tif (!mem_cgroup_is_root(memcg)) {\n\t\tret = memcg_kmem_charge_memcg(page, gfp, order, memcg);\n\t\tif (!ret)\n\t\t\t__SetPageKmemcg(page);\n\t}\n\tcss_put(&memcg->css);\n\treturn ret;\n}"
  },
  {
    "function_name": "memcg_kmem_charge_memcg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2561-2581",
    "snippet": "int memcg_kmem_charge_memcg(struct page *page, gfp_t gfp, int order,\n\t\t\t    struct mem_cgroup *memcg)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page_counter *counter;\n\tint ret;\n\n\tret = try_charge(memcg, gfp, nr_pages);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) &&\n\t    !page_counter_try_charge(&memcg->kmem, nr_pages, &counter)) {\n\t\tcancel_charge(memcg, nr_pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tpage->mem_cgroup = memcg;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancel_charge",
          "args": [
            "memcg",
            "nr_pages"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2318-2328",
          "snippet": "static void cancel_charge(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn;\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void cancel_charge(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn;\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_try_charge",
          "args": [
            "&memcg->kmem",
            "nr_pages",
            "&counter"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_try_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "99-148",
          "snippet": "bool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nbool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_charge",
          "args": [
            "memcg",
            "gfp",
            "nr_pages"
          ],
          "line": 2568
        },
        "resolved": true,
        "details": {
          "function_name": "try_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2147-2316",
          "snippet": "static int try_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t      unsigned int nr_pages)\n{\n\tunsigned int batch = max(MEMCG_CHARGE_BATCH, nr_pages);\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct page_counter *counter;\n\tunsigned long nr_reclaimed;\n\tbool may_swap = true;\n\tbool drained = false;\n\tbool oomed = false;\n\tenum oom_status oom_status;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\nretry:\n\tif (consume_stock(memcg, nr_pages))\n\t\treturn 0;\n\n\tif (!do_memsw_account() ||\n\t    page_counter_try_charge(&memcg->memsw, batch, &counter)) {\n\t\tif (page_counter_try_charge(&memcg->memory, batch, &counter))\n\t\t\tgoto done_restock;\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&memcg->memsw, batch);\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memory);\n\t} else {\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memsw);\n\t\tmay_swap = false;\n\t}\n\n\tif (batch > nr_pages) {\n\t\tbatch = nr_pages;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Unlike in global OOM situations, memcg is not in a physical\n\t * memory shortage.  Allow dying and OOM-killed tasks to\n\t * bypass the last charges so that they can exit quickly and\n\t * free their memory.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current) ||\n\t\t     fatal_signal_pending(current) ||\n\t\t     current->flags & PF_EXITING))\n\t\tgoto force;\n\n\t/*\n\t * Prevent unbounded recursion when reclaim operations need to\n\t * allocate memory. This might exceed the limits temporarily,\n\t * but we prefer facilitating memory reclaim and getting back\n\t * under the limit over triggering OOM kills in these cases.\n\t */\n\tif (unlikely(current->flags & PF_MEMALLOC))\n\t\tgoto force;\n\n\tif (unlikely(task_in_memcg_oom(current)))\n\t\tgoto nomem;\n\n\tif (!gfpflags_allow_blocking(gfp_mask))\n\t\tgoto nomem;\n\n\tmemcg_memory_event(mem_over_limit, MEMCG_MAX);\n\n\tnr_reclaimed = try_to_free_mem_cgroup_pages(mem_over_limit, nr_pages,\n\t\t\t\t\t\t    gfp_mask, may_swap);\n\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\tgoto retry;\n\n\tif (!drained) {\n\t\tdrain_all_stock(mem_over_limit);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nomem;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_reclaimed && nr_pages <= (1 << PAGE_ALLOC_COSTLY_ORDER))\n\t\tgoto retry;\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\tgoto retry;\n\n\tif (nr_retries--)\n\t\tgoto retry;\n\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL && oomed)\n\t\tgoto nomem;\n\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\tgoto force;\n\n\tif (fatal_signal_pending(current))\n\t\tgoto force;\n\n\t/*\n\t * keep retrying as long as the memcg oom killer is able to make\n\t * a forward progress or bypass the charge if the oom killer\n\t * couldn't make any progress.\n\t */\n\toom_status = mem_cgroup_oom(mem_over_limit, gfp_mask,\n\t\t       get_order(nr_pages * PAGE_SIZE));\n\tswitch (oom_status) {\n\tcase OOM_SUCCESS:\n\t\tnr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\toomed = true;\n\t\tgoto retry;\n\tcase OOM_FAILED:\n\t\tgoto force;\n\tdefault:\n\t\tgoto nomem;\n\t}\nnomem:\n\tif (!(gfp_mask & __GFP_NOFAIL))\n\t\treturn -ENOMEM;\nforce:\n\t/*\n\t * The allocation either can't fail or will lead to more memory\n\t * being freed very soon.  Allow memory usage go over the limit\n\t * temporarily by force charging it.\n\t */\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\treturn 0;\n\ndone_restock:\n\tcss_get_many(&memcg->css, batch);\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\n\t/*\n\t * If the hierarchy is above the normal consumption range, schedule\n\t * reclaim on returning to userland.  We can perform reclaim here\n\t * if __GFP_RECLAIM but let's always punt for simplicity and so that\n\t * GFP_KERNEL can consistently be used during reclaim.  @memcg is\n\t * not recorded as it most likely matches current's and won't\n\t * change in the meantime.  As high limit is checked again before\n\t * reclaim, the cost of mismatch is negligible.\n\t */\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) > memcg->high) {\n\t\t\t/* Don't bother a random interrupted task */\n\t\t\tif (in_interrupt()) {\n\t\t\t\tschedule_work(&memcg->high_work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->memcg_nr_pages_over_high += batch;\n\t\t\tset_notify_resume(current);\n\t\t\tbreak;\n\t\t}\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define MEM_CGROUP_RECLAIM_RETRIES\t5"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MEM_CGROUP_RECLAIM_RETRIES\t5\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int try_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t      unsigned int nr_pages)\n{\n\tunsigned int batch = max(MEMCG_CHARGE_BATCH, nr_pages);\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct page_counter *counter;\n\tunsigned long nr_reclaimed;\n\tbool may_swap = true;\n\tbool drained = false;\n\tbool oomed = false;\n\tenum oom_status oom_status;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\nretry:\n\tif (consume_stock(memcg, nr_pages))\n\t\treturn 0;\n\n\tif (!do_memsw_account() ||\n\t    page_counter_try_charge(&memcg->memsw, batch, &counter)) {\n\t\tif (page_counter_try_charge(&memcg->memory, batch, &counter))\n\t\t\tgoto done_restock;\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&memcg->memsw, batch);\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memory);\n\t} else {\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memsw);\n\t\tmay_swap = false;\n\t}\n\n\tif (batch > nr_pages) {\n\t\tbatch = nr_pages;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Unlike in global OOM situations, memcg is not in a physical\n\t * memory shortage.  Allow dying and OOM-killed tasks to\n\t * bypass the last charges so that they can exit quickly and\n\t * free their memory.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current) ||\n\t\t     fatal_signal_pending(current) ||\n\t\t     current->flags & PF_EXITING))\n\t\tgoto force;\n\n\t/*\n\t * Prevent unbounded recursion when reclaim operations need to\n\t * allocate memory. This might exceed the limits temporarily,\n\t * but we prefer facilitating memory reclaim and getting back\n\t * under the limit over triggering OOM kills in these cases.\n\t */\n\tif (unlikely(current->flags & PF_MEMALLOC))\n\t\tgoto force;\n\n\tif (unlikely(task_in_memcg_oom(current)))\n\t\tgoto nomem;\n\n\tif (!gfpflags_allow_blocking(gfp_mask))\n\t\tgoto nomem;\n\n\tmemcg_memory_event(mem_over_limit, MEMCG_MAX);\n\n\tnr_reclaimed = try_to_free_mem_cgroup_pages(mem_over_limit, nr_pages,\n\t\t\t\t\t\t    gfp_mask, may_swap);\n\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\tgoto retry;\n\n\tif (!drained) {\n\t\tdrain_all_stock(mem_over_limit);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nomem;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_reclaimed && nr_pages <= (1 << PAGE_ALLOC_COSTLY_ORDER))\n\t\tgoto retry;\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\tgoto retry;\n\n\tif (nr_retries--)\n\t\tgoto retry;\n\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL && oomed)\n\t\tgoto nomem;\n\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\tgoto force;\n\n\tif (fatal_signal_pending(current))\n\t\tgoto force;\n\n\t/*\n\t * keep retrying as long as the memcg oom killer is able to make\n\t * a forward progress or bypass the charge if the oom killer\n\t * couldn't make any progress.\n\t */\n\toom_status = mem_cgroup_oom(mem_over_limit, gfp_mask,\n\t\t       get_order(nr_pages * PAGE_SIZE));\n\tswitch (oom_status) {\n\tcase OOM_SUCCESS:\n\t\tnr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\toomed = true;\n\t\tgoto retry;\n\tcase OOM_FAILED:\n\t\tgoto force;\n\tdefault:\n\t\tgoto nomem;\n\t}\nnomem:\n\tif (!(gfp_mask & __GFP_NOFAIL))\n\t\treturn -ENOMEM;\nforce:\n\t/*\n\t * The allocation either can't fail or will lead to more memory\n\t * being freed very soon.  Allow memory usage go over the limit\n\t * temporarily by force charging it.\n\t */\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\treturn 0;\n\ndone_restock:\n\tcss_get_many(&memcg->css, batch);\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\n\t/*\n\t * If the hierarchy is above the normal consumption range, schedule\n\t * reclaim on returning to userland.  We can perform reclaim here\n\t * if __GFP_RECLAIM but let's always punt for simplicity and so that\n\t * GFP_KERNEL can consistently be used during reclaim.  @memcg is\n\t * not recorded as it most likely matches current's and won't\n\t * change in the meantime.  As high limit is checked again before\n\t * reclaim, the cost of mismatch is negligible.\n\t */\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) > memcg->high) {\n\t\t\t/* Don't bother a random interrupted task */\n\t\t\tif (in_interrupt()) {\n\t\t\t\tschedule_work(&memcg->high_work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->memcg_nr_pages_over_high += batch;\n\t\t\tset_notify_resume(current);\n\t\t\tbreak;\n\t\t}\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nint memcg_kmem_charge_memcg(struct page *page, gfp_t gfp, int order,\n\t\t\t    struct mem_cgroup *memcg)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page_counter *counter;\n\tint ret;\n\n\tret = try_charge(memcg, gfp, nr_pages);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) &&\n\t    !page_counter_try_charge(&memcg->kmem, nr_pages, &counter)) {\n\t\tcancel_charge(memcg, nr_pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tpage->mem_cgroup = memcg;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_kmem_put_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2546-2550",
    "snippet": "void memcg_kmem_put_cache(struct kmem_cache *cachep)\n{\n\tif (!is_root_cache(cachep))\n\t\tcss_put(&cachep->memcg_params.memcg->css);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&cachep->memcg_params.memcg->css"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "cachep"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid memcg_kmem_put_cache(struct kmem_cache *cachep)\n{\n\tif (!is_root_cache(cachep))\n\t\tcss_put(&cachep->memcg_params.memcg->css);\n}"
  },
  {
    "function_name": "memcg_kmem_get_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2504-2540",
    "snippet": "struct kmem_cache *memcg_kmem_get_cache(struct kmem_cache *cachep)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct kmem_cache *memcg_cachep;\n\tint kmemcg_id;\n\n\tVM_BUG_ON(!is_root_cache(cachep));\n\n\tif (memcg_kmem_bypass())\n\t\treturn cachep;\n\n\tmemcg = get_mem_cgroup_from_current();\n\tkmemcg_id = READ_ONCE(memcg->kmemcg_id);\n\tif (kmemcg_id < 0)\n\t\tgoto out;\n\n\tmemcg_cachep = cache_from_memcg_idx(cachep, kmemcg_id);\n\tif (likely(memcg_cachep))\n\t\treturn memcg_cachep;\n\n\t/*\n\t * If we are in a safe context (can wait, and not in interrupt\n\t * context), we could be be predictable and return right away.\n\t * This would guarantee that the allocation being performed\n\t * already belongs in the new cache.\n\t *\n\t * However, there are some clashes that can arrive from locking.\n\t * For instance, because we acquire the slab_mutex while doing\n\t * memcg_create_kmem_cache, this means no further allocation\n\t * could happen with the slab_mutex held. So it's better to\n\t * defer everything.\n\t */\n\tmemcg_schedule_kmem_cache_create(memcg, cachep);\nout:\n\tcss_put(&memcg->css);\n\treturn cachep;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&memcg->css"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_schedule_kmem_cache_create",
          "args": [
            "memcg",
            "cachep"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_schedule_kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2463-2479",
          "snippet": "static void memcg_schedule_kmem_cache_create(struct mem_cgroup *memcg,\n\t\t\t\t\t       struct kmem_cache *cachep)\n{\n\tstruct memcg_kmem_cache_create_work *cw;\n\n\tcw = kmalloc(sizeof(*cw), GFP_NOWAIT | __GFP_NOWARN);\n\tif (!cw)\n\t\treturn;\n\n\tcss_get(&memcg->css);\n\n\tcw->memcg = memcg;\n\tcw->cachep = cachep;\n\tINIT_WORK(&cw->work, memcg_kmem_cache_create_func);\n\n\tqueue_work(memcg_kmem_cache_wq, &cw->work);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_schedule_kmem_cache_create(struct mem_cgroup *memcg,\n\t\t\t\t\t       struct kmem_cache *cachep)\n{\n\tstruct memcg_kmem_cache_create_work *cw;\n\n\tcw = kmalloc(sizeof(*cw), GFP_NOWAIT | __GFP_NOWARN);\n\tif (!cw)\n\t\treturn;\n\n\tcss_get(&memcg->css);\n\n\tcw->memcg = memcg;\n\tcw->cachep = cachep;\n\tINIT_WORK(&cw->work, memcg_kmem_cache_create_func);\n\n\tqueue_work(memcg_kmem_cache_wq, &cw->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "memcg_cachep"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_from_memcg_idx",
          "args": [
            "cachep",
            "kmemcg_id"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "cache_from_memcg_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "324-328",
          "snippet": "static inline struct kmem_cache *\ncache_from_memcg_idx(struct kmem_cache *s, int idx)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *\ncache_from_memcg_idx(struct kmem_cache *s, int idx)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "memcg->kmemcg_id"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mem_cgroup_from_current",
          "args": [],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "get_mem_cgroup_from_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "879-891",
          "snippet": "mem_cgroup *get_mem_cgroup_from_current(void)\n{\n\tif (unlikely(current->active_memcg)) {\n\t\tstruct mem_cgroup *memcg = root_mem_cgroup;\n\n\t\trcu_read_lock();\n\t\tif (css_tryget_online(&current->active_memcg->css))\n\t\t\tmemcg = current->active_memcg;\n\t\trcu_read_unlock();\n\t\treturn memcg;\n\t}\n\treturn get_mem_cgroup_from_mm(current->mm);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nmem_cgroup *get_mem_cgroup_from_current(void)\n{\n\tif (unlikely(current->active_memcg)) {\n\t\tstruct mem_cgroup *memcg = root_mem_cgroup;\n\n\t\trcu_read_lock();\n\t\tif (css_tryget_online(&current->active_memcg->css))\n\t\t\tmemcg = current->active_memcg;\n\t\trcu_read_unlock();\n\t\treturn memcg;\n\t}\n\treturn get_mem_cgroup_from_mm(current->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_kmem_bypass",
          "args": [],
          "line": 2512
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_kmem_bypass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2481-2486",
          "snippet": "static inline bool memcg_kmem_bypass(void)\n{\n\tif (in_interrupt() || !current->mm || (current->flags & PF_KTHREAD))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic inline bool memcg_kmem_bypass(void)\n{\n\tif (in_interrupt() || !current->mm || (current->flags & PF_KTHREAD))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_root_cache(cachep)"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "cachep"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct kmem_cache *memcg_kmem_get_cache(struct kmem_cache *cachep)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct kmem_cache *memcg_cachep;\n\tint kmemcg_id;\n\n\tVM_BUG_ON(!is_root_cache(cachep));\n\n\tif (memcg_kmem_bypass())\n\t\treturn cachep;\n\n\tmemcg = get_mem_cgroup_from_current();\n\tkmemcg_id = READ_ONCE(memcg->kmemcg_id);\n\tif (kmemcg_id < 0)\n\t\tgoto out;\n\n\tmemcg_cachep = cache_from_memcg_idx(cachep, kmemcg_id);\n\tif (likely(memcg_cachep))\n\t\treturn memcg_cachep;\n\n\t/*\n\t * If we are in a safe context (can wait, and not in interrupt\n\t * context), we could be be predictable and return right away.\n\t * This would guarantee that the allocation being performed\n\t * already belongs in the new cache.\n\t *\n\t * However, there are some clashes that can arrive from locking.\n\t * For instance, because we acquire the slab_mutex while doing\n\t * memcg_create_kmem_cache, this means no further allocation\n\t * could happen with the slab_mutex held. So it's better to\n\t * defer everything.\n\t */\n\tmemcg_schedule_kmem_cache_create(memcg, cachep);\nout:\n\tcss_put(&memcg->css);\n\treturn cachep;\n}"
  },
  {
    "function_name": "memcg_kmem_bypass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2481-2486",
    "snippet": "static inline bool memcg_kmem_bypass(void)\n{\n\tif (in_interrupt() || !current->mm || (current->flags & PF_KTHREAD))\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic inline bool memcg_kmem_bypass(void)\n{\n\tif (in_interrupt() || !current->mm || (current->flags & PF_KTHREAD))\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "memcg_schedule_kmem_cache_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2463-2479",
    "snippet": "static void memcg_schedule_kmem_cache_create(struct mem_cgroup *memcg,\n\t\t\t\t\t       struct kmem_cache *cachep)\n{\n\tstruct memcg_kmem_cache_create_work *cw;\n\n\tcw = kmalloc(sizeof(*cw), GFP_NOWAIT | __GFP_NOWARN);\n\tif (!cw)\n\t\treturn;\n\n\tcss_get(&memcg->css);\n\n\tcw->memcg = memcg;\n\tcw->cachep = cachep;\n\tINIT_WORK(&cw->work, memcg_kmem_cache_create_func);\n\n\tqueue_work(memcg_kmem_cache_wq, &cw->work);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "memcg_kmem_cache_wq",
            "&cw->work"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&cw->work",
            "memcg_kmem_cache_create_func"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "&memcg->css"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*cw)",
            "GFP_NOWAIT | __GFP_NOWARN"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_schedule_kmem_cache_create(struct mem_cgroup *memcg,\n\t\t\t\t\t       struct kmem_cache *cachep)\n{\n\tstruct memcg_kmem_cache_create_work *cw;\n\n\tcw = kmalloc(sizeof(*cw), GFP_NOWAIT | __GFP_NOWARN);\n\tif (!cw)\n\t\treturn;\n\n\tcss_get(&memcg->css);\n\n\tcw->memcg = memcg;\n\tcw->cachep = cachep;\n\tINIT_WORK(&cw->work, memcg_kmem_cache_create_func);\n\n\tqueue_work(memcg_kmem_cache_wq, &cw->work);\n}"
  },
  {
    "function_name": "memcg_kmem_cache_create_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2447-2458",
    "snippet": "static void memcg_kmem_cache_create_func(struct work_struct *w)\n{\n\tstruct memcg_kmem_cache_create_work *cw =\n\t\tcontainer_of(w, struct memcg_kmem_cache_create_work, work);\n\tstruct mem_cgroup *memcg = cw->memcg;\n\tstruct kmem_cache *cachep = cw->cachep;\n\n\tmemcg_create_kmem_cache(memcg, cachep);\n\n\tcss_put(&memcg->css);\n\tkfree(cw);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cw"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&memcg->css"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_create_kmem_cache",
          "args": [
            "memcg",
            "cachep"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_create_kmem_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "597-665",
          "snippet": "void memcg_create_kmem_cache(struct mem_cgroup *memcg,\n\t\t\t     struct kmem_cache *root_cache)\n{\n\tstatic char memcg_name_buf[NAME_MAX + 1]; /* protected by slab_mutex */\n\tstruct cgroup_subsys_state *css = &memcg->css;\n\tstruct memcg_cache_array *arr;\n\tstruct kmem_cache *s = NULL;\n\tchar *cache_name;\n\tint idx;\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\t/*\n\t * The memory cgroup could have been offlined while the cache\n\t * creation work was pending.\n\t */\n\tif (memcg->kmem_state != KMEM_ONLINE || root_cache->memcg_params.dying)\n\t\tgoto out_unlock;\n\n\tidx = memcg_cache_id(memcg);\n\tarr = rcu_dereference_protected(root_cache->memcg_params.memcg_caches,\n\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\n\t/*\n\t * Since per-memcg caches are created asynchronously on first\n\t * allocation (see memcg_kmem_get_cache()), several threads can try to\n\t * create the same cache, but only one of them may succeed.\n\t */\n\tif (arr->entries[idx])\n\t\tgoto out_unlock;\n\n\tcgroup_name(css->cgroup, memcg_name_buf, sizeof(memcg_name_buf));\n\tcache_name = kasprintf(GFP_KERNEL, \"%s(%llu:%s)\", root_cache->name,\n\t\t\t       css->serial_nr, memcg_name_buf);\n\tif (!cache_name)\n\t\tgoto out_unlock;\n\n\ts = create_cache(cache_name, root_cache->object_size,\n\t\t\t root_cache->align,\n\t\t\t root_cache->flags & CACHE_CREATE_MASK,\n\t\t\t root_cache->useroffset, root_cache->usersize,\n\t\t\t root_cache->ctor, memcg, root_cache);\n\t/*\n\t * If we could not create a memcg cache, do not complain, because\n\t * that's not critical at all as we can always proceed with the root\n\t * cache.\n\t */\n\tif (IS_ERR(s)) {\n\t\tkfree(cache_name);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Since readers won't lock (see cache_from_memcg_idx()), we need a\n\t * barrier here to ensure nobody will see the kmem_cache partially\n\t * initialized.\n\t */\n\tsmp_wmb();\n\tarr->entries[idx] = s;\n\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;",
            "static void slab_caches_to_rcu_destroy_workfn(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\nstatic void slab_caches_to_rcu_destroy_workfn(struct work_struct *work);\n\nvoid memcg_create_kmem_cache(struct mem_cgroup *memcg,\n\t\t\t     struct kmem_cache *root_cache)\n{\n\tstatic char memcg_name_buf[NAME_MAX + 1]; /* protected by slab_mutex */\n\tstruct cgroup_subsys_state *css = &memcg->css;\n\tstruct memcg_cache_array *arr;\n\tstruct kmem_cache *s = NULL;\n\tchar *cache_name;\n\tint idx;\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\t/*\n\t * The memory cgroup could have been offlined while the cache\n\t * creation work was pending.\n\t */\n\tif (memcg->kmem_state != KMEM_ONLINE || root_cache->memcg_params.dying)\n\t\tgoto out_unlock;\n\n\tidx = memcg_cache_id(memcg);\n\tarr = rcu_dereference_protected(root_cache->memcg_params.memcg_caches,\n\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\n\t/*\n\t * Since per-memcg caches are created asynchronously on first\n\t * allocation (see memcg_kmem_get_cache()), several threads can try to\n\t * create the same cache, but only one of them may succeed.\n\t */\n\tif (arr->entries[idx])\n\t\tgoto out_unlock;\n\n\tcgroup_name(css->cgroup, memcg_name_buf, sizeof(memcg_name_buf));\n\tcache_name = kasprintf(GFP_KERNEL, \"%s(%llu:%s)\", root_cache->name,\n\t\t\t       css->serial_nr, memcg_name_buf);\n\tif (!cache_name)\n\t\tgoto out_unlock;\n\n\ts = create_cache(cache_name, root_cache->object_size,\n\t\t\t root_cache->align,\n\t\t\t root_cache->flags & CACHE_CREATE_MASK,\n\t\t\t root_cache->useroffset, root_cache->usersize,\n\t\t\t root_cache->ctor, memcg, root_cache);\n\t/*\n\t * If we could not create a memcg cache, do not complain, because\n\t * that's not critical at all as we can always proceed with the root\n\t * cache.\n\t */\n\tif (IS_ERR(s)) {\n\t\tkfree(cache_name);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Since readers won't lock (see cache_from_memcg_idx()), we need a\n\t * barrier here to ensure nobody will see the kmem_cache partially\n\t * initialized.\n\t */\n\tsmp_wmb();\n\tarr->entries[idx] = s;\n\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "w",
            "structmemcg_kmem_cache_create_work",
            "work"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_kmem_cache_create_func(struct work_struct *w)\n{\n\tstruct memcg_kmem_cache_create_work *cw =\n\t\tcontainer_of(w, struct memcg_kmem_cache_create_work, work);\n\tstruct mem_cgroup *memcg = cw->memcg;\n\tstruct kmem_cache *cachep = cw->cachep;\n\n\tmemcg_create_kmem_cache(memcg, cachep);\n\n\tcss_put(&memcg->css);\n\tkfree(cw);\n}"
  },
  {
    "function_name": "memcg_free_cache_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2436-2439",
    "snippet": "static void memcg_free_cache_id(int id)\n{\n\tida_simple_remove(&memcg_cache_ida, id);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ida_simple_remove",
          "args": [
            "&memcg_cache_ida",
            "id"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void memcg_free_cache_id(int id)\n{\n\tida_simple_remove(&memcg_cache_ida, id);\n}"
  },
  {
    "function_name": "memcg_alloc_cache_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2396-2434",
    "snippet": "static int memcg_alloc_cache_id(void)\n{\n\tint id, size;\n\tint err;\n\n\tid = ida_simple_get(&memcg_cache_ida,\n\t\t\t    0, MEMCG_CACHES_MAX_SIZE, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\tif (id < memcg_nr_cache_ids)\n\t\treturn id;\n\n\t/*\n\t * There's no space for the new id in memcg_caches arrays,\n\t * so we have to grow them.\n\t */\n\tdown_write(&memcg_cache_ids_sem);\n\n\tsize = 2 * (id + 1);\n\tif (size < MEMCG_CACHES_MIN_SIZE)\n\t\tsize = MEMCG_CACHES_MIN_SIZE;\n\telse if (size > MEMCG_CACHES_MAX_SIZE)\n\t\tsize = MEMCG_CACHES_MAX_SIZE;\n\n\terr = memcg_update_all_caches(size);\n\tif (!err)\n\t\terr = memcg_update_all_list_lrus(size);\n\tif (!err)\n\t\tmemcg_nr_cache_ids = size;\n\n\tup_write(&memcg_cache_ids_sem);\n\n\tif (err) {\n\t\tida_simple_remove(&memcg_cache_ida, id);\n\t\treturn err;\n\t}\n\treturn id;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define MEMCG_CACHES_MAX_SIZE MEM_CGROUP_ID_MAX",
      "#define MEMCG_CACHES_MIN_SIZE 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ida_simple_remove",
          "args": [
            "&memcg_cache_ida",
            "id"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&memcg_cache_ids_sem"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_update_all_list_lrus",
          "args": [
            "size"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_update_all_list_lrus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "520-539",
          "snippet": "int memcg_update_all_list_lrus(int new_size)\n{\n\tint ret = 0;\n\tstruct list_lru *lru;\n\tint old_size = memcg_nr_cache_ids;\n\n\tmutex_lock(&list_lrus_mutex);\n\tlist_for_each_entry(lru, &list_lrus, list) {\n\t\tret = memcg_update_list_lru(lru, old_size, new_size);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\nout:\n\tmutex_unlock(&list_lrus_mutex);\n\treturn ret;\nfail:\n\tlist_for_each_entry_continue_reverse(lru, &list_lrus, list)\n\t\tmemcg_cancel_update_list_lru(lru, old_size, new_size);\n\tgoto out;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint memcg_update_all_list_lrus(int new_size)\n{\n\tint ret = 0;\n\tstruct list_lru *lru;\n\tint old_size = memcg_nr_cache_ids;\n\n\tmutex_lock(&list_lrus_mutex);\n\tlist_for_each_entry(lru, &list_lrus, list) {\n\t\tret = memcg_update_list_lru(lru, old_size, new_size);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\nout:\n\tmutex_unlock(&list_lrus_mutex);\n\treturn ret;\nfail:\n\tlist_for_each_entry_continue_reverse(lru, &list_lrus, list)\n\t\tmemcg_cancel_update_list_lru(lru, old_size, new_size);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_update_all_caches",
          "args": [
            "size"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_update_all_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "205-222",
          "snippet": "int memcg_update_all_caches(int num_memcgs)\n{\n\tstruct kmem_cache *s;\n\tint ret = 0;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_root_caches, root_caches_node) {\n\t\tret = update_memcg_params(s, num_memcgs);\n\t\t/*\n\t\t * Instead of freeing the memory, we'll just leave the caches\n\t\t * up to this point in an updated state.\n\t\t */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&slab_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nint memcg_update_all_caches(int num_memcgs)\n{\n\tstruct kmem_cache *s;\n\tint ret = 0;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_root_caches, root_caches_node) {\n\t\tret = update_memcg_params(s, num_memcgs);\n\t\t/*\n\t\t * Instead of freeing the memory, we'll just leave the caches\n\t\t * up to this point in an updated state.\n\t\t */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&slab_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&memcg_cache_ids_sem"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_simple_get",
          "args": [
            "&memcg_cache_ida",
            "0",
            "MEMCG_CACHES_MAX_SIZE",
            "GFP_KERNEL"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MEMCG_CACHES_MAX_SIZE MEM_CGROUP_ID_MAX\n#define MEMCG_CACHES_MIN_SIZE 4\n\nstatic int memcg_alloc_cache_id(void)\n{\n\tint id, size;\n\tint err;\n\n\tid = ida_simple_get(&memcg_cache_ida,\n\t\t\t    0, MEMCG_CACHES_MAX_SIZE, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\tif (id < memcg_nr_cache_ids)\n\t\treturn id;\n\n\t/*\n\t * There's no space for the new id in memcg_caches arrays,\n\t * so we have to grow them.\n\t */\n\tdown_write(&memcg_cache_ids_sem);\n\n\tsize = 2 * (id + 1);\n\tif (size < MEMCG_CACHES_MIN_SIZE)\n\t\tsize = MEMCG_CACHES_MIN_SIZE;\n\telse if (size > MEMCG_CACHES_MAX_SIZE)\n\t\tsize = MEMCG_CACHES_MAX_SIZE;\n\n\terr = memcg_update_all_caches(size);\n\tif (!err)\n\t\terr = memcg_update_all_list_lrus(size);\n\tif (!err)\n\t\tmemcg_nr_cache_ids = size;\n\n\tup_write(&memcg_cache_ids_sem);\n\n\tif (err) {\n\t\tida_simple_remove(&memcg_cache_ida, id);\n\t\treturn err;\n\t}\n\treturn id;\n}"
  },
  {
    "function_name": "commit_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2361-2393",
    "snippet": "static void commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t  bool lrucare)\n{\n\tint isolated;\n\n\tVM_BUG_ON_PAGE(page->mem_cgroup, page);\n\n\t/*\n\t * In some cases, SwapCache and FUSE(splice_buf->radixtree), the page\n\t * may already be on some other mem_cgroup's LRU.  Take care of it.\n\t */\n\tif (lrucare)\n\t\tlock_page_lru(page, &isolated);\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point:\n\t *\n\t * - the page is uncharged\n\t *\n\t * - the page is off-LRU\n\t *\n\t * - an anonymous fault has exclusive page access, except for\n\t *   a locked page table\n\t *\n\t * - a page cache insertion, a swapin fault, or a migration\n\t *   have the page locked\n\t */\n\tpage->mem_cgroup = memcg;\n\n\tif (lrucare)\n\t\tunlock_page_lru(page, isolated);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page_lru",
          "args": [
            "page",
            "isolated"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2346-2359",
          "snippet": "static void unlock_page_lru(struct page *page, int isolated)\n{\n\tstruct zone *zone = page_zone(page);\n\n\tif (isolated) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tSetPageLRU(page);\n\t\tadd_page_to_lru_list(page, lruvec, page_lru(page));\n\t}\n\tspin_unlock_irq(zone_lru_lock(zone));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void unlock_page_lru(struct page *page, int isolated)\n{\n\tstruct zone *zone = page_zone(page);\n\n\tif (isolated) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tSetPageLRU(page);\n\t\tadd_page_to_lru_list(page, lruvec, page_lru(page));\n\t}\n\tspin_unlock_irq(zone_lru_lock(zone));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page->mem_cgroup",
            "page"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t  bool lrucare)\n{\n\tint isolated;\n\n\tVM_BUG_ON_PAGE(page->mem_cgroup, page);\n\n\t/*\n\t * In some cases, SwapCache and FUSE(splice_buf->radixtree), the page\n\t * may already be on some other mem_cgroup's LRU.  Take care of it.\n\t */\n\tif (lrucare)\n\t\tlock_page_lru(page, &isolated);\n\n\t/*\n\t * Nobody should be changing or seriously looking at\n\t * page->mem_cgroup at this point:\n\t *\n\t * - the page is uncharged\n\t *\n\t * - the page is off-LRU\n\t *\n\t * - an anonymous fault has exclusive page access, except for\n\t *   a locked page table\n\t *\n\t * - a page cache insertion, a swapin fault, or a migration\n\t *   have the page locked\n\t */\n\tpage->mem_cgroup = memcg;\n\n\tif (lrucare)\n\t\tunlock_page_lru(page, isolated);\n}"
  },
  {
    "function_name": "unlock_page_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2346-2359",
    "snippet": "static void unlock_page_lru(struct page *page, int isolated)\n{\n\tstruct zone *zone = page_zone(page);\n\n\tif (isolated) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tSetPageLRU(page);\n\t\tadd_page_to_lru_list(page, lruvec, page_lru(page));\n\t}\n\tspin_unlock_irq(zone_lru_lock(zone));\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_page_to_lru_list",
          "args": [
            "page",
            "lruvec",
            "page_lru(page)"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru",
          "args": [
            "page"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageLRU",
          "args": [
            "page"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "zone->zone_pgdat"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void unlock_page_lru(struct page *page, int isolated)\n{\n\tstruct zone *zone = page_zone(page);\n\n\tif (isolated) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tSetPageLRU(page);\n\t\tadd_page_to_lru_list(page, lruvec, page_lru(page));\n\t}\n\tspin_unlock_irq(zone_lru_lock(zone));\n}"
  },
  {
    "function_name": "lock_page_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2330-2344",
    "snippet": "static void lock_page_lru(struct page *page, int *isolated)\n{\n\tstruct zone *zone = page_zone(page);\n\n\tspin_lock_irq(zone_lru_lock(zone));\n\tif (PageLRU(page)) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\t*isolated = 1;\n\t} else\n\t\t*isolated = 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "page_lru(page)"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru",
          "args": [
            "page"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageLRU",
          "args": [
            "page"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "zone->zone_pgdat"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void lock_page_lru(struct page *page, int *isolated)\n{\n\tstruct zone *zone = page_zone(page);\n\n\tspin_lock_irq(zone_lru_lock(zone));\n\tif (PageLRU(page)) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\t*isolated = 1;\n\t} else\n\t\t*isolated = 0;\n}"
  },
  {
    "function_name": "cancel_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2318-2328",
    "snippet": "static void cancel_charge(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn;\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put_many",
          "args": [
            "&memcg->css",
            "nr_pages"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_uncharge",
          "args": [
            "&memcg->memsw",
            "nr_pages"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "155-161",
          "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void cancel_charge(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn;\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}"
  },
  {
    "function_name": "try_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2147-2316",
    "snippet": "static int try_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t      unsigned int nr_pages)\n{\n\tunsigned int batch = max(MEMCG_CHARGE_BATCH, nr_pages);\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct page_counter *counter;\n\tunsigned long nr_reclaimed;\n\tbool may_swap = true;\n\tbool drained = false;\n\tbool oomed = false;\n\tenum oom_status oom_status;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\nretry:\n\tif (consume_stock(memcg, nr_pages))\n\t\treturn 0;\n\n\tif (!do_memsw_account() ||\n\t    page_counter_try_charge(&memcg->memsw, batch, &counter)) {\n\t\tif (page_counter_try_charge(&memcg->memory, batch, &counter))\n\t\t\tgoto done_restock;\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&memcg->memsw, batch);\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memory);\n\t} else {\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memsw);\n\t\tmay_swap = false;\n\t}\n\n\tif (batch > nr_pages) {\n\t\tbatch = nr_pages;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Unlike in global OOM situations, memcg is not in a physical\n\t * memory shortage.  Allow dying and OOM-killed tasks to\n\t * bypass the last charges so that they can exit quickly and\n\t * free their memory.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current) ||\n\t\t     fatal_signal_pending(current) ||\n\t\t     current->flags & PF_EXITING))\n\t\tgoto force;\n\n\t/*\n\t * Prevent unbounded recursion when reclaim operations need to\n\t * allocate memory. This might exceed the limits temporarily,\n\t * but we prefer facilitating memory reclaim and getting back\n\t * under the limit over triggering OOM kills in these cases.\n\t */\n\tif (unlikely(current->flags & PF_MEMALLOC))\n\t\tgoto force;\n\n\tif (unlikely(task_in_memcg_oom(current)))\n\t\tgoto nomem;\n\n\tif (!gfpflags_allow_blocking(gfp_mask))\n\t\tgoto nomem;\n\n\tmemcg_memory_event(mem_over_limit, MEMCG_MAX);\n\n\tnr_reclaimed = try_to_free_mem_cgroup_pages(mem_over_limit, nr_pages,\n\t\t\t\t\t\t    gfp_mask, may_swap);\n\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\tgoto retry;\n\n\tif (!drained) {\n\t\tdrain_all_stock(mem_over_limit);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nomem;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_reclaimed && nr_pages <= (1 << PAGE_ALLOC_COSTLY_ORDER))\n\t\tgoto retry;\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\tgoto retry;\n\n\tif (nr_retries--)\n\t\tgoto retry;\n\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL && oomed)\n\t\tgoto nomem;\n\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\tgoto force;\n\n\tif (fatal_signal_pending(current))\n\t\tgoto force;\n\n\t/*\n\t * keep retrying as long as the memcg oom killer is able to make\n\t * a forward progress or bypass the charge if the oom killer\n\t * couldn't make any progress.\n\t */\n\toom_status = mem_cgroup_oom(mem_over_limit, gfp_mask,\n\t\t       get_order(nr_pages * PAGE_SIZE));\n\tswitch (oom_status) {\n\tcase OOM_SUCCESS:\n\t\tnr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\toomed = true;\n\t\tgoto retry;\n\tcase OOM_FAILED:\n\t\tgoto force;\n\tdefault:\n\t\tgoto nomem;\n\t}\nnomem:\n\tif (!(gfp_mask & __GFP_NOFAIL))\n\t\treturn -ENOMEM;\nforce:\n\t/*\n\t * The allocation either can't fail or will lead to more memory\n\t * being freed very soon.  Allow memory usage go over the limit\n\t * temporarily by force charging it.\n\t */\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\treturn 0;\n\ndone_restock:\n\tcss_get_many(&memcg->css, batch);\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\n\t/*\n\t * If the hierarchy is above the normal consumption range, schedule\n\t * reclaim on returning to userland.  We can perform reclaim here\n\t * if __GFP_RECLAIM but let's always punt for simplicity and so that\n\t * GFP_KERNEL can consistently be used during reclaim.  @memcg is\n\t * not recorded as it most likely matches current's and won't\n\t * change in the meantime.  As high limit is checked again before\n\t * reclaim, the cost of mismatch is negligible.\n\t */\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) > memcg->high) {\n\t\t\t/* Don't bother a random interrupted task */\n\t\t\tif (in_interrupt()) {\n\t\t\t\tschedule_work(&memcg->high_work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->memcg_nr_pages_over_high += batch;\n\t\t\tset_notify_resume(current);\n\t\t\tbreak;\n\t\t}\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define MEM_CGROUP_RECLAIM_RETRIES\t5"
    ],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_notify_resume",
          "args": [
            "current"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&memcg->high_work"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refill_stock",
          "args": [
            "memcg",
            "batch - nr_pages"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "refill_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2004-2022",
          "snippet": "static void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tif (stock->cached != memcg) { /* reset if necessary */\n\t\tdrain_stock(stock);\n\t\tstock->cached = memcg;\n\t}\n\tstock->nr_pages += nr_pages;\n\n\tif (stock->nr_pages > MEMCG_CHARGE_BATCH)\n\t\tdrain_stock(stock);\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\n\nstatic void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tif (stock->cached != memcg) { /* reset if necessary */\n\t\tdrain_stock(stock);\n\t\tstock->cached = memcg;\n\t}\n\tstock->nr_pages += nr_pages;\n\n\tif (stock->nr_pages > MEMCG_CHARGE_BATCH)\n\t\tdrain_stock(stock);\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_get_many",
          "args": [
            "&memcg->css",
            "batch"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get_many",
          "args": [
            "&memcg->css",
            "nr_pages"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_charge",
          "args": [
            "&memcg->memsw",
            "nr_pages"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "72-88",
          "snippet": "void page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_oom",
          "args": [
            "mem_over_limit",
            "gfp_mask",
            "get_order(nr_pages * PAGE_SIZE)"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_oom_control_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3810-3824",
          "snippet": "static int mem_cgroup_oom_control_write(struct cgroup_subsys_state *css,\n\tstruct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\t/* cannot set to root cgroup and only 0 and 1 are allowed */\n\tif (!css->parent || !((val == 0) || (val == 1)))\n\t\treturn -EINVAL;\n\n\tmemcg->oom_kill_disable = val;\n\tif (!val)\n\t\tmemcg_oom_recover(memcg);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int mem_cgroup_oom_control_write(struct cgroup_subsys_state *css,\n\tstruct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\t/* cannot set to root cgroup and only 0 and 1 are allowed */\n\tif (!css->parent || !((val == 0) || (val == 1)))\n\t\treturn -EINVAL;\n\n\tmemcg->oom_kill_disable = val;\n\tif (!val)\n\t\tmemcg_oom_recover(memcg);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "nr_pages * PAGE_SIZE"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_wait_acct_move",
          "args": [
            "mem_over_limit"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_wait_acct_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1256-1270",
          "snippet": "static bool mem_cgroup_wait_acct_move(struct mem_cgroup *memcg)\n{\n\tif (mc.moving_task && current != mc.moving_task) {\n\t\tif (mem_cgroup_under_move(memcg)) {\n\t\t\tDEFINE_WAIT(wait);\n\t\t\tprepare_to_wait(&mc.waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t\t/* moving charge context might have finished. */\n\t\t\tif (mc.moving_task)\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&mc.waitq, &wait);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic bool mem_cgroup_wait_acct_move(struct mem_cgroup *memcg)\n{\n\tif (mc.moving_task && current != mc.moving_task) {\n\t\tif (mem_cgroup_under_move(memcg)) {\n\t\t\tDEFINE_WAIT(wait);\n\t\t\tprepare_to_wait(&mc.waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t\t/* moving charge context might have finished. */\n\t\t\tif (mc.moving_task)\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&mc.waitq, &wait);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_all_stock",
          "args": [
            "mem_over_limit"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2028-2063",
          "snippet": "static void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define FLUSHING_CACHED_CHARGE\t0"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);",
            "static DEFINE_MUTEX(percpu_charge_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define FLUSHING_CACHED_CHARGE\t0\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\nstatic DEFINE_MUTEX(percpu_charge_mutex);\n\nstatic void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_margin",
          "args": [
            "mem_over_limit"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_margin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1204-1225",
          "snippet": "static unsigned long mem_cgroup_margin(struct mem_cgroup *memcg)\n{\n\tunsigned long margin = 0;\n\tunsigned long count;\n\tunsigned long limit;\n\n\tcount = page_counter_read(&memcg->memory);\n\tlimit = READ_ONCE(memcg->memory.max);\n\tif (count < limit)\n\t\tmargin = limit - count;\n\n\tif (do_memsw_account()) {\n\t\tcount = page_counter_read(&memcg->memsw);\n\t\tlimit = READ_ONCE(memcg->memsw.max);\n\t\tif (count <= limit)\n\t\t\tmargin = min(margin, limit - count);\n\t\telse\n\t\t\tmargin = 0;\n\t}\n\n\treturn margin;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long mem_cgroup_margin(struct mem_cgroup *memcg)\n{\n\tunsigned long margin = 0;\n\tunsigned long count;\n\tunsigned long limit;\n\n\tcount = page_counter_read(&memcg->memory);\n\tlimit = READ_ONCE(memcg->memory.max);\n\tif (count < limit)\n\t\tmargin = limit - count;\n\n\tif (do_memsw_account()) {\n\t\tcount = page_counter_read(&memcg->memsw);\n\t\tlimit = READ_ONCE(memcg->memsw.max);\n\t\tif (count <= limit)\n\t\t\tmargin = min(margin, limit - count);\n\t\telse\n\t\t\tmargin = 0;\n\t}\n\n\treturn margin;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_mem_cgroup_pages",
          "args": [
            "mem_over_limit",
            "nr_pages",
            "gfp_mask",
            "may_swap"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_mem_cgroup_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3311-3358",
          "snippet": "unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_memory_event",
          "args": [
            "mem_over_limit",
            "MEMCG_MAX"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "gfp_mask"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task_in_memcg_oom(current)"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_in_memcg_oom",
          "args": [
            "current"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->flags & PF_MEMALLOC"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk_is_oom_victim(current) ||\n\t\t     fatal_signal_pending(current) ||\n\t\t     current->flags & PF_EXITING"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsk_is_oom_victim",
          "args": [
            "current"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_counter",
          "args": [
            "counter",
            "memsw"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_counter",
          "args": [
            "counter",
            "memory"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_uncharge",
          "args": [
            "&memcg->memsw",
            "batch"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "155-161",
          "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_try_charge",
          "args": [
            "&memcg->memory",
            "batch",
            "&counter"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_try_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "99-148",
          "snippet": "bool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nbool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "consume_stock",
          "args": [
            "memcg",
            "nr_pages"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "consume_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1943-1963",
          "snippet": "static bool consume_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tif (nr_pages > MEMCG_CHARGE_BATCH)\n\t\treturn ret;\n\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tif (memcg == stock->cached && stock->nr_pages >= nr_pages) {\n\t\tstock->nr_pages -= nr_pages;\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\n\nstatic bool consume_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tif (nr_pages > MEMCG_CHARGE_BATCH)\n\t\treturn ret;\n\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tif (memcg == stock->cached && stock->nr_pages >= nr_pages) {\n\t\tstock->nr_pages -= nr_pages;\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "MEMCG_CHARGE_BATCH",
            "nr_pages"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "swap_max_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6579-6590",
          "snippet": "static int swap_max_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long max = READ_ONCE(memcg->swap.max);\n\n\tif (max == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)max * PAGE_SIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int swap_max_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long max = READ_ONCE(memcg->swap.max);\n\n\tif (max == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)max * PAGE_SIZE);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define MEM_CGROUP_RECLAIM_RETRIES\t5\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int try_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t      unsigned int nr_pages)\n{\n\tunsigned int batch = max(MEMCG_CHARGE_BATCH, nr_pages);\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct page_counter *counter;\n\tunsigned long nr_reclaimed;\n\tbool may_swap = true;\n\tbool drained = false;\n\tbool oomed = false;\n\tenum oom_status oom_status;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\nretry:\n\tif (consume_stock(memcg, nr_pages))\n\t\treturn 0;\n\n\tif (!do_memsw_account() ||\n\t    page_counter_try_charge(&memcg->memsw, batch, &counter)) {\n\t\tif (page_counter_try_charge(&memcg->memory, batch, &counter))\n\t\t\tgoto done_restock;\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&memcg->memsw, batch);\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memory);\n\t} else {\n\t\tmem_over_limit = mem_cgroup_from_counter(counter, memsw);\n\t\tmay_swap = false;\n\t}\n\n\tif (batch > nr_pages) {\n\t\tbatch = nr_pages;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Unlike in global OOM situations, memcg is not in a physical\n\t * memory shortage.  Allow dying and OOM-killed tasks to\n\t * bypass the last charges so that they can exit quickly and\n\t * free their memory.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current) ||\n\t\t     fatal_signal_pending(current) ||\n\t\t     current->flags & PF_EXITING))\n\t\tgoto force;\n\n\t/*\n\t * Prevent unbounded recursion when reclaim operations need to\n\t * allocate memory. This might exceed the limits temporarily,\n\t * but we prefer facilitating memory reclaim and getting back\n\t * under the limit over triggering OOM kills in these cases.\n\t */\n\tif (unlikely(current->flags & PF_MEMALLOC))\n\t\tgoto force;\n\n\tif (unlikely(task_in_memcg_oom(current)))\n\t\tgoto nomem;\n\n\tif (!gfpflags_allow_blocking(gfp_mask))\n\t\tgoto nomem;\n\n\tmemcg_memory_event(mem_over_limit, MEMCG_MAX);\n\n\tnr_reclaimed = try_to_free_mem_cgroup_pages(mem_over_limit, nr_pages,\n\t\t\t\t\t\t    gfp_mask, may_swap);\n\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\tgoto retry;\n\n\tif (!drained) {\n\t\tdrain_all_stock(mem_over_limit);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nomem;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_reclaimed && nr_pages <= (1 << PAGE_ALLOC_COSTLY_ORDER))\n\t\tgoto retry;\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\tgoto retry;\n\n\tif (nr_retries--)\n\t\tgoto retry;\n\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL && oomed)\n\t\tgoto nomem;\n\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\tgoto force;\n\n\tif (fatal_signal_pending(current))\n\t\tgoto force;\n\n\t/*\n\t * keep retrying as long as the memcg oom killer is able to make\n\t * a forward progress or bypass the charge if the oom killer\n\t * couldn't make any progress.\n\t */\n\toom_status = mem_cgroup_oom(mem_over_limit, gfp_mask,\n\t\t       get_order(nr_pages * PAGE_SIZE));\n\tswitch (oom_status) {\n\tcase OOM_SUCCESS:\n\t\tnr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\toomed = true;\n\t\tgoto retry;\n\tcase OOM_FAILED:\n\t\tgoto force;\n\tdefault:\n\t\tgoto nomem;\n\t}\nnomem:\n\tif (!(gfp_mask & __GFP_NOFAIL))\n\t\treturn -ENOMEM;\nforce:\n\t/*\n\t * The allocation either can't fail or will lead to more memory\n\t * being freed very soon.  Allow memory usage go over the limit\n\t * temporarily by force charging it.\n\t */\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\treturn 0;\n\ndone_restock:\n\tcss_get_many(&memcg->css, batch);\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\n\t/*\n\t * If the hierarchy is above the normal consumption range, schedule\n\t * reclaim on returning to userland.  We can perform reclaim here\n\t * if __GFP_RECLAIM but let's always punt for simplicity and so that\n\t * GFP_KERNEL can consistently be used during reclaim.  @memcg is\n\t * not recorded as it most likely matches current's and won't\n\t * change in the meantime.  As high limit is checked again before\n\t * reclaim, the cost of mismatch is negligible.\n\t */\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) > memcg->high) {\n\t\t\t/* Don't bother a random interrupted task */\n\t\t\tif (in_interrupt()) {\n\t\t\t\tschedule_work(&memcg->high_work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->memcg_nr_pages_over_high += batch;\n\t\t\tset_notify_resume(current);\n\t\t\tbreak;\n\t\t}\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_handle_over_high",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2133-2145",
    "snippet": "void mem_cgroup_handle_over_high(void)\n{\n\tunsigned int nr_pages = current->memcg_nr_pages_over_high;\n\tstruct mem_cgroup *memcg;\n\n\tif (likely(!nr_pages))\n\t\treturn;\n\n\tmemcg = get_mem_cgroup_from_mm(current->mm);\n\treclaim_high(memcg, nr_pages, GFP_KERNEL);\n\tcss_put(&memcg->css);\n\tcurrent->memcg_nr_pages_over_high = 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&memcg->css"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reclaim_high",
          "args": [
            "memcg",
            "nr_pages",
            "GFP_KERNEL"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "reclaim_high",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2109-2119",
          "snippet": "static void reclaim_high(struct mem_cgroup *memcg,\n\t\t\t unsigned int nr_pages,\n\t\t\t gfp_t gfp_mask)\n{\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) <= memcg->high)\n\t\t\tcontinue;\n\t\tmemcg_memory_event(memcg, MEMCG_HIGH);\n\t\ttry_to_free_mem_cgroup_pages(memcg, nr_pages, gfp_mask, true);\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void reclaim_high(struct mem_cgroup *memcg,\n\t\t\t unsigned int nr_pages,\n\t\t\t gfp_t gfp_mask)\n{\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) <= memcg->high)\n\t\t\tcontinue;\n\t\tmemcg_memory_event(memcg, MEMCG_HIGH);\n\t\ttry_to_free_mem_cgroup_pages(memcg, nr_pages, gfp_mask, true);\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mem_cgroup_from_mm",
          "args": [
            "current->mm"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "get_mem_cgroup_from_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "827-851",
          "snippet": "struct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdo {\n\t\t/*\n\t\t * Page cache insertions can happen withou an\n\t\t * actual mm context, e.g. during disk probing\n\t\t * on boot, loopback IO, acct() writes etc.\n\t\t */\n\t\tif (unlikely(!mm))\n\t\t\tmemcg = root_mem_cgroup;\n\t\telse {\n\t\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\t\tif (unlikely(!memcg))\n\t\t\t\tmemcg = root_mem_cgroup;\n\t\t}\n\t} while (!css_tryget_online(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdo {\n\t\t/*\n\t\t * Page cache insertions can happen withou an\n\t\t * actual mm context, e.g. during disk probing\n\t\t * on boot, loopback IO, acct() writes etc.\n\t\t */\n\t\tif (unlikely(!mm))\n\t\t\tmemcg = root_mem_cgroup;\n\t\telse {\n\t\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\t\tif (unlikely(!memcg))\n\t\t\t\tmemcg = root_mem_cgroup;\n\t\t}\n\t} while (!css_tryget_online(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!nr_pages"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_handle_over_high(void)\n{\n\tunsigned int nr_pages = current->memcg_nr_pages_over_high;\n\tstruct mem_cgroup *memcg;\n\n\tif (likely(!nr_pages))\n\t\treturn;\n\n\tmemcg = get_mem_cgroup_from_mm(current->mm);\n\treclaim_high(memcg, nr_pages, GFP_KERNEL);\n\tcss_put(&memcg->css);\n\tcurrent->memcg_nr_pages_over_high = 0;\n}"
  },
  {
    "function_name": "high_work_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2121-2127",
    "snippet": "static void high_work_func(struct work_struct *work)\n{\n\tstruct mem_cgroup *memcg;\n\n\tmemcg = container_of(work, struct mem_cgroup, high_work);\n\treclaim_high(memcg, MEMCG_CHARGE_BATCH, GFP_KERNEL);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reclaim_high",
          "args": [
            "memcg",
            "MEMCG_CHARGE_BATCH",
            "GFP_KERNEL"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "reclaim_high",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2109-2119",
          "snippet": "static void reclaim_high(struct mem_cgroup *memcg,\n\t\t\t unsigned int nr_pages,\n\t\t\t gfp_t gfp_mask)\n{\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) <= memcg->high)\n\t\t\tcontinue;\n\t\tmemcg_memory_event(memcg, MEMCG_HIGH);\n\t\ttry_to_free_mem_cgroup_pages(memcg, nr_pages, gfp_mask, true);\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void reclaim_high(struct mem_cgroup *memcg,\n\t\t\t unsigned int nr_pages,\n\t\t\t gfp_t gfp_mask)\n{\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) <= memcg->high)\n\t\t\tcontinue;\n\t\tmemcg_memory_event(memcg, MEMCG_HIGH);\n\t\ttry_to_free_mem_cgroup_pages(memcg, nr_pages, gfp_mask, true);\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structmem_cgroup",
            "high_work"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void high_work_func(struct work_struct *work)\n{\n\tstruct mem_cgroup *memcg;\n\n\tmemcg = container_of(work, struct mem_cgroup, high_work);\n\treclaim_high(memcg, MEMCG_CHARGE_BATCH, GFP_KERNEL);\n}"
  },
  {
    "function_name": "reclaim_high",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2109-2119",
    "snippet": "static void reclaim_high(struct mem_cgroup *memcg,\n\t\t\t unsigned int nr_pages,\n\t\t\t gfp_t gfp_mask)\n{\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) <= memcg->high)\n\t\t\tcontinue;\n\t\tmemcg_memory_event(memcg, MEMCG_HIGH);\n\t\ttry_to_free_mem_cgroup_pages(memcg, nr_pages, gfp_mask, true);\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_free_mem_cgroup_pages",
          "args": [
            "memcg",
            "nr_pages",
            "gfp_mask",
            "true"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_mem_cgroup_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3311-3358",
          "snippet": "unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_memory_event",
          "args": [
            "memcg",
            "MEMCG_HIGH"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void reclaim_high(struct mem_cgroup *memcg,\n\t\t\t unsigned int nr_pages,\n\t\t\t gfp_t gfp_mask)\n{\n\tdo {\n\t\tif (page_counter_read(&memcg->memory) <= memcg->high)\n\t\t\tcontinue;\n\t\tmemcg_memory_event(memcg, MEMCG_HIGH);\n\t\ttry_to_free_mem_cgroup_pages(memcg, nr_pages, gfp_mask, true);\n\t} while ((memcg = parent_mem_cgroup(memcg)));\n}"
  },
  {
    "function_name": "memcg_hotplug_cpu_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2065-2107",
    "snippet": "static int memcg_hotplug_cpu_dead(unsigned int cpu)\n{\n\tstruct memcg_stock_pcp *stock;\n\tstruct mem_cgroup *memcg;\n\n\tstock = &per_cpu(memcg_stock, cpu);\n\tdrain_stock(stock);\n\n\tfor_each_mem_cgroup(memcg) {\n\t\tint i;\n\n\t\tfor (i = 0; i < MEMCG_NR_STAT; i++) {\n\t\t\tint nid;\n\t\t\tlong x;\n\n\t\t\tx = this_cpu_xchg(memcg->stat_cpu->count[i], 0);\n\t\t\tif (x)\n\t\t\t\tatomic_long_add(x, &memcg->stat[i]);\n\n\t\t\tif (i >= NR_VM_NODE_STAT_ITEMS)\n\t\t\t\tcontinue;\n\n\t\t\tfor_each_node(nid) {\n\t\t\t\tstruct mem_cgroup_per_node *pn;\n\n\t\t\t\tpn = mem_cgroup_nodeinfo(memcg, nid);\n\t\t\t\tx = this_cpu_xchg(pn->lruvec_stat_cpu->count[i], 0);\n\t\t\t\tif (x)\n\t\t\t\t\tatomic_long_add(x, &pn->lruvec_stat[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++) {\n\t\t\tlong x;\n\n\t\t\tx = this_cpu_xchg(memcg->stat_cpu->events[i], 0);\n\t\t\tif (x)\n\t\t\t\tatomic_long_add(x, &memcg->events[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "x",
            "&memcg->events[i]"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_xchg",
          "args": [
            "memcg->stat_cpu->events[i]",
            "0"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "x",
            "&pn->lruvec_stat[i]"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_xchg",
          "args": [
            "pn->lruvec_stat_cpu->count[i]",
            "0"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nodeinfo",
          "args": [
            "memcg",
            "nid"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "x",
            "&memcg->stat[i]"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_xchg",
          "args": [
            "memcg->stat_cpu->count[i]",
            "0"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_stock",
          "args": [
            "stock"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "drain_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1968-1980",
          "snippet": "static void drain_stock(struct memcg_stock_pcp *stock)\n{\n\tstruct mem_cgroup *old = stock->cached;\n\n\tif (stock->nr_pages) {\n\t\tpage_counter_uncharge(&old->memory, stock->nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&old->memsw, stock->nr_pages);\n\t\tcss_put_many(&old->css, stock->nr_pages);\n\t\tstock->nr_pages = 0;\n\t}\n\tstock->cached = NULL;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void drain_stock(struct memcg_stock_pcp *stock)\n{\n\tstruct mem_cgroup *old = stock->cached;\n\n\tif (stock->nr_pages) {\n\t\tpage_counter_uncharge(&old->memory, stock->nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&old->memsw, stock->nr_pages);\n\t\tcss_put_many(&old->css, stock->nr_pages);\n\t\tstock->nr_pages = 0;\n\t}\n\tstock->cached = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "memcg_stock",
            "cpu"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\n\nstatic int memcg_hotplug_cpu_dead(unsigned int cpu)\n{\n\tstruct memcg_stock_pcp *stock;\n\tstruct mem_cgroup *memcg;\n\n\tstock = &per_cpu(memcg_stock, cpu);\n\tdrain_stock(stock);\n\n\tfor_each_mem_cgroup(memcg) {\n\t\tint i;\n\n\t\tfor (i = 0; i < MEMCG_NR_STAT; i++) {\n\t\t\tint nid;\n\t\t\tlong x;\n\n\t\t\tx = this_cpu_xchg(memcg->stat_cpu->count[i], 0);\n\t\t\tif (x)\n\t\t\t\tatomic_long_add(x, &memcg->stat[i]);\n\n\t\t\tif (i >= NR_VM_NODE_STAT_ITEMS)\n\t\t\t\tcontinue;\n\n\t\t\tfor_each_node(nid) {\n\t\t\t\tstruct mem_cgroup_per_node *pn;\n\n\t\t\t\tpn = mem_cgroup_nodeinfo(memcg, nid);\n\t\t\t\tx = this_cpu_xchg(pn->lruvec_stat_cpu->count[i], 0);\n\t\t\t\tif (x)\n\t\t\t\t\tatomic_long_add(x, &pn->lruvec_stat[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++) {\n\t\t\tlong x;\n\n\t\t\tx = this_cpu_xchg(memcg->stat_cpu->events[i], 0);\n\t\t\tif (x)\n\t\t\t\tatomic_long_add(x, &memcg->events[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "drain_all_stock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2028-2063",
    "snippet": "static void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define FLUSHING_CACHED_CHARGE\t0"
    ],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);",
      "static DEFINE_MUTEX(percpu_charge_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&percpu_charge_mutex"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&memcg->css"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work_on",
          "args": [
            "cpu",
            "&stock->work"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_local_stock",
          "args": [
            "&stock->work"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "drain_local_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1982-1998",
          "snippet": "static void drain_local_stock(struct work_struct *dummy)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\n\t/*\n\t * The only protection from memory hotplug vs. drain_stock races is\n\t * that we always operate on local CPU stock here with IRQ disabled\n\t */\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tdrain_stock(stock);\n\tclear_bit(FLUSHING_CACHED_CHARGE, &stock->flags);\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define FLUSHING_CACHED_CHARGE\t0"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define FLUSHING_CACHED_CHARGE\t0\n\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\n\nstatic void drain_local_stock(struct work_struct *dummy)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\n\t/*\n\t * The only protection from memory hotplug vs. drain_stock races is\n\t * that we always operate on local CPU stock here with IRQ disabled\n\t */\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tdrain_stock(stock);\n\tclear_bit(FLUSHING_CACHED_CHARGE, &stock->flags);\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "FLUSHING_CACHED_CHARGE",
            "&stock->flags"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&memcg->css"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_descendant",
          "args": [
            "memcg",
            "root_memcg"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget",
          "args": [
            "&memcg->css"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "memcg_stock",
            "cpu"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&percpu_charge_mutex"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define FLUSHING_CACHED_CHARGE\t0\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\nstatic DEFINE_MUTEX(percpu_charge_mutex);\n\nstatic void drain_all_stock(struct mem_cgroup *root_memcg)\n{\n\tint cpu, curcpu;\n\n\t/* If someone's already draining, avoid adding running more workers. */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\t/*\n\t * Notify other cpus that system-wide \"drain\" is running\n\t * We do not care about races with the cpu hotplug because cpu down\n\t * as well as workers from this path always operate on the local\n\t * per-cpu data. CPU up doesn't touch memcg_stock at all.\n\t */\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages || !css_tryget(&memcg->css))\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_is_descendant(memcg, root_memcg)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t\tcss_put(&memcg->css);\n\t}\n\tput_cpu();\n\tmutex_unlock(&percpu_charge_mutex);\n}"
  },
  {
    "function_name": "refill_stock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "2004-2022",
    "snippet": "static void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tif (stock->cached != memcg) { /* reset if necessary */\n\t\tdrain_stock(stock);\n\t\tstock->cached = memcg;\n\t}\n\tstock->nr_pages += nr_pages;\n\n\tif (stock->nr_pages > MEMCG_CHARGE_BATCH)\n\t\tdrain_stock(stock);\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_stock",
          "args": [
            "stock"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "drain_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1968-1980",
          "snippet": "static void drain_stock(struct memcg_stock_pcp *stock)\n{\n\tstruct mem_cgroup *old = stock->cached;\n\n\tif (stock->nr_pages) {\n\t\tpage_counter_uncharge(&old->memory, stock->nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&old->memsw, stock->nr_pages);\n\t\tcss_put_many(&old->css, stock->nr_pages);\n\t\tstock->nr_pages = 0;\n\t}\n\tstock->cached = NULL;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void drain_stock(struct memcg_stock_pcp *stock)\n{\n\tstruct mem_cgroup *old = stock->cached;\n\n\tif (stock->nr_pages) {\n\t\tpage_counter_uncharge(&old->memory, stock->nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&old->memsw, stock->nr_pages);\n\t\tcss_put_many(&old->css, stock->nr_pages);\n\t\tstock->nr_pages = 0;\n\t}\n\tstock->cached = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&memcg_stock"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\n\nstatic void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tif (stock->cached != memcg) { /* reset if necessary */\n\t\tdrain_stock(stock);\n\t\tstock->cached = memcg;\n\t}\n\tstock->nr_pages += nr_pages;\n\n\tif (stock->nr_pages > MEMCG_CHARGE_BATCH)\n\t\tdrain_stock(stock);\n\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "drain_local_stock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1982-1998",
    "snippet": "static void drain_local_stock(struct work_struct *dummy)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\n\t/*\n\t * The only protection from memory hotplug vs. drain_stock races is\n\t * that we always operate on local CPU stock here with IRQ disabled\n\t */\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tdrain_stock(stock);\n\tclear_bit(FLUSHING_CACHED_CHARGE, &stock->flags);\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define FLUSHING_CACHED_CHARGE\t0"
    ],
    "globals_used": [
      "static __always_inline struct",
      "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FLUSHING_CACHED_CHARGE",
            "&stock->flags"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_stock",
          "args": [
            "stock"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "drain_stock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1968-1980",
          "snippet": "static void drain_stock(struct memcg_stock_pcp *stock)\n{\n\tstruct mem_cgroup *old = stock->cached;\n\n\tif (stock->nr_pages) {\n\t\tpage_counter_uncharge(&old->memory, stock->nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&old->memsw, stock->nr_pages);\n\t\tcss_put_many(&old->css, stock->nr_pages);\n\t\tstock->nr_pages = 0;\n\t}\n\tstock->cached = NULL;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void drain_stock(struct memcg_stock_pcp *stock)\n{\n\tstruct mem_cgroup *old = stock->cached;\n\n\tif (stock->nr_pages) {\n\t\tpage_counter_uncharge(&old->memory, stock->nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&old->memsw, stock->nr_pages);\n\t\tcss_put_many(&old->css, stock->nr_pages);\n\t\tstock->nr_pages = 0;\n\t}\n\tstock->cached = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&memcg_stock"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define FLUSHING_CACHED_CHARGE\t0\n\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\n\nstatic void drain_local_stock(struct work_struct *dummy)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\n\t/*\n\t * The only protection from memory hotplug vs. drain_stock races is\n\t * that we always operate on local CPU stock here with IRQ disabled\n\t */\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tdrain_stock(stock);\n\tclear_bit(FLUSHING_CACHED_CHARGE, &stock->flags);\n\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "drain_stock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1968-1980",
    "snippet": "static void drain_stock(struct memcg_stock_pcp *stock)\n{\n\tstruct mem_cgroup *old = stock->cached;\n\n\tif (stock->nr_pages) {\n\t\tpage_counter_uncharge(&old->memory, stock->nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&old->memsw, stock->nr_pages);\n\t\tcss_put_many(&old->css, stock->nr_pages);\n\t\tstock->nr_pages = 0;\n\t}\n\tstock->cached = NULL;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put_many",
          "args": [
            "&old->css",
            "stock->nr_pages"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_uncharge",
          "args": [
            "&old->memsw",
            "stock->nr_pages"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "155-161",
          "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void drain_stock(struct memcg_stock_pcp *stock)\n{\n\tstruct mem_cgroup *old = stock->cached;\n\n\tif (stock->nr_pages) {\n\t\tpage_counter_uncharge(&old->memory, stock->nr_pages);\n\t\tif (do_memsw_account())\n\t\t\tpage_counter_uncharge(&old->memsw, stock->nr_pages);\n\t\tcss_put_many(&old->css, stock->nr_pages);\n\t\tstock->nr_pages = 0;\n\t}\n\tstock->cached = NULL;\n}"
  },
  {
    "function_name": "consume_stock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1943-1963",
    "snippet": "static bool consume_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tif (nr_pages > MEMCG_CHARGE_BATCH)\n\t\treturn ret;\n\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tif (memcg == stock->cached && stock->nr_pages >= nr_pages) {\n\t\tstock->nr_pages -= nr_pages;\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&memcg_stock"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\n\nstatic bool consume_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tif (nr_pages > MEMCG_CHARGE_BATCH)\n\t\treturn ret;\n\n\tlocal_irq_save(flags);\n\n\tstock = this_cpu_ptr(&memcg_stock);\n\tif (memcg == stock->cached && stock->nr_pages >= nr_pages) {\n\t\tstock->nr_pages -= nr_pages;\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "unlock_page_memcg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1916-1919",
    "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__unlock_page_memcg",
          "args": [
            "page->mem_cgroup"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "__unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1898-1910",
          "snippet": "void __unlock_page_memcg(struct mem_cgroup *memcg)\n{\n\tif (memcg && memcg->move_lock_task == current) {\n\t\tunsigned long flags = memcg->move_lock_flags;\n\n\t\tmemcg->move_lock_task = NULL;\n\t\tmemcg->move_lock_flags = 0;\n\n\t\tspin_unlock_irqrestore(&memcg->move_lock, flags);\n\t}\n\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid __unlock_page_memcg(struct mem_cgroup *memcg)\n{\n\tif (memcg && memcg->move_lock_task == current) {\n\t\tunsigned long flags = memcg->move_lock_flags;\n\n\t\tmemcg->move_lock_task = NULL;\n\t\tmemcg->move_lock_flags = 0;\n\n\t\tspin_unlock_irqrestore(&memcg->move_lock, flags);\n\t}\n\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
  },
  {
    "function_name": "__unlock_page_memcg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1898-1910",
    "snippet": "void __unlock_page_memcg(struct mem_cgroup *memcg)\n{\n\tif (memcg && memcg->move_lock_task == current) {\n\t\tunsigned long flags = memcg->move_lock_flags;\n\n\t\tmemcg->move_lock_task = NULL;\n\t\tmemcg->move_lock_flags = 0;\n\n\t\tspin_unlock_irqrestore(&memcg->move_lock, flags);\n\t}\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&memcg->move_lock",
            "flags"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid __unlock_page_memcg(struct mem_cgroup *memcg)\n{\n\tif (memcg && memcg->move_lock_task == current) {\n\t\tunsigned long flags = memcg->move_lock_flags;\n\n\t\tmemcg->move_lock_task = NULL;\n\t\tmemcg->move_lock_flags = 0;\n\n\t\tspin_unlock_irqrestore(&memcg->move_lock, flags);\n\t}\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "lock_page_memcg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1846-1889",
    "snippet": "struct mem_cgroup *lock_page_memcg(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned long flags;\n\n\t/*\n\t * The RCU lock is held throughout the transaction.  The fast\n\t * path can get away without acquiring the memcg->move_lock\n\t * because page moving starts with an RCU grace period.\n\t *\n\t * The RCU lock also protects the memcg from being freed when\n\t * the page state that is going to change is the only thing\n\t * preventing the page itself from being freed. E.g. writeback\n\t * doesn't hold a page reference and relies on PG_writeback to\n\t * keep off truncation, migration and so forth.\n         */\n\trcu_read_lock();\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\nagain:\n\tmemcg = page->mem_cgroup;\n\tif (unlikely(!memcg))\n\t\treturn NULL;\n\n\tif (atomic_read(&memcg->moving_account) <= 0)\n\t\treturn memcg;\n\n\tspin_lock_irqsave(&memcg->move_lock, flags);\n\tif (memcg != page->mem_cgroup) {\n\t\tspin_unlock_irqrestore(&memcg->move_lock, flags);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * When charge migration first begins, we can have locked and\n\t * unlocked page stat updates happening concurrently.  Track\n\t * the task who has the lock for unlock_page_memcg().\n\t */\n\tmemcg->move_lock_task = current;\n\tmemcg->move_lock_flags = flags;\n\n\treturn memcg;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&memcg->move_lock",
            "flags"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&memcg->move_lock",
            "flags"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&memcg->moving_account"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!memcg"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *lock_page_memcg(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned long flags;\n\n\t/*\n\t * The RCU lock is held throughout the transaction.  The fast\n\t * path can get away without acquiring the memcg->move_lock\n\t * because page moving starts with an RCU grace period.\n\t *\n\t * The RCU lock also protects the memcg from being freed when\n\t * the page state that is going to change is the only thing\n\t * preventing the page itself from being freed. E.g. writeback\n\t * doesn't hold a page reference and relies on PG_writeback to\n\t * keep off truncation, migration and so forth.\n         */\n\trcu_read_lock();\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\nagain:\n\tmemcg = page->mem_cgroup;\n\tif (unlikely(!memcg))\n\t\treturn NULL;\n\n\tif (atomic_read(&memcg->moving_account) <= 0)\n\t\treturn memcg;\n\n\tspin_lock_irqsave(&memcg->move_lock, flags);\n\tif (memcg != page->mem_cgroup) {\n\t\tspin_unlock_irqrestore(&memcg->move_lock, flags);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * When charge migration first begins, we can have locked and\n\t * unlocked page stat updates happening concurrently.  Track\n\t * the task who has the lock for unlock_page_memcg().\n\t */\n\tmemcg->move_lock_task = current;\n\tmemcg->move_lock_flags = flags;\n\n\treturn memcg;\n}"
  },
  {
    "function_name": "mem_cgroup_print_oom_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1828-1833",
    "snippet": "void mem_cgroup_print_oom_group(struct mem_cgroup *memcg)\n{\n\tpr_info(\"Tasks in \");\n\tpr_cont_cgroup_path(memcg->css.cgroup);\n\tpr_cont(\" are going to be killed due to memory.oom.group set\\n\");\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" are going to be killed due to memory.oom.group set\\n\""
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont_cgroup_path",
          "args": [
            "memcg->css.cgroup"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Tasks in \""
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_print_oom_group(struct mem_cgroup *memcg)\n{\n\tpr_info(\"Tasks in \");\n\tpr_cont_cgroup_path(memcg->css.cgroup);\n\tpr_cont(\" are going to be killed due to memory.oom.group set\\n\");\n}"
  },
  {
    "function_name": "mem_cgroup_get_oom_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1789-1826",
    "snippet": "struct mem_cgroup *mem_cgroup_get_oom_group(struct task_struct *victim,\n\t\t\t\t\t    struct mem_cgroup *oom_domain)\n{\n\tstruct mem_cgroup *oom_group = NULL;\n\tstruct mem_cgroup *memcg;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn NULL;\n\n\tif (!oom_domain)\n\t\toom_domain = root_mem_cgroup;\n\n\trcu_read_lock();\n\n\tmemcg = mem_cgroup_from_task(victim);\n\tif (memcg == root_mem_cgroup)\n\t\tgoto out;\n\n\t/*\n\t * Traverse the memory cgroup hierarchy from the victim task's\n\t * cgroup up to the OOMing cgroup (or root) to find the\n\t * highest-level memory cgroup with oom.group set.\n\t */\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tif (memcg->oom_group)\n\t\t\toom_group = memcg;\n\n\t\tif (memcg == oom_domain)\n\t\t\tbreak;\n\t}\n\n\tif (oom_group)\n\t\tcss_get(&oom_group->css);\nout:\n\trcu_read_unlock();\n\n\treturn oom_group;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "&oom_group->css"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_task",
          "args": [
            "victim"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_from_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "805-816",
          "snippet": "struct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstruct mem_cgroup *mem_cgroup_get_oom_group(struct task_struct *victim,\n\t\t\t\t\t    struct mem_cgroup *oom_domain)\n{\n\tstruct mem_cgroup *oom_group = NULL;\n\tstruct mem_cgroup *memcg;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn NULL;\n\n\tif (!oom_domain)\n\t\toom_domain = root_mem_cgroup;\n\n\trcu_read_lock();\n\n\tmemcg = mem_cgroup_from_task(victim);\n\tif (memcg == root_mem_cgroup)\n\t\tgoto out;\n\n\t/*\n\t * Traverse the memory cgroup hierarchy from the victim task's\n\t * cgroup up to the OOMing cgroup (or root) to find the\n\t * highest-level memory cgroup with oom.group set.\n\t */\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tif (memcg->oom_group)\n\t\t\toom_group = memcg;\n\n\t\tif (memcg == oom_domain)\n\t\t\tbreak;\n\t}\n\n\tif (oom_group)\n\t\tcss_get(&oom_group->css);\nout:\n\trcu_read_unlock();\n\n\treturn oom_group;\n}"
  },
  {
    "function_name": "mem_cgroup_oom_synchronize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1726-1777",
    "snippet": "bool mem_cgroup_oom_synchronize(bool handle)\n{\n\tstruct mem_cgroup *memcg = current->memcg_in_oom;\n\tstruct oom_wait_info owait;\n\tbool locked;\n\n\t/* OOM is global, do not handle */\n\tif (!memcg)\n\t\treturn false;\n\n\tif (!handle)\n\t\tgoto cleanup;\n\n\towait.memcg = memcg;\n\towait.wait.flags = 0;\n\towait.wait.func = memcg_oom_wake_function;\n\towait.wait.private = current;\n\tINIT_LIST_HEAD(&owait.wait.entry);\n\n\tprepare_to_wait(&memcg_oom_waitq, &owait.wait, TASK_KILLABLE);\n\tmem_cgroup_mark_under_oom(memcg);\n\n\tlocked = mem_cgroup_oom_trylock(memcg);\n\n\tif (locked)\n\t\tmem_cgroup_oom_notify(memcg);\n\n\tif (locked && !memcg->oom_kill_disable) {\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t\tmem_cgroup_out_of_memory(memcg, current->memcg_oom_gfp_mask,\n\t\t\t\t\t current->memcg_oom_order);\n\t} else {\n\t\tschedule();\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t}\n\n\tif (locked) {\n\t\tmem_cgroup_oom_unlock(memcg);\n\t\t/*\n\t\t * There is no guarantee that an OOM-lock contender\n\t\t * sees the wakeups triggered by the OOM kill\n\t\t * uncharges.  Wake any sleepers explicitely.\n\t\t */\n\t\tmemcg_oom_recover(memcg);\n\t}\ncleanup:\n\tcurrent->memcg_in_oom = NULL;\n\tcss_put(&memcg->css);\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&memcg->css"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_oom_recover",
          "args": [
            "memcg"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_oom_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1646-1658",
          "snippet": "static void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);\n\nstatic void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_oom_unlock",
          "args": [
            "memcg"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_oom_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1587-1596",
          "snippet": "static void mem_cgroup_oom_unlock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tspin_lock(&memcg_oom_lock);\n\tmutex_release(&memcg_oom_lock_dep_map, 1, _RET_IP_);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\titer->oom_lock = false;\n\tspin_unlock(&memcg_oom_lock);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_SPINLOCK(memcg_oom_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic void mem_cgroup_oom_unlock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tspin_lock(&memcg_oom_lock);\n\tmutex_release(&memcg_oom_lock_dep_map, 1, _RET_IP_);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\titer->oom_lock = false;\n\tspin_unlock(&memcg_oom_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&memcg_oom_waitq",
            "&owait.wait"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_unmark_under_oom",
          "args": [
            "memcg"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_unmark_under_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1608-1621",
          "snippet": "static void mem_cgroup_unmark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\t/*\n\t * When a new child is created while the hierarchy is under oom,\n\t * mem_cgroup_oom_lock() may not be called. Watch for underflow.\n\t */\n\tspin_lock(&memcg_oom_lock);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tif (iter->under_oom > 0)\n\t\t\titer->under_oom--;\n\tspin_unlock(&memcg_oom_lock);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_SPINLOCK(memcg_oom_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic void mem_cgroup_unmark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\t/*\n\t * When a new child is created while the hierarchy is under oom,\n\t * mem_cgroup_oom_lock() may not be called. Watch for underflow.\n\t */\n\tspin_lock(&memcg_oom_lock);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tif (iter->under_oom > 0)\n\t\t\titer->under_oom--;\n\tspin_unlock(&memcg_oom_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_schedule_balance_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "191-195",
          "snippet": "static void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool pcpu_async_enabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic bool pcpu_async_enabled;\n\nstatic void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_out_of_memory",
          "args": [
            "memcg",
            "current->memcg_oom_gfp_mask",
            "current->memcg_oom_order"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_out_of_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1373-1389",
          "snippet": "static bool mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t\t\t     int order)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = NULL,\n\t\t.nodemask = NULL,\n\t\t.memcg = memcg,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tbool ret;\n\n\tmutex_lock(&oom_lock);\n\tret = out_of_memory(&oc);\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic bool mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t\t\t     int order)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = NULL,\n\t\t.nodemask = NULL,\n\t\t.memcg = memcg,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tbool ret;\n\n\tmutex_lock(&oom_lock);\n\tret = out_of_memory(&oc);\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&memcg_oom_waitq",
            "&owait.wait"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_oom_notify",
          "args": [
            "memcg"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_oom_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3567-3573",
          "snippet": "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tmem_cgroup_oom_notify_cb(iter);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tmem_cgroup_oom_notify_cb(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_oom_trylock",
          "args": [
            "memcg"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_oom_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1548-1585",
          "snippet": "static bool mem_cgroup_oom_trylock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter, *failed = NULL;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tif (iter->oom_lock) {\n\t\t\t/*\n\t\t\t * this subtree of our hierarchy is already locked\n\t\t\t * so we cannot give a lock.\n\t\t\t */\n\t\t\tfailed = iter;\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t} else\n\t\t\titer->oom_lock = true;\n\t}\n\n\tif (failed) {\n\t\t/*\n\t\t * OK, we failed to lock the whole subtree so we have\n\t\t * to clean up what we set up to the failing subtree\n\t\t */\n\t\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\t\tif (iter == failed) {\n\t\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titer->oom_lock = false;\n\t\t}\n\t} else\n\t\tmutex_acquire(&memcg_oom_lock_dep_map, 0, 1, _RET_IP_);\n\n\tspin_unlock(&memcg_oom_lock);\n\n\treturn !failed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_SPINLOCK(memcg_oom_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic bool mem_cgroup_oom_trylock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter, *failed = NULL;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tif (iter->oom_lock) {\n\t\t\t/*\n\t\t\t * this subtree of our hierarchy is already locked\n\t\t\t * so we cannot give a lock.\n\t\t\t */\n\t\t\tfailed = iter;\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t} else\n\t\t\titer->oom_lock = true;\n\t}\n\n\tif (failed) {\n\t\t/*\n\t\t * OK, we failed to lock the whole subtree so we have\n\t\t * to clean up what we set up to the failing subtree\n\t\t */\n\t\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\t\tif (iter == failed) {\n\t\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titer->oom_lock = false;\n\t\t}\n\t} else\n\t\tmutex_acquire(&memcg_oom_lock_dep_map, 0, 1, _RET_IP_);\n\n\tspin_unlock(&memcg_oom_lock);\n\n\treturn !failed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_mark_under_oom",
          "args": [
            "memcg"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_mark_under_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1598-1606",
          "snippet": "static void mem_cgroup_mark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tspin_lock(&memcg_oom_lock);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\titer->under_oom++;\n\tspin_unlock(&memcg_oom_lock);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DEFINE_SPINLOCK(memcg_oom_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic void mem_cgroup_mark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tspin_lock(&memcg_oom_lock);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\titer->under_oom++;\n\tspin_unlock(&memcg_oom_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&memcg_oom_waitq",
            "&owait.wait",
            "TASK_KILLABLE"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&owait.wait.entry"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);\n\nbool mem_cgroup_oom_synchronize(bool handle)\n{\n\tstruct mem_cgroup *memcg = current->memcg_in_oom;\n\tstruct oom_wait_info owait;\n\tbool locked;\n\n\t/* OOM is global, do not handle */\n\tif (!memcg)\n\t\treturn false;\n\n\tif (!handle)\n\t\tgoto cleanup;\n\n\towait.memcg = memcg;\n\towait.wait.flags = 0;\n\towait.wait.func = memcg_oom_wake_function;\n\towait.wait.private = current;\n\tINIT_LIST_HEAD(&owait.wait.entry);\n\n\tprepare_to_wait(&memcg_oom_waitq, &owait.wait, TASK_KILLABLE);\n\tmem_cgroup_mark_under_oom(memcg);\n\n\tlocked = mem_cgroup_oom_trylock(memcg);\n\n\tif (locked)\n\t\tmem_cgroup_oom_notify(memcg);\n\n\tif (locked && !memcg->oom_kill_disable) {\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t\tmem_cgroup_out_of_memory(memcg, current->memcg_oom_gfp_mask,\n\t\t\t\t\t current->memcg_oom_order);\n\t} else {\n\t\tschedule();\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t}\n\n\tif (locked) {\n\t\tmem_cgroup_oom_unlock(memcg);\n\t\t/*\n\t\t * There is no guarantee that an OOM-lock contender\n\t\t * sees the wakeups triggered by the OOM kill\n\t\t * uncharges.  Wake any sleepers explicitely.\n\t\t */\n\t\tmemcg_oom_recover(memcg);\n\t}\ncleanup:\n\tcurrent->memcg_in_oom = NULL;\n\tcss_put(&memcg->css);\n\treturn true;\n}"
  },
  {
    "function_name": "mem_cgroup_oom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1667-1707",
    "snippet": "static enum oom_status mem_cgroup_oom(struct mem_cgroup *memcg, gfp_t mask, int order)\n{\n\tif (order > PAGE_ALLOC_COSTLY_ORDER)\n\t\treturn OOM_SKIPPED;\n\n\tmemcg_memory_event(memcg, MEMCG_OOM);\n\n\t/*\n\t * We are in the middle of the charge context here, so we\n\t * don't want to block when potentially sitting on a callstack\n\t * that holds all kinds of filesystem and mm locks.\n\t *\n\t * cgroup1 allows disabling the OOM killer and waiting for outside\n\t * handling until the charge can succeed; remember the context and put\n\t * the task to sleep at the end of the page fault when all locks are\n\t * released.\n\t *\n\t * On the other hand, in-kernel OOM killer allows for an async victim\n\t * memory reclaim (oom_reaper) and that means that we are not solely\n\t * relying on the oom victim to make a forward progress and we can\n\t * invoke the oom killer here.\n\t *\n\t * Please note that mem_cgroup_out_of_memory might fail to find a\n\t * victim and then we have to bail out from the charge path.\n\t */\n\tif (memcg->oom_kill_disable) {\n\t\tif (!current->in_user_fault)\n\t\t\treturn OOM_SKIPPED;\n\t\tcss_get(&memcg->css);\n\t\tcurrent->memcg_in_oom = memcg;\n\t\tcurrent->memcg_oom_gfp_mask = mask;\n\t\tcurrent->memcg_oom_order = order;\n\n\t\treturn OOM_ASYNC;\n\t}\n\n\tif (mem_cgroup_out_of_memory(memcg, mask, order))\n\t\treturn OOM_SUCCESS;\n\n\treturn OOM_FAILED;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_out_of_memory",
          "args": [
            "memcg",
            "mask",
            "order"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_out_of_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1373-1389",
          "snippet": "static bool mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t\t\t     int order)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = NULL,\n\t\t.nodemask = NULL,\n\t\t.memcg = memcg,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tbool ret;\n\n\tmutex_lock(&oom_lock);\n\tret = out_of_memory(&oc);\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic bool mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t\t\t     int order)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = NULL,\n\t\t.nodemask = NULL,\n\t\t.memcg = memcg,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tbool ret;\n\n\tmutex_lock(&oom_lock);\n\tret = out_of_memory(&oc);\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "&memcg->css"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_memory_event",
          "args": [
            "memcg",
            "MEMCG_OOM"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic enum oom_status mem_cgroup_oom(struct mem_cgroup *memcg, gfp_t mask, int order)\n{\n\tif (order > PAGE_ALLOC_COSTLY_ORDER)\n\t\treturn OOM_SKIPPED;\n\n\tmemcg_memory_event(memcg, MEMCG_OOM);\n\n\t/*\n\t * We are in the middle of the charge context here, so we\n\t * don't want to block when potentially sitting on a callstack\n\t * that holds all kinds of filesystem and mm locks.\n\t *\n\t * cgroup1 allows disabling the OOM killer and waiting for outside\n\t * handling until the charge can succeed; remember the context and put\n\t * the task to sleep at the end of the page fault when all locks are\n\t * released.\n\t *\n\t * On the other hand, in-kernel OOM killer allows for an async victim\n\t * memory reclaim (oom_reaper) and that means that we are not solely\n\t * relying on the oom victim to make a forward progress and we can\n\t * invoke the oom killer here.\n\t *\n\t * Please note that mem_cgroup_out_of_memory might fail to find a\n\t * victim and then we have to bail out from the charge path.\n\t */\n\tif (memcg->oom_kill_disable) {\n\t\tif (!current->in_user_fault)\n\t\t\treturn OOM_SKIPPED;\n\t\tcss_get(&memcg->css);\n\t\tcurrent->memcg_in_oom = memcg;\n\t\tcurrent->memcg_oom_gfp_mask = mask;\n\t\tcurrent->memcg_oom_order = order;\n\n\t\treturn OOM_ASYNC;\n\t}\n\n\tif (mem_cgroup_out_of_memory(memcg, mask, order))\n\t\treturn OOM_SUCCESS;\n\n\treturn OOM_FAILED;\n}"
  },
  {
    "function_name": "memcg_oom_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1646-1658",
    "snippet": "static void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up",
          "args": [
            "&memcg_oom_waitq",
            "TASK_NORMAL",
            "0",
            "memcg"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);\n\nstatic void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\t/*\n\t * For the following lockless ->under_oom test, the only required\n\t * guarantee is that it must see the state asserted by an OOM when\n\t * this function is called as a result of userland actions\n\t * triggered by the notification of the OOM.  This is trivially\n\t * achieved by invoking mem_cgroup_mark_under_oom() before\n\t * triggering notification.\n\t */\n\tif (memcg && memcg->under_oom)\n\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}"
  },
  {
    "function_name": "memcg_oom_wake_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1630-1644",
    "snippet": "static int memcg_oom_wake_function(wait_queue_entry_t *wait,\n\tunsigned mode, int sync, void *arg)\n{\n\tstruct mem_cgroup *wake_memcg = (struct mem_cgroup *)arg;\n\tstruct mem_cgroup *oom_wait_memcg;\n\tstruct oom_wait_info *oom_wait_info;\n\n\toom_wait_info = container_of(wait, struct oom_wait_info, wait);\n\toom_wait_memcg = oom_wait_info->memcg;\n\n\tif (!mem_cgroup_is_descendant(wake_memcg, oom_wait_memcg) &&\n\t    !mem_cgroup_is_descendant(oom_wait_memcg, wake_memcg))\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, arg);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "autoremove_wake_function",
          "args": [
            "wait",
            "mode",
            "sync",
            "arg"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_descendant",
          "args": [
            "oom_wait_memcg",
            "wake_memcg"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_descendant",
          "args": [
            "wake_memcg",
            "oom_wait_memcg"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structoom_wait_info",
            "wait"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_oom_wake_function(wait_queue_entry_t *wait,\n\tunsigned mode, int sync, void *arg)\n{\n\tstruct mem_cgroup *wake_memcg = (struct mem_cgroup *)arg;\n\tstruct mem_cgroup *oom_wait_memcg;\n\tstruct oom_wait_info *oom_wait_info;\n\n\toom_wait_info = container_of(wait, struct oom_wait_info, wait);\n\toom_wait_memcg = oom_wait_info->memcg;\n\n\tif (!mem_cgroup_is_descendant(wake_memcg, oom_wait_memcg) &&\n\t    !mem_cgroup_is_descendant(oom_wait_memcg, wake_memcg))\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, arg);\n}"
  },
  {
    "function_name": "mem_cgroup_unmark_under_oom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1608-1621",
    "snippet": "static void mem_cgroup_unmark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\t/*\n\t * When a new child is created while the hierarchy is under oom,\n\t * mem_cgroup_oom_lock() may not be called. Watch for underflow.\n\t */\n\tspin_lock(&memcg_oom_lock);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tif (iter->under_oom > 0)\n\t\t\titer->under_oom--;\n\tspin_unlock(&memcg_oom_lock);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_SPINLOCK(memcg_oom_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "iter",
            "memcg"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic void mem_cgroup_unmark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\t/*\n\t * When a new child is created while the hierarchy is under oom,\n\t * mem_cgroup_oom_lock() may not be called. Watch for underflow.\n\t */\n\tspin_lock(&memcg_oom_lock);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tif (iter->under_oom > 0)\n\t\t\titer->under_oom--;\n\tspin_unlock(&memcg_oom_lock);\n}"
  },
  {
    "function_name": "mem_cgroup_mark_under_oom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1598-1606",
    "snippet": "static void mem_cgroup_mark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tspin_lock(&memcg_oom_lock);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\titer->under_oom++;\n\tspin_unlock(&memcg_oom_lock);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_SPINLOCK(memcg_oom_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "iter",
            "memcg"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic void mem_cgroup_mark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tspin_lock(&memcg_oom_lock);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\titer->under_oom++;\n\tspin_unlock(&memcg_oom_lock);\n}"
  },
  {
    "function_name": "mem_cgroup_oom_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1587-1596",
    "snippet": "static void mem_cgroup_oom_unlock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tspin_lock(&memcg_oom_lock);\n\tmutex_release(&memcg_oom_lock_dep_map, 1, _RET_IP_);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\titer->oom_lock = false;\n\tspin_unlock(&memcg_oom_lock);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_SPINLOCK(memcg_oom_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "iter",
            "memcg"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_release",
          "args": [
            "&memcg_oom_lock_dep_map",
            "1",
            "_RET_IP_"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic void mem_cgroup_oom_unlock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tspin_lock(&memcg_oom_lock);\n\tmutex_release(&memcg_oom_lock_dep_map, 1, _RET_IP_);\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\titer->oom_lock = false;\n\tspin_unlock(&memcg_oom_lock);\n}"
  },
  {
    "function_name": "mem_cgroup_oom_trylock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1548-1585",
    "snippet": "static bool mem_cgroup_oom_trylock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter, *failed = NULL;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tif (iter->oom_lock) {\n\t\t\t/*\n\t\t\t * this subtree of our hierarchy is already locked\n\t\t\t * so we cannot give a lock.\n\t\t\t */\n\t\t\tfailed = iter;\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t} else\n\t\t\titer->oom_lock = true;\n\t}\n\n\tif (failed) {\n\t\t/*\n\t\t * OK, we failed to lock the whole subtree so we have\n\t\t * to clean up what we set up to the failing subtree\n\t\t */\n\t\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\t\tif (iter == failed) {\n\t\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titer->oom_lock = false;\n\t\t}\n\t} else\n\t\tmutex_acquire(&memcg_oom_lock_dep_map, 0, 1, _RET_IP_);\n\n\tspin_unlock(&memcg_oom_lock);\n\n\treturn !failed;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static DEFINE_SPINLOCK(memcg_oom_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_acquire",
          "args": [
            "&memcg_oom_lock_dep_map",
            "0",
            "1",
            "_RET_IP_"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_iter_break",
          "args": [
            "memcg",
            "iter"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_iter_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1025-1032",
          "snippet": "void mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic __always_inline struct;\n\nvoid mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "iter",
            "memcg"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "iter",
            "memcg"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&memcg_oom_lock"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\n\nstatic bool mem_cgroup_oom_trylock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter, *failed = NULL;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tif (iter->oom_lock) {\n\t\t\t/*\n\t\t\t * this subtree of our hierarchy is already locked\n\t\t\t * so we cannot give a lock.\n\t\t\t */\n\t\t\tfailed = iter;\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t} else\n\t\t\titer->oom_lock = true;\n\t}\n\n\tif (failed) {\n\t\t/*\n\t\t * OK, we failed to lock the whole subtree so we have\n\t\t * to clean up what we set up to the failing subtree\n\t\t */\n\t\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\t\tif (iter == failed) {\n\t\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titer->oom_lock = false;\n\t\t}\n\t} else\n\t\tmutex_acquire(&memcg_oom_lock_dep_map, 0, 1, _RET_IP_);\n\n\tspin_unlock(&memcg_oom_lock);\n\n\treturn !failed;\n}"
  },
  {
    "function_name": "mem_cgroup_soft_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1485-1534",
    "snippet": "static int mem_cgroup_soft_reclaim(struct mem_cgroup *root_memcg,\n\t\t\t\t   pg_data_t *pgdat,\n\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t   unsigned long *total_scanned)\n{\n\tstruct mem_cgroup *victim = NULL;\n\tint total = 0;\n\tint loop = 0;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\tstruct mem_cgroup_reclaim_cookie reclaim = {\n\t\t.pgdat = pgdat,\n\t\t.priority = 0,\n\t};\n\n\texcess = soft_limit_excess(root_memcg);\n\n\twhile (1) {\n\t\tvictim = mem_cgroup_iter(root_memcg, victim, &reclaim);\n\t\tif (!victim) {\n\t\t\tloop++;\n\t\t\tif (loop >= 2) {\n\t\t\t\t/*\n\t\t\t\t * If we have not been able to reclaim\n\t\t\t\t * anything, it might because there are\n\t\t\t\t * no reclaimable pages under this hierarchy\n\t\t\t\t */\n\t\t\t\tif (!total)\n\t\t\t\t\tbreak;\n\t\t\t\t/*\n\t\t\t\t * We want to do more targeted reclaim.\n\t\t\t\t * excess >> 2 is not to excessive so as to\n\t\t\t\t * reclaim too much, nor too less that we keep\n\t\t\t\t * coming back to reclaim from this cgroup\n\t\t\t\t */\n\t\t\t\tif (total >= (excess >> 2) ||\n\t\t\t\t\t(loop > MEM_CGROUP_MAX_RECLAIM_LOOPS))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttotal += mem_cgroup_shrink_node(victim, gfp_mask, false,\n\t\t\t\t\tpgdat, &nr_scanned);\n\t\t*total_scanned += nr_scanned;\n\t\tif (!soft_limit_excess(root_memcg))\n\t\t\tbreak;\n\t}\n\tmem_cgroup_iter_break(root_memcg, victim);\n\treturn total;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define\tMEM_CGROUP_MAX_RECLAIM_LOOPS\t\t100"
    ],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_iter_break",
          "args": [
            "root_memcg",
            "victim"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_iter_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1025-1032",
          "snippet": "void mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic __always_inline struct;\n\nvoid mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "soft_limit_excess",
          "args": [
            "root_memcg"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "soft_limit_excess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "584-594",
          "snippet": "static unsigned long soft_limit_excess(struct mem_cgroup *memcg)\n{\n\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);\n\tunsigned long excess = 0;\n\n\tif (nr_pages > soft_limit)\n\t\texcess = nr_pages - soft_limit;\n\n\treturn excess;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long soft_limit_excess(struct mem_cgroup *memcg)\n{\n\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);\n\tunsigned long excess = 0;\n\n\tif (nr_pages > soft_limit)\n\t\texcess = nr_pages - soft_limit;\n\n\treturn excess;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_shrink_node",
          "args": [
            "victim",
            "gfp_mask",
            "false",
            "pgdat",
            "&nr_scanned"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_shrink_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3273-3309",
          "snippet": "unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,\n\t\t\t\t\t\tgfp_t gfp_mask, bool noswap,\n\t\t\t\t\t\tpg_data_t *pgdat,\n\t\t\t\t\t\tunsigned long *nr_scanned)\n{\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = SWAP_CLUSTER_MAX,\n\t\t.target_mem_cgroup = memcg,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.may_swap = !noswap,\n\t};\n\tunsigned long lru_pages;\n\n\tsc.gfp_mask = (gfp_mask & GFP_RECLAIM_MASK) |\n\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK);\n\n\ttrace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,\n\t\t\t\t\t\t      sc.may_writepage,\n\t\t\t\t\t\t      sc.gfp_mask,\n\t\t\t\t\t\t      sc.reclaim_idx);\n\n\t/*\n\t * NOTE: Although we can get the priority field, using it\n\t * here is not a good idea, since it limits the pages we can scan.\n\t * if we don't reclaim here, the shrink_node from balance_pgdat\n\t * will pick up pages from other mem cgroup's as well. We hack\n\t * the priority and make it zero.\n\t */\n\tshrink_node_memcg(pgdat, memcg, &sc, &lru_pages);\n\n\ttrace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);\n\n\t*nr_scanned = sc.nr_scanned;\n\treturn sc.nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,\n\t\t\t\t\t\tgfp_t gfp_mask, bool noswap,\n\t\t\t\t\t\tpg_data_t *pgdat,\n\t\t\t\t\t\tunsigned long *nr_scanned)\n{\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = SWAP_CLUSTER_MAX,\n\t\t.target_mem_cgroup = memcg,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.may_swap = !noswap,\n\t};\n\tunsigned long lru_pages;\n\n\tsc.gfp_mask = (gfp_mask & GFP_RECLAIM_MASK) |\n\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK);\n\n\ttrace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,\n\t\t\t\t\t\t      sc.may_writepage,\n\t\t\t\t\t\t      sc.gfp_mask,\n\t\t\t\t\t\t      sc.reclaim_idx);\n\n\t/*\n\t * NOTE: Although we can get the priority field, using it\n\t * here is not a good idea, since it limits the pages we can scan.\n\t * if we don't reclaim here, the shrink_node from balance_pgdat\n\t * will pick up pages from other mem cgroup's as well. We hack\n\t * the priority and make it zero.\n\t */\n\tshrink_node_memcg(pgdat, memcg, &sc, &lru_pages);\n\n\ttrace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);\n\n\t*nr_scanned = sc.nr_scanned;\n\treturn sc.nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_iter",
          "args": [
            "root_memcg",
            "victim",
            "&reclaim"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "910-1018",
          "snippet": "struct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define\tMEM_CGROUP_MAX_RECLAIM_LOOPS\t\t100\n\nstatic __always_inline struct;\n\nstatic int mem_cgroup_soft_reclaim(struct mem_cgroup *root_memcg,\n\t\t\t\t   pg_data_t *pgdat,\n\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t   unsigned long *total_scanned)\n{\n\tstruct mem_cgroup *victim = NULL;\n\tint total = 0;\n\tint loop = 0;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\tstruct mem_cgroup_reclaim_cookie reclaim = {\n\t\t.pgdat = pgdat,\n\t\t.priority = 0,\n\t};\n\n\texcess = soft_limit_excess(root_memcg);\n\n\twhile (1) {\n\t\tvictim = mem_cgroup_iter(root_memcg, victim, &reclaim);\n\t\tif (!victim) {\n\t\t\tloop++;\n\t\t\tif (loop >= 2) {\n\t\t\t\t/*\n\t\t\t\t * If we have not been able to reclaim\n\t\t\t\t * anything, it might because there are\n\t\t\t\t * no reclaimable pages under this hierarchy\n\t\t\t\t */\n\t\t\t\tif (!total)\n\t\t\t\t\tbreak;\n\t\t\t\t/*\n\t\t\t\t * We want to do more targeted reclaim.\n\t\t\t\t * excess >> 2 is not to excessive so as to\n\t\t\t\t * reclaim too much, nor too less that we keep\n\t\t\t\t * coming back to reclaim from this cgroup\n\t\t\t\t */\n\t\t\t\tif (total >= (excess >> 2) ||\n\t\t\t\t\t(loop > MEM_CGROUP_MAX_RECLAIM_LOOPS))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttotal += mem_cgroup_shrink_node(victim, gfp_mask, false,\n\t\t\t\t\tpgdat, &nr_scanned);\n\t\t*total_scanned += nr_scanned;\n\t\tif (!soft_limit_excess(root_memcg))\n\t\t\tbreak;\n\t}\n\tmem_cgroup_iter_break(root_memcg, victim);\n\treturn total;\n}"
  },
  {
    "function_name": "mem_cgroup_select_victim_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1479-1482",
    "snippet": "int mem_cgroup_select_victim_node(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_select_victim_node(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_select_victim_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1459-1477",
    "snippet": "int mem_cgroup_select_victim_node(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tmem_cgroup_may_update_nodemask(memcg);\n\tnode = memcg->last_scanned_node;\n\n\tnode = next_node_in(node, memcg->scan_nodes);\n\t/*\n\t * mem_cgroup_may_update_nodemask might have seen no reclaimmable pages\n\t * last time it really checked all the LRUs due to rate limiting.\n\t * Fallback to the current node in that case for simplicity.\n\t */\n\tif (unlikely(node == MAX_NUMNODES))\n\t\tnode = numa_node_id();\n\n\tmemcg->last_scanned_node = node;\n\treturn node;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "node == MAX_NUMNODES"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_node_in",
          "args": [
            "node",
            "memcg->scan_nodes"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_may_update_nodemask",
          "args": [
            "memcg"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_may_update_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1422-1445",
          "snippet": "static void mem_cgroup_may_update_nodemask(struct mem_cgroup *memcg)\n{\n\tint nid;\n\t/*\n\t * numainfo_events > 0 means there was at least NUMAINFO_EVENTS_TARGET\n\t * pagein/pageout changes since the last update.\n\t */\n\tif (!atomic_read(&memcg->numainfo_events))\n\t\treturn;\n\tif (atomic_inc_return(&memcg->numainfo_updating) > 1)\n\t\treturn;\n\n\t/* make a nodemask where this memcg uses memory from */\n\tmemcg->scan_nodes = node_states[N_MEMORY];\n\n\tfor_each_node_mask(nid, node_states[N_MEMORY]) {\n\n\t\tif (!test_mem_cgroup_node_reclaimable(memcg, nid, false))\n\t\t\tnode_clear(nid, memcg->scan_nodes);\n\t}\n\n\tatomic_set(&memcg->numainfo_events, 0);\n\tatomic_set(&memcg->numainfo_updating, 0);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define NUMAINFO_EVENTS_TARGET\t1024"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define NUMAINFO_EVENTS_TARGET\t1024\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_may_update_nodemask(struct mem_cgroup *memcg)\n{\n\tint nid;\n\t/*\n\t * numainfo_events > 0 means there was at least NUMAINFO_EVENTS_TARGET\n\t * pagein/pageout changes since the last update.\n\t */\n\tif (!atomic_read(&memcg->numainfo_events))\n\t\treturn;\n\tif (atomic_inc_return(&memcg->numainfo_updating) > 1)\n\t\treturn;\n\n\t/* make a nodemask where this memcg uses memory from */\n\tmemcg->scan_nodes = node_states[N_MEMORY];\n\n\tfor_each_node_mask(nid, node_states[N_MEMORY]) {\n\n\t\tif (!test_mem_cgroup_node_reclaimable(memcg, nid, false))\n\t\t\tnode_clear(nid, memcg->scan_nodes);\n\t}\n\n\tatomic_set(&memcg->numainfo_events, 0);\n\tatomic_set(&memcg->numainfo_updating, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_select_victim_node(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tmem_cgroup_may_update_nodemask(memcg);\n\tnode = memcg->last_scanned_node;\n\n\tnode = next_node_in(node, memcg->scan_nodes);\n\t/*\n\t * mem_cgroup_may_update_nodemask might have seen no reclaimmable pages\n\t * last time it really checked all the LRUs due to rate limiting.\n\t * Fallback to the current node in that case for simplicity.\n\t */\n\tif (unlikely(node == MAX_NUMNODES))\n\t\tnode = numa_node_id();\n\n\tmemcg->last_scanned_node = node;\n\treturn node;\n}"
  },
  {
    "function_name": "mem_cgroup_may_update_nodemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1422-1445",
    "snippet": "static void mem_cgroup_may_update_nodemask(struct mem_cgroup *memcg)\n{\n\tint nid;\n\t/*\n\t * numainfo_events > 0 means there was at least NUMAINFO_EVENTS_TARGET\n\t * pagein/pageout changes since the last update.\n\t */\n\tif (!atomic_read(&memcg->numainfo_events))\n\t\treturn;\n\tif (atomic_inc_return(&memcg->numainfo_updating) > 1)\n\t\treturn;\n\n\t/* make a nodemask where this memcg uses memory from */\n\tmemcg->scan_nodes = node_states[N_MEMORY];\n\n\tfor_each_node_mask(nid, node_states[N_MEMORY]) {\n\n\t\tif (!test_mem_cgroup_node_reclaimable(memcg, nid, false))\n\t\t\tnode_clear(nid, memcg->scan_nodes);\n\t}\n\n\tatomic_set(&memcg->numainfo_events, 0);\n\tatomic_set(&memcg->numainfo_updating, 0);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define NUMAINFO_EVENTS_TARGET\t1024"
    ],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&memcg->numainfo_updating",
            "0"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&memcg->numainfo_events",
            "0"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_clear",
          "args": [
            "nid",
            "memcg->scan_nodes"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_mem_cgroup_node_reclaimable",
          "args": [
            "memcg",
            "nid",
            "false"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "test_mem_cgroup_node_reclaimable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1403-1414",
          "snippet": "static bool test_mem_cgroup_node_reclaimable(struct mem_cgroup *memcg,\n\t\tint nid, bool noswap)\n{\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_FILE))\n\t\treturn true;\n\tif (noswap || !total_swap_pages)\n\t\treturn false;\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_ANON))\n\t\treturn true;\n\treturn false;\n\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic bool test_mem_cgroup_node_reclaimable(struct mem_cgroup *memcg,\n\t\tint nid, bool noswap)\n{\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_FILE))\n\t\treturn true;\n\tif (noswap || !total_swap_pages)\n\t\treturn false;\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_ANON))\n\t\treturn true;\n\treturn false;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_node_mask",
          "args": [
            "nid",
            "node_states[N_MEMORY]"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&memcg->numainfo_updating"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&memcg->numainfo_events"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define NUMAINFO_EVENTS_TARGET\t1024\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_may_update_nodemask(struct mem_cgroup *memcg)\n{\n\tint nid;\n\t/*\n\t * numainfo_events > 0 means there was at least NUMAINFO_EVENTS_TARGET\n\t * pagein/pageout changes since the last update.\n\t */\n\tif (!atomic_read(&memcg->numainfo_events))\n\t\treturn;\n\tif (atomic_inc_return(&memcg->numainfo_updating) > 1)\n\t\treturn;\n\n\t/* make a nodemask where this memcg uses memory from */\n\tmemcg->scan_nodes = node_states[N_MEMORY];\n\n\tfor_each_node_mask(nid, node_states[N_MEMORY]) {\n\n\t\tif (!test_mem_cgroup_node_reclaimable(memcg, nid, false))\n\t\t\tnode_clear(nid, memcg->scan_nodes);\n\t}\n\n\tatomic_set(&memcg->numainfo_events, 0);\n\tatomic_set(&memcg->numainfo_updating, 0);\n}"
  },
  {
    "function_name": "test_mem_cgroup_node_reclaimable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1403-1414",
    "snippet": "static bool test_mem_cgroup_node_reclaimable(struct mem_cgroup *memcg,\n\t\tint nid, bool noswap)\n{\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_FILE))\n\t\treturn true;\n\tif (noswap || !total_swap_pages)\n\t\treturn false;\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_ANON))\n\t\treturn true;\n\treturn false;\n\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_node_nr_lru_pages",
          "args": [
            "memcg",
            "nid",
            "LRU_ALL_ANON"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_node_nr_lru_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "721-736",
          "snippet": "unsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   int nid, unsigned int lru_mask)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(NODE_DATA(nid), memcg);\n\tunsigned long nr = 0;\n\tenum lru_list lru;\n\n\tVM_BUG_ON((unsigned)nid >= nr_node_ids);\n\n\tfor_each_lru(lru) {\n\t\tif (!(BIT(lru) & lru_mask))\n\t\t\tcontinue;\n\t\tnr += mem_cgroup_get_lru_size(lruvec, lru);\n\t}\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nunsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   int nid, unsigned int lru_mask)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(NODE_DATA(nid), memcg);\n\tunsigned long nr = 0;\n\tenum lru_list lru;\n\n\tVM_BUG_ON((unsigned)nid >= nr_node_ids);\n\n\tfor_each_lru(lru) {\n\t\tif (!(BIT(lru) & lru_mask))\n\t\t\tcontinue;\n\t\tnr += mem_cgroup_get_lru_size(lruvec, lru);\n\t}\n\treturn nr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic bool test_mem_cgroup_node_reclaimable(struct mem_cgroup *memcg,\n\t\tint nid, bool noswap)\n{\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_FILE))\n\t\treturn true;\n\tif (noswap || !total_swap_pages)\n\t\treturn false;\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_ANON))\n\t\treturn true;\n\treturn false;\n\n}"
  },
  {
    "function_name": "mem_cgroup_out_of_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1373-1389",
    "snippet": "static bool mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t\t\t     int order)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = NULL,\n\t\t.nodemask = NULL,\n\t\t.memcg = memcg,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tbool ret;\n\n\tmutex_lock(&oom_lock);\n\tret = out_of_memory(&oc);\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&oom_lock"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_of_memory",
          "args": [
            "&oc"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "out_of_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "1053-1123",
          "snippet": "bool out_of_memory(struct oom_control *oc)\n{\n\tunsigned long freed = 0;\n\tenum oom_constraint constraint = CONSTRAINT_NONE;\n\n\tif (oom_killer_disabled)\n\t\treturn false;\n\n\tif (!is_memcg_oom(oc)) {\n\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);\n\t\tif (freed > 0)\n\t\t\t/* Got some memory back in the last second. */\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If current has a pending SIGKILL or is exiting, then automatically\n\t * select it.  The goal is to allow it to allocate so that it may\n\t * quickly exit and free its memory.\n\t */\n\tif (task_will_free_mem(current)) {\n\t\tmark_oom_victim(current);\n\t\twake_oom_reaper(current);\n\t\treturn true;\n\t}\n\n\t/*\n\t * The OOM killer does not compensate for IO-less reclaim.\n\t * pagefault_out_of_memory lost its gfp context so we have to\n\t * make sure exclude 0 mask - all other users should have at least\n\t * ___GFP_DIRECT_RECLAIM to get here.\n\t */\n\tif (oc->gfp_mask && !(oc->gfp_mask & __GFP_FS))\n\t\treturn true;\n\n\t/*\n\t * Check if there were limitations on the allocation (only relevant for\n\t * NUMA and memcg) that may require different handling.\n\t */\n\tconstraint = constrained_alloc(oc);\n\tif (constraint != CONSTRAINT_MEMORY_POLICY)\n\t\toc->nodemask = NULL;\n\tcheck_panic_on_oom(oc, constraint);\n\n\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&\n\t    current->mm && !oom_unkillable_task(current, NULL, oc->nodemask) &&\n\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(current);\n\t\toc->chosen = current;\n\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");\n\t\treturn true;\n\t}\n\n\tselect_bad_process(oc);\n\t/* Found nothing?!?! */\n\tif (!oc->chosen) {\n\t\tdump_header(oc, NULL);\n\t\tpr_warn(\"Out of memory and no killable processes...\\n\");\n\t\t/*\n\t\t * If we got here due to an actual allocation at the\n\t\t * system level, we cannot survive this and will enter\n\t\t * an endless loop in the allocator. Bail out now.\n\t\t */\n\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))\n\t\t\tpanic(\"System is deadlocked on memory\\n\");\n\t}\n\tif (oc->chosen && oc->chosen != (void *)-1UL)\n\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\");\n\treturn !!oc->chosen;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_oom_kill_allocating_task;",
            "static bool oom_killer_disabled",
            "static BLOCKING_NOTIFIER_HEAD(oom_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_oom_kill_allocating_task;\nstatic bool oom_killer_disabled;\nstatic BLOCKING_NOTIFIER_HEAD(oom_notify_list);\n\nbool out_of_memory(struct oom_control *oc)\n{\n\tunsigned long freed = 0;\n\tenum oom_constraint constraint = CONSTRAINT_NONE;\n\n\tif (oom_killer_disabled)\n\t\treturn false;\n\n\tif (!is_memcg_oom(oc)) {\n\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);\n\t\tif (freed > 0)\n\t\t\t/* Got some memory back in the last second. */\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If current has a pending SIGKILL or is exiting, then automatically\n\t * select it.  The goal is to allow it to allocate so that it may\n\t * quickly exit and free its memory.\n\t */\n\tif (task_will_free_mem(current)) {\n\t\tmark_oom_victim(current);\n\t\twake_oom_reaper(current);\n\t\treturn true;\n\t}\n\n\t/*\n\t * The OOM killer does not compensate for IO-less reclaim.\n\t * pagefault_out_of_memory lost its gfp context so we have to\n\t * make sure exclude 0 mask - all other users should have at least\n\t * ___GFP_DIRECT_RECLAIM to get here.\n\t */\n\tif (oc->gfp_mask && !(oc->gfp_mask & __GFP_FS))\n\t\treturn true;\n\n\t/*\n\t * Check if there were limitations on the allocation (only relevant for\n\t * NUMA and memcg) that may require different handling.\n\t */\n\tconstraint = constrained_alloc(oc);\n\tif (constraint != CONSTRAINT_MEMORY_POLICY)\n\t\toc->nodemask = NULL;\n\tcheck_panic_on_oom(oc, constraint);\n\n\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&\n\t    current->mm && !oom_unkillable_task(current, NULL, oc->nodemask) &&\n\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(current);\n\t\toc->chosen = current;\n\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");\n\t\treturn true;\n\t}\n\n\tselect_bad_process(oc);\n\t/* Found nothing?!?! */\n\tif (!oc->chosen) {\n\t\tdump_header(oc, NULL);\n\t\tpr_warn(\"Out of memory and no killable processes...\\n\");\n\t\t/*\n\t\t * If we got here due to an actual allocation at the\n\t\t * system level, we cannot survive this and will enter\n\t\t * an endless loop in the allocator. Bail out now.\n\t\t */\n\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))\n\t\t\tpanic(\"System is deadlocked on memory\\n\");\n\t}\n\tif (oc->chosen && oc->chosen != (void *)-1UL)\n\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\");\n\treturn !!oc->chosen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&oom_lock"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic bool mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t\t\t     int order)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = NULL,\n\t\t.nodemask = NULL,\n\t\t.memcg = memcg,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tbool ret;\n\n\tmutex_lock(&oom_lock);\n\tret = out_of_memory(&oc);\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "mem_cgroup_get_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1356-1371",
    "snippet": "unsigned long mem_cgroup_get_max(struct mem_cgroup *memcg)\n{\n\tunsigned long max;\n\n\tmax = memcg->memory.max;\n\tif (mem_cgroup_swappiness(memcg)) {\n\t\tunsigned long memsw_max;\n\t\tunsigned long swap_max;\n\n\t\tmemsw_max = memcg->memsw.max;\n\t\tswap_max = memcg->swap.max;\n\t\tswap_max = min(swap_max, (unsigned long)total_swap_pages);\n\t\tmax = min(max + swap_max, memsw_max);\n\t}\n\treturn max;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max + swap_max",
            "memsw_max"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "memory_min_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5342-5353",
          "snippet": "static int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_swappiness",
          "args": [
            "memcg"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nunsigned long mem_cgroup_get_max(struct mem_cgroup *memcg)\n{\n\tunsigned long max;\n\n\tmax = memcg->memory.max;\n\tif (mem_cgroup_swappiness(memcg)) {\n\t\tunsigned long memsw_max;\n\t\tunsigned long swap_max;\n\n\t\tmemsw_max = memcg->memsw.max;\n\t\tswap_max = memcg->swap.max;\n\t\tswap_max = min(swap_max, (unsigned long)total_swap_pages);\n\t\tmax = min(max + swap_max, memsw_max);\n\t}\n\treturn max;\n}"
  },
  {
    "function_name": "mem_cgroup_print_oom_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1303-1351",
    "snippet": "void mem_cgroup_print_oom_info(struct mem_cgroup *memcg, struct task_struct *p)\n{\n\tstruct mem_cgroup *iter;\n\tunsigned int i;\n\n\trcu_read_lock();\n\n\tif (p) {\n\t\tpr_info(\"Task in \");\n\t\tpr_cont_cgroup_path(task_cgroup(p, memory_cgrp_id));\n\t\tpr_cont(\" killed as a result of limit of \");\n\t} else {\n\t\tpr_info(\"Memory limit reached of cgroup \");\n\t}\n\n\tpr_cont_cgroup_path(memcg->css.cgroup);\n\tpr_cont(\"\\n\");\n\n\trcu_read_unlock();\n\n\tpr_info(\"memory: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->memory)),\n\t\tK((u64)memcg->memory.max), memcg->memory.failcnt);\n\tpr_info(\"memory+swap: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->memsw)),\n\t\tK((u64)memcg->memsw.max), memcg->memsw.failcnt);\n\tpr_info(\"kmem: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->kmem)),\n\t\tK((u64)memcg->kmem.max), memcg->kmem.failcnt);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tpr_info(\"Memory cgroup stats for \");\n\t\tpr_cont_cgroup_path(iter->css.cgroup);\n\t\tpr_cont(\":\");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(memcg1_stats); i++) {\n\t\t\tif (memcg1_stats[i] == MEMCG_SWAP && !do_swap_account)\n\t\t\t\tcontinue;\n\t\t\tpr_cont(\" %s:%luKB\", memcg1_stat_names[i],\n\t\t\t\tK(memcg_page_state(iter, memcg1_stats[i])));\n\t\t}\n\n\t\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\t\tpr_cont(\" %s:%luKB\", mem_cgroup_lru_names[i],\n\t\t\t\tK(mem_cgroup_nr_lru_pages(iter, BIT(i))));\n\n\t\tpr_cont(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define do_swap_account\t\t0"
    ],
    "globals_used": [
      "static const char *const mem_cgroup_lru_names[] = {\n\t\"inactive_anon\",\n\t\"active_anon\",\n\t\"inactive_file\",\n\t\"active_file\",\n\t\"unevictable\",\n};",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "static const unsigned int memcg1_stats[] = {\n\tMEMCG_CACHE,\n\tMEMCG_RSS,\n\tMEMCG_RSS_HUGE,\n\tNR_SHMEM,\n\tNR_FILE_MAPPED,\n\tNR_FILE_DIRTY,\n\tNR_WRITEBACK,\n\tMEMCG_SWAP,\n};",
      "static const char *const memcg1_stat_names[] = {\n\t\"cache\",\n\t\"rss\",\n\t\"rss_huge\",\n\t\"shmem\",\n\t\"mapped_file\",\n\t\"dirty\",\n\t\"writeback\",\n\t\"swap\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %s:%luKB\"",
            "mem_cgroup_lru_names[i]",
            "K(mem_cgroup_nr_lru_pages(iter, BIT(i)))"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "mem_cgroup_nr_lru_pages(iter, BIT(i))"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nr_lru_pages",
          "args": [
            "iter",
            "BIT(i)"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_nr_lru_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "738-747",
          "snippet": "static unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "i"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %s:%luKB\"",
            "memcg1_stat_names[i]",
            "K(memcg_page_state(iter, memcg1_stats[i]))"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "memcg_page_state(iter, memcg1_stats[i])"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_page_state",
          "args": [
            "iter",
            "memcg1_stats[i]"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "memcg1_stats"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\":\""
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont_cgroup_path",
          "args": [
            "iter->css.cgroup"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Memory cgroup stats for \""
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "iter",
            "memcg"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kmem: usage %llukB, limit %llukB, failcnt %lu\\n\"",
            "K((u64)page_counter_read(&memcg->kmem))",
            "K((u64)memcg->kmem.max)",
            "memcg->kmem.failcnt"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "(u64)memcg->kmem.max"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "(u64)page_counter_read(&memcg->kmem)"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->kmem"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"memory+swap: usage %llukB, limit %llukB, failcnt %lu\\n\"",
            "K((u64)page_counter_read(&memcg->memsw))",
            "K((u64)memcg->memsw.max)",
            "memcg->memsw.failcnt"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "(u64)memcg->memsw.max"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "(u64)page_counter_read(&memcg->memsw)"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memsw"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"memory: usage %llukB, limit %llukB, failcnt %lu\\n\"",
            "K((u64)page_counter_read(&memcg->memory))",
            "K((u64)memcg->memory.max)",
            "memcg->memory.failcnt"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "(u64)memcg->memory.max"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "(u64)page_counter_read(&memcg->memory)"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont_cgroup_path",
          "args": [
            "memcg->css.cgroup"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Memory limit reached of cgroup \""
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" killed as a result of limit of \""
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont_cgroup_path",
          "args": [
            "task_cgroup(p, memory_cgrp_id)"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cgroup",
          "args": [
            "p",
            "memory_cgrp_id"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Task in \""
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstatic const char *const mem_cgroup_lru_names[] = {\n\t\"inactive_anon\",\n\t\"active_anon\",\n\t\"inactive_file\",\n\t\"active_file\",\n\t\"unevictable\",\n};\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic const unsigned int memcg1_stats[] = {\n\tMEMCG_CACHE,\n\tMEMCG_RSS,\n\tMEMCG_RSS_HUGE,\n\tNR_SHMEM,\n\tNR_FILE_MAPPED,\n\tNR_FILE_DIRTY,\n\tNR_WRITEBACK,\n\tMEMCG_SWAP,\n};\nstatic const char *const memcg1_stat_names[] = {\n\t\"cache\",\n\t\"rss\",\n\t\"rss_huge\",\n\t\"shmem\",\n\t\"mapped_file\",\n\t\"dirty\",\n\t\"writeback\",\n\t\"swap\",\n};\n\nvoid mem_cgroup_print_oom_info(struct mem_cgroup *memcg, struct task_struct *p)\n{\n\tstruct mem_cgroup *iter;\n\tunsigned int i;\n\n\trcu_read_lock();\n\n\tif (p) {\n\t\tpr_info(\"Task in \");\n\t\tpr_cont_cgroup_path(task_cgroup(p, memory_cgrp_id));\n\t\tpr_cont(\" killed as a result of limit of \");\n\t} else {\n\t\tpr_info(\"Memory limit reached of cgroup \");\n\t}\n\n\tpr_cont_cgroup_path(memcg->css.cgroup);\n\tpr_cont(\"\\n\");\n\n\trcu_read_unlock();\n\n\tpr_info(\"memory: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->memory)),\n\t\tK((u64)memcg->memory.max), memcg->memory.failcnt);\n\tpr_info(\"memory+swap: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->memsw)),\n\t\tK((u64)memcg->memsw.max), memcg->memsw.failcnt);\n\tpr_info(\"kmem: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->kmem)),\n\t\tK((u64)memcg->kmem.max), memcg->kmem.failcnt);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tpr_info(\"Memory cgroup stats for \");\n\t\tpr_cont_cgroup_path(iter->css.cgroup);\n\t\tpr_cont(\":\");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(memcg1_stats); i++) {\n\t\t\tif (memcg1_stats[i] == MEMCG_SWAP && !do_swap_account)\n\t\t\t\tcontinue;\n\t\t\tpr_cont(\" %s:%luKB\", memcg1_stat_names[i],\n\t\t\t\tK(memcg_page_state(iter, memcg1_stats[i])));\n\t\t}\n\n\t\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\t\tpr_cont(\" %s:%luKB\", mem_cgroup_lru_names[i],\n\t\t\t\tK(mem_cgroup_nr_lru_pages(iter, BIT(i))));\n\n\t\tpr_cont(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "mem_cgroup_wait_acct_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1256-1270",
    "snippet": "static bool mem_cgroup_wait_acct_move(struct mem_cgroup *memcg)\n{\n\tif (mc.moving_task && current != mc.moving_task) {\n\t\tif (mem_cgroup_under_move(memcg)) {\n\t\t\tDEFINE_WAIT(wait);\n\t\t\tprepare_to_wait(&mc.waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t\t/* moving charge context might have finished. */\n\t\t\tif (mc.moving_task)\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&mc.waitq, &wait);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&mc.waitq",
            "&wait"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_schedule_balance_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "191-195",
          "snippet": "static void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool pcpu_async_enabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic bool pcpu_async_enabled;\n\nstatic void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&mc.waitq",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_under_move",
          "args": [
            "memcg"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_under_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1234-1254",
          "snippet": "static bool mem_cgroup_under_move(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tbool ret = false;\n\t/*\n\t * Unlike task_move routines, we access mc.to, mc.from not under\n\t * mutual exclusion by cgroup_mutex. Here, we take spinlock instead.\n\t */\n\tspin_lock(&mc.lock);\n\tfrom = mc.from;\n\tto = mc.to;\n\tif (!from)\n\t\tgoto unlock;\n\n\tret = mem_cgroup_is_descendant(from, memcg) ||\n\t\tmem_cgroup_is_descendant(to, memcg);\nunlock:\n\tspin_unlock(&mc.lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic bool mem_cgroup_under_move(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tbool ret = false;\n\t/*\n\t * Unlike task_move routines, we access mc.to, mc.from not under\n\t * mutual exclusion by cgroup_mutex. Here, we take spinlock instead.\n\t */\n\tspin_lock(&mc.lock);\n\tfrom = mc.from;\n\tto = mc.to;\n\tif (!from)\n\t\tgoto unlock;\n\n\tret = mem_cgroup_is_descendant(from, memcg) ||\n\t\tmem_cgroup_is_descendant(to, memcg);\nunlock:\n\tspin_unlock(&mc.lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic bool mem_cgroup_wait_acct_move(struct mem_cgroup *memcg)\n{\n\tif (mc.moving_task && current != mc.moving_task) {\n\t\tif (mem_cgroup_under_move(memcg)) {\n\t\t\tDEFINE_WAIT(wait);\n\t\t\tprepare_to_wait(&mc.waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t\t/* moving charge context might have finished. */\n\t\t\tif (mc.moving_task)\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&mc.waitq, &wait);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "mem_cgroup_under_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1234-1254",
    "snippet": "static bool mem_cgroup_under_move(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tbool ret = false;\n\t/*\n\t * Unlike task_move routines, we access mc.to, mc.from not under\n\t * mutual exclusion by cgroup_mutex. Here, we take spinlock instead.\n\t */\n\tspin_lock(&mc.lock);\n\tfrom = mc.from;\n\tto = mc.to;\n\tif (!from)\n\t\tgoto unlock;\n\n\tret = mem_cgroup_is_descendant(from, memcg) ||\n\t\tmem_cgroup_is_descendant(to, memcg);\nunlock:\n\tspin_unlock(&mc.lock);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mc.lock"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_descendant",
          "args": [
            "to",
            "memcg"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_descendant",
          "args": [
            "from",
            "memcg"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mc.lock"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mm_struct  *mm;\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long flags;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\nstatic __always_inline struct;\n\nstatic bool mem_cgroup_under_move(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tbool ret = false;\n\t/*\n\t * Unlike task_move routines, we access mc.to, mc.from not under\n\t * mutual exclusion by cgroup_mutex. Here, we take spinlock instead.\n\t */\n\tspin_lock(&mc.lock);\n\tfrom = mc.from;\n\tto = mc.to;\n\tif (!from)\n\t\tgoto unlock;\n\n\tret = mem_cgroup_is_descendant(from, memcg) ||\n\t\tmem_cgroup_is_descendant(to, memcg);\nunlock:\n\tspin_unlock(&mc.lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "mem_cgroup_margin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1204-1225",
    "snippet": "static unsigned long mem_cgroup_margin(struct mem_cgroup *memcg)\n{\n\tunsigned long margin = 0;\n\tunsigned long count;\n\tunsigned long limit;\n\n\tcount = page_counter_read(&memcg->memory);\n\tlimit = READ_ONCE(memcg->memory.max);\n\tif (count < limit)\n\t\tmargin = limit - count;\n\n\tif (do_memsw_account()) {\n\t\tcount = page_counter_read(&memcg->memsw);\n\t\tlimit = READ_ONCE(memcg->memsw.max);\n\t\tif (count <= limit)\n\t\t\tmargin = min(margin, limit - count);\n\t\telse\n\t\t\tmargin = 0;\n\t}\n\n\treturn margin;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "margin",
            "limit - count"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "memory_min_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5342-5353",
          "snippet": "static int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memory_min_show(struct seq_file *m, void *v)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\tunsigned long min = READ_ONCE(memcg->memory.min);\n\n\tif (min == PAGE_COUNTER_MAX)\n\t\tseq_puts(m, \"max\\n\");\n\telse\n\t\tseq_printf(m, \"%llu\\n\", (u64)min * PAGE_SIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "memcg->memsw.max"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memsw"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_memsw_account",
          "args": [],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "do_memsw_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "98-101",
          "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "memcg->memory.max"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long mem_cgroup_margin(struct mem_cgroup *memcg)\n{\n\tunsigned long margin = 0;\n\tunsigned long count;\n\tunsigned long limit;\n\n\tcount = page_counter_read(&memcg->memory);\n\tlimit = READ_ONCE(memcg->memory.max);\n\tif (count < limit)\n\t\tmargin = limit - count;\n\n\tif (do_memsw_account()) {\n\t\tcount = page_counter_read(&memcg->memsw);\n\t\tlimit = READ_ONCE(memcg->memsw.max);\n\t\tif (count <= limit)\n\t\t\tmargin = min(margin, limit - count);\n\t\telse\n\t\t\tmargin = 0;\n\t}\n\n\treturn margin;\n}"
  },
  {
    "function_name": "task_in_mem_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1171-1195",
    "snippet": "bool task_in_mem_cgroup(struct task_struct *task, struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *task_memcg;\n\tstruct task_struct *p;\n\tbool ret;\n\n\tp = find_lock_task_mm(task);\n\tif (p) {\n\t\ttask_memcg = get_mem_cgroup_from_mm(p->mm);\n\t\ttask_unlock(p);\n\t} else {\n\t\t/*\n\t\t * All threads may have already detached their mm's, but the oom\n\t\t * killer still needs to detect if they have already been oom\n\t\t * killed to prevent needlessly killing additional tasks.\n\t\t */\n\t\trcu_read_lock();\n\t\ttask_memcg = mem_cgroup_from_task(task);\n\t\tcss_get(&task_memcg->css);\n\t\trcu_read_unlock();\n\t}\n\tret = mem_cgroup_is_descendant(task_memcg, memcg);\n\tcss_put(&task_memcg->css);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&task_memcg->css"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_descendant",
          "args": [
            "task_memcg",
            "memcg"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "&task_memcg->css"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_task",
          "args": [
            "task"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_from_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "805-816",
          "snippet": "struct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "p"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mem_cgroup_from_mm",
          "args": [
            "p->mm"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "get_mem_cgroup_from_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "827-851",
          "snippet": "struct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdo {\n\t\t/*\n\t\t * Page cache insertions can happen withou an\n\t\t * actual mm context, e.g. during disk probing\n\t\t * on boot, loopback IO, acct() writes etc.\n\t\t */\n\t\tif (unlikely(!mm))\n\t\t\tmemcg = root_mem_cgroup;\n\t\telse {\n\t\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\t\tif (unlikely(!memcg))\n\t\t\t\tmemcg = root_mem_cgroup;\n\t\t}\n\t} while (!css_tryget_online(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdo {\n\t\t/*\n\t\t * Page cache insertions can happen withou an\n\t\t * actual mm context, e.g. during disk probing\n\t\t * on boot, loopback IO, acct() writes etc.\n\t\t */\n\t\tif (unlikely(!mm))\n\t\t\tmemcg = root_mem_cgroup;\n\t\telse {\n\t\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\t\tif (unlikely(!memcg))\n\t\t\t\tmemcg = root_mem_cgroup;\n\t\t}\n\t} while (!css_tryget_online(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lock_task_mm",
          "args": [
            "task"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_task_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "120-137",
          "snippet": "struct task_struct *find_lock_task_mm(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\trcu_read_lock();\n\n\tfor_each_thread(p, t) {\n\t\ttask_lock(t);\n\t\tif (likely(t->mm))\n\t\t\tgoto found;\n\t\ttask_unlock(t);\n\t}\n\tt = NULL;\nfound:\n\trcu_read_unlock();\n\n\treturn t;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstruct task_struct *find_lock_task_mm(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\trcu_read_lock();\n\n\tfor_each_thread(p, t) {\n\t\ttask_lock(t);\n\t\tif (likely(t->mm))\n\t\t\tgoto found;\n\t\ttask_unlock(t);\n\t}\n\tt = NULL;\nfound:\n\trcu_read_unlock();\n\n\treturn t;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nbool task_in_mem_cgroup(struct task_struct *task, struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *task_memcg;\n\tstruct task_struct *p;\n\tbool ret;\n\n\tp = find_lock_task_mm(task);\n\tif (p) {\n\t\ttask_memcg = get_mem_cgroup_from_mm(p->mm);\n\t\ttask_unlock(p);\n\t} else {\n\t\t/*\n\t\t * All threads may have already detached their mm's, but the oom\n\t\t * killer still needs to detect if they have already been oom\n\t\t * killed to prevent needlessly killing additional tasks.\n\t\t */\n\t\trcu_read_lock();\n\t\ttask_memcg = mem_cgroup_from_task(task);\n\t\tcss_get(&task_memcg->css);\n\t\trcu_read_unlock();\n\t}\n\tret = mem_cgroup_is_descendant(task_memcg, memcg);\n\tcss_put(&task_memcg->css);\n\treturn ret;\n}"
  },
  {
    "function_name": "mem_cgroup_update_lru_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1143-1169",
    "snippet": "void mem_cgroup_update_lru_size(struct lruvec *lruvec, enum lru_list lru,\n\t\t\t\tint zid, int nr_pages)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tunsigned long *lru_size;\n\tlong size;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tmz = container_of(lruvec, struct mem_cgroup_per_node, lruvec);\n\tlru_size = &mz->lru_zone_size[zid][lru];\n\n\tif (nr_pages < 0)\n\t\t*lru_size += nr_pages;\n\n\tsize = *lru_size;\n\tif (WARN_ONCE(size < 0,\n\t\t\"%s(%p, %d, %d): lru_size %ld\\n\",\n\t\t__func__, lruvec, lru, nr_pages, size)) {\n\t\tVM_BUG_ON(1);\n\t\t*lru_size = 0;\n\t}\n\n\tif (nr_pages > 0)\n\t\t*lru_size += nr_pages;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "1"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "size < 0",
            "\"%s(%p, %d, %d): lru_size %ld\\n\"",
            "__func__",
            "lruvec",
            "lru",
            "nr_pages",
            "size"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lruvec",
            "structmem_cgroup_per_node",
            "lruvec"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_update_lru_size(struct lruvec *lruvec, enum lru_list lru,\n\t\t\t\tint zid, int nr_pages)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tunsigned long *lru_size;\n\tlong size;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tmz = container_of(lruvec, struct mem_cgroup_per_node, lruvec);\n\tlru_size = &mz->lru_zone_size[zid][lru];\n\n\tif (nr_pages < 0)\n\t\t*lru_size += nr_pages;\n\n\tsize = *lru_size;\n\tif (WARN_ONCE(size < 0,\n\t\t\"%s(%p, %d, %d): lru_size %ld\\n\",\n\t\t__func__, lruvec, lru, nr_pages, size)) {\n\t\tVM_BUG_ON(1);\n\t\t*lru_size = 0;\n\t}\n\n\tif (nr_pages > 0)\n\t\t*lru_size += nr_pages;\n}"
  },
  {
    "function_name": "mem_cgroup_page_lruvec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1100-1130",
    "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lruvec->pgdat != pgdat"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_nodeinfo",
          "args": [
            "memcg",
            "page"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_nodeinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "499-505",
          "snippet": "static struct mem_cgroup_per_node *\nmem_cgroup_page_nodeinfo(struct mem_cgroup *memcg, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\n\treturn memcg->nodeinfo[nid];\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_per_node *\nmem_cgroup_page_nodeinfo(struct mem_cgroup *memcg, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\n\treturn memcg->nodeinfo[nid];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
  },
  {
    "function_name": "mem_cgroup_scan_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1067-1089",
    "snippet": "int mem_cgroup_scan_tasks(struct mem_cgroup *memcg,\n\t\t\t  int (*fn)(struct task_struct *, void *), void *arg)\n{\n\tstruct mem_cgroup *iter;\n\tint ret = 0;\n\n\tBUG_ON(memcg == root_mem_cgroup);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tstruct css_task_iter it;\n\t\tstruct task_struct *task;\n\n\t\tcss_task_iter_start(&iter->css, 0, &it);\n\t\twhile (!ret && (task = css_task_iter_next(&it)))\n\t\t\tret = fn(task, arg);\n\t\tcss_task_iter_end(&it);\n\t\tif (ret) {\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_iter_break",
          "args": [
            "memcg",
            "iter"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_iter_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1025-1032",
          "snippet": "void mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic __always_inline struct;\n\nvoid mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&it"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "task",
            "arg"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_in_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1328-1331",
          "snippet": "static inline bool __meminit early_pfn_in_nid(unsigned long pfn, int node)\n{\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool __meminit early_pfn_in_nid(unsigned long pfn, int node)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&it"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&iter->css",
            "0",
            "&it"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_cgroup_tree",
          "args": [
            "iter",
            "memcg"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "memcg == root_mem_cgroup"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_scan_tasks(struct mem_cgroup *memcg,\n\t\t\t  int (*fn)(struct task_struct *, void *), void *arg)\n{\n\tstruct mem_cgroup *iter;\n\tint ret = 0;\n\n\tBUG_ON(memcg == root_mem_cgroup);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tstruct css_task_iter it;\n\t\tstruct task_struct *task;\n\n\t\tcss_task_iter_start(&iter->css, 0, &it);\n\t\twhile (!ret && (task = css_task_iter_next(&it)))\n\t\t\tret = fn(task, arg);\n\t\tcss_task_iter_end(&it);\n\t\tif (ret) {\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "invalidate_reclaim_iterators",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1034-1052",
    "snippet": "static void invalidate_reclaim_iterators(struct mem_cgroup *dead_memcg)\n{\n\tstruct mem_cgroup *memcg = dead_memcg;\n\tstruct mem_cgroup_reclaim_iter *iter;\n\tstruct mem_cgroup_per_node *mz;\n\tint nid;\n\tint i;\n\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tfor_each_node(nid) {\n\t\t\tmz = mem_cgroup_nodeinfo(memcg, nid);\n\t\t\tfor (i = 0; i <= DEF_PRIORITY; i++) {\n\t\t\t\titer = &mz->iter[i];\n\t\t\t\tcmpxchg(&iter->position,\n\t\t\t\t\tdead_memcg, NULL);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&iter->position",
            "dead_memcg",
            "NULL"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "note_cmpxchg_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1992-2014",
          "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nodeinfo",
          "args": [
            "memcg",
            "nid"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void invalidate_reclaim_iterators(struct mem_cgroup *dead_memcg)\n{\n\tstruct mem_cgroup *memcg = dead_memcg;\n\tstruct mem_cgroup_reclaim_iter *iter;\n\tstruct mem_cgroup_per_node *mz;\n\tint nid;\n\tint i;\n\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tfor_each_node(nid) {\n\t\t\tmz = mem_cgroup_nodeinfo(memcg, nid);\n\t\t\tfor (i = 0; i <= DEF_PRIORITY; i++) {\n\t\t\t\titer = &mz->iter[i];\n\t\t\t\tcmpxchg(&iter->position,\n\t\t\t\t\tdead_memcg, NULL);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "mem_cgroup_iter_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "1025-1032",
    "snippet": "void mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&prev->css"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic __always_inline struct;\n\nvoid mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}"
  },
  {
    "function_name": "mem_cgroup_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "910-1018",
    "snippet": "struct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&prev->css"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&pos->css"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&iter->position",
            "pos",
            "memcg"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "note_cmpxchg_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1992-2014",
          "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tryget",
          "args": [
            "css"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_descendant_pre",
          "args": [
            "css",
            "&root->css"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget",
          "args": [
            "&pos->css"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "iter->position"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nodeinfo",
          "args": [
            "root",
            "reclaim->pgdat->node_id"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}"
  },
  {
    "function_name": "get_mem_cgroup_from_current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "879-891",
    "snippet": "mem_cgroup *get_mem_cgroup_from_current(void)\n{\n\tif (unlikely(current->active_memcg)) {\n\t\tstruct mem_cgroup *memcg = root_mem_cgroup;\n\n\t\trcu_read_lock();\n\t\tif (css_tryget_online(&current->active_memcg->css))\n\t\t\tmemcg = current->active_memcg;\n\t\trcu_read_unlock();\n\t\treturn memcg;\n\t}\n\treturn get_mem_cgroup_from_mm(current->mm);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_mem_cgroup_from_mm",
          "args": [
            "current->mm"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "get_mem_cgroup_from_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "827-851",
          "snippet": "struct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdo {\n\t\t/*\n\t\t * Page cache insertions can happen withou an\n\t\t * actual mm context, e.g. during disk probing\n\t\t * on boot, loopback IO, acct() writes etc.\n\t\t */\n\t\tif (unlikely(!mm))\n\t\t\tmemcg = root_mem_cgroup;\n\t\telse {\n\t\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\t\tif (unlikely(!memcg))\n\t\t\t\tmemcg = root_mem_cgroup;\n\t\t}\n\t} while (!css_tryget_online(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdo {\n\t\t/*\n\t\t * Page cache insertions can happen withou an\n\t\t * actual mm context, e.g. during disk probing\n\t\t * on boot, loopback IO, acct() writes etc.\n\t\t */\n\t\tif (unlikely(!mm))\n\t\t\tmemcg = root_mem_cgroup;\n\t\telse {\n\t\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\t\tif (unlikely(!memcg))\n\t\t\t\tmemcg = root_mem_cgroup;\n\t\t}\n\t} while (!css_tryget_online(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "&current->active_memcg->css"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->active_memcg"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nmem_cgroup *get_mem_cgroup_from_current(void)\n{\n\tif (unlikely(current->active_memcg)) {\n\t\tstruct mem_cgroup *memcg = root_mem_cgroup;\n\n\t\trcu_read_lock();\n\t\tif (css_tryget_online(&current->active_memcg->css))\n\t\t\tmemcg = current->active_memcg;\n\t\trcu_read_unlock();\n\t\treturn memcg;\n\t}\n\treturn get_mem_cgroup_from_mm(current->mm);\n}"
  },
  {
    "function_name": "get_mem_cgroup_from_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "861-873",
    "snippet": "struct mem_cgroup *get_mem_cgroup_from_page(struct page *page)\n{\n\tstruct mem_cgroup *memcg = page->mem_cgroup;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tif (!memcg || !css_tryget_online(&memcg->css))\n\t\tmemcg = root_mem_cgroup;\n\trcu_read_unlock();\n\treturn memcg;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "&memcg->css"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *get_mem_cgroup_from_page(struct page *page)\n{\n\tstruct mem_cgroup *memcg = page->mem_cgroup;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tif (!memcg || !css_tryget_online(&memcg->css))\n\t\tmemcg = root_mem_cgroup;\n\trcu_read_unlock();\n\treturn memcg;\n}"
  },
  {
    "function_name": "get_mem_cgroup_from_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "827-851",
    "snippet": "struct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdo {\n\t\t/*\n\t\t * Page cache insertions can happen withou an\n\t\t * actual mm context, e.g. during disk probing\n\t\t * on boot, loopback IO, acct() writes etc.\n\t\t */\n\t\tif (unlikely(!mm))\n\t\t\tmemcg = root_mem_cgroup;\n\t\telse {\n\t\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\t\tif (unlikely(!memcg))\n\t\t\t\tmemcg = root_mem_cgroup;\n\t\t}\n\t} while (!css_tryget_online(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "&memcg->css"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!memcg"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_task",
          "args": [
            "rcu_dereference(mm->owner)"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_from_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "805-816",
          "snippet": "struct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "mm->owner"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mm"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdo {\n\t\t/*\n\t\t * Page cache insertions can happen withou an\n\t\t * actual mm context, e.g. during disk probing\n\t\t * on boot, loopback IO, acct() writes etc.\n\t\t */\n\t\tif (unlikely(!mm))\n\t\t\tmemcg = root_mem_cgroup;\n\t\telse {\n\t\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\t\tif (unlikely(!memcg))\n\t\t\t\tmemcg = root_mem_cgroup;\n\t\t}\n\t} while (!css_tryget_online(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}"
  },
  {
    "function_name": "mem_cgroup_from_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "805-816",
    "snippet": "struct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "task_css(p, memory_cgrp_id)"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "p",
            "memory_cgrp_id"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn mem_cgroup_from_css(task_css(p, memory_cgrp_id));\n}"
  },
  {
    "function_name": "memcg_check_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "781-803",
    "snippet": "static void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&memcg->numainfo_events"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "do_numainfo"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_update_tree",
          "args": [
            "memcg",
            "page"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_update_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "596-631",
          "snippet": "static void mem_cgroup_update_tree(struct mem_cgroup *memcg, struct page *page)\n{\n\tunsigned long excess;\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup_tree_per_node *mctz;\n\n\tmctz = soft_limit_tree_from_page(page);\n\tif (!mctz)\n\t\treturn;\n\t/*\n\t * Necessary to update all ancestors when hierarchy is used.\n\t * because their event counter is not touched.\n\t */\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\t\texcess = soft_limit_excess(memcg);\n\t\t/*\n\t\t * We have to update the tree if mz is on RB-tree or\n\t\t * mem is over its softlimit.\n\t\t */\n\t\tif (excess || mz->on_tree) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&mctz->lock, flags);\n\t\t\t/* if on-tree, remove it */\n\t\t\tif (mz->on_tree)\n\t\t\t\t__mem_cgroup_remove_exceeded(mz, mctz);\n\t\t\t/*\n\t\t\t * Insert again. mz->usage_in_excess will be updated.\n\t\t\t * If excess is 0, no tree ops.\n\t\t\t */\n\t\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);\n\t\t\tspin_unlock_irqrestore(&mctz->lock, flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_update_tree(struct mem_cgroup *memcg, struct page *page)\n{\n\tunsigned long excess;\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup_tree_per_node *mctz;\n\n\tmctz = soft_limit_tree_from_page(page);\n\tif (!mctz)\n\t\treturn;\n\t/*\n\t * Necessary to update all ancestors when hierarchy is used.\n\t * because their event counter is not touched.\n\t */\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\t\texcess = soft_limit_excess(memcg);\n\t\t/*\n\t\t * We have to update the tree if mz is on RB-tree or\n\t\t * mem is over its softlimit.\n\t\t */\n\t\tif (excess || mz->on_tree) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&mctz->lock, flags);\n\t\t\t/* if on-tree, remove it */\n\t\t\tif (mz->on_tree)\n\t\t\t\t__mem_cgroup_remove_exceeded(mz, mctz);\n\t\t\t/*\n\t\t\t * Insert again. mz->usage_in_excess will be updated.\n\t\t\t * If excess is 0, no tree ops.\n\t\t\t */\n\t\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);\n\t\t\tspin_unlock_irqrestore(&mctz->lock, flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "do_softlimit"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_threshold",
          "args": [
            "memcg"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_threshold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3529-3538",
          "snippet": "static void mem_cgroup_threshold(struct mem_cgroup *memcg)\n{\n\twhile (memcg) {\n\t\t__mem_cgroup_threshold(memcg, false);\n\t\tif (do_memsw_account())\n\t\t\t__mem_cgroup_threshold(memcg, true);\n\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg)\n{\n\twhile (memcg) {\n\t\t__mem_cgroup_threshold(memcg, false);\n\t\tif (do_memsw_account())\n\t\t\t__mem_cgroup_threshold(memcg, true);\n\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_event_ratelimit",
          "args": [
            "memcg",
            "MEM_CGROUP_TARGET_NUMAINFO"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_event_ratelimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "749-775",
          "snippet": "static bool mem_cgroup_event_ratelimit(struct mem_cgroup *memcg,\n\t\t\t\t       enum mem_cgroup_events_target target)\n{\n\tunsigned long val, next;\n\n\tval = __this_cpu_read(memcg->stat_cpu->nr_page_events);\n\tnext = __this_cpu_read(memcg->stat_cpu->targets[target]);\n\t/* from time_after() in jiffies.h */\n\tif ((long)(next - val) < 0) {\n\t\tswitch (target) {\n\t\tcase MEM_CGROUP_TARGET_THRESH:\n\t\t\tnext = val + THRESHOLDS_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_SOFTLIMIT:\n\t\t\tnext = val + SOFTLIMIT_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_NUMAINFO:\n\t\t\tnext = val + NUMAINFO_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t__this_cpu_write(memcg->stat_cpu->targets[target], next);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define NUMAINFO_EVENTS_TARGET\t1024",
            "#define SOFTLIMIT_EVENTS_TARGET 1024",
            "#define THRESHOLDS_EVENTS_TARGET 128"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define NUMAINFO_EVENTS_TARGET\t1024\n#define SOFTLIMIT_EVENTS_TARGET 1024\n#define THRESHOLDS_EVENTS_TARGET 128\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic bool mem_cgroup_event_ratelimit(struct mem_cgroup *memcg,\n\t\t\t\t       enum mem_cgroup_events_target target)\n{\n\tunsigned long val, next;\n\n\tval = __this_cpu_read(memcg->stat_cpu->nr_page_events);\n\tnext = __this_cpu_read(memcg->stat_cpu->targets[target]);\n\t/* from time_after() in jiffies.h */\n\tif ((long)(next - val) < 0) {\n\t\tswitch (target) {\n\t\tcase MEM_CGROUP_TARGET_THRESH:\n\t\t\tnext = val + THRESHOLDS_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_SOFTLIMIT:\n\t\t\tnext = val + SOFTLIMIT_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_NUMAINFO:\n\t\t\tnext = val + NUMAINFO_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t__this_cpu_write(memcg->stat_cpu->targets[target], next);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t}\n}"
  },
  {
    "function_name": "mem_cgroup_event_ratelimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "749-775",
    "snippet": "static bool mem_cgroup_event_ratelimit(struct mem_cgroup *memcg,\n\t\t\t\t       enum mem_cgroup_events_target target)\n{\n\tunsigned long val, next;\n\n\tval = __this_cpu_read(memcg->stat_cpu->nr_page_events);\n\tnext = __this_cpu_read(memcg->stat_cpu->targets[target]);\n\t/* from time_after() in jiffies.h */\n\tif ((long)(next - val) < 0) {\n\t\tswitch (target) {\n\t\tcase MEM_CGROUP_TARGET_THRESH:\n\t\t\tnext = val + THRESHOLDS_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_SOFTLIMIT:\n\t\t\tnext = val + SOFTLIMIT_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_NUMAINFO:\n\t\t\tnext = val + NUMAINFO_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t__this_cpu_write(memcg->stat_cpu->targets[target], next);\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define NUMAINFO_EVENTS_TARGET\t1024",
      "#define SOFTLIMIT_EVENTS_TARGET 1024",
      "#define THRESHOLDS_EVENTS_TARGET 128"
    ],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "memcg->stat_cpu->targets[target]",
            "next"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "memcg->stat_cpu->targets[target]"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "memcg->stat_cpu->nr_page_events"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define NUMAINFO_EVENTS_TARGET\t1024\n#define SOFTLIMIT_EVENTS_TARGET 1024\n#define THRESHOLDS_EVENTS_TARGET 128\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic bool mem_cgroup_event_ratelimit(struct mem_cgroup *memcg,\n\t\t\t\t       enum mem_cgroup_events_target target)\n{\n\tunsigned long val, next;\n\n\tval = __this_cpu_read(memcg->stat_cpu->nr_page_events);\n\tnext = __this_cpu_read(memcg->stat_cpu->targets[target]);\n\t/* from time_after() in jiffies.h */\n\tif ((long)(next - val) < 0) {\n\t\tswitch (target) {\n\t\tcase MEM_CGROUP_TARGET_THRESH:\n\t\t\tnext = val + THRESHOLDS_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_SOFTLIMIT:\n\t\t\tnext = val + SOFTLIMIT_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_NUMAINFO:\n\t\t\tnext = val + NUMAINFO_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t__this_cpu_write(memcg->stat_cpu->targets[target], next);\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "mem_cgroup_nr_lru_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "738-747",
    "snippet": "static unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_node_nr_lru_pages",
          "args": [
            "memcg",
            "nid",
            "lru_mask"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_node_nr_lru_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "721-736",
          "snippet": "unsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   int nid, unsigned int lru_mask)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(NODE_DATA(nid), memcg);\n\tunsigned long nr = 0;\n\tenum lru_list lru;\n\n\tVM_BUG_ON((unsigned)nid >= nr_node_ids);\n\n\tfor_each_lru(lru) {\n\t\tif (!(BIT(lru) & lru_mask))\n\t\t\tcontinue;\n\t\tnr += mem_cgroup_get_lru_size(lruvec, lru);\n\t}\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nunsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   int nid, unsigned int lru_mask)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(NODE_DATA(nid), memcg);\n\tunsigned long nr = 0;\n\tenum lru_list lru;\n\n\tVM_BUG_ON((unsigned)nid >= nr_node_ids);\n\n\tfor_each_lru(lru) {\n\t\tif (!(BIT(lru) & lru_mask))\n\t\t\tcontinue;\n\t\tnr += mem_cgroup_get_lru_size(lruvec, lru);\n\t}\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tunsigned long nr = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tnr += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn nr;\n}"
  },
  {
    "function_name": "mem_cgroup_node_nr_lru_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "721-736",
    "snippet": "unsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   int nid, unsigned int lru_mask)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(NODE_DATA(nid), memcg);\n\tunsigned long nr = 0;\n\tenum lru_list lru;\n\n\tVM_BUG_ON((unsigned)nid >= nr_node_ids);\n\n\tfor_each_lru(lru) {\n\t\tif (!(BIT(lru) & lru_mask))\n\t\t\tcontinue;\n\t\tnr += mem_cgroup_get_lru_size(lruvec, lru);\n\t}\n\treturn nr;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_get_lru_size",
          "args": [
            "lruvec",
            "lru"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "lru"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "(unsigned)nid >= nr_node_ids"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_lruvec",
          "args": [
            "NODE_DATA(nid)",
            "memcg"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nunsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   int nid, unsigned int lru_mask)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(NODE_DATA(nid), memcg);\n\tunsigned long nr = 0;\n\tenum lru_list lru;\n\n\tVM_BUG_ON((unsigned)nid >= nr_node_ids);\n\n\tfor_each_lru(lru) {\n\t\tif (!(BIT(lru) & lru_mask))\n\t\t\tcontinue;\n\t\tnr += mem_cgroup_get_lru_size(lruvec, lru);\n\t}\n\treturn nr;\n}"
  },
  {
    "function_name": "mem_cgroup_charge_statistics",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "689-719",
    "snippet": "static void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t bool compound, int nr_pages)\n{\n\t/*\n\t * Here, RSS means 'mapped anon' and anon's SwapCache. Shmem/tmpfs is\n\t * counted as CACHE even if it's on ANON LRU.\n\t */\n\tif (PageAnon(page))\n\t\t__mod_memcg_state(memcg, MEMCG_RSS, nr_pages);\n\telse {\n\t\t__mod_memcg_state(memcg, MEMCG_CACHE, nr_pages);\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_memcg_state(memcg, NR_SHMEM, nr_pages);\n\t}\n\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t__mod_memcg_state(memcg, MEMCG_RSS_HUGE, nr_pages);\n\t}\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__count_memcg_events(memcg, PGPGIN, 1);\n\telse {\n\t\t__count_memcg_events(memcg, PGPGOUT, 1);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat_cpu->nr_page_events, nr_pages);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_add",
          "args": [
            "memcg->stat_cpu->nr_page_events",
            "nr_pages"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_memcg_events",
          "args": [
            "memcg",
            "PGPGOUT",
            "1"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_memcg_events",
          "args": [
            "memcg",
            "PGPGIN",
            "1"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "memcg",
            "MEMCG_RSS_HUGE",
            "nr_pages"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageTransHuge(page)",
            "page"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "memcg",
            "NR_SHMEM",
            "nr_pages"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "memcg",
            "MEMCG_CACHE",
            "nr_pages"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_memcg_state",
          "args": [
            "memcg",
            "MEMCG_RSS",
            "nr_pages"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t bool compound, int nr_pages)\n{\n\t/*\n\t * Here, RSS means 'mapped anon' and anon's SwapCache. Shmem/tmpfs is\n\t * counted as CACHE even if it's on ANON LRU.\n\t */\n\tif (PageAnon(page))\n\t\t__mod_memcg_state(memcg, MEMCG_RSS, nr_pages);\n\telse {\n\t\t__mod_memcg_state(memcg, MEMCG_CACHE, nr_pages);\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_memcg_state(memcg, NR_SHMEM, nr_pages);\n\t}\n\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t__mod_memcg_state(memcg, MEMCG_RSS_HUGE, nr_pages);\n\t}\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__count_memcg_events(memcg, PGPGIN, 1);\n\telse {\n\t\t__count_memcg_events(memcg, PGPGOUT, 1);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat_cpu->nr_page_events, nr_pages);\n}"
  },
  {
    "function_name": "memcg_sum_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "683-687",
    "snippet": "static unsigned long memcg_sum_events(struct mem_cgroup *memcg,\n\t\t\t\t      int event)\n{\n\treturn atomic_long_read(&memcg->events[event]);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&memcg->events[event]"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long memcg_sum_events(struct mem_cgroup *memcg,\n\t\t\t\t      int event)\n{\n\treturn atomic_long_read(&memcg->events[event]);\n}"
  },
  {
    "function_name": "mem_cgroup_largest_soft_limit_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "672-681",
    "snippet": "static struct mem_cgroup_per_node *\nmem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_node *mctz)\n{\n\tstruct mem_cgroup_per_node *mz;\n\n\tspin_lock_irq(&mctz->lock);\n\tmz = __mem_cgroup_largest_soft_limit_node(mctz);\n\tspin_unlock_irq(&mctz->lock);\n\treturn mz;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&mctz->lock"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_largest_soft_limit_node",
          "args": [
            "mctz"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_largest_soft_limit_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "647-670",
          "snippet": "static struct mem_cgroup_per_node *\n__mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_node *mctz)\n{\n\tstruct mem_cgroup_per_node *mz;\n\nretry:\n\tmz = NULL;\n\tif (!mctz->rb_rightmost)\n\t\tgoto done;\t\t/* Nothing to reclaim from */\n\n\tmz = rb_entry(mctz->rb_rightmost,\n\t\t      struct mem_cgroup_per_node, tree_node);\n\t/*\n\t * Remove the node now but someone else can add it back,\n\t * we will to add it back at the end of reclaim to its correct\n\t * position in the tree.\n\t */\n\t__mem_cgroup_remove_exceeded(mz, mctz);\n\tif (!soft_limit_excess(mz->memcg) ||\n\t    !css_tryget_online(&mz->memcg->css))\n\t\tgoto retry;\ndone:\n\treturn mz;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_per_node *\n__mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_node *mctz)\n{\n\tstruct mem_cgroup_per_node *mz;\n\nretry:\n\tmz = NULL;\n\tif (!mctz->rb_rightmost)\n\t\tgoto done;\t\t/* Nothing to reclaim from */\n\n\tmz = rb_entry(mctz->rb_rightmost,\n\t\t      struct mem_cgroup_per_node, tree_node);\n\t/*\n\t * Remove the node now but someone else can add it back,\n\t * we will to add it back at the end of reclaim to its correct\n\t * position in the tree.\n\t */\n\t__mem_cgroup_remove_exceeded(mz, mctz);\n\tif (!soft_limit_excess(mz->memcg) ||\n\t    !css_tryget_online(&mz->memcg->css))\n\t\tgoto retry;\ndone:\n\treturn mz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&mctz->lock"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_per_node *\nmem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_node *mctz)\n{\n\tstruct mem_cgroup_per_node *mz;\n\n\tspin_lock_irq(&mctz->lock);\n\tmz = __mem_cgroup_largest_soft_limit_node(mctz);\n\tspin_unlock_irq(&mctz->lock);\n\treturn mz;\n}"
  },
  {
    "function_name": "__mem_cgroup_largest_soft_limit_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "647-670",
    "snippet": "static struct mem_cgroup_per_node *\n__mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_node *mctz)\n{\n\tstruct mem_cgroup_per_node *mz;\n\nretry:\n\tmz = NULL;\n\tif (!mctz->rb_rightmost)\n\t\tgoto done;\t\t/* Nothing to reclaim from */\n\n\tmz = rb_entry(mctz->rb_rightmost,\n\t\t      struct mem_cgroup_per_node, tree_node);\n\t/*\n\t * Remove the node now but someone else can add it back,\n\t * we will to add it back at the end of reclaim to its correct\n\t * position in the tree.\n\t */\n\t__mem_cgroup_remove_exceeded(mz, mctz);\n\tif (!soft_limit_excess(mz->memcg) ||\n\t    !css_tryget_online(&mz->memcg->css))\n\t\tgoto retry;\ndone:\n\treturn mz;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "&mz->memcg->css"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "soft_limit_excess",
          "args": [
            "mz->memcg"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "soft_limit_excess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "584-594",
          "snippet": "static unsigned long soft_limit_excess(struct mem_cgroup *memcg)\n{\n\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);\n\tunsigned long excess = 0;\n\n\tif (nr_pages > soft_limit)\n\t\texcess = nr_pages - soft_limit;\n\n\treturn excess;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long soft_limit_excess(struct mem_cgroup *memcg)\n{\n\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);\n\tunsigned long excess = 0;\n\n\tif (nr_pages > soft_limit)\n\t\texcess = nr_pages - soft_limit;\n\n\treturn excess;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_remove_exceeded",
          "args": [
            "mz",
            "mctz"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_remove_exceeded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "561-572",
          "snippet": "static void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\n\tif (&mz->tree_node == mctz->rb_rightmost)\n\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);\n\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\n\tif (&mz->tree_node == mctz->rb_rightmost)\n\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);\n\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "mctz->rb_rightmost",
            "structmem_cgroup_per_node",
            "tree_node"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_per_node *\n__mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_node *mctz)\n{\n\tstruct mem_cgroup_per_node *mz;\n\nretry:\n\tmz = NULL;\n\tif (!mctz->rb_rightmost)\n\t\tgoto done;\t\t/* Nothing to reclaim from */\n\n\tmz = rb_entry(mctz->rb_rightmost,\n\t\t      struct mem_cgroup_per_node, tree_node);\n\t/*\n\t * Remove the node now but someone else can add it back,\n\t * we will to add it back at the end of reclaim to its correct\n\t * position in the tree.\n\t */\n\t__mem_cgroup_remove_exceeded(mz, mctz);\n\tif (!soft_limit_excess(mz->memcg) ||\n\t    !css_tryget_online(&mz->memcg->css))\n\t\tgoto retry;\ndone:\n\treturn mz;\n}"
  },
  {
    "function_name": "mem_cgroup_remove_from_trees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "633-645",
    "snippet": "static void mem_cgroup_remove_from_trees(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_tree_per_node *mctz;\n\tstruct mem_cgroup_per_node *mz;\n\tint nid;\n\n\tfor_each_node(nid) {\n\t\tmz = mem_cgroup_nodeinfo(memcg, nid);\n\t\tmctz = soft_limit_tree_node(nid);\n\t\tif (mctz)\n\t\t\tmem_cgroup_remove_exceeded(mz, mctz);\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_remove_exceeded",
          "args": [
            "mz",
            "mctz"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_remove_exceeded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "574-582",
          "snippet": "static void mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t       struct mem_cgroup_tree_per_node *mctz)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mctz->lock, flags);\n\t__mem_cgroup_remove_exceeded(mz, mctz);\n\tspin_unlock_irqrestore(&mctz->lock, flags);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t       struct mem_cgroup_tree_per_node *mctz)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mctz->lock, flags);\n\t__mem_cgroup_remove_exceeded(mz, mctz);\n\tspin_unlock_irqrestore(&mctz->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "soft_limit_tree_node",
          "args": [
            "nid"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "soft_limit_tree_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "507-511",
          "snippet": "static struct mem_cgroup_tree_per_node *\nsoft_limit_tree_node(int nid)\n{\n\treturn soft_limit_tree.rb_tree_per_node[nid];\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mem_cgroup_tree soft_limit_tree",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct mem_cgroup_tree soft_limit_tree;\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_tree_per_node *\nsoft_limit_tree_node(int nid)\n{\n\treturn soft_limit_tree.rb_tree_per_node[nid];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nodeinfo",
          "args": [
            "memcg",
            "nid"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_remove_from_trees(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_tree_per_node *mctz;\n\tstruct mem_cgroup_per_node *mz;\n\tint nid;\n\n\tfor_each_node(nid) {\n\t\tmz = mem_cgroup_nodeinfo(memcg, nid);\n\t\tmctz = soft_limit_tree_node(nid);\n\t\tif (mctz)\n\t\t\tmem_cgroup_remove_exceeded(mz, mctz);\n\t}\n}"
  },
  {
    "function_name": "mem_cgroup_update_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "596-631",
    "snippet": "static void mem_cgroup_update_tree(struct mem_cgroup *memcg, struct page *page)\n{\n\tunsigned long excess;\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup_tree_per_node *mctz;\n\n\tmctz = soft_limit_tree_from_page(page);\n\tif (!mctz)\n\t\treturn;\n\t/*\n\t * Necessary to update all ancestors when hierarchy is used.\n\t * because their event counter is not touched.\n\t */\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\t\texcess = soft_limit_excess(memcg);\n\t\t/*\n\t\t * We have to update the tree if mz is on RB-tree or\n\t\t * mem is over its softlimit.\n\t\t */\n\t\tif (excess || mz->on_tree) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&mctz->lock, flags);\n\t\t\t/* if on-tree, remove it */\n\t\t\tif (mz->on_tree)\n\t\t\t\t__mem_cgroup_remove_exceeded(mz, mctz);\n\t\t\t/*\n\t\t\t * Insert again. mz->usage_in_excess will be updated.\n\t\t\t * If excess is 0, no tree ops.\n\t\t\t */\n\t\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);\n\t\t\tspin_unlock_irqrestore(&mctz->lock, flags);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&mctz->lock",
            "flags"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_insert_exceeded",
          "args": [
            "mz",
            "mctz",
            "excess"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_insert_exceeded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "521-559",
          "snippet": "static void __mem_cgroup_insert_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz,\n\t\t\t\t\t unsigned long new_usage_in_excess)\n{\n\tstruct rb_node **p = &mctz->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct mem_cgroup_per_node *mz_node;\n\tbool rightmost = true;\n\n\tif (mz->on_tree)\n\t\treturn;\n\n\tmz->usage_in_excess = new_usage_in_excess;\n\tif (!mz->usage_in_excess)\n\t\treturn;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmz_node = rb_entry(parent, struct mem_cgroup_per_node,\n\t\t\t\t\ttree_node);\n\t\tif (mz->usage_in_excess < mz_node->usage_in_excess) {\n\t\t\tp = &(*p)->rb_left;\n\t\t\trightmost = false;\n\t\t}\n\n\t\t/*\n\t\t * We can't avoid mem cgroups that are over their soft\n\t\t * limit by the same amount\n\t\t */\n\t\telse if (mz->usage_in_excess >= mz_node->usage_in_excess)\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tif (rightmost)\n\t\tmctz->rb_rightmost = &mz->tree_node;\n\n\trb_link_node(&mz->tree_node, parent, p);\n\trb_insert_color(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_insert_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz,\n\t\t\t\t\t unsigned long new_usage_in_excess)\n{\n\tstruct rb_node **p = &mctz->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct mem_cgroup_per_node *mz_node;\n\tbool rightmost = true;\n\n\tif (mz->on_tree)\n\t\treturn;\n\n\tmz->usage_in_excess = new_usage_in_excess;\n\tif (!mz->usage_in_excess)\n\t\treturn;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmz_node = rb_entry(parent, struct mem_cgroup_per_node,\n\t\t\t\t\ttree_node);\n\t\tif (mz->usage_in_excess < mz_node->usage_in_excess) {\n\t\t\tp = &(*p)->rb_left;\n\t\t\trightmost = false;\n\t\t}\n\n\t\t/*\n\t\t * We can't avoid mem cgroups that are over their soft\n\t\t * limit by the same amount\n\t\t */\n\t\telse if (mz->usage_in_excess >= mz_node->usage_in_excess)\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tif (rightmost)\n\t\tmctz->rb_rightmost = &mz->tree_node;\n\n\trb_link_node(&mz->tree_node, parent, p);\n\trb_insert_color(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_remove_exceeded",
          "args": [
            "mz",
            "mctz"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_remove_exceeded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "561-572",
          "snippet": "static void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\n\tif (&mz->tree_node == mctz->rb_rightmost)\n\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);\n\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\n\tif (&mz->tree_node == mctz->rb_rightmost)\n\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);\n\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&mctz->lock",
            "flags"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "soft_limit_excess",
          "args": [
            "memcg"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "soft_limit_excess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "584-594",
          "snippet": "static unsigned long soft_limit_excess(struct mem_cgroup *memcg)\n{\n\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);\n\tunsigned long excess = 0;\n\n\tif (nr_pages > soft_limit)\n\t\texcess = nr_pages - soft_limit;\n\n\treturn excess;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long soft_limit_excess(struct mem_cgroup *memcg)\n{\n\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);\n\tunsigned long excess = 0;\n\n\tif (nr_pages > soft_limit)\n\t\texcess = nr_pages - soft_limit;\n\n\treturn excess;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_nodeinfo",
          "args": [
            "memcg",
            "page"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_nodeinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "499-505",
          "snippet": "static struct mem_cgroup_per_node *\nmem_cgroup_page_nodeinfo(struct mem_cgroup *memcg, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\n\treturn memcg->nodeinfo[nid];\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_per_node *\nmem_cgroup_page_nodeinfo(struct mem_cgroup *memcg, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\n\treturn memcg->nodeinfo[nid];\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "soft_limit_tree_from_page",
          "args": [
            "page"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "soft_limit_tree_from_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "513-519",
          "snippet": "static struct mem_cgroup_tree_per_node *\nsoft_limit_tree_from_page(struct page *page)\n{\n\tint nid = page_to_nid(page);\n\n\treturn soft_limit_tree.rb_tree_per_node[nid];\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mem_cgroup_tree soft_limit_tree",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct mem_cgroup_tree soft_limit_tree;\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_tree_per_node *\nsoft_limit_tree_from_page(struct page *page)\n{\n\tint nid = page_to_nid(page);\n\n\treturn soft_limit_tree.rb_tree_per_node[nid];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void mem_cgroup_update_tree(struct mem_cgroup *memcg, struct page *page)\n{\n\tunsigned long excess;\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup_tree_per_node *mctz;\n\n\tmctz = soft_limit_tree_from_page(page);\n\tif (!mctz)\n\t\treturn;\n\t/*\n\t * Necessary to update all ancestors when hierarchy is used.\n\t * because their event counter is not touched.\n\t */\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\t\texcess = soft_limit_excess(memcg);\n\t\t/*\n\t\t * We have to update the tree if mz is on RB-tree or\n\t\t * mem is over its softlimit.\n\t\t */\n\t\tif (excess || mz->on_tree) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&mctz->lock, flags);\n\t\t\t/* if on-tree, remove it */\n\t\t\tif (mz->on_tree)\n\t\t\t\t__mem_cgroup_remove_exceeded(mz, mctz);\n\t\t\t/*\n\t\t\t * Insert again. mz->usage_in_excess will be updated.\n\t\t\t * If excess is 0, no tree ops.\n\t\t\t */\n\t\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);\n\t\t\tspin_unlock_irqrestore(&mctz->lock, flags);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "soft_limit_excess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "584-594",
    "snippet": "static unsigned long soft_limit_excess(struct mem_cgroup *memcg)\n{\n\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);\n\tunsigned long excess = 0;\n\n\tif (nr_pages > soft_limit)\n\t\texcess = nr_pages - soft_limit;\n\n\treturn excess;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "memcg->soft_limit"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&memcg->memory"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic unsigned long soft_limit_excess(struct mem_cgroup *memcg)\n{\n\tunsigned long nr_pages = page_counter_read(&memcg->memory);\n\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);\n\tunsigned long excess = 0;\n\n\tif (nr_pages > soft_limit)\n\t\texcess = nr_pages - soft_limit;\n\n\treturn excess;\n}"
  },
  {
    "function_name": "mem_cgroup_remove_exceeded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "574-582",
    "snippet": "static void mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t       struct mem_cgroup_tree_per_node *mctz)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mctz->lock, flags);\n\t__mem_cgroup_remove_exceeded(mz, mctz);\n\tspin_unlock_irqrestore(&mctz->lock, flags);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&mctz->lock",
            "flags"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mem_cgroup_remove_exceeded",
          "args": [
            "mz",
            "mctz"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_cgroup_remove_exceeded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "561-572",
          "snippet": "static void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\n\tif (&mz->tree_node == mctz->rb_rightmost)\n\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);\n\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\n\tif (&mz->tree_node == mctz->rb_rightmost)\n\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);\n\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&mctz->lock",
            "flags"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t       struct mem_cgroup_tree_per_node *mctz)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mctz->lock, flags);\n\t__mem_cgroup_remove_exceeded(mz, mctz);\n\tspin_unlock_irqrestore(&mctz->lock, flags);\n}"
  },
  {
    "function_name": "__mem_cgroup_remove_exceeded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "561-572",
    "snippet": "static void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\n\tif (&mz->tree_node == mctz->rb_rightmost)\n\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);\n\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&mz->tree_node",
            "&mctz->rb_root"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "vma_rb_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "479-489",
          "snippet": "static __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&mz->tree_node"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\n\tif (&mz->tree_node == mctz->rb_rightmost)\n\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);\n\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}"
  },
  {
    "function_name": "__mem_cgroup_insert_exceeded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "521-559",
    "snippet": "static void __mem_cgroup_insert_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz,\n\t\t\t\t\t unsigned long new_usage_in_excess)\n{\n\tstruct rb_node **p = &mctz->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct mem_cgroup_per_node *mz_node;\n\tbool rightmost = true;\n\n\tif (mz->on_tree)\n\t\treturn;\n\n\tmz->usage_in_excess = new_usage_in_excess;\n\tif (!mz->usage_in_excess)\n\t\treturn;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmz_node = rb_entry(parent, struct mem_cgroup_per_node,\n\t\t\t\t\ttree_node);\n\t\tif (mz->usage_in_excess < mz_node->usage_in_excess) {\n\t\t\tp = &(*p)->rb_left;\n\t\t\trightmost = false;\n\t\t}\n\n\t\t/*\n\t\t * We can't avoid mem cgroups that are over their soft\n\t\t * limit by the same amount\n\t\t */\n\t\telse if (mz->usage_in_excess >= mz_node->usage_in_excess)\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tif (rightmost)\n\t\tmctz->rb_rightmost = &mz->tree_node;\n\n\trb_link_node(&mz->tree_node, parent, p);\n\trb_insert_color(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = true;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&mz->tree_node",
            "&mctz->rb_root"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&mz->tree_node",
            "parent",
            "p"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structmem_cgroup_per_node",
            "tree_node"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void __mem_cgroup_insert_exceeded(struct mem_cgroup_per_node *mz,\n\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz,\n\t\t\t\t\t unsigned long new_usage_in_excess)\n{\n\tstruct rb_node **p = &mctz->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct mem_cgroup_per_node *mz_node;\n\tbool rightmost = true;\n\n\tif (mz->on_tree)\n\t\treturn;\n\n\tmz->usage_in_excess = new_usage_in_excess;\n\tif (!mz->usage_in_excess)\n\t\treturn;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmz_node = rb_entry(parent, struct mem_cgroup_per_node,\n\t\t\t\t\ttree_node);\n\t\tif (mz->usage_in_excess < mz_node->usage_in_excess) {\n\t\t\tp = &(*p)->rb_left;\n\t\t\trightmost = false;\n\t\t}\n\n\t\t/*\n\t\t * We can't avoid mem cgroups that are over their soft\n\t\t * limit by the same amount\n\t\t */\n\t\telse if (mz->usage_in_excess >= mz_node->usage_in_excess)\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tif (rightmost)\n\t\tmctz->rb_rightmost = &mz->tree_node;\n\n\trb_link_node(&mz->tree_node, parent, p);\n\trb_insert_color(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = true;\n}"
  },
  {
    "function_name": "soft_limit_tree_from_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "513-519",
    "snippet": "static struct mem_cgroup_tree_per_node *\nsoft_limit_tree_from_page(struct page *page)\n{\n\tint nid = page_to_nid(page);\n\n\treturn soft_limit_tree.rb_tree_per_node[nid];\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mem_cgroup_tree soft_limit_tree",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct mem_cgroup_tree soft_limit_tree;\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_tree_per_node *\nsoft_limit_tree_from_page(struct page *page)\n{\n\tint nid = page_to_nid(page);\n\n\treturn soft_limit_tree.rb_tree_per_node[nid];\n}"
  },
  {
    "function_name": "soft_limit_tree_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "507-511",
    "snippet": "static struct mem_cgroup_tree_per_node *\nsoft_limit_tree_node(int nid)\n{\n\treturn soft_limit_tree.rb_tree_per_node[nid];\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mem_cgroup_tree soft_limit_tree",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic struct mem_cgroup_tree soft_limit_tree;\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_tree_per_node *\nsoft_limit_tree_node(int nid)\n{\n\treturn soft_limit_tree.rb_tree_per_node[nid];\n}"
  },
  {
    "function_name": "mem_cgroup_page_nodeinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "499-505",
    "snippet": "static struct mem_cgroup_per_node *\nmem_cgroup_page_nodeinfo(struct mem_cgroup *memcg, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\n\treturn memcg->nodeinfo[nid];\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup_per_node *\nmem_cgroup_page_nodeinfo(struct mem_cgroup *memcg, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\n\treturn memcg->nodeinfo[nid];\n}"
  },
  {
    "function_name": "page_cgroup_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "484-497",
    "snippet": "ino_t page_cgroup_ino(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned long ino = 0;\n\n\trcu_read_lock();\n\tmemcg = READ_ONCE(page->mem_cgroup);\n\twhile (memcg && !(memcg->css.flags & CSS_ONLINE))\n\t\tmemcg = parent_mem_cgroup(memcg);\n\tif (memcg)\n\t\tino = cgroup_ino(memcg->css.cgroup);\n\trcu_read_unlock();\n\treturn ino;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_ino",
          "args": [
            "memcg->css.cgroup"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "page_cgroup_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "484-497",
          "snippet": "ino_t page_cgroup_ino(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned long ino = 0;\n\n\trcu_read_lock();\n\tmemcg = READ_ONCE(page->mem_cgroup);\n\twhile (memcg && !(memcg->css.flags & CSS_ONLINE))\n\t\tmemcg = parent_mem_cgroup(memcg);\n\tif (memcg)\n\t\tino = cgroup_ino(memcg->css.cgroup);\n\trcu_read_unlock();\n\treturn ino;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page->mem_cgroup"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nino_t page_cgroup_ino(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned long ino = 0;\n\n\trcu_read_lock();\n\tmemcg = READ_ONCE(page->mem_cgroup);\n\twhile (memcg && !(memcg->css.flags & CSS_ONLINE))\n\t\tmemcg = parent_mem_cgroup(memcg);\n\tif (memcg)\n\t\tino = cgroup_ino(memcg->css.cgroup);\n\trcu_read_unlock();\n\treturn ino;\n}"
  },
  {
    "function_name": "mem_cgroup_css_from_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "459-469",
    "snippet": "struct cgroup_subsys_state *mem_cgroup_css_from_page(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\n\tmemcg = page->mem_cgroup;\n\n\tif (!memcg || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\tmemcg = root_mem_cgroup;\n\n\treturn &memcg->css;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstruct cgroup_subsys_state *mem_cgroup_css_from_page(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\n\tmemcg = page->mem_cgroup;\n\n\tif (!memcg || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\tmemcg = root_mem_cgroup;\n\n\treturn &memcg->css;\n}"
  },
  {
    "function_name": "memcg_free_shrinker_maps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "445-445",
    "snippet": "static void memcg_free_shrinker_maps(struct mem_cgroup *memcg) { }",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_free_shrinker_maps(struct mem_cgroup *memcg) { }"
  },
  {
    "function_name": "memcg_alloc_shrinker_maps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "441-444",
    "snippet": "static int memcg_alloc_shrinker_maps(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_alloc_shrinker_maps(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_set_shrinker_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "426-438",
    "snippet": "void memcg_set_shrinker_bit(struct mem_cgroup *memcg, int nid, int shrinker_id)\n{\n\tif (shrinker_id >= 0 && memcg && !mem_cgroup_is_root(memcg)) {\n\t\tstruct memcg_shrinker_map *map;\n\n\t\trcu_read_lock();\n\t\tmap = rcu_dereference(memcg->nodeinfo[nid]->shrinker_map);\n\t\t/* Pairs with smp mb in shrink_slab() */\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(shrinker_id, map->map);\n\t\trcu_read_unlock();\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "shrinker_id",
            "map->map"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "memcg->nodeinfo[nid]->shrinker_map"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid memcg_set_shrinker_bit(struct mem_cgroup *memcg, int nid, int shrinker_id)\n{\n\tif (shrinker_id >= 0 && memcg && !mem_cgroup_is_root(memcg)) {\n\t\tstruct memcg_shrinker_map *map;\n\n\t\trcu_read_lock();\n\t\tmap = rcu_dereference(memcg->nodeinfo[nid]->shrinker_map);\n\t\t/* Pairs with smp mb in shrink_slab() */\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(shrinker_id, map->map);\n\t\trcu_read_unlock();\n\t}\n}"
  },
  {
    "function_name": "memcg_expand_shrinker_maps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "398-424",
    "snippet": "int memcg_expand_shrinker_maps(int new_id)\n{\n\tint size, old_size, ret = 0;\n\tstruct mem_cgroup *memcg;\n\n\tsize = DIV_ROUND_UP(new_id + 1, BITS_PER_LONG) * sizeof(unsigned long);\n\told_size = memcg_shrinker_map_size;\n\tif (size <= old_size)\n\t\treturn 0;\n\n\tmutex_lock(&memcg_shrinker_map_mutex);\n\tif (!root_mem_cgroup)\n\t\tgoto unlock;\n\n\tfor_each_mem_cgroup(memcg) {\n\t\tif (mem_cgroup_is_root(memcg))\n\t\t\tcontinue;\n\t\tret = memcg_expand_one_shrinker_map(memcg, size, old_size);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\nunlock:\n\tif (!ret)\n\t\tmemcg_shrinker_map_size = size;\n\tmutex_unlock(&memcg_shrinker_map_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&memcg_shrinker_map_mutex"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_expand_one_shrinker_map",
          "args": [
            "memcg",
            "size",
            "old_size"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_expand_one_shrinker_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "326-354",
          "snippet": "static int memcg_expand_one_shrinker_map(struct mem_cgroup *memcg,\n\t\t\t\t\t int size, int old_size)\n{\n\tstruct memcg_shrinker_map *new, *old;\n\tint nid;\n\n\tlockdep_assert_held(&memcg_shrinker_map_mutex);\n\n\tfor_each_node(nid) {\n\t\told = rcu_dereference_protected(\n\t\t\tmem_cgroup_nodeinfo(memcg, nid)->shrinker_map, true);\n\t\t/* Not yet online memcg */\n\t\tif (!old)\n\t\t\treturn 0;\n\n\t\tnew = kvmalloc(sizeof(*new) + size, GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Set all old bits, clear all new bits */\n\t\tmemset(new->map, (int)0xff, old_size);\n\t\tmemset((void *)new->map + old_size, 0, size - old_size);\n\n\t\trcu_assign_pointer(memcg->nodeinfo[nid]->shrinker_map, new);\n\t\tcall_rcu(&old->rcu, memcg_free_shrinker_map_rcu);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_expand_one_shrinker_map(struct mem_cgroup *memcg,\n\t\t\t\t\t int size, int old_size)\n{\n\tstruct memcg_shrinker_map *new, *old;\n\tint nid;\n\n\tlockdep_assert_held(&memcg_shrinker_map_mutex);\n\n\tfor_each_node(nid) {\n\t\told = rcu_dereference_protected(\n\t\t\tmem_cgroup_nodeinfo(memcg, nid)->shrinker_map, true);\n\t\t/* Not yet online memcg */\n\t\tif (!old)\n\t\t\treturn 0;\n\n\t\tnew = kvmalloc(sizeof(*new) + size, GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Set all old bits, clear all new bits */\n\t\tmemset(new->map, (int)0xff, old_size);\n\t\tmemset((void *)new->map + old_size, 0, size - old_size);\n\n\t\trcu_assign_pointer(memcg->nodeinfo[nid]->shrinker_map, new);\n\t\tcall_rcu(&old->rcu, memcg_free_shrinker_map_rcu);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&memcg_shrinker_map_mutex"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "new_id + 1",
            "BITS_PER_LONG"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint memcg_expand_shrinker_maps(int new_id)\n{\n\tint size, old_size, ret = 0;\n\tstruct mem_cgroup *memcg;\n\n\tsize = DIV_ROUND_UP(new_id + 1, BITS_PER_LONG) * sizeof(unsigned long);\n\told_size = memcg_shrinker_map_size;\n\tif (size <= old_size)\n\t\treturn 0;\n\n\tmutex_lock(&memcg_shrinker_map_mutex);\n\tif (!root_mem_cgroup)\n\t\tgoto unlock;\n\n\tfor_each_mem_cgroup(memcg) {\n\t\tif (mem_cgroup_is_root(memcg))\n\t\t\tcontinue;\n\t\tret = memcg_expand_one_shrinker_map(memcg, size, old_size);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\nunlock:\n\tif (!ret)\n\t\tmemcg_shrinker_map_size = size;\n\tmutex_unlock(&memcg_shrinker_map_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "memcg_alloc_shrinker_maps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "374-396",
    "snippet": "static int memcg_alloc_shrinker_maps(struct mem_cgroup *memcg)\n{\n\tstruct memcg_shrinker_map *map;\n\tint nid, size, ret = 0;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\n\n\tmutex_lock(&memcg_shrinker_map_mutex);\n\tsize = memcg_shrinker_map_size;\n\tfor_each_node(nid) {\n\t\tmap = kvzalloc(sizeof(*map) + size, GFP_KERNEL);\n\t\tif (!map) {\n\t\t\tmemcg_free_shrinker_maps(memcg);\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\trcu_assign_pointer(memcg->nodeinfo[nid]->shrinker_map, map);\n\t}\n\tmutex_unlock(&memcg_shrinker_map_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&memcg_shrinker_map_mutex"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "memcg->nodeinfo[nid]->shrinker_map",
            "map"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_free_shrinker_maps",
          "args": [
            "memcg"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_free_shrinker_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "445-445",
          "snippet": "static void memcg_free_shrinker_maps(struct mem_cgroup *memcg) { }",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_free_shrinker_maps(struct mem_cgroup *memcg) { }"
        }
      },
      {
        "call_info": {
          "callee": "kvzalloc",
          "args": [
            "sizeof(*map) + size",
            "GFP_KERNEL"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&memcg_shrinker_map_mutex"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_alloc_shrinker_maps(struct mem_cgroup *memcg)\n{\n\tstruct memcg_shrinker_map *map;\n\tint nid, size, ret = 0;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn 0;\n\n\tmutex_lock(&memcg_shrinker_map_mutex);\n\tsize = memcg_shrinker_map_size;\n\tfor_each_node(nid) {\n\t\tmap = kvzalloc(sizeof(*map) + size, GFP_KERNEL);\n\t\tif (!map) {\n\t\t\tmemcg_free_shrinker_maps(memcg);\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\trcu_assign_pointer(memcg->nodeinfo[nid]->shrinker_map, map);\n\t}\n\tmutex_unlock(&memcg_shrinker_map_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "memcg_free_shrinker_maps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "356-372",
    "snippet": "static void memcg_free_shrinker_maps(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_per_node *pn;\n\tstruct memcg_shrinker_map *map;\n\tint nid;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn;\n\n\tfor_each_node(nid) {\n\t\tpn = mem_cgroup_nodeinfo(memcg, nid);\n\t\tmap = rcu_dereference_protected(pn->shrinker_map, true);\n\t\tif (map)\n\t\t\tkvfree(map);\n\t\trcu_assign_pointer(pn->shrinker_map, NULL);\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "pn->shrinker_map",
            "NULL"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "map"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "pn->shrinker_map",
            "true"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nodeinfo",
          "args": [
            "memcg",
            "nid"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic void memcg_free_shrinker_maps(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_per_node *pn;\n\tstruct memcg_shrinker_map *map;\n\tint nid;\n\n\tif (mem_cgroup_is_root(memcg))\n\t\treturn;\n\n\tfor_each_node(nid) {\n\t\tpn = mem_cgroup_nodeinfo(memcg, nid);\n\t\tmap = rcu_dereference_protected(pn->shrinker_map, true);\n\t\tif (map)\n\t\t\tkvfree(map);\n\t\trcu_assign_pointer(pn->shrinker_map, NULL);\n\t}\n}"
  },
  {
    "function_name": "memcg_expand_one_shrinker_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "326-354",
    "snippet": "static int memcg_expand_one_shrinker_map(struct mem_cgroup *memcg,\n\t\t\t\t\t int size, int old_size)\n{\n\tstruct memcg_shrinker_map *new, *old;\n\tint nid;\n\n\tlockdep_assert_held(&memcg_shrinker_map_mutex);\n\n\tfor_each_node(nid) {\n\t\told = rcu_dereference_protected(\n\t\t\tmem_cgroup_nodeinfo(memcg, nid)->shrinker_map, true);\n\t\t/* Not yet online memcg */\n\t\tif (!old)\n\t\t\treturn 0;\n\n\t\tnew = kvmalloc(sizeof(*new) + size, GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Set all old bits, clear all new bits */\n\t\tmemset(new->map, (int)0xff, old_size);\n\t\tmemset((void *)new->map + old_size, 0, size - old_size);\n\n\t\trcu_assign_pointer(memcg->nodeinfo[nid]->shrinker_map, new);\n\t\tcall_rcu(&old->rcu, memcg_free_shrinker_map_rcu);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&old->rcu",
            "memcg_free_shrinker_map_rcu"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "memcg->nodeinfo[nid]->shrinker_map",
            "new"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)new->map + old_size",
            "0",
            "size - old_size"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "sizeof(*new) + size",
            "GFP_KERNEL"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "mem_cgroup_nodeinfo(memcg, nid)->shrinker_map",
            "true"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nodeinfo",
          "args": [
            "memcg",
            "nid"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&memcg_shrinker_map_mutex"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic int memcg_expand_one_shrinker_map(struct mem_cgroup *memcg,\n\t\t\t\t\t int size, int old_size)\n{\n\tstruct memcg_shrinker_map *new, *old;\n\tint nid;\n\n\tlockdep_assert_held(&memcg_shrinker_map_mutex);\n\n\tfor_each_node(nid) {\n\t\told = rcu_dereference_protected(\n\t\t\tmem_cgroup_nodeinfo(memcg, nid)->shrinker_map, true);\n\t\t/* Not yet online memcg */\n\t\tif (!old)\n\t\t\treturn 0;\n\n\t\tnew = kvmalloc(sizeof(*new) + size, GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Set all old bits, clear all new bits */\n\t\tmemset(new->map, (int)0xff, old_size);\n\t\tmemset((void *)new->map + old_size, 0, size - old_size);\n\n\t\trcu_assign_pointer(memcg->nodeinfo[nid]->shrinker_map, new);\n\t\tcall_rcu(&old->rcu, memcg_free_shrinker_map_rcu);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_free_shrinker_map_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "321-324",
    "snippet": "static void memcg_free_shrinker_map_rcu(struct rcu_head *head)\n{\n\tkvfree(container_of(head, struct memcg_shrinker_map, rcu));\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstatic void memcg_free_shrinker_map_rcu(struct rcu_head *head)\n{\n\tkvfree(container_of(head, struct memcg_shrinker_map, rcu));\n}"
  },
  {
    "function_name": "memcg_put_cache_ids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "287-290",
    "snippet": "void memcg_put_cache_ids(void)\n{\n\tup_read(&memcg_cache_ids_sem);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&memcg_cache_ids_sem"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nvoid memcg_put_cache_ids(void)\n{\n\tup_read(&memcg_cache_ids_sem);\n}"
  },
  {
    "function_name": "memcg_get_cache_ids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "282-285",
    "snippet": "void memcg_get_cache_ids(void)\n{\n\tdown_read(&memcg_cache_ids_sem);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&memcg_cache_ids_sem"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nvoid memcg_get_cache_ids(void)\n{\n\tdown_read(&memcg_cache_ids_sem);\n}"
  },
  {
    "function_name": "vmpressure_to_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "259-262",
    "snippet": "struct cgroup_subsys_state *vmpressure_to_css(struct vmpressure *vmpr)\n{\n\treturn &container_of(vmpr, struct mem_cgroup, vmpressure)->css;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "vmpr",
            "structmem_cgroup",
            "vmpressure"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstruct cgroup_subsys_state *vmpressure_to_css(struct vmpressure *vmpr)\n{\n\treturn &container_of(vmpr, struct mem_cgroup, vmpressure)->css;\n}"
  },
  {
    "function_name": "memcg_to_vmpressure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "252-257",
    "snippet": "struct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg)\n{\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\treturn &memcg->vmpressure;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mem_cgroup *root_mem_cgroup",
      "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
      "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg)\n{\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\treturn &memcg->vmpressure;\n}"
  },
  {
    "function_name": "do_memsw_account",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
    "lines": "98-101",
    "snippet": "static bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include <linux/uaccess.h>",
      "#include \"slab.h\"",
      "#include <net/ip.h>",
      "#include <net/sock.h>",
      "#include \"internal.h\"",
      "#include <linux/tracehook.h>",
      "#include <linux/file.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/poll.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/limits.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/smp.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [
      "#define do_swap_account\t\t0"
    ],
    "globals_used": [
      "struct cgroup_subsys memory_cgrp_subsys",
      "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstatic bool do_memsw_account(void)\n{\n\treturn !cgroup_subsys_on_dfl(memory_cgrp_subsys) && do_swap_account;\n}"
  }
]