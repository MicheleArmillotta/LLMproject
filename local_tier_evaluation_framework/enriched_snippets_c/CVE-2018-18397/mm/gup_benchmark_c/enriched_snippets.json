[
  {
    "function_name": "gup_benchmark_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup_benchmark.c",
    "lines": "123-133",
    "snippet": "static int gup_benchmark_init(void)\n{\n\tvoid *ret;\n\n\tret = debugfs_create_file_unsafe(\"gup_benchmark\", 0600, NULL, NULL,\n\t\t\t&gup_benchmark_fops);\n\tif (!ret)\n\t\tpr_warn(\"Failed to create gup_benchmark in debugfs\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/debugfs.h>",
      "#include <linux/ktime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations gup_benchmark_fops = {\n\t.open = nonseekable_open,\n\t.unlocked_ioctl = gup_benchmark_ioctl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to create gup_benchmark in debugfs\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"gup_benchmark\"",
            "0600",
            "NULL",
            "NULL",
            "&gup_benchmark_fops"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/debugfs.h>\n#include <linux/ktime.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic const struct file_operations gup_benchmark_fops = {\n\t.open = nonseekable_open,\n\t.unlocked_ioctl = gup_benchmark_ioctl,\n};\n\nstatic int gup_benchmark_init(void)\n{\n\tvoid *ret;\n\n\tret = debugfs_create_file_unsafe(\"gup_benchmark\", 0600, NULL, NULL,\n\t\t\t&gup_benchmark_fops);\n\tif (!ret)\n\t\tpr_warn(\"Failed to create gup_benchmark in debugfs\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gup_benchmark_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup_benchmark.c",
    "lines": "90-116",
    "snippet": "static long gup_benchmark_ioctl(struct file *filep, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct gup_benchmark gup;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase GUP_FAST_BENCHMARK:\n\tcase GUP_LONGTERM_BENCHMARK:\n\tcase GUP_BENCHMARK:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&gup, (void __user *)arg, sizeof(gup)))\n\t\treturn -EFAULT;\n\n\tret = __gup_benchmark_ioctl(cmd, &gup);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user((void __user *)arg, &gup, sizeof(gup)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/debugfs.h>",
      "#include <linux/ktime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define GUP_BENCHMARK\t\t_IOWR('g', 3, struct gup_benchmark)",
      "#define GUP_LONGTERM_BENCHMARK\t_IOWR('g', 2, struct gup_benchmark)",
      "#define GUP_FAST_BENCHMARK\t_IOWR('g', 1, struct gup_benchmark)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void __user *)arg",
            "&gup",
            "sizeof(gup)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gup_benchmark_ioctl",
          "args": [
            "cmd",
            "&gup"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "__gup_benchmark_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup_benchmark.c",
          "lines": "22-88",
          "snippet": "static int __gup_benchmark_ioctl(unsigned int cmd,\n\t\tstruct gup_benchmark *gup)\n{\n\tktime_t start_time, end_time;\n\tunsigned long i, nr_pages, addr, next;\n\tint nr;\n\tstruct page **pages;\n\n\tif (gup->size > ULONG_MAX)\n\t\treturn -EINVAL;\n\n\tnr_pages = gup->size / PAGE_SIZE;\n\tpages = kvcalloc(nr_pages, sizeof(void *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tnr = gup->nr_pages_per_call;\n\tstart_time = ktime_get();\n\tfor (addr = gup->addr; addr < gup->addr + gup->size; addr = next) {\n\t\tif (nr != gup->nr_pages_per_call)\n\t\t\tbreak;\n\n\t\tnext = addr + nr * PAGE_SIZE;\n\t\tif (next > gup->addr + gup->size) {\n\t\t\tnext = gup->addr + gup->size;\n\t\t\tnr = (next - addr) / PAGE_SIZE;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase GUP_FAST_BENCHMARK:\n\t\t\tnr = get_user_pages_fast(addr, nr, gup->flags & 1,\n\t\t\t\t\t\t pages + i);\n\t\t\tbreak;\n\t\tcase GUP_LONGTERM_BENCHMARK:\n\t\t\tnr = get_user_pages_longterm(addr, nr, gup->flags & 1,\n\t\t\t\t\t\t     pages + i, NULL);\n\t\t\tbreak;\n\t\tcase GUP_BENCHMARK:\n\t\t\tnr = get_user_pages(addr, nr, gup->flags & 1, pages + i,\n\t\t\t\t\t    NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (nr <= 0)\n\t\t\tbreak;\n\t\ti += nr;\n\t}\n\tend_time = ktime_get();\n\n\tgup->get_delta_usec = ktime_us_delta(end_time, start_time);\n\tgup->size = addr - gup->addr;\n\n\tstart_time = ktime_get();\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (!pages[i])\n\t\t\tbreak;\n\t\tput_page(pages[i]);\n\t}\n\tend_time = ktime_get();\n\tgup->put_delta_usec = ktime_us_delta(end_time, start_time);\n\n\tkvfree(pages);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include <linux/ktime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define GUP_BENCHMARK\t\t_IOWR('g', 3, struct gup_benchmark)",
            "#define GUP_LONGTERM_BENCHMARK\t_IOWR('g', 2, struct gup_benchmark)",
            "#define GUP_FAST_BENCHMARK\t_IOWR('g', 1, struct gup_benchmark)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include <linux/ktime.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define GUP_BENCHMARK\t\t_IOWR('g', 3, struct gup_benchmark)\n#define GUP_LONGTERM_BENCHMARK\t_IOWR('g', 2, struct gup_benchmark)\n#define GUP_FAST_BENCHMARK\t_IOWR('g', 1, struct gup_benchmark)\n\nstatic int __gup_benchmark_ioctl(unsigned int cmd,\n\t\tstruct gup_benchmark *gup)\n{\n\tktime_t start_time, end_time;\n\tunsigned long i, nr_pages, addr, next;\n\tint nr;\n\tstruct page **pages;\n\n\tif (gup->size > ULONG_MAX)\n\t\treturn -EINVAL;\n\n\tnr_pages = gup->size / PAGE_SIZE;\n\tpages = kvcalloc(nr_pages, sizeof(void *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tnr = gup->nr_pages_per_call;\n\tstart_time = ktime_get();\n\tfor (addr = gup->addr; addr < gup->addr + gup->size; addr = next) {\n\t\tif (nr != gup->nr_pages_per_call)\n\t\t\tbreak;\n\n\t\tnext = addr + nr * PAGE_SIZE;\n\t\tif (next > gup->addr + gup->size) {\n\t\t\tnext = gup->addr + gup->size;\n\t\t\tnr = (next - addr) / PAGE_SIZE;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase GUP_FAST_BENCHMARK:\n\t\t\tnr = get_user_pages_fast(addr, nr, gup->flags & 1,\n\t\t\t\t\t\t pages + i);\n\t\t\tbreak;\n\t\tcase GUP_LONGTERM_BENCHMARK:\n\t\t\tnr = get_user_pages_longterm(addr, nr, gup->flags & 1,\n\t\t\t\t\t\t     pages + i, NULL);\n\t\t\tbreak;\n\t\tcase GUP_BENCHMARK:\n\t\t\tnr = get_user_pages(addr, nr, gup->flags & 1, pages + i,\n\t\t\t\t\t    NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (nr <= 0)\n\t\t\tbreak;\n\t\ti += nr;\n\t}\n\tend_time = ktime_get();\n\n\tgup->get_delta_usec = ktime_us_delta(end_time, start_time);\n\tgup->size = addr - gup->addr;\n\n\tstart_time = ktime_get();\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (!pages[i])\n\t\t\tbreak;\n\t\tput_page(pages[i]);\n\t}\n\tend_time = ktime_get();\n\tgup->put_delta_usec = ktime_us_delta(end_time, start_time);\n\n\tkvfree(pages);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&gup",
            "(void __user *)arg",
            "sizeof(gup)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/debugfs.h>\n#include <linux/ktime.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define GUP_BENCHMARK\t\t_IOWR('g', 3, struct gup_benchmark)\n#define GUP_LONGTERM_BENCHMARK\t_IOWR('g', 2, struct gup_benchmark)\n#define GUP_FAST_BENCHMARK\t_IOWR('g', 1, struct gup_benchmark)\n\nstatic long gup_benchmark_ioctl(struct file *filep, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct gup_benchmark gup;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase GUP_FAST_BENCHMARK:\n\tcase GUP_LONGTERM_BENCHMARK:\n\tcase GUP_BENCHMARK:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&gup, (void __user *)arg, sizeof(gup)))\n\t\treturn -EFAULT;\n\n\tret = __gup_benchmark_ioctl(cmd, &gup);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user((void __user *)arg, &gup, sizeof(gup)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__gup_benchmark_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup_benchmark.c",
    "lines": "22-88",
    "snippet": "static int __gup_benchmark_ioctl(unsigned int cmd,\n\t\tstruct gup_benchmark *gup)\n{\n\tktime_t start_time, end_time;\n\tunsigned long i, nr_pages, addr, next;\n\tint nr;\n\tstruct page **pages;\n\n\tif (gup->size > ULONG_MAX)\n\t\treturn -EINVAL;\n\n\tnr_pages = gup->size / PAGE_SIZE;\n\tpages = kvcalloc(nr_pages, sizeof(void *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tnr = gup->nr_pages_per_call;\n\tstart_time = ktime_get();\n\tfor (addr = gup->addr; addr < gup->addr + gup->size; addr = next) {\n\t\tif (nr != gup->nr_pages_per_call)\n\t\t\tbreak;\n\n\t\tnext = addr + nr * PAGE_SIZE;\n\t\tif (next > gup->addr + gup->size) {\n\t\t\tnext = gup->addr + gup->size;\n\t\t\tnr = (next - addr) / PAGE_SIZE;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase GUP_FAST_BENCHMARK:\n\t\t\tnr = get_user_pages_fast(addr, nr, gup->flags & 1,\n\t\t\t\t\t\t pages + i);\n\t\t\tbreak;\n\t\tcase GUP_LONGTERM_BENCHMARK:\n\t\t\tnr = get_user_pages_longterm(addr, nr, gup->flags & 1,\n\t\t\t\t\t\t     pages + i, NULL);\n\t\t\tbreak;\n\t\tcase GUP_BENCHMARK:\n\t\t\tnr = get_user_pages(addr, nr, gup->flags & 1, pages + i,\n\t\t\t\t\t    NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (nr <= 0)\n\t\t\tbreak;\n\t\ti += nr;\n\t}\n\tend_time = ktime_get();\n\n\tgup->get_delta_usec = ktime_us_delta(end_time, start_time);\n\tgup->size = addr - gup->addr;\n\n\tstart_time = ktime_get();\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (!pages[i])\n\t\t\tbreak;\n\t\tput_page(pages[i]);\n\t}\n\tend_time = ktime_get();\n\tgup->put_delta_usec = ktime_us_delta(end_time, start_time);\n\n\tkvfree(pages);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/debugfs.h>",
      "#include <linux/ktime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define GUP_BENCHMARK\t\t_IOWR('g', 3, struct gup_benchmark)",
      "#define GUP_LONGTERM_BENCHMARK\t_IOWR('g', 2, struct gup_benchmark)",
      "#define GUP_FAST_BENCHMARK\t_IOWR('g', 1, struct gup_benchmark)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "pages"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_us_delta",
          "args": [
            "end_time",
            "start_time"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pages[i]"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_us_delta",
          "args": [
            "end_time",
            "start_time"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages",
          "args": [
            "addr",
            "nr",
            "gup->flags & 1",
            "pages + i",
            "NULL"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_pages_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "172-177",
          "snippet": "long get_user_pages_locked(unsigned long start, unsigned long nr_pages,\n\t\t\t    unsigned int gup_flags, struct page **pages,\n\t\t\t    int *locked)\n{\n\treturn get_user_pages(start, nr_pages, gup_flags, pages, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nlong get_user_pages_locked(unsigned long start, unsigned long nr_pages,\n\t\t\t    unsigned int gup_flags, struct page **pages,\n\t\t\t    int *locked)\n{\n\treturn get_user_pages(start, nr_pages, gup_flags, pages, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_pages_longterm",
          "args": [
            "addr",
            "nr",
            "gup->flags & 1",
            "pages + i",
            "NULL"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_pages_longterm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1142-1189",
          "snippet": "long get_user_pages_longterm(unsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas_arg)\n{\n\tstruct vm_area_struct **vmas = vmas_arg;\n\tstruct vm_area_struct *vma_prev = NULL;\n\tlong rc, i;\n\n\tif (!pages)\n\t\treturn -EINVAL;\n\n\tif (!vmas) {\n\t\tvmas = kcalloc(nr_pages, sizeof(struct vm_area_struct *),\n\t\t\t       GFP_KERNEL);\n\t\tif (!vmas)\n\t\t\treturn -ENOMEM;\n\t}\n\n\trc = get_user_pages(start, nr_pages, gup_flags, pages, vmas);\n\n\tfor (i = 0; i < rc; i++) {\n\t\tstruct vm_area_struct *vma = vmas[i];\n\n\t\tif (vma == vma_prev)\n\t\t\tcontinue;\n\n\t\tvma_prev = vma;\n\n\t\tif (vma_is_fsdax(vma))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Either get_user_pages() failed, or the vma validation\n\t * succeeded, in either case we don't need to put_page() before\n\t * returning.\n\t */\n\tif (i >= rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < rc; i++)\n\t\tput_page(pages[i]);\n\trc = -EOPNOTSUPP;\nout:\n\tif (vmas != vmas_arg)\n\t\tkfree(vmas);\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong get_user_pages_longterm(unsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas_arg)\n{\n\tstruct vm_area_struct **vmas = vmas_arg;\n\tstruct vm_area_struct *vma_prev = NULL;\n\tlong rc, i;\n\n\tif (!pages)\n\t\treturn -EINVAL;\n\n\tif (!vmas) {\n\t\tvmas = kcalloc(nr_pages, sizeof(struct vm_area_struct *),\n\t\t\t       GFP_KERNEL);\n\t\tif (!vmas)\n\t\t\treturn -ENOMEM;\n\t}\n\n\trc = get_user_pages(start, nr_pages, gup_flags, pages, vmas);\n\n\tfor (i = 0; i < rc; i++) {\n\t\tstruct vm_area_struct *vma = vmas[i];\n\n\t\tif (vma == vma_prev)\n\t\t\tcontinue;\n\n\t\tvma_prev = vma;\n\n\t\tif (vma_is_fsdax(vma))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Either get_user_pages() failed, or the vma validation\n\t * succeeded, in either case we don't need to put_page() before\n\t * returning.\n\t */\n\tif (i >= rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < rc; i++)\n\t\tput_page(pages[i]);\n\trc = -EOPNOTSUPP;\nout:\n\tif (vmas != vmas_arg)\n\t\tkfree(vmas);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_pages_fast",
          "args": [
            "addr",
            "nr",
            "gup->flags & 1",
            "pages + i"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_pages_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "329-334",
          "snippet": "int __weak get_user_pages_fast(unsigned long start,\n\t\t\t\tint nr_pages, int write, struct page **pages)\n{\n\treturn get_user_pages_unlocked(start, nr_pages, pages,\n\t\t\t\t       write ? FOLL_WRITE : 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __weak get_user_pages_fast(unsigned long start,\n\t\t\t\tint nr_pages, int write, struct page **pages)\n{\n\treturn get_user_pages_unlocked(start, nr_pages, pages,\n\t\t\t\t       write ? FOLL_WRITE : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "nr_pages",
            "sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/debugfs.h>\n#include <linux/ktime.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define GUP_BENCHMARK\t\t_IOWR('g', 3, struct gup_benchmark)\n#define GUP_LONGTERM_BENCHMARK\t_IOWR('g', 2, struct gup_benchmark)\n#define GUP_FAST_BENCHMARK\t_IOWR('g', 1, struct gup_benchmark)\n\nstatic int __gup_benchmark_ioctl(unsigned int cmd,\n\t\tstruct gup_benchmark *gup)\n{\n\tktime_t start_time, end_time;\n\tunsigned long i, nr_pages, addr, next;\n\tint nr;\n\tstruct page **pages;\n\n\tif (gup->size > ULONG_MAX)\n\t\treturn -EINVAL;\n\n\tnr_pages = gup->size / PAGE_SIZE;\n\tpages = kvcalloc(nr_pages, sizeof(void *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tnr = gup->nr_pages_per_call;\n\tstart_time = ktime_get();\n\tfor (addr = gup->addr; addr < gup->addr + gup->size; addr = next) {\n\t\tif (nr != gup->nr_pages_per_call)\n\t\t\tbreak;\n\n\t\tnext = addr + nr * PAGE_SIZE;\n\t\tif (next > gup->addr + gup->size) {\n\t\t\tnext = gup->addr + gup->size;\n\t\t\tnr = (next - addr) / PAGE_SIZE;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase GUP_FAST_BENCHMARK:\n\t\t\tnr = get_user_pages_fast(addr, nr, gup->flags & 1,\n\t\t\t\t\t\t pages + i);\n\t\t\tbreak;\n\t\tcase GUP_LONGTERM_BENCHMARK:\n\t\t\tnr = get_user_pages_longterm(addr, nr, gup->flags & 1,\n\t\t\t\t\t\t     pages + i, NULL);\n\t\t\tbreak;\n\t\tcase GUP_BENCHMARK:\n\t\t\tnr = get_user_pages(addr, nr, gup->flags & 1, pages + i,\n\t\t\t\t\t    NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (nr <= 0)\n\t\t\tbreak;\n\t\ti += nr;\n\t}\n\tend_time = ktime_get();\n\n\tgup->get_delta_usec = ktime_us_delta(end_time, start_time);\n\tgup->size = addr - gup->addr;\n\n\tstart_time = ktime_get();\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (!pages[i])\n\t\t\tbreak;\n\t\tput_page(pages[i]);\n\t}\n\tend_time = ktime_get();\n\tgup->put_delta_usec = ktime_us_delta(end_time, start_time);\n\n\tkvfree(pages);\n\treturn 0;\n}"
  }
]