[
  {
    "function_name": "extfrag_debug_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "2119-2139",
    "snippet": "static int __init extfrag_debug_init(void)\n{\n\tstruct dentry *extfrag_debug_root;\n\n\textfrag_debug_root = debugfs_create_dir(\"extfrag\", NULL);\n\tif (!extfrag_debug_root)\n\t\treturn -ENOMEM;\n\n\tif (!debugfs_create_file(\"unusable_index\", 0444,\n\t\t\textfrag_debug_root, NULL, &unusable_file_ops))\n\t\tgoto fail;\n\n\tif (!debugfs_create_file(\"extfrag_index\", 0444,\n\t\t\textfrag_debug_root, NULL, &extfrag_file_ops))\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tdebugfs_remove_recursive(extfrag_debug_root);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "extfrag_debug_root"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"extfrag_index\"",
            "0444",
            "extfrag_debug_root",
            "NULL",
            "&extfrag_file_ops"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"unusable_index\"",
            "0444",
            "extfrag_debug_root",
            "NULL",
            "&unusable_file_ops"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"extfrag\"",
            "NULL"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int __init extfrag_debug_init(void)\n{\n\tstruct dentry *extfrag_debug_root;\n\n\textfrag_debug_root = debugfs_create_dir(\"extfrag\", NULL);\n\tif (!extfrag_debug_root)\n\t\treturn -ENOMEM;\n\n\tif (!debugfs_create_file(\"unusable_index\", 0444,\n\t\t\textfrag_debug_root, NULL, &unusable_file_ops))\n\t\tgoto fail;\n\n\tif (!debugfs_create_file(\"extfrag_index\", 0444,\n\t\t\textfrag_debug_root, NULL, &extfrag_file_ops))\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tdebugfs_remove_recursive(extfrag_debug_root);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "extfrag_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "2107-2110",
    "snippet": "static int extfrag_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &extfrag_op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&extfrag_op"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int extfrag_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &extfrag_op);\n}"
  },
  {
    "function_name": "extfrag_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "2091-2098",
    "snippet": "static int extfrag_show(struct seq_file *m, void *arg)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\twalk_zones_in_node(m, pgdat, true, false, extfrag_show_print);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_zones_in_node",
          "args": [
            "m",
            "pgdat",
            "true",
            "false",
            "extfrag_show_print"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "walk_zones_in_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1331-1349",
          "snippet": "static void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int extfrag_show(struct seq_file *m, void *arg)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\twalk_zones_in_node(m, pgdat, true, false, extfrag_show_print);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "extfrag_show_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "2067-2086",
    "snippet": "static void extfrag_show_print(struct seq_file *m,\n\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)\n{\n\tunsigned int order;\n\tint index;\n\n\t/* Alloc on stack as interrupts are disabled for zone walk */\n\tstruct contig_page_info info;\n\n\tseq_printf(m, \"Node %d, zone %8s \",\n\t\t\t\tpgdat->node_id,\n\t\t\t\tzone->name);\n\tfor (order = 0; order < MAX_ORDER; ++order) {\n\t\tfill_contig_page_info(zone, order, &info);\n\t\tindex = __fragmentation_index(order, &info);\n\t\tseq_printf(m, \"%d.%03d \", index / 1000, index % 1000);\n\t}\n\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%d.%03d \"",
            "index / 1000",
            "index % 1000"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fragmentation_index",
          "args": [
            "order",
            "&info"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "__fragmentation_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1053-1074",
          "snippet": "static int __fragmentation_index(unsigned int order, struct contig_page_info *info)\n{\n\tunsigned long requested = 1UL << order;\n\n\tif (WARN_ON_ONCE(order >= MAX_ORDER))\n\t\treturn 0;\n\n\tif (!info->free_blocks_total)\n\t\treturn 0;\n\n\t/* Fragmentation index only makes sense when a request would fail */\n\tif (info->free_blocks_suitable)\n\t\treturn -1000;\n\n\t/*\n\t * Index is between 0 and 1 so return within 3 decimal places\n\t *\n\t * 0 => allocation would fail due to lack of memory\n\t * 1 => allocation would fail due to fragmentation\n\t */\n\treturn 1000 - div_u64( (1000+(div_u64(info->free_pages * 1000ULL, requested))), info->free_blocks_total);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int __fragmentation_index(unsigned int order, struct contig_page_info *info)\n{\n\tunsigned long requested = 1UL << order;\n\n\tif (WARN_ON_ONCE(order >= MAX_ORDER))\n\t\treturn 0;\n\n\tif (!info->free_blocks_total)\n\t\treturn 0;\n\n\t/* Fragmentation index only makes sense when a request would fail */\n\tif (info->free_blocks_suitable)\n\t\treturn -1000;\n\n\t/*\n\t * Index is between 0 and 1 so return within 3 decimal places\n\t *\n\t * 0 => allocation would fail due to lack of memory\n\t * 1 => allocation would fail due to fragmentation\n\t */\n\treturn 1000 - div_u64( (1000+(div_u64(info->free_pages * 1000ULL, requested))), info->free_blocks_total);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_contig_page_info",
          "args": [
            "zone",
            "order",
            "&info"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "fill_contig_page_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1019-1044",
          "snippet": "static void fill_contig_page_info(struct zone *zone,\n\t\t\t\tunsigned int suitable_order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\tunsigned int order;\n\n\tinfo->free_pages = 0;\n\tinfo->free_blocks_total = 0;\n\tinfo->free_blocks_suitable = 0;\n\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tunsigned long blocks;\n\n\t\t/* Count number of free blocks */\n\t\tblocks = zone->free_area[order].nr_free;\n\t\tinfo->free_blocks_total += blocks;\n\n\t\t/* Count free base pages */\n\t\tinfo->free_pages += blocks << order;\n\n\t\t/* Count the suitable free blocks */\n\t\tif (order >= suitable_order)\n\t\t\tinfo->free_blocks_suitable += blocks <<\n\t\t\t\t\t\t(order - suitable_order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void fill_contig_page_info(struct zone *zone,\n\t\t\t\tunsigned int suitable_order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\tunsigned int order;\n\n\tinfo->free_pages = 0;\n\tinfo->free_blocks_total = 0;\n\tinfo->free_blocks_suitable = 0;\n\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tunsigned long blocks;\n\n\t\t/* Count number of free blocks */\n\t\tblocks = zone->free_area[order].nr_free;\n\t\tinfo->free_blocks_total += blocks;\n\n\t\t/* Count free base pages */\n\t\tinfo->free_pages += blocks << order;\n\n\t\t/* Count the suitable free blocks */\n\t\tif (order >= suitable_order)\n\t\t\tinfo->free_blocks_suitable += blocks <<\n\t\t\t\t\t\t(order - suitable_order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Node %d, zone %8s \"",
            "pgdat->node_id",
            "zone->name"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void extfrag_show_print(struct seq_file *m,\n\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)\n{\n\tunsigned int order;\n\tint index;\n\n\t/* Alloc on stack as interrupts are disabled for zone walk */\n\tstruct contig_page_info info;\n\n\tseq_printf(m, \"Node %d, zone %8s \",\n\t\t\t\tpgdat->node_id,\n\t\t\t\tzone->name);\n\tfor (order = 0; order < MAX_ORDER; ++order) {\n\t\tfill_contig_page_info(zone, order, &info);\n\t\tindex = __fragmentation_index(order, &info);\n\t\tseq_printf(m, \"%d.%03d \", index / 1000, index % 1000);\n\t}\n\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "unusable_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "2055-2058",
    "snippet": "static int unusable_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &unusable_op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&unusable_op"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int unusable_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &unusable_op);\n}"
  },
  {
    "function_name": "unusable_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "2035-2046",
    "snippet": "static int unusable_show(struct seq_file *m, void *arg)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\t/* check memoryless node */\n\tif (!node_state(pgdat->node_id, N_MEMORY))\n\t\treturn 0;\n\n\twalk_zones_in_node(m, pgdat, true, false, unusable_show_print);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_zones_in_node",
          "args": [
            "m",
            "pgdat",
            "true",
            "false",
            "unusable_show_print"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "walk_zones_in_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1331-1349",
          "snippet": "static void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_state",
          "args": [
            "pgdat->node_id",
            "N_MEMORY"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "634-641",
          "snippet": "void inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int unusable_show(struct seq_file *m, void *arg)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\t/* check memoryless node */\n\tif (!node_state(pgdat->node_id, N_MEMORY))\n\t\treturn 0;\n\n\twalk_zones_in_node(m, pgdat, true, false, unusable_show_print);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "unusable_show_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "2007-2024",
    "snippet": "static void unusable_show_print(struct seq_file *m,\n\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)\n{\n\tunsigned int order;\n\tint index;\n\tstruct contig_page_info info;\n\n\tseq_printf(m, \"Node %d, zone %8s \",\n\t\t\t\tpgdat->node_id,\n\t\t\t\tzone->name);\n\tfor (order = 0; order < MAX_ORDER; ++order) {\n\t\tfill_contig_page_info(zone, order, &info);\n\t\tindex = unusable_free_index(order, &info);\n\t\tseq_printf(m, \"%d.%03d \", index / 1000, index % 1000);\n\t}\n\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%d.%03d \"",
            "index / 1000",
            "index % 1000"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unusable_free_index",
          "args": [
            "order",
            "&info"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "unusable_free_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1989-2005",
          "snippet": "static int unusable_free_index(unsigned int order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\t/* No free memory is interpreted as all free memory is unusable */\n\tif (info->free_pages == 0)\n\t\treturn 1000;\n\n\t/*\n\t * Index should be a value between 0 and 1. Return a value to 3\n\t * decimal places.\n\t *\n\t * 0 => no fragmentation\n\t * 1 => high fragmentation\n\t */\n\treturn div_u64((info->free_pages - (info->free_blocks_suitable << order)) * 1000ULL, info->free_pages);\n\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int unusable_free_index(unsigned int order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\t/* No free memory is interpreted as all free memory is unusable */\n\tif (info->free_pages == 0)\n\t\treturn 1000;\n\n\t/*\n\t * Index should be a value between 0 and 1. Return a value to 3\n\t * decimal places.\n\t *\n\t * 0 => no fragmentation\n\t * 1 => high fragmentation\n\t */\n\treturn div_u64((info->free_pages - (info->free_blocks_suitable << order)) * 1000ULL, info->free_pages);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_contig_page_info",
          "args": [
            "zone",
            "order",
            "&info"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "fill_contig_page_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1019-1044",
          "snippet": "static void fill_contig_page_info(struct zone *zone,\n\t\t\t\tunsigned int suitable_order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\tunsigned int order;\n\n\tinfo->free_pages = 0;\n\tinfo->free_blocks_total = 0;\n\tinfo->free_blocks_suitable = 0;\n\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tunsigned long blocks;\n\n\t\t/* Count number of free blocks */\n\t\tblocks = zone->free_area[order].nr_free;\n\t\tinfo->free_blocks_total += blocks;\n\n\t\t/* Count free base pages */\n\t\tinfo->free_pages += blocks << order;\n\n\t\t/* Count the suitable free blocks */\n\t\tif (order >= suitable_order)\n\t\t\tinfo->free_blocks_suitable += blocks <<\n\t\t\t\t\t\t(order - suitable_order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void fill_contig_page_info(struct zone *zone,\n\t\t\t\tunsigned int suitable_order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\tunsigned int order;\n\n\tinfo->free_pages = 0;\n\tinfo->free_blocks_total = 0;\n\tinfo->free_blocks_suitable = 0;\n\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tunsigned long blocks;\n\n\t\t/* Count number of free blocks */\n\t\tblocks = zone->free_area[order].nr_free;\n\t\tinfo->free_blocks_total += blocks;\n\n\t\t/* Count free base pages */\n\t\tinfo->free_pages += blocks << order;\n\n\t\t/* Count the suitable free blocks */\n\t\tif (order >= suitable_order)\n\t\t\tinfo->free_blocks_suitable += blocks <<\n\t\t\t\t\t\t(order - suitable_order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Node %d, zone %8s \"",
            "pgdat->node_id",
            "zone->name"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void unusable_show_print(struct seq_file *m,\n\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)\n{\n\tunsigned int order;\n\tint index;\n\tstruct contig_page_info info;\n\n\tseq_printf(m, \"Node %d, zone %8s \",\n\t\t\t\tpgdat->node_id,\n\t\t\t\tzone->name);\n\tfor (order = 0; order < MAX_ORDER; ++order) {\n\t\tfill_contig_page_info(zone, order, &info);\n\t\tindex = unusable_free_index(order, &info);\n\t\tseq_printf(m, \"%d.%03d \", index / 1000, index % 1000);\n\t}\n\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "unusable_free_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1989-2005",
    "snippet": "static int unusable_free_index(unsigned int order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\t/* No free memory is interpreted as all free memory is unusable */\n\tif (info->free_pages == 0)\n\t\treturn 1000;\n\n\t/*\n\t * Index should be a value between 0 and 1. Return a value to 3\n\t * decimal places.\n\t *\n\t * 0 => no fragmentation\n\t * 1 => high fragmentation\n\t */\n\treturn div_u64((info->free_pages - (info->free_blocks_suitable << order)) * 1000ULL, info->free_pages);\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "(info->free_pages - (info->free_blocks_suitable << order)) * 1000ULL",
            "info->free_pages"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int unusable_free_index(unsigned int order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\t/* No free memory is interpreted as all free memory is unusable */\n\tif (info->free_pages == 0)\n\t\treturn 1000;\n\n\t/*\n\t * Index should be a value between 0 and 1. Return a value to 3\n\t * decimal places.\n\t *\n\t * 0 => no fragmentation\n\t * 1 => high fragmentation\n\t */\n\treturn div_u64((info->free_pages - (info->free_blocks_suitable << order)) * 1000ULL, info->free_pages);\n\n}"
  },
  {
    "function_name": "init_mm_internals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1951-1981",
    "snippet": "void __init init_mm_internals(void)\n{\n\tint ret __maybe_unused;\n\n\tmm_percpu_wq = alloc_workqueue(\"mm_percpu_wq\", WQ_MEM_RECLAIM, 0);\n\n#ifdef CONFIG_SMP\n\tret = cpuhp_setup_state_nocalls(CPUHP_MM_VMSTAT_DEAD, \"mm/vmstat:dead\",\n\t\t\t\t\tNULL, vmstat_cpu_dead);\n\tif (ret < 0)\n\t\tpr_err(\"vmstat: failed to register 'dead' hotplug state\\n\");\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, \"mm/vmstat:online\",\n\t\t\t\t\tvmstat_cpu_online,\n\t\t\t\t\tvmstat_cpu_down_prep);\n\tif (ret < 0)\n\t\tpr_err(\"vmstat: failed to register 'online' hotplug state\\n\");\n\n\tget_online_cpus();\n\tinit_cpu_node_state();\n\tput_online_cpus();\n\n\tstart_shepherd_timer();\n#endif\n#ifdef CONFIG_PROC_FS\n\tproc_create_seq(\"buddyinfo\", 0444, NULL, &fragmentation_op);\n\tproc_create_seq(\"pagetypeinfo\", 0444, NULL, &pagetypeinfo_op);\n\tproc_create_seq(\"vmstat\", 0444, NULL, &vmstat_op);\n\tproc_create_seq(\"zoneinfo\", 0444, NULL, &zoneinfo_op);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *mm_percpu_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_seq",
          "args": [
            "\"zoneinfo\"",
            "0444",
            "NULL",
            "&zoneinfo_op"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_seq",
          "args": [
            "\"vmstat\"",
            "0444",
            "NULL",
            "&vmstat_op"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_seq",
          "args": [
            "\"pagetypeinfo\"",
            "0444",
            "NULL",
            "&pagetypeinfo_op"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_seq",
          "args": [
            "\"buddyinfo\"",
            "0444",
            "NULL",
            "&fragmentation_op"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_shepherd_timer",
          "args": [],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "start_shepherd_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1896-1906",
          "snippet": "static void __init start_shepherd_timer(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_DEFERRABLE_WORK(per_cpu_ptr(&vmstat_work, cpu),\n\t\t\tvmstat_update);\n\n\tschedule_delayed_work(&shepherd,\n\t\tround_jiffies_relative(sysctl_stat_interval));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void __init start_shepherd_timer(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_DEFERRABLE_WORK(per_cpu_ptr(&vmstat_work, cpu),\n\t\t\tvmstat_update);\n\n\tschedule_delayed_work(&shepherd,\n\t\tround_jiffies_relative(sysctl_stat_interval));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cpu_node_state",
          "args": [],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1908-1916",
          "snippet": "static void __init init_cpu_node_state(void)\n{\n\tint node;\n\n\tfor_each_online_node(node) {\n\t\tif (cpumask_weight(cpumask_of_node(node)) > 0)\n\t\t\tnode_set_state(node, N_CPU);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void __init init_cpu_node_state(void)\n{\n\tint node;\n\n\tfor_each_online_node(node) {\n\t\tif (cpumask_weight(cpumask_of_node(node)) > 0)\n\t\t\tnode_set_state(node, N_CPU);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"vmstat: failed to register 'online' hotplug state\\n\""
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"mm/vmstat:online\"",
            "vmstat_cpu_online",
            "vmstat_cpu_down_prep"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"vmstat: failed to register 'dead' hotplug state\\n\""
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_MM_VMSTAT_DEAD",
            "\"mm/vmstat:dead\"",
            "NULL",
            "vmstat_cpu_dead"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"mm_percpu_wq\"",
            "WQ_MEM_RECLAIM",
            "0"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstruct workqueue_struct *mm_percpu_wq;\n\nvoid __init init_mm_internals(void)\n{\n\tint ret __maybe_unused;\n\n\tmm_percpu_wq = alloc_workqueue(\"mm_percpu_wq\", WQ_MEM_RECLAIM, 0);\n\n#ifdef CONFIG_SMP\n\tret = cpuhp_setup_state_nocalls(CPUHP_MM_VMSTAT_DEAD, \"mm/vmstat:dead\",\n\t\t\t\t\tNULL, vmstat_cpu_dead);\n\tif (ret < 0)\n\t\tpr_err(\"vmstat: failed to register 'dead' hotplug state\\n\");\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, \"mm/vmstat:online\",\n\t\t\t\t\tvmstat_cpu_online,\n\t\t\t\t\tvmstat_cpu_down_prep);\n\tif (ret < 0)\n\t\tpr_err(\"vmstat: failed to register 'online' hotplug state\\n\");\n\n\tget_online_cpus();\n\tinit_cpu_node_state();\n\tput_online_cpus();\n\n\tstart_shepherd_timer();\n#endif\n#ifdef CONFIG_PROC_FS\n\tproc_create_seq(\"buddyinfo\", 0444, NULL, &fragmentation_op);\n\tproc_create_seq(\"pagetypeinfo\", 0444, NULL, &pagetypeinfo_op);\n\tproc_create_seq(\"vmstat\", 0444, NULL, &vmstat_op);\n\tproc_create_seq(\"zoneinfo\", 0444, NULL, &zoneinfo_op);\n#endif\n}"
  },
  {
    "function_name": "vmstat_cpu_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1931-1945",
    "snippet": "static int vmstat_cpu_dead(unsigned int cpu)\n{\n\tconst struct cpumask *node_cpus;\n\tint node;\n\n\tnode = cpu_to_node(cpu);\n\n\trefresh_zone_stat_thresholds();\n\tnode_cpus = cpumask_of_node(node);\n\tif (cpumask_weight(node_cpus) > 0)\n\t\treturn 0;\n\n\tnode_clear_state(node, N_CPU);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_clear_state",
          "args": [
            "node",
            "N_CPU"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "node_cpus"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "node"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refresh_zone_stat_thresholds",
          "args": [],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "refresh_zone_stat_thresholds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "245-288",
          "snippet": "void refresh_zone_stat_thresholds(void)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\n\t/* Zero current pgdat thresholds */\n\tfor_each_online_pgdat(pgdat) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold = 0;\n\t\t}\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\t\tunsigned long max_drift, tolerate_drift;\n\n\t\tthreshold = calculate_normal_threshold(zone);\n\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tint pgdat_threshold;\n\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\n\t\t\t/* Base nodestat threshold on the largest populated zone. */\n\t\t\tpgdat_threshold = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold;\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold\n\t\t\t\t= max(threshold, pgdat_threshold);\n\t\t}\n\n\t\t/*\n\t\t * Only set percpu_drift_mark if there is a danger that\n\t\t * NR_FREE_PAGES reports the low watermark is ok when in fact\n\t\t * the min watermark could be breached by an allocation\n\t\t */\n\t\ttolerate_drift = low_wmark_pages(zone) - min_wmark_pages(zone);\n\t\tmax_drift = num_online_cpus() * threshold;\n\t\tif (max_drift > tolerate_drift)\n\t\t\tzone->percpu_drift_mark = high_wmark_pages(zone) +\n\t\t\t\t\tmax_drift;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid refresh_zone_stat_thresholds(void)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\n\t/* Zero current pgdat thresholds */\n\tfor_each_online_pgdat(pgdat) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold = 0;\n\t\t}\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\t\tunsigned long max_drift, tolerate_drift;\n\n\t\tthreshold = calculate_normal_threshold(zone);\n\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tint pgdat_threshold;\n\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\n\t\t\t/* Base nodestat threshold on the largest populated zone. */\n\t\t\tpgdat_threshold = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold;\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold\n\t\t\t\t= max(threshold, pgdat_threshold);\n\t\t}\n\n\t\t/*\n\t\t * Only set percpu_drift_mark if there is a danger that\n\t\t * NR_FREE_PAGES reports the low watermark is ok when in fact\n\t\t * the min watermark could be breached by an allocation\n\t\t */\n\t\ttolerate_drift = low_wmark_pages(zone) - min_wmark_pages(zone);\n\t\tmax_drift = num_online_cpus() * threshold;\n\t\tif (max_drift > tolerate_drift)\n\t\t\tzone->percpu_drift_mark = high_wmark_pages(zone) +\n\t\t\t\t\tmax_drift;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int vmstat_cpu_dead(unsigned int cpu)\n{\n\tconst struct cpumask *node_cpus;\n\tint node;\n\n\tnode = cpu_to_node(cpu);\n\n\trefresh_zone_stat_thresholds();\n\tnode_cpus = cpumask_of_node(node);\n\tif (cpumask_weight(node_cpus) > 0)\n\t\treturn 0;\n\n\tnode_clear_state(node, N_CPU);\n\treturn 0;\n}"
  },
  {
    "function_name": "vmstat_cpu_down_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1925-1929",
    "snippet": "static int vmstat_cpu_down_prep(unsigned int cpu)\n{\n\tcancel_delayed_work_sync(&per_cpu(vmstat_work, cpu));\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&per_cpu(vmstat_work, cpu)"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vmstat_work",
            "cpu"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int vmstat_cpu_down_prep(unsigned int cpu)\n{\n\tcancel_delayed_work_sync(&per_cpu(vmstat_work, cpu));\n\treturn 0;\n}"
  },
  {
    "function_name": "vmstat_cpu_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1918-1923",
    "snippet": "static int vmstat_cpu_online(unsigned int cpu)\n{\n\trefresh_zone_stat_thresholds();\n\tnode_set_state(cpu_to_node(cpu), N_CPU);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_set_state",
          "args": [
            "cpu_to_node(cpu)",
            "N_CPU"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refresh_zone_stat_thresholds",
          "args": [],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "refresh_zone_stat_thresholds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "245-288",
          "snippet": "void refresh_zone_stat_thresholds(void)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\n\t/* Zero current pgdat thresholds */\n\tfor_each_online_pgdat(pgdat) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold = 0;\n\t\t}\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\t\tunsigned long max_drift, tolerate_drift;\n\n\t\tthreshold = calculate_normal_threshold(zone);\n\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tint pgdat_threshold;\n\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\n\t\t\t/* Base nodestat threshold on the largest populated zone. */\n\t\t\tpgdat_threshold = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold;\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold\n\t\t\t\t= max(threshold, pgdat_threshold);\n\t\t}\n\n\t\t/*\n\t\t * Only set percpu_drift_mark if there is a danger that\n\t\t * NR_FREE_PAGES reports the low watermark is ok when in fact\n\t\t * the min watermark could be breached by an allocation\n\t\t */\n\t\ttolerate_drift = low_wmark_pages(zone) - min_wmark_pages(zone);\n\t\tmax_drift = num_online_cpus() * threshold;\n\t\tif (max_drift > tolerate_drift)\n\t\t\tzone->percpu_drift_mark = high_wmark_pages(zone) +\n\t\t\t\t\tmax_drift;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid refresh_zone_stat_thresholds(void)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\n\t/* Zero current pgdat thresholds */\n\tfor_each_online_pgdat(pgdat) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold = 0;\n\t\t}\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\t\tunsigned long max_drift, tolerate_drift;\n\n\t\tthreshold = calculate_normal_threshold(zone);\n\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tint pgdat_threshold;\n\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\n\t\t\t/* Base nodestat threshold on the largest populated zone. */\n\t\t\tpgdat_threshold = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold;\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold\n\t\t\t\t= max(threshold, pgdat_threshold);\n\t\t}\n\n\t\t/*\n\t\t * Only set percpu_drift_mark if there is a danger that\n\t\t * NR_FREE_PAGES reports the low watermark is ok when in fact\n\t\t * the min watermark could be breached by an allocation\n\t\t */\n\t\ttolerate_drift = low_wmark_pages(zone) - min_wmark_pages(zone);\n\t\tmax_drift = num_online_cpus() * threshold;\n\t\tif (max_drift > tolerate_drift)\n\t\t\tzone->percpu_drift_mark = high_wmark_pages(zone) +\n\t\t\t\t\tmax_drift;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int vmstat_cpu_online(unsigned int cpu)\n{\n\trefresh_zone_stat_thresholds();\n\tnode_set_state(cpu_to_node(cpu), N_CPU);\n\treturn 0;\n}"
  },
  {
    "function_name": "init_cpu_node_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1908-1916",
    "snippet": "static void __init init_cpu_node_state(void)\n{\n\tint node;\n\n\tfor_each_online_node(node) {\n\t\tif (cpumask_weight(cpumask_of_node(node)) > 0)\n\t\t\tnode_set_state(node, N_CPU);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_set_state",
          "args": [
            "node",
            "N_CPU"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "cpumask_of_node(node)"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "node"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void __init init_cpu_node_state(void)\n{\n\tint node;\n\n\tfor_each_online_node(node) {\n\t\tif (cpumask_weight(cpumask_of_node(node)) > 0)\n\t\t\tnode_set_state(node, N_CPU);\n\t}\n}"
  },
  {
    "function_name": "start_shepherd_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1896-1906",
    "snippet": "static void __init start_shepherd_timer(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_DEFERRABLE_WORK(per_cpu_ptr(&vmstat_work, cpu),\n\t\t\tvmstat_update);\n\n\tschedule_delayed_work(&shepherd,\n\t\tround_jiffies_relative(sysctl_stat_interval));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&shepherd",
            "round_jiffies_relative(sysctl_stat_interval)"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_jiffies_relative",
          "args": [
            "sysctl_stat_interval"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void __init start_shepherd_timer(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_DEFERRABLE_WORK(per_cpu_ptr(&vmstat_work, cpu),\n\t\t\tvmstat_update);\n\n\tschedule_delayed_work(&shepherd,\n\t\tround_jiffies_relative(sysctl_stat_interval));\n}"
  },
  {
    "function_name": "vmstat_shepherd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1878-1894",
    "snippet": "static void vmstat_shepherd(struct work_struct *w)\n{\n\tint cpu;\n\n\tget_online_cpus();\n\t/* Check processors whose vmstat worker threads have been disabled */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct delayed_work *dw = &per_cpu(vmstat_work, cpu);\n\n\t\tif (!delayed_work_pending(dw) && need_update(cpu))\n\t\t\tqueue_delayed_work_on(cpu, mm_percpu_wq, dw, 0);\n\t}\n\tput_online_cpus();\n\n\tschedule_delayed_work(&shepherd,\n\t\tround_jiffies_relative(sysctl_stat_interval));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *mm_percpu_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&shepherd",
            "round_jiffies_relative(sysctl_stat_interval)"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_jiffies_relative",
          "args": [
            "sysctl_stat_interval"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_delayed_work_on",
          "args": [
            "cpu",
            "mm_percpu_wq",
            "dw",
            "0"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_update",
          "args": [
            "cpu"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "need_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1816-1841",
          "snippet": "static bool need_update(int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset *p = per_cpu_ptr(zone->pageset, cpu);\n\n\t\tBUILD_BUG_ON(sizeof(p->vm_stat_diff[0]) != 1);\n#ifdef CONFIG_NUMA\n\t\tBUILD_BUG_ON(sizeof(p->vm_numa_stat_diff[0]) != 2);\n#endif\n\n\t\t/*\n\t\t * The fast way of checking if there are any vmstat diffs.\n\t\t */\n\t\tif (memchr_inv(p->vm_stat_diff, 0, NR_VM_ZONE_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_stat_diff[0])))\n\t\t\treturn true;\n#ifdef CONFIG_NUMA\n\t\tif (memchr_inv(p->vm_numa_stat_diff, 0, NR_VM_NUMA_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_numa_stat_diff[0])))\n\t\t\treturn true;\n#endif\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool need_update(int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset *p = per_cpu_ptr(zone->pageset, cpu);\n\n\t\tBUILD_BUG_ON(sizeof(p->vm_stat_diff[0]) != 1);\n#ifdef CONFIG_NUMA\n\t\tBUILD_BUG_ON(sizeof(p->vm_numa_stat_diff[0]) != 2);\n#endif\n\n\t\t/*\n\t\t * The fast way of checking if there are any vmstat diffs.\n\t\t */\n\t\tif (memchr_inv(p->vm_stat_diff, 0, NR_VM_ZONE_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_stat_diff[0])))\n\t\t\treturn true;\n#ifdef CONFIG_NUMA\n\t\tif (memchr_inv(p->vm_numa_stat_diff, 0, NR_VM_NUMA_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_numa_stat_diff[0])))\n\t\t\treturn true;\n#endif\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_work_pending",
          "args": [
            "dw"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vmstat_work",
            "cpu"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstruct workqueue_struct *mm_percpu_wq;\n\nstatic void vmstat_shepherd(struct work_struct *w)\n{\n\tint cpu;\n\n\tget_online_cpus();\n\t/* Check processors whose vmstat worker threads have been disabled */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct delayed_work *dw = &per_cpu(vmstat_work, cpu);\n\n\t\tif (!delayed_work_pending(dw) && need_update(cpu))\n\t\t\tqueue_delayed_work_on(cpu, mm_percpu_wq, dw, 0);\n\t}\n\tput_online_cpus();\n\n\tschedule_delayed_work(&shepherd,\n\t\tround_jiffies_relative(sysctl_stat_interval));\n}"
  },
  {
    "function_name": "quiet_vmstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1848-1866",
    "snippet": "void quiet_vmstat(void)\n{\n\tif (system_state != SYSTEM_RUNNING)\n\t\treturn;\n\n\tif (!delayed_work_pending(this_cpu_ptr(&vmstat_work)))\n\t\treturn;\n\n\tif (!need_update(smp_processor_id()))\n\t\treturn;\n\n\t/*\n\t * Just refresh counters and do not care about the pending delayed\n\t * vmstat_update. It doesn't fire that often to matter and canceling\n\t * it would be too expensive from this path.\n\t * vmstat_shepherd will take care about that for us.\n\t */\n\trefresh_cpu_vm_stats(false);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refresh_cpu_vm_stats",
          "args": [
            "false"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "refresh_cpu_vm_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "744-839",
          "snippet": "static int refresh_cpu_vm_stats(bool do_pagesets)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\tint changes = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset __percpu *p = zone->pageset;\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n#ifdef CONFIG_NUMA\n\t\t\t\t/* 3 seconds idle till flush */\n\t\t\t\t__this_cpu_write(p->expire, 3);\n#endif\n\t\t\t}\n\t\t}\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_numa_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t\t__this_cpu_write(p->expire, 3);\n\t\t\t}\n\t\t}\n\n\t\tif (do_pagesets) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Deal with draining the remote pageset of this\n\t\t\t * processor\n\t\t\t *\n\t\t\t * Check if there are pages remaining in this pageset\n\t\t\t * if not then there is nothing to expire.\n\t\t\t */\n\t\t\tif (!__this_cpu_read(p->expire) ||\n\t\t\t       !__this_cpu_read(p->pcp.count))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * We never drain zones local to this processor.\n\t\t\t */\n\t\t\tif (zone_to_nid(zone) == numa_node_id()) {\n\t\t\t\t__this_cpu_write(p->expire, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (__this_cpu_dec_return(p->expire))\n\t\t\t\tcontinue;\n\n\t\t\tif (__this_cpu_read(p->pcp.count)) {\n\t\t\t\tdrain_zone_pages(zone, this_cpu_ptr(&p->pcp));\n\t\t\t\tchanges++;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat __percpu *p = pgdat->per_cpu_nodestats;\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_node_stat_diff[i], 0);\n\t\t\tif (v) {\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tchanges += fold_diff(global_zone_diff, global_numa_diff,\n\t\t\t     global_node_diff);\n#else\n\tchanges += fold_diff(global_zone_diff, global_node_diff);\n#endif\n\treturn changes;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nstatic int refresh_cpu_vm_stats(bool do_pagesets)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\tint changes = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset __percpu *p = zone->pageset;\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n#ifdef CONFIG_NUMA\n\t\t\t\t/* 3 seconds idle till flush */\n\t\t\t\t__this_cpu_write(p->expire, 3);\n#endif\n\t\t\t}\n\t\t}\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_numa_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t\t__this_cpu_write(p->expire, 3);\n\t\t\t}\n\t\t}\n\n\t\tif (do_pagesets) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Deal with draining the remote pageset of this\n\t\t\t * processor\n\t\t\t *\n\t\t\t * Check if there are pages remaining in this pageset\n\t\t\t * if not then there is nothing to expire.\n\t\t\t */\n\t\t\tif (!__this_cpu_read(p->expire) ||\n\t\t\t       !__this_cpu_read(p->pcp.count))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * We never drain zones local to this processor.\n\t\t\t */\n\t\t\tif (zone_to_nid(zone) == numa_node_id()) {\n\t\t\t\t__this_cpu_write(p->expire, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (__this_cpu_dec_return(p->expire))\n\t\t\t\tcontinue;\n\n\t\t\tif (__this_cpu_read(p->pcp.count)) {\n\t\t\t\tdrain_zone_pages(zone, this_cpu_ptr(&p->pcp));\n\t\t\t\tchanges++;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat __percpu *p = pgdat->per_cpu_nodestats;\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_node_stat_diff[i], 0);\n\t\t\tif (v) {\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tchanges += fold_diff(global_zone_diff, global_numa_diff,\n\t\t\t     global_node_diff);\n#else\n\tchanges += fold_diff(global_zone_diff, global_node_diff);\n#endif\n\treturn changes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_update",
          "args": [
            "smp_processor_id()"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "need_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1816-1841",
          "snippet": "static bool need_update(int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset *p = per_cpu_ptr(zone->pageset, cpu);\n\n\t\tBUILD_BUG_ON(sizeof(p->vm_stat_diff[0]) != 1);\n#ifdef CONFIG_NUMA\n\t\tBUILD_BUG_ON(sizeof(p->vm_numa_stat_diff[0]) != 2);\n#endif\n\n\t\t/*\n\t\t * The fast way of checking if there are any vmstat diffs.\n\t\t */\n\t\tif (memchr_inv(p->vm_stat_diff, 0, NR_VM_ZONE_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_stat_diff[0])))\n\t\t\treturn true;\n#ifdef CONFIG_NUMA\n\t\tif (memchr_inv(p->vm_numa_stat_diff, 0, NR_VM_NUMA_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_numa_stat_diff[0])))\n\t\t\treturn true;\n#endif\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool need_update(int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset *p = per_cpu_ptr(zone->pageset, cpu);\n\n\t\tBUILD_BUG_ON(sizeof(p->vm_stat_diff[0]) != 1);\n#ifdef CONFIG_NUMA\n\t\tBUILD_BUG_ON(sizeof(p->vm_numa_stat_diff[0]) != 2);\n#endif\n\n\t\t/*\n\t\t * The fast way of checking if there are any vmstat diffs.\n\t\t */\n\t\tif (memchr_inv(p->vm_stat_diff, 0, NR_VM_ZONE_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_stat_diff[0])))\n\t\t\treturn true;\n#ifdef CONFIG_NUMA\n\t\tif (memchr_inv(p->vm_numa_stat_diff, 0, NR_VM_NUMA_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_numa_stat_diff[0])))\n\t\t\treturn true;\n#endif\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayed_work_pending",
          "args": [
            "this_cpu_ptr(&vmstat_work)"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&vmstat_work"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid quiet_vmstat(void)\n{\n\tif (system_state != SYSTEM_RUNNING)\n\t\treturn;\n\n\tif (!delayed_work_pending(this_cpu_ptr(&vmstat_work)))\n\t\treturn;\n\n\tif (!need_update(smp_processor_id()))\n\t\treturn;\n\n\t/*\n\t * Just refresh counters and do not care about the pending delayed\n\t * vmstat_update. It doesn't fire that often to matter and canceling\n\t * it would be too expensive from this path.\n\t * vmstat_shepherd will take care about that for us.\n\t */\n\trefresh_cpu_vm_stats(false);\n}"
  },
  {
    "function_name": "need_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1816-1841",
    "snippet": "static bool need_update(int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset *p = per_cpu_ptr(zone->pageset, cpu);\n\n\t\tBUILD_BUG_ON(sizeof(p->vm_stat_diff[0]) != 1);\n#ifdef CONFIG_NUMA\n\t\tBUILD_BUG_ON(sizeof(p->vm_numa_stat_diff[0]) != 2);\n#endif\n\n\t\t/*\n\t\t * The fast way of checking if there are any vmstat diffs.\n\t\t */\n\t\tif (memchr_inv(p->vm_stat_diff, 0, NR_VM_ZONE_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_stat_diff[0])))\n\t\t\treturn true;\n#ifdef CONFIG_NUMA\n\t\tif (memchr_inv(p->vm_numa_stat_diff, 0, NR_VM_NUMA_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_numa_stat_diff[0])))\n\t\t\treturn true;\n#endif\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "p->vm_numa_stat_diff",
            "0",
            "NR_VM_NUMA_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_numa_stat_diff[0])"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "p->vm_stat_diff",
            "0",
            "NR_VM_ZONE_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_stat_diff[0])"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(p->vm_numa_stat_diff[0]) != 2"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(p->vm_stat_diff[0]) != 1"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "zone->pageset",
            "cpu"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool need_update(int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset *p = per_cpu_ptr(zone->pageset, cpu);\n\n\t\tBUILD_BUG_ON(sizeof(p->vm_stat_diff[0]) != 1);\n#ifdef CONFIG_NUMA\n\t\tBUILD_BUG_ON(sizeof(p->vm_numa_stat_diff[0]) != 2);\n#endif\n\n\t\t/*\n\t\t * The fast way of checking if there are any vmstat diffs.\n\t\t */\n\t\tif (memchr_inv(p->vm_stat_diff, 0, NR_VM_ZONE_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_stat_diff[0])))\n\t\t\treturn true;\n#ifdef CONFIG_NUMA\n\t\tif (memchr_inv(p->vm_numa_stat_diff, 0, NR_VM_NUMA_STAT_ITEMS *\n\t\t\t       sizeof(p->vm_numa_stat_diff[0])))\n\t\t\treturn true;\n#endif\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "vmstat_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1793-1805",
    "snippet": "static void vmstat_update(struct work_struct *w)\n{\n\tif (refresh_cpu_vm_stats(true)) {\n\t\t/*\n\t\t * Counters were updated so we expect more updates\n\t\t * to occur in the future. Keep on running the\n\t\t * update worker thread.\n\t\t */\n\t\tqueue_delayed_work_on(smp_processor_id(), mm_percpu_wq,\n\t\t\t\tthis_cpu_ptr(&vmstat_work),\n\t\t\t\tround_jiffies_relative(sysctl_stat_interval));\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *mm_percpu_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work_on",
          "args": [
            "smp_processor_id()",
            "mm_percpu_wq",
            "this_cpu_ptr(&vmstat_work)",
            "round_jiffies_relative(sysctl_stat_interval)"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_jiffies_relative",
          "args": [
            "sysctl_stat_interval"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&vmstat_work"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refresh_cpu_vm_stats",
          "args": [
            "true"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "refresh_cpu_vm_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "744-839",
          "snippet": "static int refresh_cpu_vm_stats(bool do_pagesets)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\tint changes = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset __percpu *p = zone->pageset;\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n#ifdef CONFIG_NUMA\n\t\t\t\t/* 3 seconds idle till flush */\n\t\t\t\t__this_cpu_write(p->expire, 3);\n#endif\n\t\t\t}\n\t\t}\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_numa_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t\t__this_cpu_write(p->expire, 3);\n\t\t\t}\n\t\t}\n\n\t\tif (do_pagesets) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Deal with draining the remote pageset of this\n\t\t\t * processor\n\t\t\t *\n\t\t\t * Check if there are pages remaining in this pageset\n\t\t\t * if not then there is nothing to expire.\n\t\t\t */\n\t\t\tif (!__this_cpu_read(p->expire) ||\n\t\t\t       !__this_cpu_read(p->pcp.count))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * We never drain zones local to this processor.\n\t\t\t */\n\t\t\tif (zone_to_nid(zone) == numa_node_id()) {\n\t\t\t\t__this_cpu_write(p->expire, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (__this_cpu_dec_return(p->expire))\n\t\t\t\tcontinue;\n\n\t\t\tif (__this_cpu_read(p->pcp.count)) {\n\t\t\t\tdrain_zone_pages(zone, this_cpu_ptr(&p->pcp));\n\t\t\t\tchanges++;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat __percpu *p = pgdat->per_cpu_nodestats;\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_node_stat_diff[i], 0);\n\t\t\tif (v) {\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tchanges += fold_diff(global_zone_diff, global_numa_diff,\n\t\t\t     global_node_diff);\n#else\n\tchanges += fold_diff(global_zone_diff, global_node_diff);\n#endif\n\treturn changes;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nstatic int refresh_cpu_vm_stats(bool do_pagesets)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\tint changes = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset __percpu *p = zone->pageset;\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n#ifdef CONFIG_NUMA\n\t\t\t\t/* 3 seconds idle till flush */\n\t\t\t\t__this_cpu_write(p->expire, 3);\n#endif\n\t\t\t}\n\t\t}\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_numa_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t\t__this_cpu_write(p->expire, 3);\n\t\t\t}\n\t\t}\n\n\t\tif (do_pagesets) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Deal with draining the remote pageset of this\n\t\t\t * processor\n\t\t\t *\n\t\t\t * Check if there are pages remaining in this pageset\n\t\t\t * if not then there is nothing to expire.\n\t\t\t */\n\t\t\tif (!__this_cpu_read(p->expire) ||\n\t\t\t       !__this_cpu_read(p->pcp.count))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * We never drain zones local to this processor.\n\t\t\t */\n\t\t\tif (zone_to_nid(zone) == numa_node_id()) {\n\t\t\t\t__this_cpu_write(p->expire, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (__this_cpu_dec_return(p->expire))\n\t\t\t\tcontinue;\n\n\t\t\tif (__this_cpu_read(p->pcp.count)) {\n\t\t\t\tdrain_zone_pages(zone, this_cpu_ptr(&p->pcp));\n\t\t\t\tchanges++;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat __percpu *p = pgdat->per_cpu_nodestats;\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_node_stat_diff[i], 0);\n\t\t\tif (v) {\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tchanges += fold_diff(global_zone_diff, global_numa_diff,\n\t\t\t     global_node_diff);\n#else\n\tchanges += fold_diff(global_zone_diff, global_node_diff);\n#endif\n\treturn changes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstruct workqueue_struct *mm_percpu_wq;\n\nstatic void vmstat_update(struct work_struct *w)\n{\n\tif (refresh_cpu_vm_stats(true)) {\n\t\t/*\n\t\t * Counters were updated so we expect more updates\n\t\t * to occur in the future. Keep on running the\n\t\t * update worker thread.\n\t\t */\n\t\tqueue_delayed_work_on(smp_processor_id(), mm_percpu_wq,\n\t\t\t\tthis_cpu_ptr(&vmstat_work),\n\t\t\t\tround_jiffies_relative(sysctl_stat_interval));\n\t}\n}"
  },
  {
    "function_name": "vmstat_refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1743-1790",
    "snippet": "int vmstat_refresh(struct ctl_table *table, int write,\n\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tlong val;\n\tint err;\n\tint i;\n\n\t/*\n\t * The regular update, every sysctl_stat_interval, may come later\n\t * than expected: leaving a significant amount in per_cpu buckets.\n\t * This is particularly misleading when checking a quantity of HUGE\n\t * pages, immediately after running a test.  /proc/sys/vm/stat_refresh,\n\t * which can equally be echo'ed to or cat'ted from (by root),\n\t * can be used to update the stats just before reading them.\n\t *\n\t * Oh, and since global_zone_page_state() etc. are so careful to hide\n\t * transiently negative values, report an error here if any of\n\t * the stats is negative, so we know to go looking for imbalance.\n\t */\n\terr = schedule_on_each_cpu(refresh_vm_stats);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {\n\t\tval = atomic_long_read(&vm_zone_stat[i]);\n\t\tif (val < 0) {\n\t\t\tpr_warn(\"%s: %s %ld\\n\",\n\t\t\t\t__func__, vmstat_text[i], val);\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_NUMA\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++) {\n\t\tval = atomic_long_read(&vm_numa_stat[i]);\n\t\tif (val < 0) {\n\t\t\tpr_warn(\"%s: %s %ld\\n\",\n\t\t\t\t__func__, vmstat_text[i + NR_VM_ZONE_STAT_ITEMS], val);\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n#endif\n\tif (err)\n\t\treturn err;\n\tif (write)\n\t\t*ppos += *lenp;\n\telse\n\t\t*lenp = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS]",
      "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: %s %ld\\n\"",
            "__func__",
            "vmstat_text[i + NR_VM_ZONE_STAT_ITEMS]",
            "val"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&vm_numa_stat[i]"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: %s %ld\\n\"",
            "__func__",
            "vmstat_text[i]",
            "val"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&vm_zone_stat[i]"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_on_each_cpu",
          "args": [
            "refresh_vm_stats"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS];\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nint vmstat_refresh(struct ctl_table *table, int write,\n\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tlong val;\n\tint err;\n\tint i;\n\n\t/*\n\t * The regular update, every sysctl_stat_interval, may come later\n\t * than expected: leaving a significant amount in per_cpu buckets.\n\t * This is particularly misleading when checking a quantity of HUGE\n\t * pages, immediately after running a test.  /proc/sys/vm/stat_refresh,\n\t * which can equally be echo'ed to or cat'ted from (by root),\n\t * can be used to update the stats just before reading them.\n\t *\n\t * Oh, and since global_zone_page_state() etc. are so careful to hide\n\t * transiently negative values, report an error here if any of\n\t * the stats is negative, so we know to go looking for imbalance.\n\t */\n\terr = schedule_on_each_cpu(refresh_vm_stats);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {\n\t\tval = atomic_long_read(&vm_zone_stat[i]);\n\t\tif (val < 0) {\n\t\t\tpr_warn(\"%s: %s %ld\\n\",\n\t\t\t\t__func__, vmstat_text[i], val);\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_NUMA\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++) {\n\t\tval = atomic_long_read(&vm_numa_stat[i]);\n\t\tif (val < 0) {\n\t\t\tpr_warn(\"%s: %s %ld\\n\",\n\t\t\t\t__func__, vmstat_text[i + NR_VM_ZONE_STAT_ITEMS], val);\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n#endif\n\tif (err)\n\t\treturn err;\n\tif (write)\n\t\t*ppos += *lenp;\n\telse\n\t\t*lenp = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "refresh_vm_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1738-1741",
    "snippet": "static void refresh_vm_stats(struct work_struct *work)\n{\n\trefresh_cpu_vm_stats(true);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refresh_cpu_vm_stats",
          "args": [
            "true"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "refresh_cpu_vm_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "744-839",
          "snippet": "static int refresh_cpu_vm_stats(bool do_pagesets)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\tint changes = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset __percpu *p = zone->pageset;\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n#ifdef CONFIG_NUMA\n\t\t\t\t/* 3 seconds idle till flush */\n\t\t\t\t__this_cpu_write(p->expire, 3);\n#endif\n\t\t\t}\n\t\t}\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_numa_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t\t__this_cpu_write(p->expire, 3);\n\t\t\t}\n\t\t}\n\n\t\tif (do_pagesets) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Deal with draining the remote pageset of this\n\t\t\t * processor\n\t\t\t *\n\t\t\t * Check if there are pages remaining in this pageset\n\t\t\t * if not then there is nothing to expire.\n\t\t\t */\n\t\t\tif (!__this_cpu_read(p->expire) ||\n\t\t\t       !__this_cpu_read(p->pcp.count))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * We never drain zones local to this processor.\n\t\t\t */\n\t\t\tif (zone_to_nid(zone) == numa_node_id()) {\n\t\t\t\t__this_cpu_write(p->expire, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (__this_cpu_dec_return(p->expire))\n\t\t\t\tcontinue;\n\n\t\t\tif (__this_cpu_read(p->pcp.count)) {\n\t\t\t\tdrain_zone_pages(zone, this_cpu_ptr(&p->pcp));\n\t\t\t\tchanges++;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat __percpu *p = pgdat->per_cpu_nodestats;\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_node_stat_diff[i], 0);\n\t\t\tif (v) {\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tchanges += fold_diff(global_zone_diff, global_numa_diff,\n\t\t\t     global_node_diff);\n#else\n\tchanges += fold_diff(global_zone_diff, global_node_diff);\n#endif\n\treturn changes;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nstatic int refresh_cpu_vm_stats(bool do_pagesets)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\tint changes = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset __percpu *p = zone->pageset;\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n#ifdef CONFIG_NUMA\n\t\t\t\t/* 3 seconds idle till flush */\n\t\t\t\t__this_cpu_write(p->expire, 3);\n#endif\n\t\t\t}\n\t\t}\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_numa_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t\t__this_cpu_write(p->expire, 3);\n\t\t\t}\n\t\t}\n\n\t\tif (do_pagesets) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Deal with draining the remote pageset of this\n\t\t\t * processor\n\t\t\t *\n\t\t\t * Check if there are pages remaining in this pageset\n\t\t\t * if not then there is nothing to expire.\n\t\t\t */\n\t\t\tif (!__this_cpu_read(p->expire) ||\n\t\t\t       !__this_cpu_read(p->pcp.count))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * We never drain zones local to this processor.\n\t\t\t */\n\t\t\tif (zone_to_nid(zone) == numa_node_id()) {\n\t\t\t\t__this_cpu_write(p->expire, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (__this_cpu_dec_return(p->expire))\n\t\t\t\tcontinue;\n\n\t\t\tif (__this_cpu_read(p->pcp.count)) {\n\t\t\t\tdrain_zone_pages(zone, this_cpu_ptr(&p->pcp));\n\t\t\t\tchanges++;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat __percpu *p = pgdat->per_cpu_nodestats;\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_node_stat_diff[i], 0);\n\t\t\tif (v) {\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tchanges += fold_diff(global_zone_diff, global_numa_diff,\n\t\t\t     global_node_diff);\n#else\n\tchanges += fold_diff(global_zone_diff, global_node_diff);\n#endif\n\treturn changes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void refresh_vm_stats(struct work_struct *work)\n{\n\trefresh_cpu_vm_stats(true);\n}"
  },
  {
    "function_name": "vmstat_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1719-1723",
    "snippet": "static void vmstat_stop(struct seq_file *m, void *arg)\n{\n\tkfree(m->private);\n\tm->private = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "m->private"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void vmstat_stop(struct seq_file *m, void *arg)\n{\n\tkfree(m->private);\n\tm->private = NULL;\n}"
  },
  {
    "function_name": "vmstat_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1708-1717",
    "snippet": "static int vmstat_show(struct seq_file *m, void *arg)\n{\n\tunsigned long *l = arg;\n\tunsigned long off = l - (unsigned long *)m->private;\n\n\tseq_puts(m, vmstat_text[off]);\n\tseq_put_decimal_ull(m, \" \", *l);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_put_decimal_ull",
          "args": [
            "m",
            "\" \"",
            "*l"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "vmstat_text[off]"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int vmstat_show(struct seq_file *m, void *arg)\n{\n\tunsigned long *l = arg;\n\tunsigned long off = l - (unsigned long *)m->private;\n\n\tseq_puts(m, vmstat_text[off]);\n\tseq_put_decimal_ull(m, \" \", *l);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}"
  },
  {
    "function_name": "vmstat_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1700-1706",
    "snippet": "static void *vmstat_next(struct seq_file *m, void *arg, loff_t *pos)\n{\n\t(*pos)++;\n\tif (*pos >= ARRAY_SIZE(vmstat_text))\n\t\treturn NULL;\n\treturn (unsigned long *)m->private + *pos;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vmstat_text"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void *vmstat_next(struct seq_file *m, void *arg, loff_t *pos)\n{\n\t(*pos)++;\n\tif (*pos >= ARRAY_SIZE(vmstat_text))\n\t\treturn NULL;\n\treturn (unsigned long *)m->private + *pos;\n}"
  },
  {
    "function_name": "vmstat_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1652-1698",
    "snippet": "static void *vmstat_start(struct seq_file *m, loff_t *pos)\n{\n\tunsigned long *v;\n\tint i, stat_items_size;\n\n\tif (*pos >= ARRAY_SIZE(vmstat_text))\n\t\treturn NULL;\n\tstat_items_size = NR_VM_ZONE_STAT_ITEMS * sizeof(unsigned long) +\n\t\t\t  NR_VM_NUMA_STAT_ITEMS * sizeof(unsigned long) +\n\t\t\t  NR_VM_NODE_STAT_ITEMS * sizeof(unsigned long) +\n\t\t\t  NR_VM_WRITEBACK_STAT_ITEMS * sizeof(unsigned long);\n\n#ifdef CONFIG_VM_EVENT_COUNTERS\n\tstat_items_size += sizeof(struct vm_event_state);\n#endif\n\n\tBUILD_BUG_ON(stat_items_size !=\n\t\t     ARRAY_SIZE(vmstat_text) * sizeof(unsigned long));\n\tv = kmalloc(stat_items_size, GFP_KERNEL);\n\tm->private = v;\n\tif (!v)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tv[i] = global_zone_page_state(i);\n\tv += NR_VM_ZONE_STAT_ITEMS;\n\n#ifdef CONFIG_NUMA\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\tv[i] = global_numa_state(i);\n\tv += NR_VM_NUMA_STAT_ITEMS;\n#endif\n\n\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\tv[i] = global_node_page_state(i);\n\tv += NR_VM_NODE_STAT_ITEMS;\n\n\tglobal_dirty_limits(v + NR_DIRTY_BG_THRESHOLD,\n\t\t\t    v + NR_DIRTY_THRESHOLD);\n\tv += NR_VM_WRITEBACK_STAT_ITEMS;\n\n#ifdef CONFIG_VM_EVENT_COUNTERS\n\tall_vm_events(v);\n\tv[PGPGIN] /= 2;\t\t/* sectors -> kbytes */\n\tv[PGPGOUT] /= 2;\n#endif\n\treturn (unsigned long *)m->private + *pos;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "all_vm_events",
          "args": [
            "v"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "all_vm_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "130-135",
          "snippet": "void all_vm_events(unsigned long *ret)\n{\n\tget_online_cpus();\n\tsum_vm_events(ret);\n\tput_online_cpus();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid all_vm_events(unsigned long *ret)\n{\n\tget_online_cpus();\n\tsum_vm_events(ret);\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_dirty_limits",
          "args": [
            "v + NR_DIRTY_BG_THRESHOLD",
            "v + NR_DIRTY_THRESHOLD"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "global_dirty_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "458-467",
          "snippet": "void global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT_NO_WB };\n\n\tgdtc.avail = global_dirtyable_memory();\n\tdomain_dirty_limits(&gdtc);\n\n\t*pbackground = gdtc.bg_thresh;\n\t*pdirty = gdtc.thresh;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define GDTC_INIT_NO_WB",
            "#define GDTC_INIT_NO_WB\t\t.dom = &global_wb_domain"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define GDTC_INIT_NO_WB\n#define GDTC_INIT_NO_WB\t\t.dom = &global_wb_domain\n\nvoid global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT_NO_WB };\n\n\tgdtc.avail = global_dirtyable_memory();\n\tdomain_dirty_limits(&gdtc);\n\n\t*pbackground = gdtc.bg_thresh;\n\t*pdirty = gdtc.thresh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "i"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_numa_state",
          "args": [
            "i"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "i"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "stat_items_size",
            "GFP_KERNEL"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "stat_items_size !=\n\t\t     ARRAY_SIZE(vmstat_text) * sizeof(unsigned long)"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vmstat_text"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vmstat_text"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void *vmstat_start(struct seq_file *m, loff_t *pos)\n{\n\tunsigned long *v;\n\tint i, stat_items_size;\n\n\tif (*pos >= ARRAY_SIZE(vmstat_text))\n\t\treturn NULL;\n\tstat_items_size = NR_VM_ZONE_STAT_ITEMS * sizeof(unsigned long) +\n\t\t\t  NR_VM_NUMA_STAT_ITEMS * sizeof(unsigned long) +\n\t\t\t  NR_VM_NODE_STAT_ITEMS * sizeof(unsigned long) +\n\t\t\t  NR_VM_WRITEBACK_STAT_ITEMS * sizeof(unsigned long);\n\n#ifdef CONFIG_VM_EVENT_COUNTERS\n\tstat_items_size += sizeof(struct vm_event_state);\n#endif\n\n\tBUILD_BUG_ON(stat_items_size !=\n\t\t     ARRAY_SIZE(vmstat_text) * sizeof(unsigned long));\n\tv = kmalloc(stat_items_size, GFP_KERNEL);\n\tm->private = v;\n\tif (!v)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tv[i] = global_zone_page_state(i);\n\tv += NR_VM_ZONE_STAT_ITEMS;\n\n#ifdef CONFIG_NUMA\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\tv[i] = global_numa_state(i);\n\tv += NR_VM_NUMA_STAT_ITEMS;\n#endif\n\n\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\tv[i] = global_node_page_state(i);\n\tv += NR_VM_NODE_STAT_ITEMS;\n\n\tglobal_dirty_limits(v + NR_DIRTY_BG_THRESHOLD,\n\t\t\t    v + NR_DIRTY_THRESHOLD);\n\tv += NR_VM_WRITEBACK_STAT_ITEMS;\n\n#ifdef CONFIG_VM_EVENT_COUNTERS\n\tall_vm_events(v);\n\tv[PGPGIN] /= 2;\t\t/* sectors -> kbytes */\n\tv[PGPGOUT] /= 2;\n#endif\n\treturn (unsigned long *)m->private + *pos;\n}"
  },
  {
    "function_name": "zoneinfo_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1631-1636",
    "snippet": "static int zoneinfo_show(struct seq_file *m, void *arg)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\twalk_zones_in_node(m, pgdat, false, false, zoneinfo_show_print);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_zones_in_node",
          "args": [
            "m",
            "pgdat",
            "false",
            "false",
            "zoneinfo_show_print"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "walk_zones_in_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1331-1349",
          "snippet": "static void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int zoneinfo_show(struct seq_file *m, void *arg)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\twalk_zones_in_node(m, pgdat, false, false, zoneinfo_show_print);\n\treturn 0;\n}"
  },
  {
    "function_name": "zoneinfo_show_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1544-1623",
    "snippet": "static void zoneinfo_show_print(struct seq_file *m, pg_data_t *pgdat,\n\t\t\t\t\t\t\tstruct zone *zone)\n{\n\tint i;\n\tseq_printf(m, \"Node %d, zone %8s\", pgdat->node_id, zone->name);\n\tif (is_zone_first_populated(pgdat, zone)) {\n\t\tseq_printf(m, \"\\n  per-node stats\");\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {\n\t\t\tseq_printf(m, \"\\n      %-12s %lu\",\n\t\t\t\tvmstat_text[i + NR_VM_ZONE_STAT_ITEMS +\n\t\t\t\tNR_VM_NUMA_STAT_ITEMS],\n\t\t\t\tnode_page_state(pgdat, i));\n\t\t}\n\t}\n\tseq_printf(m,\n\t\t   \"\\n  pages free     %lu\"\n\t\t   \"\\n        min      %lu\"\n\t\t   \"\\n        low      %lu\"\n\t\t   \"\\n        high     %lu\"\n\t\t   \"\\n        spanned  %lu\"\n\t\t   \"\\n        present  %lu\"\n\t\t   \"\\n        managed  %lu\",\n\t\t   zone_page_state(zone, NR_FREE_PAGES),\n\t\t   min_wmark_pages(zone),\n\t\t   low_wmark_pages(zone),\n\t\t   high_wmark_pages(zone),\n\t\t   zone->spanned_pages,\n\t\t   zone->present_pages,\n\t\t   zone->managed_pages);\n\n\tseq_printf(m,\n\t\t   \"\\n        protection: (%ld\",\n\t\t   zone->lowmem_reserve[0]);\n\tfor (i = 1; i < ARRAY_SIZE(zone->lowmem_reserve); i++)\n\t\tseq_printf(m, \", %ld\", zone->lowmem_reserve[i]);\n\tseq_putc(m, ')');\n\n\t/* If unpopulated, no other information is useful */\n\tif (!populated_zone(zone)) {\n\t\tseq_putc(m, '\\n');\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tseq_printf(m, \"\\n      %-12s %lu\", vmstat_text[i],\n\t\t\t\tzone_page_state(zone, i));\n\n#ifdef CONFIG_NUMA\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\tseq_printf(m, \"\\n      %-12s %lu\",\n\t\t\t\tvmstat_text[i + NR_VM_ZONE_STAT_ITEMS],\n\t\t\t\tzone_numa_state_snapshot(zone, i));\n#endif\n\n\tseq_printf(m, \"\\n  pagesets\");\n\tfor_each_online_cpu(i) {\n\t\tstruct per_cpu_pageset *pageset;\n\n\t\tpageset = per_cpu_ptr(zone->pageset, i);\n\t\tseq_printf(m,\n\t\t\t   \"\\n    cpu: %i\"\n\t\t\t   \"\\n              count: %i\"\n\t\t\t   \"\\n              high:  %i\"\n\t\t\t   \"\\n              batch: %i\",\n\t\t\t   i,\n\t\t\t   pageset->pcp.count,\n\t\t\t   pageset->pcp.high,\n\t\t\t   pageset->pcp.batch);\n#ifdef CONFIG_SMP\n\t\tseq_printf(m, \"\\n  vm stats threshold: %d\",\n\t\t\t\tpageset->stat_threshold);\n#endif\n\t}\n\tseq_printf(m,\n\t\t   \"\\n  node_unreclaimable:  %u\"\n\t\t   \"\\n  start_pfn:           %lu\",\n\t\t   pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES,\n\t\t   zone->zone_start_pfn);\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n  node_unreclaimable:  %u\"\n\t\t   \"\\n  start_pfn:           %lu\"",
            "pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES",
            "zone->zone_start_pfn"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n  vm stats threshold: %d\"",
            "pageset->stat_threshold"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n    cpu: %i\"\n\t\t\t   \"\\n              count: %i\"\n\t\t\t   \"\\n              high:  %i\"\n\t\t\t   \"\\n              batch: %i\"",
            "i",
            "pageset->pcp.count",
            "pageset->pcp.high",
            "pageset->pcp.batch"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "zone->pageset",
            "i"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n  pagesets\""
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n      %-12s %lu\"",
            "vmstat_text[i + NR_VM_ZONE_STAT_ITEMS]",
            "zone_numa_state_snapshot(zone, i)"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_numa_state_snapshot",
          "args": [
            "zone",
            "i"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n      %-12s %lu\"",
            "vmstat_text[i]",
            "zone_page_state(zone, i)"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "zone",
            "i"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "')'"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\", %ld\"",
            "zone->lowmem_reserve[i]"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "zone->lowmem_reserve"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n        protection: (%ld\"",
            "zone->lowmem_reserve[0]"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n  pages free     %lu\"\n\t\t   \"\\n        min      %lu\"\n\t\t   \"\\n        low      %lu\"\n\t\t   \"\\n        high     %lu\"\n\t\t   \"\\n        spanned  %lu\"\n\t\t   \"\\n        present  %lu\"\n\t\t   \"\\n        managed  %lu\"",
            "zone_page_state(zone, NR_FREE_PAGES)",
            "min_wmark_pages(zone)",
            "low_wmark_pages(zone)",
            "high_wmark_pages(zone)",
            "zone->spanned_pages",
            "zone->present_pages",
            "zone->managed_pages"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "high_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n      %-12s %lu\"",
            "vmstat_text[i + NR_VM_ZONE_STAT_ITEMS +\n\t\t\t\tNR_VM_NUMA_STAT_ITEMS]",
            "node_page_state(pgdat, i)"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "i"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n  per-node stats\""
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_first_populated",
          "args": [
            "pgdat",
            "zone"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "is_zone_first_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1530-1542",
          "snippet": "static bool is_zone_first_populated(pg_data_t *pgdat, struct zone *zone)\n{\n\tint zid;\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *compare = &pgdat->node_zones[zid];\n\n\t\tif (populated_zone(compare))\n\t\t\treturn zone == compare;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool is_zone_first_populated(pg_data_t *pgdat, struct zone *zone)\n{\n\tint zid;\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *compare = &pgdat->node_zones[zid];\n\n\t\tif (populated_zone(compare))\n\t\t\treturn zone == compare;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Node %d, zone %8s\"",
            "pgdat->node_id",
            "zone->name"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void zoneinfo_show_print(struct seq_file *m, pg_data_t *pgdat,\n\t\t\t\t\t\t\tstruct zone *zone)\n{\n\tint i;\n\tseq_printf(m, \"Node %d, zone %8s\", pgdat->node_id, zone->name);\n\tif (is_zone_first_populated(pgdat, zone)) {\n\t\tseq_printf(m, \"\\n  per-node stats\");\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {\n\t\t\tseq_printf(m, \"\\n      %-12s %lu\",\n\t\t\t\tvmstat_text[i + NR_VM_ZONE_STAT_ITEMS +\n\t\t\t\tNR_VM_NUMA_STAT_ITEMS],\n\t\t\t\tnode_page_state(pgdat, i));\n\t\t}\n\t}\n\tseq_printf(m,\n\t\t   \"\\n  pages free     %lu\"\n\t\t   \"\\n        min      %lu\"\n\t\t   \"\\n        low      %lu\"\n\t\t   \"\\n        high     %lu\"\n\t\t   \"\\n        spanned  %lu\"\n\t\t   \"\\n        present  %lu\"\n\t\t   \"\\n        managed  %lu\",\n\t\t   zone_page_state(zone, NR_FREE_PAGES),\n\t\t   min_wmark_pages(zone),\n\t\t   low_wmark_pages(zone),\n\t\t   high_wmark_pages(zone),\n\t\t   zone->spanned_pages,\n\t\t   zone->present_pages,\n\t\t   zone->managed_pages);\n\n\tseq_printf(m,\n\t\t   \"\\n        protection: (%ld\",\n\t\t   zone->lowmem_reserve[0]);\n\tfor (i = 1; i < ARRAY_SIZE(zone->lowmem_reserve); i++)\n\t\tseq_printf(m, \", %ld\", zone->lowmem_reserve[i]);\n\tseq_putc(m, ')');\n\n\t/* If unpopulated, no other information is useful */\n\tif (!populated_zone(zone)) {\n\t\tseq_putc(m, '\\n');\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tseq_printf(m, \"\\n      %-12s %lu\", vmstat_text[i],\n\t\t\t\tzone_page_state(zone, i));\n\n#ifdef CONFIG_NUMA\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\tseq_printf(m, \"\\n      %-12s %lu\",\n\t\t\t\tvmstat_text[i + NR_VM_ZONE_STAT_ITEMS],\n\t\t\t\tzone_numa_state_snapshot(zone, i));\n#endif\n\n\tseq_printf(m, \"\\n  pagesets\");\n\tfor_each_online_cpu(i) {\n\t\tstruct per_cpu_pageset *pageset;\n\n\t\tpageset = per_cpu_ptr(zone->pageset, i);\n\t\tseq_printf(m,\n\t\t\t   \"\\n    cpu: %i\"\n\t\t\t   \"\\n              count: %i\"\n\t\t\t   \"\\n              high:  %i\"\n\t\t\t   \"\\n              batch: %i\",\n\t\t\t   i,\n\t\t\t   pageset->pcp.count,\n\t\t\t   pageset->pcp.high,\n\t\t\t   pageset->pcp.batch);\n#ifdef CONFIG_SMP\n\t\tseq_printf(m, \"\\n  vm stats threshold: %d\",\n\t\t\t\tpageset->stat_threshold);\n#endif\n\t}\n\tseq_printf(m,\n\t\t   \"\\n  node_unreclaimable:  %u\"\n\t\t   \"\\n  start_pfn:           %lu\",\n\t\t   pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES,\n\t\t   zone->zone_start_pfn);\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "is_zone_first_populated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1530-1542",
    "snippet": "static bool is_zone_first_populated(pg_data_t *pgdat, struct zone *zone)\n{\n\tint zid;\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *compare = &pgdat->node_zones[zid];\n\n\t\tif (populated_zone(compare))\n\t\t\treturn zone == compare;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "compare"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool is_zone_first_populated(pg_data_t *pgdat, struct zone *zone)\n{\n\tint zid;\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *compare = &pgdat->node_zones[zid];\n\n\t\tif (populated_zone(compare))\n\t\t\treturn zone == compare;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "pagetypeinfo_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1498-1514",
    "snippet": "static int pagetypeinfo_show(struct seq_file *m, void *arg)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\t/* check memoryless node */\n\tif (!node_state(pgdat->node_id, N_MEMORY))\n\t\treturn 0;\n\n\tseq_printf(m, \"Page block order: %d\\n\", pageblock_order);\n\tseq_printf(m, \"Pages per block:  %lu\\n\", pageblock_nr_pages);\n\tseq_putc(m, '\\n');\n\tpagetypeinfo_showfree(m, pgdat);\n\tpagetypeinfo_showblockcount(m, pgdat);\n\tpagetypeinfo_showmixedcount(m, pgdat);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagetypeinfo_showmixedcount",
          "args": [
            "m",
            "pgdat"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "pagetypeinfo_showmixedcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1474-1492",
          "snippet": "static void pagetypeinfo_showmixedcount(struct seq_file *m, pg_data_t *pgdat)\n{\n#ifdef CONFIG_PAGE_OWNER\n\tint mtype;\n\n\tif (!static_branch_unlikely(&page_owner_inited))\n\t\treturn;\n\n\tdrain_all_pages(NULL);\n\n\tseq_printf(m, \"\\n%-23s\", \"Number of mixed blocks \");\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)\n\t\tseq_printf(m, \"%12s \", migratetype_names[mtype]);\n\tseq_putc(m, '\\n');\n\n\twalk_zones_in_node(m, pgdat, true, true,\n\t\tpagetypeinfo_showmixedcount_print);\n#endif /* CONFIG_PAGE_OWNER */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void pagetypeinfo_showmixedcount(struct seq_file *m, pg_data_t *pgdat)\n{\n#ifdef CONFIG_PAGE_OWNER\n\tint mtype;\n\n\tif (!static_branch_unlikely(&page_owner_inited))\n\t\treturn;\n\n\tdrain_all_pages(NULL);\n\n\tseq_printf(m, \"\\n%-23s\", \"Number of mixed blocks \");\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)\n\t\tseq_printf(m, \"%12s \", migratetype_names[mtype]);\n\tseq_putc(m, '\\n');\n\n\twalk_zones_in_node(m, pgdat, true, true,\n\t\tpagetypeinfo_showmixedcount_print);\n#endif /* CONFIG_PAGE_OWNER */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagetypeinfo_showblockcount",
          "args": [
            "m",
            "pgdat"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "pagetypeinfo_showblockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1453-1466",
          "snippet": "static int pagetypeinfo_showblockcount(struct seq_file *m, void *arg)\n{\n\tint mtype;\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\tseq_printf(m, \"\\n%-23s\", \"Number of blocks type \");\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)\n\t\tseq_printf(m, \"%12s \", migratetype_names[mtype]);\n\tseq_putc(m, '\\n');\n\twalk_zones_in_node(m, pgdat, true, false,\n\t\tpagetypeinfo_showblockcount_print);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int pagetypeinfo_showblockcount(struct seq_file *m, void *arg)\n{\n\tint mtype;\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\tseq_printf(m, \"\\n%-23s\", \"Number of blocks type \");\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)\n\t\tseq_printf(m, \"%12s \", migratetype_names[mtype]);\n\tseq_putc(m, '\\n');\n\twalk_zones_in_node(m, pgdat, true, false,\n\t\tpagetypeinfo_showblockcount_print);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagetypeinfo_showfree",
          "args": [
            "m",
            "pgdat"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "pagetypeinfo_showfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1400-1414",
          "snippet": "static int pagetypeinfo_showfree(struct seq_file *m, void *arg)\n{\n\tint order;\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\t/* Print header */\n\tseq_printf(m, \"%-43s \", \"Free pages count per migrate type at order\");\n\tfor (order = 0; order < MAX_ORDER; ++order)\n\t\tseq_printf(m, \"%6d \", order);\n\tseq_putc(m, '\\n');\n\n\twalk_zones_in_node(m, pgdat, true, false, pagetypeinfo_showfree_print);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int pagetypeinfo_showfree(struct seq_file *m, void *arg)\n{\n\tint order;\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\t/* Print header */\n\tseq_printf(m, \"%-43s \", \"Free pages count per migrate type at order\");\n\tfor (order = 0; order < MAX_ORDER; ++order)\n\t\tseq_printf(m, \"%6d \", order);\n\tseq_putc(m, '\\n');\n\n\twalk_zones_in_node(m, pgdat, true, false, pagetypeinfo_showfree_print);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Pages per block:  %lu\\n\"",
            "pageblock_nr_pages"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Page block order: %d\\n\"",
            "pageblock_order"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_state",
          "args": [
            "pgdat->node_id",
            "N_MEMORY"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "634-641",
          "snippet": "void inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int pagetypeinfo_show(struct seq_file *m, void *arg)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\t/* check memoryless node */\n\tif (!node_state(pgdat->node_id, N_MEMORY))\n\t\treturn 0;\n\n\tseq_printf(m, \"Page block order: %d\\n\", pageblock_order);\n\tseq_printf(m, \"Pages per block:  %lu\\n\", pageblock_nr_pages);\n\tseq_putc(m, '\\n');\n\tpagetypeinfo_showfree(m, pgdat);\n\tpagetypeinfo_showblockcount(m, pgdat);\n\tpagetypeinfo_showmixedcount(m, pgdat);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pagetypeinfo_showmixedcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1474-1492",
    "snippet": "static void pagetypeinfo_showmixedcount(struct seq_file *m, pg_data_t *pgdat)\n{\n#ifdef CONFIG_PAGE_OWNER\n\tint mtype;\n\n\tif (!static_branch_unlikely(&page_owner_inited))\n\t\treturn;\n\n\tdrain_all_pages(NULL);\n\n\tseq_printf(m, \"\\n%-23s\", \"Number of mixed blocks \");\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)\n\t\tseq_printf(m, \"%12s \", migratetype_names[mtype]);\n\tseq_putc(m, '\\n');\n\n\twalk_zones_in_node(m, pgdat, true, true,\n\t\tpagetypeinfo_showmixedcount_print);\n#endif /* CONFIG_PAGE_OWNER */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_zones_in_node",
          "args": [
            "m",
            "pgdat",
            "true",
            "true",
            "pagetypeinfo_showmixedcount_print"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "walk_zones_in_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1331-1349",
          "snippet": "static void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%12s \"",
            "migratetype_names[mtype]"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n%-23s\"",
            "\"Number of mixed blocks \""
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_all_pages",
          "args": [
            "NULL"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2614-2682",
          "snippet": "void drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&page_owner_inited"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void pagetypeinfo_showmixedcount(struct seq_file *m, pg_data_t *pgdat)\n{\n#ifdef CONFIG_PAGE_OWNER\n\tint mtype;\n\n\tif (!static_branch_unlikely(&page_owner_inited))\n\t\treturn;\n\n\tdrain_all_pages(NULL);\n\n\tseq_printf(m, \"\\n%-23s\", \"Number of mixed blocks \");\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)\n\t\tseq_printf(m, \"%12s \", migratetype_names[mtype]);\n\tseq_putc(m, '\\n');\n\n\twalk_zones_in_node(m, pgdat, true, true,\n\t\tpagetypeinfo_showmixedcount_print);\n#endif /* CONFIG_PAGE_OWNER */\n}"
  },
  {
    "function_name": "pagetypeinfo_showblockcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1453-1466",
    "snippet": "static int pagetypeinfo_showblockcount(struct seq_file *m, void *arg)\n{\n\tint mtype;\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\tseq_printf(m, \"\\n%-23s\", \"Number of blocks type \");\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)\n\t\tseq_printf(m, \"%12s \", migratetype_names[mtype]);\n\tseq_putc(m, '\\n');\n\twalk_zones_in_node(m, pgdat, true, false,\n\t\tpagetypeinfo_showblockcount_print);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_zones_in_node",
          "args": [
            "m",
            "pgdat",
            "true",
            "false",
            "pagetypeinfo_showblockcount_print"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "walk_zones_in_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1331-1349",
          "snippet": "static void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%12s \"",
            "migratetype_names[mtype]"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n%-23s\"",
            "\"Number of blocks type \""
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int pagetypeinfo_showblockcount(struct seq_file *m, void *arg)\n{\n\tint mtype;\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\tseq_printf(m, \"\\n%-23s\", \"Number of blocks type \");\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)\n\t\tseq_printf(m, \"%12s \", migratetype_names[mtype]);\n\tseq_putc(m, '\\n');\n\twalk_zones_in_node(m, pgdat, true, false,\n\t\tpagetypeinfo_showblockcount_print);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pagetypeinfo_showblockcount_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1416-1450",
    "snippet": "static void pagetypeinfo_showblockcount_print(struct seq_file *m,\n\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)\n{\n\tint mtype;\n\tunsigned long pfn;\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long count[MIGRATE_TYPES] = { 0, };\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Watch for unexpected holes punched in the memmap */\n\t\tif (!memmap_valid_within(pfn, page, zone))\n\t\t\tcontinue;\n\n\t\tif (page_zone(page) != zone)\n\t\t\tcontinue;\n\n\t\tmtype = get_pageblock_migratetype(page);\n\n\t\tif (mtype < MIGRATE_TYPES)\n\t\t\tcount[mtype]++;\n\t}\n\n\t/* Print counts */\n\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)\n\t\tseq_printf(m, \"%12lu \", count[mtype]);\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%12lu \"",
            "count[mtype]"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Node %d, zone %8s \"",
            "pgdat->node_id",
            "zone->name"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmap_valid_within",
          "args": [
            "pfn",
            "page",
            "zone"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "memmap_valid_within",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "76-86",
          "snippet": "bool memmap_valid_within(unsigned long pfn,\n\t\t\t\t\tstruct page *page, struct zone *zone)\n{\n\tif (page_to_pfn(page) != pfn)\n\t\treturn false;\n\n\tif (page_zone(page) != zone)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nbool memmap_valid_within(unsigned long pfn,\n\t\t\t\t\tstruct page *page, struct zone *zone)\n{\n\tif (page_to_pfn(page) != pfn)\n\t\treturn false;\n\n\tif (page_zone(page) != zone)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_online_page",
          "args": [
            "pfn"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void pagetypeinfo_showblockcount_print(struct seq_file *m,\n\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)\n{\n\tint mtype;\n\tunsigned long pfn;\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long count[MIGRATE_TYPES] = { 0, };\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Watch for unexpected holes punched in the memmap */\n\t\tif (!memmap_valid_within(pfn, page, zone))\n\t\t\tcontinue;\n\n\t\tif (page_zone(page) != zone)\n\t\t\tcontinue;\n\n\t\tmtype = get_pageblock_migratetype(page);\n\n\t\tif (mtype < MIGRATE_TYPES)\n\t\t\tcount[mtype]++;\n\t}\n\n\t/* Print counts */\n\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)\n\t\tseq_printf(m, \"%12lu \", count[mtype]);\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "pagetypeinfo_showfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1400-1414",
    "snippet": "static int pagetypeinfo_showfree(struct seq_file *m, void *arg)\n{\n\tint order;\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\t/* Print header */\n\tseq_printf(m, \"%-43s \", \"Free pages count per migrate type at order\");\n\tfor (order = 0; order < MAX_ORDER; ++order)\n\t\tseq_printf(m, \"%6d \", order);\n\tseq_putc(m, '\\n');\n\n\twalk_zones_in_node(m, pgdat, true, false, pagetypeinfo_showfree_print);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_zones_in_node",
          "args": [
            "m",
            "pgdat",
            "true",
            "false",
            "pagetypeinfo_showfree_print"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "walk_zones_in_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1331-1349",
          "snippet": "static void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%6d \"",
            "order"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%-43s \"",
            "\"Free pages count per migrate type at order\""
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int pagetypeinfo_showfree(struct seq_file *m, void *arg)\n{\n\tint order;\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\t/* Print header */\n\tseq_printf(m, \"%-43s \", \"Free pages count per migrate type at order\");\n\tfor (order = 0; order < MAX_ORDER; ++order)\n\t\tseq_printf(m, \"%6d \", order);\n\tseq_putc(m, '\\n');\n\n\twalk_zones_in_node(m, pgdat, true, false, pagetypeinfo_showfree_print);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pagetypeinfo_showfree_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1374-1397",
    "snippet": "static void pagetypeinfo_showfree_print(struct seq_file *m,\n\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)\n{\n\tint order, mtype;\n\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++) {\n\t\tseq_printf(m, \"Node %4d, zone %8s, type %12s \",\n\t\t\t\t\tpgdat->node_id,\n\t\t\t\t\tzone->name,\n\t\t\t\t\tmigratetype_names[mtype]);\n\t\tfor (order = 0; order < MAX_ORDER; ++order) {\n\t\t\tunsigned long freecount = 0;\n\t\t\tstruct free_area *area;\n\t\t\tstruct list_head *curr;\n\n\t\t\tarea = &(zone->free_area[order]);\n\n\t\t\tlist_for_each(curr, &area->free_list[mtype])\n\t\t\t\tfreecount++;\n\t\t\tseq_printf(m, \"%6lu \", freecount);\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%6lu \"",
            "freecount"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "curr",
            "&area->free_list[mtype]"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Node %4d, zone %8s, type %12s \"",
            "pgdat->node_id",
            "zone->name",
            "migratetype_names[mtype]"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void pagetypeinfo_showfree_print(struct seq_file *m,\n\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)\n{\n\tint order, mtype;\n\n\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++) {\n\t\tseq_printf(m, \"Node %4d, zone %8s, type %12s \",\n\t\t\t\t\tpgdat->node_id,\n\t\t\t\t\tzone->name,\n\t\t\t\t\tmigratetype_names[mtype]);\n\t\tfor (order = 0; order < MAX_ORDER; ++order) {\n\t\t\tunsigned long freecount = 0;\n\t\t\tstruct free_area *area;\n\t\t\tstruct list_head *curr;\n\n\t\t\tarea = &(zone->free_area[order]);\n\n\t\t\tlist_for_each(curr, &area->free_list[mtype])\n\t\t\t\tfreecount++;\n\t\t\tseq_printf(m, \"%6lu \", freecount);\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n}"
  },
  {
    "function_name": "frag_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1367-1372",
    "snippet": "static int frag_show(struct seq_file *m, void *arg)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\twalk_zones_in_node(m, pgdat, true, false, frag_show_print);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_zones_in_node",
          "args": [
            "m",
            "pgdat",
            "true",
            "false",
            "frag_show_print"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "walk_zones_in_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1331-1349",
          "snippet": "static void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int frag_show(struct seq_file *m, void *arg)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\twalk_zones_in_node(m, pgdat, true, false, frag_show_print);\n\treturn 0;\n}"
  },
  {
    "function_name": "frag_show_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1353-1362",
    "snippet": "static void frag_show_print(struct seq_file *m, pg_data_t *pgdat,\n\t\t\t\t\t\tstruct zone *zone)\n{\n\tint order;\n\n\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);\n\tfor (order = 0; order < MAX_ORDER; ++order)\n\t\tseq_printf(m, \"%6lu \", zone->free_area[order].nr_free);\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%6lu \"",
            "zone->free_area[order].nr_free"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Node %d, zone %8s \"",
            "pgdat->node_id",
            "zone->name"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void frag_show_print(struct seq_file *m, pg_data_t *pgdat,\n\t\t\t\t\t\tstruct zone *zone)\n{\n\tint order;\n\n\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);\n\tfor (order = 0; order < MAX_ORDER; ++order)\n\t\tseq_printf(m, \"%6lu \", zone->free_area[order].nr_free);\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "walk_zones_in_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1331-1349",
    "snippet": "static void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print",
          "args": [
            "m",
            "pgdat",
            "zone"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "extfrag_show_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "2067-2086",
          "snippet": "static void extfrag_show_print(struct seq_file *m,\n\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)\n{\n\tunsigned int order;\n\tint index;\n\n\t/* Alloc on stack as interrupts are disabled for zone walk */\n\tstruct contig_page_info info;\n\n\tseq_printf(m, \"Node %d, zone %8s \",\n\t\t\t\tpgdat->node_id,\n\t\t\t\tzone->name);\n\tfor (order = 0; order < MAX_ORDER; ++order) {\n\t\tfill_contig_page_info(zone, order, &info);\n\t\tindex = __fragmentation_index(order, &info);\n\t\tseq_printf(m, \"%d.%03d \", index / 1000, index % 1000);\n\t}\n\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void extfrag_show_print(struct seq_file *m,\n\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)\n{\n\tunsigned int order;\n\tint index;\n\n\t/* Alloc on stack as interrupts are disabled for zone walk */\n\tstruct contig_page_info info;\n\n\tseq_printf(m, \"Node %d, zone %8s \",\n\t\t\t\tpgdat->node_id,\n\t\t\t\tzone->name);\n\tfor (order = 0; order < MAX_ORDER; ++order) {\n\t\tfill_contig_page_info(zone, order, &info);\n\t\tindex = __fragmentation_index(order, &info);\n\t\tseq_printf(m, \"%d.%03d \", index / 1000, index % 1000);\n\t}\n\n\tseq_putc(m, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,\n\t\tbool assert_populated, bool nolock,\n\t\tvoid (*print)(struct seq_file *m, pg_data_t *, struct zone *))\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\tunsigned long flags;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (assert_populated && !populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!nolock)\n\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tprint(m, pgdat, zone);\n\t\tif (!nolock)\n\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n}"
  },
  {
    "function_name": "frag_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1323-1325",
    "snippet": "static void frag_stop(struct seq_file *m, void *arg)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void frag_stop(struct seq_file *m, void *arg)\n{\n}"
  },
  {
    "function_name": "frag_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1315-1321",
    "snippet": "static void *frag_next(struct seq_file *m, void *arg, loff_t *pos)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\t(*pos)++;\n\treturn next_online_pgdat(pgdat);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_online_pgdat",
          "args": [
            "pgdat"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "next_online_pgdat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "18-25",
          "snippet": "struct pglist_data *next_online_pgdat(struct pglist_data *pgdat)\n{\n\tint nid = next_online_node(pgdat->node_id);\n\n\tif (nid == MAX_NUMNODES)\n\t\treturn NULL;\n\treturn NODE_DATA(nid);\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstruct pglist_data *next_online_pgdat(struct pglist_data *pgdat)\n{\n\tint nid = next_online_node(pgdat->node_id);\n\n\tif (nid == MAX_NUMNODES)\n\t\treturn NULL;\n\treturn NODE_DATA(nid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void *frag_next(struct seq_file *m, void *arg, loff_t *pos)\n{\n\tpg_data_t *pgdat = (pg_data_t *)arg;\n\n\t(*pos)++;\n\treturn next_online_pgdat(pgdat);\n}"
  },
  {
    "function_name": "frag_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1302-1313",
    "snippet": "static void *frag_start(struct seq_file *m, loff_t *pos)\n{\n\tpg_data_t *pgdat;\n\tloff_t node = *pos;\n\n\tfor (pgdat = first_online_pgdat();\n\t     pgdat && node;\n\t     pgdat = next_online_pgdat(pgdat))\n\t\t--node;\n\n\treturn pgdat;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_online_pgdat",
          "args": [
            "pgdat"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "next_online_pgdat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "18-25",
          "snippet": "struct pglist_data *next_online_pgdat(struct pglist_data *pgdat)\n{\n\tint nid = next_online_node(pgdat->node_id);\n\n\tif (nid == MAX_NUMNODES)\n\t\treturn NULL;\n\treturn NODE_DATA(nid);\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstruct pglist_data *next_online_pgdat(struct pglist_data *pgdat)\n{\n\tint nid = next_online_node(pgdat->node_id);\n\n\tif (nid == MAX_NUMNODES)\n\t\treturn NULL;\n\treturn NODE_DATA(nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_online_pgdat",
          "args": [],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "first_online_pgdat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "13-16",
          "snippet": "struct pglist_data *first_online_pgdat(void)\n{\n\treturn NODE_DATA(first_online_node);\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstruct pglist_data *first_online_pgdat(void)\n{\n\treturn NODE_DATA(first_online_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void *frag_start(struct seq_file *m, loff_t *pos)\n{\n\tpg_data_t *pgdat;\n\tloff_t node = *pos;\n\n\tfor (pgdat = first_online_pgdat();\n\t     pgdat && node;\n\t     pgdat = next_online_pgdat(pgdat))\n\t\t--node;\n\n\treturn pgdat;\n}"
  },
  {
    "function_name": "fragmentation_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1077-1083",
    "snippet": "int fragmentation_index(struct zone *zone, unsigned int order)\n{\n\tstruct contig_page_info info;\n\n\tfill_contig_page_info(zone, order, &info);\n\treturn __fragmentation_index(order, &info);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fragmentation_index",
          "args": [
            "order",
            "&info"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "__fragmentation_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1053-1074",
          "snippet": "static int __fragmentation_index(unsigned int order, struct contig_page_info *info)\n{\n\tunsigned long requested = 1UL << order;\n\n\tif (WARN_ON_ONCE(order >= MAX_ORDER))\n\t\treturn 0;\n\n\tif (!info->free_blocks_total)\n\t\treturn 0;\n\n\t/* Fragmentation index only makes sense when a request would fail */\n\tif (info->free_blocks_suitable)\n\t\treturn -1000;\n\n\t/*\n\t * Index is between 0 and 1 so return within 3 decimal places\n\t *\n\t * 0 => allocation would fail due to lack of memory\n\t * 1 => allocation would fail due to fragmentation\n\t */\n\treturn 1000 - div_u64( (1000+(div_u64(info->free_pages * 1000ULL, requested))), info->free_blocks_total);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int __fragmentation_index(unsigned int order, struct contig_page_info *info)\n{\n\tunsigned long requested = 1UL << order;\n\n\tif (WARN_ON_ONCE(order >= MAX_ORDER))\n\t\treturn 0;\n\n\tif (!info->free_blocks_total)\n\t\treturn 0;\n\n\t/* Fragmentation index only makes sense when a request would fail */\n\tif (info->free_blocks_suitable)\n\t\treturn -1000;\n\n\t/*\n\t * Index is between 0 and 1 so return within 3 decimal places\n\t *\n\t * 0 => allocation would fail due to lack of memory\n\t * 1 => allocation would fail due to fragmentation\n\t */\n\treturn 1000 - div_u64( (1000+(div_u64(info->free_pages * 1000ULL, requested))), info->free_blocks_total);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_contig_page_info",
          "args": [
            "zone",
            "order",
            "&info"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "fill_contig_page_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1019-1044",
          "snippet": "static void fill_contig_page_info(struct zone *zone,\n\t\t\t\tunsigned int suitable_order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\tunsigned int order;\n\n\tinfo->free_pages = 0;\n\tinfo->free_blocks_total = 0;\n\tinfo->free_blocks_suitable = 0;\n\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tunsigned long blocks;\n\n\t\t/* Count number of free blocks */\n\t\tblocks = zone->free_area[order].nr_free;\n\t\tinfo->free_blocks_total += blocks;\n\n\t\t/* Count free base pages */\n\t\tinfo->free_pages += blocks << order;\n\n\t\t/* Count the suitable free blocks */\n\t\tif (order >= suitable_order)\n\t\t\tinfo->free_blocks_suitable += blocks <<\n\t\t\t\t\t\t(order - suitable_order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void fill_contig_page_info(struct zone *zone,\n\t\t\t\tunsigned int suitable_order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\tunsigned int order;\n\n\tinfo->free_pages = 0;\n\tinfo->free_blocks_total = 0;\n\tinfo->free_blocks_suitable = 0;\n\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tunsigned long blocks;\n\n\t\t/* Count number of free blocks */\n\t\tblocks = zone->free_area[order].nr_free;\n\t\tinfo->free_blocks_total += blocks;\n\n\t\t/* Count free base pages */\n\t\tinfo->free_pages += blocks << order;\n\n\t\t/* Count the suitable free blocks */\n\t\tif (order >= suitable_order)\n\t\t\tinfo->free_blocks_suitable += blocks <<\n\t\t\t\t\t\t(order - suitable_order);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nint fragmentation_index(struct zone *zone, unsigned int order)\n{\n\tstruct contig_page_info info;\n\n\tfill_contig_page_info(zone, order, &info);\n\treturn __fragmentation_index(order, &info);\n}"
  },
  {
    "function_name": "__fragmentation_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1053-1074",
    "snippet": "static int __fragmentation_index(unsigned int order, struct contig_page_info *info)\n{\n\tunsigned long requested = 1UL << order;\n\n\tif (WARN_ON_ONCE(order >= MAX_ORDER))\n\t\treturn 0;\n\n\tif (!info->free_blocks_total)\n\t\treturn 0;\n\n\t/* Fragmentation index only makes sense when a request would fail */\n\tif (info->free_blocks_suitable)\n\t\treturn -1000;\n\n\t/*\n\t * Index is between 0 and 1 so return within 3 decimal places\n\t *\n\t * 0 => allocation would fail due to lack of memory\n\t * 1 => allocation would fail due to fragmentation\n\t */\n\treturn 1000 - div_u64( (1000+(div_u64(info->free_pages * 1000ULL, requested))), info->free_blocks_total);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "(1000+(div_u64(info->free_pages * 1000ULL, requested)))",
            "info->free_blocks_total"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "info->free_pages * 1000ULL",
            "requested"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "order >= MAX_ORDER"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int __fragmentation_index(unsigned int order, struct contig_page_info *info)\n{\n\tunsigned long requested = 1UL << order;\n\n\tif (WARN_ON_ONCE(order >= MAX_ORDER))\n\t\treturn 0;\n\n\tif (!info->free_blocks_total)\n\t\treturn 0;\n\n\t/* Fragmentation index only makes sense when a request would fail */\n\tif (info->free_blocks_suitable)\n\t\treturn -1000;\n\n\t/*\n\t * Index is between 0 and 1 so return within 3 decimal places\n\t *\n\t * 0 => allocation would fail due to lack of memory\n\t * 1 => allocation would fail due to fragmentation\n\t */\n\treturn 1000 - div_u64( (1000+(div_u64(info->free_pages * 1000ULL, requested))), info->free_blocks_total);\n}"
  },
  {
    "function_name": "fill_contig_page_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "1019-1044",
    "snippet": "static void fill_contig_page_info(struct zone *zone,\n\t\t\t\tunsigned int suitable_order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\tunsigned int order;\n\n\tinfo->free_pages = 0;\n\tinfo->free_blocks_total = 0;\n\tinfo->free_blocks_suitable = 0;\n\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tunsigned long blocks;\n\n\t\t/* Count number of free blocks */\n\t\tblocks = zone->free_area[order].nr_free;\n\t\tinfo->free_blocks_total += blocks;\n\n\t\t/* Count free base pages */\n\t\tinfo->free_pages += blocks << order;\n\n\t\t/* Count the suitable free blocks */\n\t\tif (order >= suitable_order)\n\t\t\tinfo->free_blocks_suitable += blocks <<\n\t\t\t\t\t\t(order - suitable_order);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void fill_contig_page_info(struct zone *zone,\n\t\t\t\tunsigned int suitable_order,\n\t\t\t\tstruct contig_page_info *info)\n{\n\tunsigned int order;\n\n\tinfo->free_pages = 0;\n\tinfo->free_blocks_total = 0;\n\tinfo->free_blocks_suitable = 0;\n\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tunsigned long blocks;\n\n\t\t/* Count number of free blocks */\n\t\tblocks = zone->free_area[order].nr_free;\n\t\tinfo->free_blocks_total += blocks;\n\n\t\t/* Count free base pages */\n\t\tinfo->free_pages += blocks << order;\n\n\t\t/* Count the suitable free blocks */\n\t\tif (order >= suitable_order)\n\t\t\tinfo->free_blocks_suitable += blocks <<\n\t\t\t\t\t\t(order - suitable_order);\n\t}\n}"
  },
  {
    "function_name": "node_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "991-1000",
    "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&pgdat->vm_stat[item]"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
  },
  {
    "function_name": "sum_zone_numa_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "975-986",
    "snippet": "unsigned long sum_zone_numa_state(int node,\n\t\t\t\t enum numa_stat_item item)\n{\n\tstruct zone *zones = NODE_DATA(node)->node_zones;\n\tint i;\n\tunsigned long count = 0;\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\tcount += zone_numa_state_snapshot(zones + i, item);\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_numa_state_snapshot",
          "args": [
            "zones + i",
            "item"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "node"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long sum_zone_numa_state(int node,\n\t\t\t\t enum numa_stat_item item)\n{\n\tstruct zone *zones = NODE_DATA(node)->node_zones;\n\tint i;\n\tunsigned long count = 0;\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\tcount += zone_numa_state_snapshot(zones + i, item);\n\n\treturn count;\n}"
  },
  {
    "function_name": "sum_zone_node_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "958-969",
    "snippet": "unsigned long sum_zone_node_page_state(int node,\n\t\t\t\t enum zone_stat_item item)\n{\n\tstruct zone *zones = NODE_DATA(node)->node_zones;\n\tint i;\n\tunsigned long count = 0;\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\tcount += zone_page_state(zones + i, item);\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "zones + i",
            "item"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "node"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long sum_zone_node_page_state(int node,\n\t\t\t\t enum zone_stat_item item)\n{\n\tstruct zone *zones = NODE_DATA(node)->node_zones;\n\tint i;\n\tunsigned long count = 0;\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\tcount += zone_page_state(zones + i, item);\n\n\treturn count;\n}"
  },
  {
    "function_name": "__inc_numa_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "938-951",
    "snippet": "void __inc_numa_state(struct zone *zone,\n\t\t\t\t enum numa_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\tu16 __percpu *p = pcp->vm_numa_stat_diff + item;\n\tu16 v;\n\n\tv = __this_cpu_inc_return(*p);\n\n\tif (unlikely(v > NUMA_STATS_THRESHOLD)) {\n\t\tzone_numa_state_add(v, zone, item);\n\t\t__this_cpu_write(*p, 0);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define NUMA_STATS_THRESHOLD (U16_MAX - 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "*p",
            "0"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_numa_state_add",
          "args": [
            "v",
            "zone",
            "item"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "v > NUMA_STATS_THRESHOLD"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "*p"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define NUMA_STATS_THRESHOLD (U16_MAX - 2)\n\nvoid __inc_numa_state(struct zone *zone,\n\t\t\t\t enum numa_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\tu16 __percpu *p = pcp->vm_numa_stat_diff + item;\n\tu16 v;\n\n\tv = __this_cpu_inc_return(*p);\n\n\tif (unlikely(v > NUMA_STATS_THRESHOLD)) {\n\t\tzone_numa_state_add(v, zone, item);\n\t\t__this_cpu_write(*p, 0);\n\t}\n}"
  },
  {
    "function_name": "drain_zonestat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "912-934",
    "snippet": "void drain_zonestat(struct zone *zone, struct per_cpu_pageset *pset)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (pset->vm_stat_diff[i]) {\n\t\t\tint v = pset->vm_stat_diff[i];\n\t\t\tpset->vm_stat_diff[i] = 0;\n\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\tatomic_long_add(v, &vm_zone_stat[i]);\n\t\t}\n\n#ifdef CONFIG_NUMA\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\tif (pset->vm_numa_stat_diff[i]) {\n\t\t\tint v = pset->vm_numa_stat_diff[i];\n\n\t\t\tpset->vm_numa_stat_diff[i] = 0;\n\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\tatomic_long_add(v, &vm_numa_stat[i]);\n\t\t}\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS]",
      "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "v",
            "&vm_numa_stat[i]"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "v",
            "&zone->vm_numa_stat[i]"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "v",
            "&vm_zone_stat[i]"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "v",
            "&zone->vm_stat[i]"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS];\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nvoid drain_zonestat(struct zone *zone, struct per_cpu_pageset *pset)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (pset->vm_stat_diff[i]) {\n\t\t\tint v = pset->vm_stat_diff[i];\n\t\t\tpset->vm_stat_diff[i] = 0;\n\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\tatomic_long_add(v, &vm_zone_stat[i]);\n\t\t}\n\n#ifdef CONFIG_NUMA\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\tif (pset->vm_numa_stat_diff[i]) {\n\t\t\tint v = pset->vm_numa_stat_diff[i];\n\n\t\t\tpset->vm_numa_stat_diff[i] = 0;\n\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\tatomic_long_add(v, &vm_numa_stat[i]);\n\t\t}\n#endif\n}"
  },
  {
    "function_name": "cpu_vm_stats_fold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "846-906",
    "snippet": "void cpu_vm_stats_fold(int cpu)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset *p;\n\n\t\tp = per_cpu_ptr(zone->pageset, cpu);\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\t\tif (p->vm_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_stat_diff[i];\n\t\t\t\tp->vm_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n\t\t\t}\n\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\t\tif (p->vm_numa_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_numa_stat_diff[i];\n\t\t\t\tp->vm_numa_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat *p;\n\n\t\tp = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu);\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\t\tif (p->vm_node_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_node_stat_diff[i];\n\t\t\t\tp->vm_node_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tfold_diff(global_zone_diff, global_numa_diff, global_node_diff);\n#else\n\tfold_diff(global_zone_diff, global_node_diff);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fold_diff",
          "args": [
            "global_zone_diff",
            "global_node_diff"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "fold_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "708-725",
          "snippet": "static int fold_diff(int *zone_diff, int *node_diff)\n{\n\tint i;\n\tint changes = 0;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (zone_diff[i]) {\n\t\t\tatomic_long_add(zone_diff[i], &vm_zone_stat[i]);\n\t\t\tchanges++;\n\t}\n\n\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\tif (node_diff[i]) {\n\t\t\tatomic_long_add(node_diff[i], &vm_node_stat[i]);\n\t\t\tchanges++;\n\t}\n\treturn changes;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS]",
            "atomic_long_t vm_node_stat[NR_VM_NODE_STAT_ITEMS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS];\natomic_long_t vm_node_stat[NR_VM_NODE_STAT_ITEMS];\n\nstatic int fold_diff(int *zone_diff, int *node_diff)\n{\n\tint i;\n\tint changes = 0;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (zone_diff[i]) {\n\t\t\tatomic_long_add(zone_diff[i], &vm_zone_stat[i]);\n\t\t\tchanges++;\n\t}\n\n\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\tif (node_diff[i]) {\n\t\t\tatomic_long_add(node_diff[i], &vm_node_stat[i]);\n\t\t\tchanges++;\n\t}\n\treturn changes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "v",
            "&pgdat->vm_stat[i]"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pgdat->per_cpu_nodestats",
            "cpu"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "v",
            "&zone->vm_numa_stat[i]"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "v",
            "&zone->vm_stat[i]"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "zone->pageset",
            "cpu"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nvoid cpu_vm_stats_fold(int cpu)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset *p;\n\n\t\tp = per_cpu_ptr(zone->pageset, cpu);\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\t\tif (p->vm_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_stat_diff[i];\n\t\t\t\tp->vm_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n\t\t\t}\n\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\t\tif (p->vm_numa_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_numa_stat_diff[i];\n\t\t\t\tp->vm_numa_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat *p;\n\n\t\tp = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu);\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\t\tif (p->vm_node_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_node_stat_diff[i];\n\t\t\t\tp->vm_node_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tfold_diff(global_zone_diff, global_numa_diff, global_node_diff);\n#else\n\tfold_diff(global_zone_diff, global_node_diff);\n#endif\n}"
  },
  {
    "function_name": "refresh_cpu_vm_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "744-839",
    "snippet": "static int refresh_cpu_vm_stats(bool do_pagesets)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\tint changes = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset __percpu *p = zone->pageset;\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n#ifdef CONFIG_NUMA\n\t\t\t\t/* 3 seconds idle till flush */\n\t\t\t\t__this_cpu_write(p->expire, 3);\n#endif\n\t\t\t}\n\t\t}\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_numa_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t\t__this_cpu_write(p->expire, 3);\n\t\t\t}\n\t\t}\n\n\t\tif (do_pagesets) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Deal with draining the remote pageset of this\n\t\t\t * processor\n\t\t\t *\n\t\t\t * Check if there are pages remaining in this pageset\n\t\t\t * if not then there is nothing to expire.\n\t\t\t */\n\t\t\tif (!__this_cpu_read(p->expire) ||\n\t\t\t       !__this_cpu_read(p->pcp.count))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * We never drain zones local to this processor.\n\t\t\t */\n\t\t\tif (zone_to_nid(zone) == numa_node_id()) {\n\t\t\t\t__this_cpu_write(p->expire, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (__this_cpu_dec_return(p->expire))\n\t\t\t\tcontinue;\n\n\t\t\tif (__this_cpu_read(p->pcp.count)) {\n\t\t\t\tdrain_zone_pages(zone, this_cpu_ptr(&p->pcp));\n\t\t\t\tchanges++;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat __percpu *p = pgdat->per_cpu_nodestats;\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_node_stat_diff[i], 0);\n\t\t\tif (v) {\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tchanges += fold_diff(global_zone_diff, global_numa_diff,\n\t\t\t     global_node_diff);\n#else\n\tchanges += fold_diff(global_zone_diff, global_node_diff);\n#endif\n\treturn changes;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fold_diff",
          "args": [
            "global_zone_diff",
            "global_node_diff"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "fold_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "708-725",
          "snippet": "static int fold_diff(int *zone_diff, int *node_diff)\n{\n\tint i;\n\tint changes = 0;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (zone_diff[i]) {\n\t\t\tatomic_long_add(zone_diff[i], &vm_zone_stat[i]);\n\t\t\tchanges++;\n\t}\n\n\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\tif (node_diff[i]) {\n\t\t\tatomic_long_add(node_diff[i], &vm_node_stat[i]);\n\t\t\tchanges++;\n\t}\n\treturn changes;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS]",
            "atomic_long_t vm_node_stat[NR_VM_NODE_STAT_ITEMS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS];\natomic_long_t vm_node_stat[NR_VM_NODE_STAT_ITEMS];\n\nstatic int fold_diff(int *zone_diff, int *node_diff)\n{\n\tint i;\n\tint changes = 0;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (zone_diff[i]) {\n\t\t\tatomic_long_add(zone_diff[i], &vm_zone_stat[i]);\n\t\t\tchanges++;\n\t}\n\n\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\tif (node_diff[i]) {\n\t\t\tatomic_long_add(node_diff[i], &vm_node_stat[i]);\n\t\t\tchanges++;\n\t}\n\treturn changes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "v",
            "&pgdat->vm_stat[i]"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_xchg",
          "args": [
            "p->vm_node_stat_diff[i]",
            "0"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_zone_pages",
          "args": [
            "zone",
            "this_cpu_ptr(&p->pcp)"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "drain_zone_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2525-2536",
          "snippet": "void drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp)\n{\n\tunsigned long flags;\n\tint to_drain, batch;\n\n\tlocal_irq_save(flags);\n\tbatch = READ_ONCE(pcp->batch);\n\tto_drain = min(pcp->count, batch);\n\tif (to_drain > 0)\n\t\tfree_pcppages_bulk(zone, to_drain, pcp);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp)\n{\n\tunsigned long flags;\n\tint to_drain, batch;\n\n\tlocal_irq_save(flags);\n\tbatch = READ_ONCE(pcp->batch);\n\tto_drain = min(pcp->count, batch);\n\tif (to_drain > 0)\n\t\tfree_pcppages_bulk(zone, to_drain, pcp);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&p->pcp"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "p->pcp.count"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec_return",
          "args": [
            "p->expire"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "p->expire",
            "0"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "p->pcp.count"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "p->expire"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "p->expire",
            "3"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "v",
            "&zone->vm_numa_stat[i]"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_xchg",
          "args": [
            "p->vm_numa_stat_diff[i]",
            "0"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "p->expire",
            "3"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "v",
            "&zone->vm_stat[i]"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_xchg",
          "args": [
            "p->vm_stat_diff[i]",
            "0"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nstatic int refresh_cpu_vm_stats(bool do_pagesets)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\tint changes = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset __percpu *p = zone->pageset;\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n#ifdef CONFIG_NUMA\n\t\t\t\t/* 3 seconds idle till flush */\n\t\t\t\t__this_cpu_write(p->expire, 3);\n#endif\n\t\t\t}\n\t\t}\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_numa_stat_diff[i], 0);\n\t\t\tif (v) {\n\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t\t__this_cpu_write(p->expire, 3);\n\t\t\t}\n\t\t}\n\n\t\tif (do_pagesets) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Deal with draining the remote pageset of this\n\t\t\t * processor\n\t\t\t *\n\t\t\t * Check if there are pages remaining in this pageset\n\t\t\t * if not then there is nothing to expire.\n\t\t\t */\n\t\t\tif (!__this_cpu_read(p->expire) ||\n\t\t\t       !__this_cpu_read(p->pcp.count))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * We never drain zones local to this processor.\n\t\t\t */\n\t\t\tif (zone_to_nid(zone) == numa_node_id()) {\n\t\t\t\t__this_cpu_write(p->expire, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (__this_cpu_dec_return(p->expire))\n\t\t\t\tcontinue;\n\n\t\t\tif (__this_cpu_read(p->pcp.count)) {\n\t\t\t\tdrain_zone_pages(zone, this_cpu_ptr(&p->pcp));\n\t\t\t\tchanges++;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat __percpu *p = pgdat->per_cpu_nodestats;\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {\n\t\t\tint v;\n\n\t\t\tv = this_cpu_xchg(p->vm_node_stat_diff[i], 0);\n\t\t\tif (v) {\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tchanges += fold_diff(global_zone_diff, global_numa_diff,\n\t\t\t     global_node_diff);\n#else\n\tchanges += fold_diff(global_zone_diff, global_node_diff);\n#endif\n\treturn changes;\n}"
  },
  {
    "function_name": "fold_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "708-725",
    "snippet": "static int fold_diff(int *zone_diff, int *node_diff)\n{\n\tint i;\n\tint changes = 0;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (zone_diff[i]) {\n\t\t\tatomic_long_add(zone_diff[i], &vm_zone_stat[i]);\n\t\t\tchanges++;\n\t}\n\n\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\tif (node_diff[i]) {\n\t\t\tatomic_long_add(node_diff[i], &vm_node_stat[i]);\n\t\t\tchanges++;\n\t}\n\treturn changes;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS]",
      "atomic_long_t vm_node_stat[NR_VM_NODE_STAT_ITEMS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "node_diff[i]",
            "&vm_node_stat[i]"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "zone_diff[i]",
            "&vm_zone_stat[i]"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS];\natomic_long_t vm_node_stat[NR_VM_NODE_STAT_ITEMS];\n\nstatic int fold_diff(int *zone_diff, int *node_diff)\n{\n\tint i;\n\tint changes = 0;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (zone_diff[i]) {\n\t\t\tatomic_long_add(zone_diff[i], &vm_zone_stat[i]);\n\t\t\tchanges++;\n\t}\n\n\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\tif (node_diff[i]) {\n\t\t\tatomic_long_add(node_diff[i], &vm_node_stat[i]);\n\t\t\tchanges++;\n\t}\n\treturn changes;\n}"
  },
  {
    "function_name": "fold_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "683-706",
    "snippet": "static int fold_diff(int *zone_diff, int *numa_diff, int *node_diff)\n{\n\tint i;\n\tint changes = 0;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (zone_diff[i]) {\n\t\t\tatomic_long_add(zone_diff[i], &vm_zone_stat[i]);\n\t\t\tchanges++;\n\t}\n\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\tif (numa_diff[i]) {\n\t\t\tatomic_long_add(numa_diff[i], &vm_numa_stat[i]);\n\t\t\tchanges++;\n\t}\n\n\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\tif (node_diff[i]) {\n\t\t\tatomic_long_add(node_diff[i], &vm_node_stat[i]);\n\t\t\tchanges++;\n\t}\n\treturn changes;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS]",
      "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]",
      "atomic_long_t vm_node_stat[NR_VM_NODE_STAT_ITEMS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "node_diff[i]",
            "&vm_node_stat[i]"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "numa_diff[i]",
            "&vm_numa_stat[i]"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "zone_diff[i]",
            "&vm_zone_stat[i]"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS];\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\natomic_long_t vm_node_stat[NR_VM_NODE_STAT_ITEMS];\n\nstatic int fold_diff(int *zone_diff, int *numa_diff, int *node_diff)\n{\n\tint i;\n\tint changes = 0;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (zone_diff[i]) {\n\t\t\tatomic_long_add(zone_diff[i], &vm_zone_stat[i]);\n\t\t\tchanges++;\n\t}\n\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\tif (numa_diff[i]) {\n\t\t\tatomic_long_add(numa_diff[i], &vm_numa_stat[i]);\n\t\t\tchanges++;\n\t}\n\n\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\tif (node_diff[i]) {\n\t\t\tatomic_long_add(node_diff[i], &vm_node_stat[i]);\n\t\t\tchanges++;\n\t}\n\treturn changes;\n}"
  },
  {
    "function_name": "dec_node_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "667-674",
    "snippet": "void dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_node_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dec_node_page_state",
          "args": [
            "page",
            "item"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "460-463",
          "snippet": "void __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_node_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "inc_node_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "655-664",
    "snippet": "void inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_node_state",
          "args": [
            "pgdat",
            "item"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "394-408",
          "snippet": "void __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v + overstep, pgdat, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v + overstep, pgdat, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "mod_node_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "644-652",
    "snippet": "void mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_node_page_state",
          "args": [
            "pgdat",
            "item",
            "delta"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "335-352",
          "snippet": "void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "inc_node_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "634-641",
    "snippet": "void inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_node_state",
          "args": [
            "pgdat",
            "item"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "394-408",
          "snippet": "void __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v + overstep, pgdat, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v + overstep, pgdat, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "dec_zone_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "624-631",
    "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dec_zone_page_state",
          "args": [
            "page",
            "item"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "454-457",
          "snippet": "void __dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\t__dec_zone_state(page_zone(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\t__dec_zone_state(page_zone(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "inc_zone_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "612-621",
    "snippet": "void inc_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\tstruct zone *zone;\n\n\tzone = page_zone(page);\n\tlocal_irq_save(flags);\n\t__inc_zone_state(zone, item);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_zone_state",
          "args": [
            "zone",
            "item"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_zone_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "378-392",
          "snippet": "void __inc_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v + overstep, zone, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v + overstep, zone, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\tstruct zone *zone;\n\n\tzone = page_zone(page);\n\tlocal_irq_save(flags);\n\t__inc_zone_state(zone, item);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "mod_zone_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "601-609",
    "snippet": "void mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t long delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_zone_page_state(zone, item, delta);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_zone_page_state",
          "args": [
            "zone",
            "item",
            "delta"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "315-332",
          "snippet": "void __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t long delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_zone_page_state(zone, item, delta);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "dec_node_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "592-595",
    "snippet": "void dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tmod_node_state(page_pgdat(page), item, -1, -1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_node_state",
          "args": [
            "page_pgdat(page)",
            "item",
            "-1",
            "-1"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "mod_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "536-572",
          "snippet": "static inline void mod_node_state(struct pglist_data *pgdat,\n       enum node_stat_item item, int delta, int overstep_mode)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to node counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a node.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to node counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tnode_page_state_add(z, pgdat, item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mod_node_state(struct pglist_data *pgdat,\n       enum node_stat_item item, int delta, int overstep_mode)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to node counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a node.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to node counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tnode_page_state_add(z, pgdat, item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tmod_node_state(page_pgdat(page), item, -1, -1);\n}"
  },
  {
    "function_name": "inc_node_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "586-589",
    "snippet": "void inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tmod_node_state(page_pgdat(page), item, 1, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_node_state",
          "args": [
            "page_pgdat(page)",
            "item",
            "1",
            "1"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "mod_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "536-572",
          "snippet": "static inline void mod_node_state(struct pglist_data *pgdat,\n       enum node_stat_item item, int delta, int overstep_mode)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to node counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a node.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to node counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tnode_page_state_add(z, pgdat, item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mod_node_state(struct pglist_data *pgdat,\n       enum node_stat_item item, int delta, int overstep_mode)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to node counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a node.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to node counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tnode_page_state_add(z, pgdat, item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tmod_node_state(page_pgdat(page), item, 1, 1);\n}"
  },
  {
    "function_name": "inc_node_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "581-584",
    "snippet": "void inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tmod_node_state(pgdat, item, 1, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_node_state",
          "args": [
            "pgdat",
            "item",
            "1",
            "1"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "mod_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "536-572",
          "snippet": "static inline void mod_node_state(struct pglist_data *pgdat,\n       enum node_stat_item item, int delta, int overstep_mode)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to node counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a node.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to node counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tnode_page_state_add(z, pgdat, item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mod_node_state(struct pglist_data *pgdat,\n       enum node_stat_item item, int delta, int overstep_mode)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to node counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a node.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to node counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tnode_page_state_add(z, pgdat, item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tmod_node_state(pgdat, item, 1, 1);\n}"
  },
  {
    "function_name": "mod_node_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "574-578",
    "snippet": "void mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tmod_node_state(pgdat, item, delta, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_node_state",
          "args": [
            "pgdat",
            "item",
            "delta",
            "0"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "mod_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "536-572",
          "snippet": "static inline void mod_node_state(struct pglist_data *pgdat,\n       enum node_stat_item item, int delta, int overstep_mode)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to node counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a node.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to node counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tnode_page_state_add(z, pgdat, item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mod_node_state(struct pglist_data *pgdat,\n       enum node_stat_item item, int delta, int overstep_mode)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to node counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a node.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to node counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tnode_page_state_add(z, pgdat, item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tmod_node_state(pgdat, item, delta, 0);\n}"
  },
  {
    "function_name": "mod_node_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "536-572",
    "snippet": "static inline void mod_node_state(struct pglist_data *pgdat,\n       enum node_stat_item item, int delta, int overstep_mode)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to node counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a node.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to node counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tnode_page_state_add(z, pgdat, item);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_page_state_add",
          "args": [
            "z",
            "pgdat",
            "item"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_cmpxchg",
          "args": [
            "*p",
            "o",
            "n"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "*p"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "pcp->stat_threshold"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mod_node_state(struct pglist_data *pgdat,\n       enum node_stat_item item, int delta, int overstep_mode)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to node counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a node.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to node counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tnode_page_state_add(z, pgdat, item);\n}"
  },
  {
    "function_name": "dec_zone_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "530-533",
    "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tmod_zone_state(page_zone(page), item, -1, -1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_zone_state",
          "args": [
            "page_zone(page)",
            "item",
            "-1",
            "-1"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "mod_zone_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "479-515",
          "snippet": "static inline void mod_zone_state(struct zone *zone,\n       enum zone_stat_item item, long delta, int overstep_mode)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to zone counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a zone.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to zone counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tzone_page_state_add(z, zone, item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mod_zone_state(struct zone *zone,\n       enum zone_stat_item item, long delta, int overstep_mode)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to zone counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a zone.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to zone counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tzone_page_state_add(z, zone, item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tmod_zone_state(page_zone(page), item, -1, -1);\n}"
  },
  {
    "function_name": "inc_zone_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "524-527",
    "snippet": "void inc_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tmod_zone_state(page_zone(page), item, 1, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_zone_state",
          "args": [
            "page_zone(page)",
            "item",
            "1",
            "1"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "mod_zone_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "479-515",
          "snippet": "static inline void mod_zone_state(struct zone *zone,\n       enum zone_stat_item item, long delta, int overstep_mode)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to zone counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a zone.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to zone counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tzone_page_state_add(z, zone, item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mod_zone_state(struct zone *zone,\n       enum zone_stat_item item, long delta, int overstep_mode)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to zone counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a zone.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to zone counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tzone_page_state_add(z, zone, item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tmod_zone_state(page_zone(page), item, 1, 1);\n}"
  },
  {
    "function_name": "mod_zone_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "517-521",
    "snippet": "void mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t long delta)\n{\n\tmod_zone_state(zone, item, delta, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_zone_state",
          "args": [
            "zone",
            "item",
            "delta",
            "0"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "mod_zone_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "479-515",
          "snippet": "static inline void mod_zone_state(struct zone *zone,\n       enum zone_stat_item item, long delta, int overstep_mode)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to zone counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a zone.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to zone counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tzone_page_state_add(z, zone, item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mod_zone_state(struct zone *zone,\n       enum zone_stat_item item, long delta, int overstep_mode)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to zone counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a zone.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to zone counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tzone_page_state_add(z, zone, item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t long delta)\n{\n\tmod_zone_state(zone, item, delta, 0);\n}"
  },
  {
    "function_name": "mod_zone_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "479-515",
    "snippet": "static inline void mod_zone_state(struct zone *zone,\n       enum zone_stat_item item, long delta, int overstep_mode)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to zone counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a zone.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to zone counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tzone_page_state_add(z, zone, item);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_page_state_add",
          "args": [
            "z",
            "zone",
            "item"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_cmpxchg",
          "args": [
            "*p",
            "o",
            "n"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "*p"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "pcp->stat_threshold"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mod_zone_state(struct zone *zone,\n       enum zone_stat_item item, long delta, int overstep_mode)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong o, n, t, z;\n\n\tdo {\n\t\tz = 0;  /* overflow to zone counters */\n\n\t\t/*\n\t\t * The fetching of the stat_threshold is racy. We may apply\n\t\t * a counter threshold to the wrong the cpu if we get\n\t\t * rescheduled while executing here. However, the next\n\t\t * counter update will apply the threshold again and\n\t\t * therefore bring the counter under the threshold again.\n\t\t *\n\t\t * Most of the time the thresholds are the same anyways\n\t\t * for all cpus in a zone.\n\t\t */\n\t\tt = this_cpu_read(pcp->stat_threshold);\n\n\t\to = this_cpu_read(*p);\n\t\tn = delta + o;\n\n\t\tif (n > t || n < -t) {\n\t\t\tint os = overstep_mode * (t >> 1) ;\n\n\t\t\t/* Overflow must be added to zone counters */\n\t\t\tz = n + os;\n\t\t\tn = -os;\n\t\t}\n\t} while (this_cpu_cmpxchg(*p, o, n) != o);\n\n\tif (z)\n\t\tzone_page_state_add(z, zone, item);\n}"
  },
  {
    "function_name": "__dec_node_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "460-463",
    "snippet": "void __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dec_node_state",
          "args": [
            "page_pgdat(page)",
            "item"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "438-452",
          "snippet": "void __dec_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v - overstep, pgdat, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v - overstep, pgdat, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}"
  },
  {
    "function_name": "__dec_zone_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "454-457",
    "snippet": "void __dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\t__dec_zone_state(page_zone(page), item);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dec_zone_state",
          "args": [
            "page_zone(page)",
            "item"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_zone_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "422-436",
          "snippet": "void __dec_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v - overstep, zone, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v - overstep, zone, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\t__dec_zone_state(page_zone(page), item);\n}"
  },
  {
    "function_name": "__dec_node_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "438-452",
    "snippet": "void __dec_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v - overstep, pgdat, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "*p",
            "overstep"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state_add",
          "args": [
            "v - overstep",
            "pgdat",
            "item"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "v < - t"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "pcp->stat_threshold"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec_return",
          "args": [
            "*p"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v - overstep, pgdat, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}"
  },
  {
    "function_name": "__dec_zone_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "422-436",
    "snippet": "void __dec_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v - overstep, zone, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "*p",
            "overstep"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state_add",
          "args": [
            "v - overstep",
            "zone",
            "item"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "v < - t"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "pcp->stat_threshold"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec_return",
          "args": [
            "*p"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v - overstep, zone, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}"
  },
  {
    "function_name": "__inc_node_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "416-419",
    "snippet": "void __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__inc_node_state",
          "args": [
            "page_pgdat(page)",
            "item"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "394-408",
          "snippet": "void __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v + overstep, pgdat, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v + overstep, pgdat, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}"
  },
  {
    "function_name": "__inc_zone_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "410-413",
    "snippet": "void __inc_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\t__inc_zone_state(page_zone(page), item);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__inc_zone_state",
          "args": [
            "page_zone(page)",
            "item"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_zone_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "378-392",
          "snippet": "void __inc_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v + overstep, zone, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v + overstep, zone, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\t__inc_zone_state(page_zone(page), item);\n}"
  },
  {
    "function_name": "__inc_node_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "394-408",
    "snippet": "void __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v + overstep, pgdat, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "*p",
            "-overstep"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state_add",
          "args": [
            "v + overstep",
            "pgdat",
            "item"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "v > t"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "pcp->stat_threshold"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "*p"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v + overstep, pgdat, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}"
  },
  {
    "function_name": "__inc_zone_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "378-392",
    "snippet": "void __inc_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v + overstep, zone, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "*p",
            "-overstep"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state_add",
          "args": [
            "v + overstep",
            "zone",
            "item"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "v > t"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "pcp->stat_threshold"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "*p"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v + overstep, zone, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}"
  },
  {
    "function_name": "__mod_node_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "335-352",
    "snippet": "void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "*p",
            "x"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state_add",
          "args": [
            "x",
            "pgdat",
            "item"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "x > t || x < -t"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "pcp->stat_threshold"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "*p"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
  },
  {
    "function_name": "__mod_zone_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "315-332",
    "snippet": "void __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "*p",
            "x"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state_add",
          "args": [
            "x",
            "zone",
            "item"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "x > t || x < -t"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "pcp->stat_threshold"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "*p"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
  },
  {
    "function_name": "set_pgdat_percpu_threshold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "290-308",
    "snippet": "void set_pgdat_percpu_threshold(pg_data_t *pgdat,\n\t\t\t\tint (*calculate_pressure)(struct zone *))\n{\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\tint i;\n\n\tfor (i = 0; i < pgdat->nr_zones; i++) {\n\t\tzone = &pgdat->node_zones[i];\n\t\tif (!zone->percpu_drift_mark)\n\t\t\tcontinue;\n\n\t\tthreshold = (*calculate_pressure)(zone);\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "zone"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid set_pgdat_percpu_threshold(pg_data_t *pgdat,\n\t\t\t\tint (*calculate_pressure)(struct zone *))\n{\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\tint i;\n\n\tfor (i = 0; i < pgdat->nr_zones; i++) {\n\t\tzone = &pgdat->node_zones[i];\n\t\tif (!zone->percpu_drift_mark)\n\t\t\tcontinue;\n\n\t\tthreshold = (*calculate_pressure)(zone);\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\t}\n}"
  },
  {
    "function_name": "refresh_zone_stat_thresholds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "245-288",
    "snippet": "void refresh_zone_stat_thresholds(void)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\n\t/* Zero current pgdat thresholds */\n\tfor_each_online_pgdat(pgdat) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold = 0;\n\t\t}\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\t\tunsigned long max_drift, tolerate_drift;\n\n\t\tthreshold = calculate_normal_threshold(zone);\n\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tint pgdat_threshold;\n\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\n\t\t\t/* Base nodestat threshold on the largest populated zone. */\n\t\t\tpgdat_threshold = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold;\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold\n\t\t\t\t= max(threshold, pgdat_threshold);\n\t\t}\n\n\t\t/*\n\t\t * Only set percpu_drift_mark if there is a danger that\n\t\t * NR_FREE_PAGES reports the low watermark is ok when in fact\n\t\t * the min watermark could be breached by an allocation\n\t\t */\n\t\ttolerate_drift = low_wmark_pages(zone) - min_wmark_pages(zone);\n\t\tmax_drift = num_online_cpus() * threshold;\n\t\tif (max_drift > tolerate_drift)\n\t\t\tzone->percpu_drift_mark = high_wmark_pages(zone) +\n\t\t\t\t\tmax_drift;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "high_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "threshold",
            "pgdat_threshold"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pgdat->per_cpu_nodestats",
            "cpu"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pgdat->per_cpu_nodestats",
            "cpu"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "zone->pageset",
            "cpu"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_normal_threshold",
          "args": [
            "zone"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_normal_threshold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "195-240",
          "snippet": "int calculate_normal_threshold(struct zone *zone)\n{\n\tint threshold;\n\tint mem;\t/* memory in 128 MB units */\n\n\t/*\n\t * The threshold scales with the number of processors and the amount\n\t * of memory per zone. More memory means that we can defer updates for\n\t * longer, more processors could lead to more contention.\n \t * fls() is used to have a cheap way of logarithmic scaling.\n\t *\n\t * Some sample thresholds:\n\t *\n\t * Threshold\tProcessors\t(fls)\tZonesize\tfls(mem+1)\n\t * ------------------------------------------------------------------\n\t * 8\t\t1\t\t1\t0.9-1 GB\t4\n\t * 16\t\t2\t\t2\t0.9-1 GB\t4\n\t * 20 \t\t2\t\t2\t1-2 GB\t\t5\n\t * 24\t\t2\t\t2\t2-4 GB\t\t6\n\t * 28\t\t2\t\t2\t4-8 GB\t\t7\n\t * 32\t\t2\t\t2\t8-16 GB\t\t8\n\t * 4\t\t2\t\t2\t<128M\t\t1\n\t * 30\t\t4\t\t3\t2-4 GB\t\t5\n\t * 48\t\t4\t\t3\t8-16 GB\t\t8\n\t * 32\t\t8\t\t4\t1-2 GB\t\t4\n\t * 32\t\t8\t\t4\t0.9-1GB\t\t4\n\t * 10\t\t16\t\t5\t<128M\t\t1\n\t * 40\t\t16\t\t5\t900M\t\t4\n\t * 70\t\t64\t\t7\t2-4 GB\t\t5\n\t * 84\t\t64\t\t7\t4-8 GB\t\t6\n\t * 108\t\t512\t\t9\t4-8 GB\t\t6\n\t * 125\t\t1024\t\t10\t8-16 GB\t\t8\n\t * 125\t\t1024\t\t10\t16-32 GB\t9\n\t */\n\n\tmem = zone->managed_pages >> (27 - PAGE_SHIFT);\n\n\tthreshold = 2 * fls(num_online_cpus()) * (1 + fls(mem));\n\n\t/*\n\t * Maximum threshold is 125\n\t */\n\tthreshold = min(125, threshold);\n\n\treturn threshold;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nint calculate_normal_threshold(struct zone *zone)\n{\n\tint threshold;\n\tint mem;\t/* memory in 128 MB units */\n\n\t/*\n\t * The threshold scales with the number of processors and the amount\n\t * of memory per zone. More memory means that we can defer updates for\n\t * longer, more processors could lead to more contention.\n \t * fls() is used to have a cheap way of logarithmic scaling.\n\t *\n\t * Some sample thresholds:\n\t *\n\t * Threshold\tProcessors\t(fls)\tZonesize\tfls(mem+1)\n\t * ------------------------------------------------------------------\n\t * 8\t\t1\t\t1\t0.9-1 GB\t4\n\t * 16\t\t2\t\t2\t0.9-1 GB\t4\n\t * 20 \t\t2\t\t2\t1-2 GB\t\t5\n\t * 24\t\t2\t\t2\t2-4 GB\t\t6\n\t * 28\t\t2\t\t2\t4-8 GB\t\t7\n\t * 32\t\t2\t\t2\t8-16 GB\t\t8\n\t * 4\t\t2\t\t2\t<128M\t\t1\n\t * 30\t\t4\t\t3\t2-4 GB\t\t5\n\t * 48\t\t4\t\t3\t8-16 GB\t\t8\n\t * 32\t\t8\t\t4\t1-2 GB\t\t4\n\t * 32\t\t8\t\t4\t0.9-1GB\t\t4\n\t * 10\t\t16\t\t5\t<128M\t\t1\n\t * 40\t\t16\t\t5\t900M\t\t4\n\t * 70\t\t64\t\t7\t2-4 GB\t\t5\n\t * 84\t\t64\t\t7\t4-8 GB\t\t6\n\t * 108\t\t512\t\t9\t4-8 GB\t\t6\n\t * 125\t\t1024\t\t10\t8-16 GB\t\t8\n\t * 125\t\t1024\t\t10\t16-32 GB\t9\n\t */\n\n\tmem = zone->managed_pages >> (27 - PAGE_SHIFT);\n\n\tthreshold = 2 * fls(num_online_cpus()) * (1 + fls(mem));\n\n\t/*\n\t * Maximum threshold is 125\n\t */\n\tthreshold = min(125, threshold);\n\n\treturn threshold;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pgdat->per_cpu_nodestats",
            "cpu"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid refresh_zone_stat_thresholds(void)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\n\t/* Zero current pgdat thresholds */\n\tfor_each_online_pgdat(pgdat) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold = 0;\n\t\t}\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\t\tunsigned long max_drift, tolerate_drift;\n\n\t\tthreshold = calculate_normal_threshold(zone);\n\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tint pgdat_threshold;\n\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\n\t\t\t/* Base nodestat threshold on the largest populated zone. */\n\t\t\tpgdat_threshold = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold;\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold\n\t\t\t\t= max(threshold, pgdat_threshold);\n\t\t}\n\n\t\t/*\n\t\t * Only set percpu_drift_mark if there is a danger that\n\t\t * NR_FREE_PAGES reports the low watermark is ok when in fact\n\t\t * the min watermark could be breached by an allocation\n\t\t */\n\t\ttolerate_drift = low_wmark_pages(zone) - min_wmark_pages(zone);\n\t\tmax_drift = num_online_cpus() * threshold;\n\t\tif (max_drift > tolerate_drift)\n\t\t\tzone->percpu_drift_mark = high_wmark_pages(zone) +\n\t\t\t\t\tmax_drift;\n\t}\n}"
  },
  {
    "function_name": "calculate_normal_threshold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "195-240",
    "snippet": "int calculate_normal_threshold(struct zone *zone)\n{\n\tint threshold;\n\tint mem;\t/* memory in 128 MB units */\n\n\t/*\n\t * The threshold scales with the number of processors and the amount\n\t * of memory per zone. More memory means that we can defer updates for\n\t * longer, more processors could lead to more contention.\n \t * fls() is used to have a cheap way of logarithmic scaling.\n\t *\n\t * Some sample thresholds:\n\t *\n\t * Threshold\tProcessors\t(fls)\tZonesize\tfls(mem+1)\n\t * ------------------------------------------------------------------\n\t * 8\t\t1\t\t1\t0.9-1 GB\t4\n\t * 16\t\t2\t\t2\t0.9-1 GB\t4\n\t * 20 \t\t2\t\t2\t1-2 GB\t\t5\n\t * 24\t\t2\t\t2\t2-4 GB\t\t6\n\t * 28\t\t2\t\t2\t4-8 GB\t\t7\n\t * 32\t\t2\t\t2\t8-16 GB\t\t8\n\t * 4\t\t2\t\t2\t<128M\t\t1\n\t * 30\t\t4\t\t3\t2-4 GB\t\t5\n\t * 48\t\t4\t\t3\t8-16 GB\t\t8\n\t * 32\t\t8\t\t4\t1-2 GB\t\t4\n\t * 32\t\t8\t\t4\t0.9-1GB\t\t4\n\t * 10\t\t16\t\t5\t<128M\t\t1\n\t * 40\t\t16\t\t5\t900M\t\t4\n\t * 70\t\t64\t\t7\t2-4 GB\t\t5\n\t * 84\t\t64\t\t7\t4-8 GB\t\t6\n\t * 108\t\t512\t\t9\t4-8 GB\t\t6\n\t * 125\t\t1024\t\t10\t8-16 GB\t\t8\n\t * 125\t\t1024\t\t10\t16-32 GB\t9\n\t */\n\n\tmem = zone->managed_pages >> (27 - PAGE_SHIFT);\n\n\tthreshold = 2 * fls(num_online_cpus()) * (1 + fls(mem));\n\n\t/*\n\t * Maximum threshold is 125\n\t */\n\tthreshold = min(125, threshold);\n\n\treturn threshold;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "125",
            "threshold"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "mem"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "num_online_cpus()"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nint calculate_normal_threshold(struct zone *zone)\n{\n\tint threshold;\n\tint mem;\t/* memory in 128 MB units */\n\n\t/*\n\t * The threshold scales with the number of processors and the amount\n\t * of memory per zone. More memory means that we can defer updates for\n\t * longer, more processors could lead to more contention.\n \t * fls() is used to have a cheap way of logarithmic scaling.\n\t *\n\t * Some sample thresholds:\n\t *\n\t * Threshold\tProcessors\t(fls)\tZonesize\tfls(mem+1)\n\t * ------------------------------------------------------------------\n\t * 8\t\t1\t\t1\t0.9-1 GB\t4\n\t * 16\t\t2\t\t2\t0.9-1 GB\t4\n\t * 20 \t\t2\t\t2\t1-2 GB\t\t5\n\t * 24\t\t2\t\t2\t2-4 GB\t\t6\n\t * 28\t\t2\t\t2\t4-8 GB\t\t7\n\t * 32\t\t2\t\t2\t8-16 GB\t\t8\n\t * 4\t\t2\t\t2\t<128M\t\t1\n\t * 30\t\t4\t\t3\t2-4 GB\t\t5\n\t * 48\t\t4\t\t3\t8-16 GB\t\t8\n\t * 32\t\t8\t\t4\t1-2 GB\t\t4\n\t * 32\t\t8\t\t4\t0.9-1GB\t\t4\n\t * 10\t\t16\t\t5\t<128M\t\t1\n\t * 40\t\t16\t\t5\t900M\t\t4\n\t * 70\t\t64\t\t7\t2-4 GB\t\t5\n\t * 84\t\t64\t\t7\t4-8 GB\t\t6\n\t * 108\t\t512\t\t9\t4-8 GB\t\t6\n\t * 125\t\t1024\t\t10\t8-16 GB\t\t8\n\t * 125\t\t1024\t\t10\t16-32 GB\t9\n\t */\n\n\tmem = zone->managed_pages >> (27 - PAGE_SHIFT);\n\n\tthreshold = 2 * fls(num_online_cpus()) * (1 + fls(mem));\n\n\t/*\n\t * Maximum threshold is 125\n\t */\n\tthreshold = min(125, threshold);\n\n\treturn threshold;\n}"
  },
  {
    "function_name": "calculate_pressure_threshold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "171-193",
    "snippet": "int calculate_pressure_threshold(struct zone *zone)\n{\n\tint threshold;\n\tint watermark_distance;\n\n\t/*\n\t * As vmstats are not up to date, there is drift between the estimated\n\t * and real values. For high thresholds and a high number of CPUs, it\n\t * is possible for the min watermark to be breached while the estimated\n\t * value looks fine. The pressure threshold is a reduced value such\n\t * that even the maximum amount of drift will not accidentally breach\n\t * the min watermark\n\t */\n\twatermark_distance = low_wmark_pages(zone) - min_wmark_pages(zone);\n\tthreshold = max(1, (int)(watermark_distance / num_online_cpus()));\n\n\t/*\n\t * Maximum threshold is 125\n\t */\n\tthreshold = min(125, threshold);\n\n\treturn threshold;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "125",
            "threshold"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "1",
            "(int)(watermark_distance / num_online_cpus())"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nint calculate_pressure_threshold(struct zone *zone)\n{\n\tint threshold;\n\tint watermark_distance;\n\n\t/*\n\t * As vmstats are not up to date, there is drift between the estimated\n\t * and real values. For high thresholds and a high number of CPUs, it\n\t * is possible for the min watermark to be breached while the estimated\n\t * value looks fine. The pressure threshold is a reduced value such\n\t * that even the maximum amount of drift will not accidentally breach\n\t * the min watermark\n\t */\n\twatermark_distance = low_wmark_pages(zone) - min_wmark_pages(zone);\n\tthreshold = max(1, (int)(watermark_distance / num_online_cpus()));\n\n\t/*\n\t * Maximum threshold is 125\n\t */\n\tthreshold = min(125, threshold);\n\n\treturn threshold;\n}"
  },
  {
    "function_name": "vm_events_fold_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "144-153",
    "snippet": "void vm_events_fold_cpu(int cpu)\n{\n\tstruct vm_event_state *fold_state = &per_cpu(vm_event_states, cpu);\n\tint i;\n\n\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++) {\n\t\tcount_vm_events(i, fold_state->event[i]);\n\t\tfold_state->event[i] = 0;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_events",
          "args": [
            "i",
            "fold_state->event[i]"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vm_event_states",
            "cpu"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid vm_events_fold_cpu(int cpu)\n{\n\tstruct vm_event_state *fold_state = &per_cpu(vm_event_states, cpu);\n\tint i;\n\n\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++) {\n\t\tcount_vm_events(i, fold_state->event[i]);\n\t\tfold_state->event[i] = 0;\n\t}\n}"
  },
  {
    "function_name": "all_vm_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "130-135",
    "snippet": "void all_vm_events(unsigned long *ret)\n{\n\tget_online_cpus();\n\tsum_vm_events(ret);\n\tput_online_cpus();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sum_vm_events",
          "args": [
            "ret"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "sum_vm_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "110-123",
          "snippet": "static void sum_vm_events(unsigned long *ret)\n{\n\tint cpu;\n\tint i;\n\n\tmemset(ret, 0, NR_VM_EVENT_ITEMS * sizeof(unsigned long));\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct vm_event_state *this = &per_cpu(vm_event_states, cpu);\n\n\t\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++)\n\t\t\tret[i] += this->event[i];\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void sum_vm_events(unsigned long *ret)\n{\n\tint cpu;\n\tint i;\n\n\tmemset(ret, 0, NR_VM_EVENT_ITEMS * sizeof(unsigned long));\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct vm_event_state *this = &per_cpu(vm_event_states, cpu);\n\n\t\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++)\n\t\t\tret[i] += this->event[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid all_vm_events(unsigned long *ret)\n{\n\tget_online_cpus();\n\tsum_vm_events(ret);\n\tput_online_cpus();\n}"
  },
  {
    "function_name": "sum_vm_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "110-123",
    "snippet": "static void sum_vm_events(unsigned long *ret)\n{\n\tint cpu;\n\tint i;\n\n\tmemset(ret, 0, NR_VM_EVENT_ITEMS * sizeof(unsigned long));\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct vm_event_state *this = &per_cpu(vm_event_states, cpu);\n\n\t\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++)\n\t\t\tret[i] += this->event[i];\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vm_event_states",
            "cpu"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ret",
            "0",
            "NR_VM_EVENT_ITEMS * sizeof(unsigned long)"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void sum_vm_events(unsigned long *ret)\n{\n\tint cpu;\n\tint i;\n\n\tmemset(ret, 0, NR_VM_EVENT_ITEMS * sizeof(unsigned long));\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct vm_event_state *this = &per_cpu(vm_event_states, cpu);\n\n\t\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++)\n\t\t\tret[i] += this->event[i];\n\t}\n}"
  },
  {
    "function_name": "sysctl_vm_numa_stat_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "77-103",
    "snippet": "int sysctl_vm_numa_stat_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tint ret, oldval;\n\n\tmutex_lock(&vm_numa_stat_lock);\n\tif (write)\n\t\toldval = sysctl_vm_numa_stat;\n\tret = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (ret || !write)\n\t\tgoto out;\n\n\tif (oldval == sysctl_vm_numa_stat)\n\t\tgoto out;\n\telse if (sysctl_vm_numa_stat == ENABLE_NUMA_STAT) {\n\t\tstatic_branch_enable(&vm_numa_stat_key);\n\t\tpr_info(\"enable numa statistics\\n\");\n\t} else {\n\t\tstatic_branch_disable(&vm_numa_stat_key);\n\t\tinvalid_numa_statistics();\n\t\tpr_info(\"disable numa statistics, and clear numa counters\\n\");\n\t}\n\nout:\n\tmutex_unlock(&vm_numa_stat_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vm_numa_stat_lock"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"disable numa statistics, and clear numa counters\\n\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_numa_statistics",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "invalid_numa_statistics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "69-73",
          "snippet": "static void invalid_numa_statistics(void)\n{\n\tzero_zones_numa_counters();\n\tzero_global_numa_counters();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void invalid_numa_statistics(void)\n{\n\tzero_zones_numa_counters();\n\tzero_global_numa_counters();\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&vm_numa_stat_key"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"enable numa statistics\\n\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&vm_numa_stat_key"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vm_numa_stat_lock"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nint sysctl_vm_numa_stat_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tint ret, oldval;\n\n\tmutex_lock(&vm_numa_stat_lock);\n\tif (write)\n\t\toldval = sysctl_vm_numa_stat;\n\tret = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (ret || !write)\n\t\tgoto out;\n\n\tif (oldval == sysctl_vm_numa_stat)\n\t\tgoto out;\n\telse if (sysctl_vm_numa_stat == ENABLE_NUMA_STAT) {\n\t\tstatic_branch_enable(&vm_numa_stat_key);\n\t\tpr_info(\"enable numa statistics\\n\");\n\t} else {\n\t\tstatic_branch_disable(&vm_numa_stat_key);\n\t\tinvalid_numa_statistics();\n\t\tpr_info(\"disable numa statistics, and clear numa counters\\n\");\n\t}\n\nout:\n\tmutex_unlock(&vm_numa_stat_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "invalid_numa_statistics",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "69-73",
    "snippet": "static void invalid_numa_statistics(void)\n{\n\tzero_zones_numa_counters();\n\tzero_global_numa_counters();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_global_numa_counters",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "zero_global_numa_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "61-67",
          "snippet": "static void zero_global_numa_counters(void)\n{\n\tint item;\n\n\tfor (item = 0; item < NR_VM_NUMA_STAT_ITEMS; item++)\n\t\tatomic_long_set(&vm_numa_stat[item], 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nstatic void zero_global_numa_counters(void)\n{\n\tint item;\n\n\tfor (item = 0; item < NR_VM_NUMA_STAT_ITEMS; item++)\n\t\tatomic_long_set(&vm_numa_stat[item], 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_zones_numa_counters",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "zero_zones_numa_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "52-58",
          "snippet": "static void zero_zones_numa_counters(void)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone)\n\t\tzero_zone_numa_counters(zone);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void zero_zones_numa_counters(void)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone)\n\t\tzero_zone_numa_counters(zone);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void invalid_numa_statistics(void)\n{\n\tzero_zones_numa_counters();\n\tzero_global_numa_counters();\n}"
  },
  {
    "function_name": "zero_global_numa_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "61-67",
    "snippet": "static void zero_global_numa_counters(void)\n{\n\tint item;\n\n\tfor (item = 0; item < NR_VM_NUMA_STAT_ITEMS; item++)\n\t\tatomic_long_set(&vm_numa_stat[item], 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&vm_numa_stat[item]",
            "0"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nstatic void zero_global_numa_counters(void)\n{\n\tint item;\n\n\tfor (item = 0; item < NR_VM_NUMA_STAT_ITEMS; item++)\n\t\tatomic_long_set(&vm_numa_stat[item], 0);\n}"
  },
  {
    "function_name": "zero_zones_numa_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "52-58",
    "snippet": "static void zero_zones_numa_counters(void)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone)\n\t\tzero_zone_numa_counters(zone);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void zero_zones_numa_counters(void)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone)\n\t\tzero_zone_numa_counters(zone);\n}"
  },
  {
    "function_name": "zero_zone_numa_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
    "lines": "39-49",
    "snippet": "static void zero_zone_numa_counters(struct zone *zone)\n{\n\tint item, cpu;\n\n\tfor (item = 0; item < NR_VM_NUMA_STAT_ITEMS; item++) {\n\t\tatomic_long_set(&zone->vm_numa_stat[item], 0);\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->vm_numa_stat_diff[item]\n\t\t\t\t\t\t= 0;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/writeback.h>",
      "#include <linux/math64.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&zone->vm_numa_stat[item]",
            "0"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nstatic void zero_zone_numa_counters(struct zone *zone)\n{\n\tint item, cpu;\n\n\tfor (item = 0; item < NR_VM_NUMA_STAT_ITEMS; item++) {\n\t\tatomic_long_set(&zone->vm_numa_stat[item], 0);\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->vm_numa_stat_diff[item]\n\t\t\t\t\t\t= 0;\n\t}\n}"
  }
]