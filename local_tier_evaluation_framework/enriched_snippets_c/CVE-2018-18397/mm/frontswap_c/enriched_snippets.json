[
  {
    "function_name": "init_frontswap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "483-496",
    "snippet": "static int __init init_frontswap(void)\n{\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *root = debugfs_create_dir(\"frontswap\", NULL);\n\tif (root == NULL)\n\t\treturn -ENXIO;\n\tdebugfs_create_u64(\"loads\", 0444, root, &frontswap_loads);\n\tdebugfs_create_u64(\"succ_stores\", 0444, root, &frontswap_succ_stores);\n\tdebugfs_create_u64(\"failed_stores\", 0444, root,\n\t\t\t   &frontswap_failed_stores);\n\tdebugfs_create_u64(\"invalidates\", 0444, root, &frontswap_invalidates);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_u64",
          "args": [
            "\"invalidates\"",
            "0444",
            "root",
            "&frontswap_invalidates"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u64",
          "args": [
            "\"failed_stores\"",
            "0444",
            "root",
            "&frontswap_failed_stores"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u64",
          "args": [
            "\"succ_stores\"",
            "0444",
            "root",
            "&frontswap_succ_stores"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u64",
          "args": [
            "\"loads\"",
            "0444",
            "root",
            "&frontswap_loads"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"frontswap\"",
            "NULL"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic int __init init_frontswap(void)\n{\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *root = debugfs_create_dir(\"frontswap\", NULL);\n\tif (root == NULL)\n\t\treturn -ENXIO;\n\tdebugfs_create_u64(\"loads\", 0444, root, &frontswap_loads);\n\tdebugfs_create_u64(\"succ_stores\", 0444, root, &frontswap_succ_stores);\n\tdebugfs_create_u64(\"failed_stores\", 0444, root,\n\t\t\t   &frontswap_failed_stores);\n\tdebugfs_create_u64(\"invalidates\", 0444, root, &frontswap_invalidates);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "frontswap_curr_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "471-480",
    "snippet": "unsigned long frontswap_curr_pages(void)\n{\n\tunsigned long totalpages = 0;\n\n\tspin_lock(&swap_lock);\n\ttotalpages = __frontswap_curr_pages();\n\tspin_unlock(&swap_lock);\n\n\treturn totalpages;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__frontswap_curr_pages",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_curr_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "372-381",
          "snippet": "static unsigned long __frontswap_curr_pages(void)\n{\n\tunsigned long totalpages = 0;\n\tstruct swap_info_struct *si = NULL;\n\n\tassert_spin_locked(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list)\n\t\ttotalpages += atomic_read(&si->frontswap_pages);\n\treturn totalpages;\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic unsigned long __frontswap_curr_pages(void)\n{\n\tunsigned long totalpages = 0;\n\tstruct swap_info_struct *si = NULL;\n\n\tassert_spin_locked(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list)\n\t\ttotalpages += atomic_read(&si->frontswap_pages);\n\treturn totalpages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_lock"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nunsigned long frontswap_curr_pages(void)\n{\n\tunsigned long totalpages = 0;\n\n\tspin_lock(&swap_lock);\n\ttotalpages = __frontswap_curr_pages();\n\tspin_unlock(&swap_lock);\n\n\treturn totalpages;\n}"
  },
  {
    "function_name": "frontswap_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "447-463",
    "snippet": "void frontswap_shrink(unsigned long target_pages)\n{\n\tunsigned long pages_to_unuse = 0;\n\tint uninitialized_var(type), ret;\n\n\t/*\n\t * we don't want to hold swap_lock while doing a very\n\t * lengthy try_to_unuse, but swap_list may change\n\t * so restart scan from swap_active_head each time\n\t */\n\tspin_lock(&swap_lock);\n\tret = __frontswap_shrink(target_pages, &pages_to_unuse, &type);\n\tspin_unlock(&swap_lock);\n\tif (ret == 0)\n\t\ttry_to_unuse(type, true, pages_to_unuse);\n\treturn;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_unuse",
          "args": [
            "type",
            "true",
            "pages_to_unuse"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_unuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2003-2225",
          "snippet": "int try_to_unuse(unsigned int type, bool frontswap,\n\t\t unsigned long pages_to_unuse)\n{\n\tstruct swap_info_struct *si = swap_info[type];\n\tstruct mm_struct *start_mm;\n\tvolatile unsigned char *swap_map; /* swap_map is accessed without\n\t\t\t\t\t   * locking. Mark it as volatile\n\t\t\t\t\t   * to prevent compiler doing\n\t\t\t\t\t   * something odd.\n\t\t\t\t\t   */\n\tunsigned char swcount;\n\tstruct page *page;\n\tswp_entry_t entry;\n\tunsigned int i = 0;\n\tint retval = 0;\n\n\t/*\n\t * When searching mms for an entry, a good strategy is to\n\t * start at the first mm we freed the previous entry from\n\t * (though actually we don't notice whether we or coincidence\n\t * freed the entry).  Initialize this start_mm with a hold.\n\t *\n\t * A simpler strategy would be to start at the last mm we\n\t * freed the previous entry from; but that would take less\n\t * advantage of mmlist ordering, which clusters forked mms\n\t * together, child after parent.  If we race with dup_mmap(), we\n\t * prefer to resolve parent before child, lest we miss entries\n\t * duplicated after we scanned child: using last mm would invert\n\t * that.\n\t */\n\tstart_mm = &init_mm;\n\tmmget(&init_mm);\n\n\t/*\n\t * Keep on scanning until all entries have gone.  Usually,\n\t * one pass through swap_map is enough, but not necessarily:\n\t * there are races when an instance of an entry might be missed.\n\t */\n\twhile ((i = find_next_to_unuse(si, i, frontswap)) != 0) {\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Get a page for the entry, using the existing swap\n\t\t * cache page if there is one.  Otherwise, get a clean\n\t\t * page and read the swap into it.\n\t\t */\n\t\tswap_map = &si->swap_map[i];\n\t\tentry = swp_entry(type, i);\n\t\tpage = read_swap_cache_async(entry,\n\t\t\t\t\tGFP_HIGHUSER_MOVABLE, NULL, 0, false);\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Either swap_duplicate() failed because entry\n\t\t\t * has been freed independently, and will not be\n\t\t\t * reused since sys_swapoff() already disabled\n\t\t\t * allocation from here, or alloc_page() failed.\n\t\t\t */\n\t\t\tswcount = *swap_map;\n\t\t\t/*\n\t\t\t * We don't hold lock here, so the swap entry could be\n\t\t\t * SWAP_MAP_BAD (when the cluster is discarding).\n\t\t\t * Instead of fail out, We can just skip the swap\n\t\t\t * entry because swapoff will wait for discarding\n\t\t\t * finish anyway.\n\t\t\t */\n\t\t\tif (!swcount || swcount == SWAP_MAP_BAD)\n\t\t\t\tcontinue;\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't hold on to start_mm if it looks like exiting.\n\t\t */\n\t\tif (atomic_read(&start_mm->mm_users) == 1) {\n\t\t\tmmput(start_mm);\n\t\t\tstart_mm = &init_mm;\n\t\t\tmmget(&init_mm);\n\t\t}\n\n\t\t/*\n\t\t * Wait for and lock page.  When do_swap_page races with\n\t\t * try_to_unuse, do_swap_page can handle the fault much\n\t\t * faster than try_to_unuse can locate the entry.  This\n\t\t * apparently redundant \"wait_on_page_locked\" lets try_to_unuse\n\t\t * defer to do_swap_page in such a case - in some tests,\n\t\t * do_swap_page and try_to_unuse repeatedly compete.\n\t\t */\n\t\twait_on_page_locked(page);\n\t\twait_on_page_writeback(page);\n\t\tlock_page(page);\n\t\twait_on_page_writeback(page);\n\n\t\t/*\n\t\t * Remove all references to entry.\n\t\t */\n\t\tswcount = *swap_map;\n\t\tif (swap_count(swcount) == SWAP_MAP_SHMEM) {\n\t\t\tretval = shmem_unuse(entry, page);\n\t\t\t/* page has already been unlocked and released */\n\t\t\tif (retval < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (swap_count(swcount) && start_mm != &init_mm)\n\t\t\tretval = unuse_mm(start_mm, entry, page);\n\n\t\tif (swap_count(*swap_map)) {\n\t\t\tint set_start_mm = (*swap_map >= swcount);\n\t\t\tstruct list_head *p = &start_mm->mmlist;\n\t\t\tstruct mm_struct *new_start_mm = start_mm;\n\t\t\tstruct mm_struct *prev_mm = start_mm;\n\t\t\tstruct mm_struct *mm;\n\n\t\t\tmmget(new_start_mm);\n\t\t\tmmget(prev_mm);\n\t\t\tspin_lock(&mmlist_lock);\n\t\t\twhile (swap_count(*swap_map) && !retval &&\n\t\t\t\t\t(p = p->next) != &start_mm->mmlist) {\n\t\t\t\tmm = list_entry(p, struct mm_struct, mmlist);\n\t\t\t\tif (!mmget_not_zero(mm))\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t\tmmput(prev_mm);\n\t\t\t\tprev_mm = mm;\n\n\t\t\t\tcond_resched();\n\n\t\t\t\tswcount = *swap_map;\n\t\t\t\tif (!swap_count(swcount)) /* any usage ? */\n\t\t\t\t\t;\n\t\t\t\telse if (mm == &init_mm)\n\t\t\t\t\tset_start_mm = 1;\n\t\t\t\telse\n\t\t\t\t\tretval = unuse_mm(mm, entry, page);\n\n\t\t\t\tif (set_start_mm && *swap_map < swcount) {\n\t\t\t\t\tmmput(new_start_mm);\n\t\t\t\t\tmmget(mm);\n\t\t\t\t\tnew_start_mm = mm;\n\t\t\t\t\tset_start_mm = 0;\n\t\t\t\t}\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t}\n\t\t\tspin_unlock(&mmlist_lock);\n\t\t\tmmput(prev_mm);\n\t\t\tmmput(start_mm);\n\t\t\tstart_mm = new_start_mm;\n\t\t}\n\t\tif (retval) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If a reference remains (rare), we would like to leave\n\t\t * the page in the swap cache; but try_to_unmap could\n\t\t * then re-duplicate the entry once we drop page lock,\n\t\t * so we might loop indefinitely; also, that page could\n\t\t * not be swapped out to other storage meanwhile.  So:\n\t\t * delete from cache even if there's another reference,\n\t\t * after ensuring that the data has been saved to disk -\n\t\t * since if the reference remains (rarer), it will be\n\t\t * read from disk into another page.  Splitting into two\n\t\t * pages would be incorrect if swap supported \"shared\n\t\t * private\" pages, but they are handled by tmpfs files.\n\t\t *\n\t\t * Given how unuse_vma() targets one particular offset\n\t\t * in an anon_vma, once the anon_vma has been determined,\n\t\t * this splitting happens to be just what is needed to\n\t\t * handle where KSM pages have been swapped out: re-reading\n\t\t * is unnecessarily slow, but we can fix that later on.\n\t\t */\n\t\tif (swap_count(*swap_map) &&\n\t\t     PageDirty(page) && PageSwapCache(page)) {\n\t\t\tstruct writeback_control wbc = {\n\t\t\t\t.sync_mode = WB_SYNC_NONE,\n\t\t\t};\n\n\t\t\tswap_writepage(compound_head(page), &wbc);\n\t\t\tlock_page(page);\n\t\t\twait_on_page_writeback(page);\n\t\t}\n\n\t\t/*\n\t\t * It is conceivable that a racing task removed this page from\n\t\t * swap cache just before we acquired the page lock at the top,\n\t\t * or while we dropped it in unuse_mm().  The page might even\n\t\t * be back in swap cache on another swap area: that we must not\n\t\t * delete, since it may not have been written out to swap yet.\n\t\t */\n\t\tif (PageSwapCache(page) &&\n\t\t    likely(page_private(page) == entry.val) &&\n\t\t    !page_swapped(page))\n\t\t\tdelete_from_swap_cache(compound_head(page));\n\n\t\t/*\n\t\t * So we could skip searching mms once swap count went\n\t\t * to 1, we did not mark any present ptes as dirty: must\n\t\t * mark page dirty so shrink_page_list will preserve it.\n\t\t */\n\t\tSetPageDirty(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\t/*\n\t\t * Make sure that we aren't completely killing\n\t\t * interactive performance.\n\t\t */\n\t\tcond_resched();\n\t\tif (frontswap && pages_to_unuse > 0) {\n\t\t\tif (!--pages_to_unuse)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmmput(start_mm);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nint try_to_unuse(unsigned int type, bool frontswap,\n\t\t unsigned long pages_to_unuse)\n{\n\tstruct swap_info_struct *si = swap_info[type];\n\tstruct mm_struct *start_mm;\n\tvolatile unsigned char *swap_map; /* swap_map is accessed without\n\t\t\t\t\t   * locking. Mark it as volatile\n\t\t\t\t\t   * to prevent compiler doing\n\t\t\t\t\t   * something odd.\n\t\t\t\t\t   */\n\tunsigned char swcount;\n\tstruct page *page;\n\tswp_entry_t entry;\n\tunsigned int i = 0;\n\tint retval = 0;\n\n\t/*\n\t * When searching mms for an entry, a good strategy is to\n\t * start at the first mm we freed the previous entry from\n\t * (though actually we don't notice whether we or coincidence\n\t * freed the entry).  Initialize this start_mm with a hold.\n\t *\n\t * A simpler strategy would be to start at the last mm we\n\t * freed the previous entry from; but that would take less\n\t * advantage of mmlist ordering, which clusters forked mms\n\t * together, child after parent.  If we race with dup_mmap(), we\n\t * prefer to resolve parent before child, lest we miss entries\n\t * duplicated after we scanned child: using last mm would invert\n\t * that.\n\t */\n\tstart_mm = &init_mm;\n\tmmget(&init_mm);\n\n\t/*\n\t * Keep on scanning until all entries have gone.  Usually,\n\t * one pass through swap_map is enough, but not necessarily:\n\t * there are races when an instance of an entry might be missed.\n\t */\n\twhile ((i = find_next_to_unuse(si, i, frontswap)) != 0) {\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Get a page for the entry, using the existing swap\n\t\t * cache page if there is one.  Otherwise, get a clean\n\t\t * page and read the swap into it.\n\t\t */\n\t\tswap_map = &si->swap_map[i];\n\t\tentry = swp_entry(type, i);\n\t\tpage = read_swap_cache_async(entry,\n\t\t\t\t\tGFP_HIGHUSER_MOVABLE, NULL, 0, false);\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Either swap_duplicate() failed because entry\n\t\t\t * has been freed independently, and will not be\n\t\t\t * reused since sys_swapoff() already disabled\n\t\t\t * allocation from here, or alloc_page() failed.\n\t\t\t */\n\t\t\tswcount = *swap_map;\n\t\t\t/*\n\t\t\t * We don't hold lock here, so the swap entry could be\n\t\t\t * SWAP_MAP_BAD (when the cluster is discarding).\n\t\t\t * Instead of fail out, We can just skip the swap\n\t\t\t * entry because swapoff will wait for discarding\n\t\t\t * finish anyway.\n\t\t\t */\n\t\t\tif (!swcount || swcount == SWAP_MAP_BAD)\n\t\t\t\tcontinue;\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't hold on to start_mm if it looks like exiting.\n\t\t */\n\t\tif (atomic_read(&start_mm->mm_users) == 1) {\n\t\t\tmmput(start_mm);\n\t\t\tstart_mm = &init_mm;\n\t\t\tmmget(&init_mm);\n\t\t}\n\n\t\t/*\n\t\t * Wait for and lock page.  When do_swap_page races with\n\t\t * try_to_unuse, do_swap_page can handle the fault much\n\t\t * faster than try_to_unuse can locate the entry.  This\n\t\t * apparently redundant \"wait_on_page_locked\" lets try_to_unuse\n\t\t * defer to do_swap_page in such a case - in some tests,\n\t\t * do_swap_page and try_to_unuse repeatedly compete.\n\t\t */\n\t\twait_on_page_locked(page);\n\t\twait_on_page_writeback(page);\n\t\tlock_page(page);\n\t\twait_on_page_writeback(page);\n\n\t\t/*\n\t\t * Remove all references to entry.\n\t\t */\n\t\tswcount = *swap_map;\n\t\tif (swap_count(swcount) == SWAP_MAP_SHMEM) {\n\t\t\tretval = shmem_unuse(entry, page);\n\t\t\t/* page has already been unlocked and released */\n\t\t\tif (retval < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (swap_count(swcount) && start_mm != &init_mm)\n\t\t\tretval = unuse_mm(start_mm, entry, page);\n\n\t\tif (swap_count(*swap_map)) {\n\t\t\tint set_start_mm = (*swap_map >= swcount);\n\t\t\tstruct list_head *p = &start_mm->mmlist;\n\t\t\tstruct mm_struct *new_start_mm = start_mm;\n\t\t\tstruct mm_struct *prev_mm = start_mm;\n\t\t\tstruct mm_struct *mm;\n\n\t\t\tmmget(new_start_mm);\n\t\t\tmmget(prev_mm);\n\t\t\tspin_lock(&mmlist_lock);\n\t\t\twhile (swap_count(*swap_map) && !retval &&\n\t\t\t\t\t(p = p->next) != &start_mm->mmlist) {\n\t\t\t\tmm = list_entry(p, struct mm_struct, mmlist);\n\t\t\t\tif (!mmget_not_zero(mm))\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t\tmmput(prev_mm);\n\t\t\t\tprev_mm = mm;\n\n\t\t\t\tcond_resched();\n\n\t\t\t\tswcount = *swap_map;\n\t\t\t\tif (!swap_count(swcount)) /* any usage ? */\n\t\t\t\t\t;\n\t\t\t\telse if (mm == &init_mm)\n\t\t\t\t\tset_start_mm = 1;\n\t\t\t\telse\n\t\t\t\t\tretval = unuse_mm(mm, entry, page);\n\n\t\t\t\tif (set_start_mm && *swap_map < swcount) {\n\t\t\t\t\tmmput(new_start_mm);\n\t\t\t\t\tmmget(mm);\n\t\t\t\t\tnew_start_mm = mm;\n\t\t\t\t\tset_start_mm = 0;\n\t\t\t\t}\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t}\n\t\t\tspin_unlock(&mmlist_lock);\n\t\t\tmmput(prev_mm);\n\t\t\tmmput(start_mm);\n\t\t\tstart_mm = new_start_mm;\n\t\t}\n\t\tif (retval) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If a reference remains (rare), we would like to leave\n\t\t * the page in the swap cache; but try_to_unmap could\n\t\t * then re-duplicate the entry once we drop page lock,\n\t\t * so we might loop indefinitely; also, that page could\n\t\t * not be swapped out to other storage meanwhile.  So:\n\t\t * delete from cache even if there's another reference,\n\t\t * after ensuring that the data has been saved to disk -\n\t\t * since if the reference remains (rarer), it will be\n\t\t * read from disk into another page.  Splitting into two\n\t\t * pages would be incorrect if swap supported \"shared\n\t\t * private\" pages, but they are handled by tmpfs files.\n\t\t *\n\t\t * Given how unuse_vma() targets one particular offset\n\t\t * in an anon_vma, once the anon_vma has been determined,\n\t\t * this splitting happens to be just what is needed to\n\t\t * handle where KSM pages have been swapped out: re-reading\n\t\t * is unnecessarily slow, but we can fix that later on.\n\t\t */\n\t\tif (swap_count(*swap_map) &&\n\t\t     PageDirty(page) && PageSwapCache(page)) {\n\t\t\tstruct writeback_control wbc = {\n\t\t\t\t.sync_mode = WB_SYNC_NONE,\n\t\t\t};\n\n\t\t\tswap_writepage(compound_head(page), &wbc);\n\t\t\tlock_page(page);\n\t\t\twait_on_page_writeback(page);\n\t\t}\n\n\t\t/*\n\t\t * It is conceivable that a racing task removed this page from\n\t\t * swap cache just before we acquired the page lock at the top,\n\t\t * or while we dropped it in unuse_mm().  The page might even\n\t\t * be back in swap cache on another swap area: that we must not\n\t\t * delete, since it may not have been written out to swap yet.\n\t\t */\n\t\tif (PageSwapCache(page) &&\n\t\t    likely(page_private(page) == entry.val) &&\n\t\t    !page_swapped(page))\n\t\t\tdelete_from_swap_cache(compound_head(page));\n\n\t\t/*\n\t\t * So we could skip searching mms once swap count went\n\t\t * to 1, we did not mark any present ptes as dirty: must\n\t\t * mark page dirty so shrink_page_list will preserve it.\n\t\t */\n\t\tSetPageDirty(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\t/*\n\t\t * Make sure that we aren't completely killing\n\t\t * interactive performance.\n\t\t */\n\t\tcond_resched();\n\t\tif (frontswap && pages_to_unuse > 0) {\n\t\t\tif (!--pages_to_unuse)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmmput(start_mm);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__frontswap_shrink",
          "args": [
            "target_pages",
            "&pages_to_unuse",
            "&type"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "421-437",
          "snippet": "static int __frontswap_shrink(unsigned long target_pages,\n\t\t\t\tunsigned long *pages_to_unuse,\n\t\t\t\tint *type)\n{\n\tunsigned long total_pages = 0, total_pages_to_unuse;\n\n\tassert_spin_locked(&swap_lock);\n\n\ttotal_pages = __frontswap_curr_pages();\n\tif (total_pages <= target_pages) {\n\t\t/* Nothing to do */\n\t\t*pages_to_unuse = 0;\n\t\treturn 1;\n\t}\n\ttotal_pages_to_unuse = total_pages - target_pages;\n\treturn __frontswap_unuse_pages(total_pages_to_unuse, pages_to_unuse, type);\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic int __frontswap_shrink(unsigned long target_pages,\n\t\t\t\tunsigned long *pages_to_unuse,\n\t\t\t\tint *type)\n{\n\tunsigned long total_pages = 0, total_pages_to_unuse;\n\n\tassert_spin_locked(&swap_lock);\n\n\ttotal_pages = __frontswap_curr_pages();\n\tif (total_pages <= target_pages) {\n\t\t/* Nothing to do */\n\t\t*pages_to_unuse = 0;\n\t\treturn 1;\n\t}\n\ttotal_pages_to_unuse = total_pages - target_pages;\n\treturn __frontswap_unuse_pages(total_pages_to_unuse, pages_to_unuse, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_lock"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nvoid frontswap_shrink(unsigned long target_pages)\n{\n\tunsigned long pages_to_unuse = 0;\n\tint uninitialized_var(type), ret;\n\n\t/*\n\t * we don't want to hold swap_lock while doing a very\n\t * lengthy try_to_unuse, but swap_list may change\n\t * so restart scan from swap_active_head each time\n\t */\n\tspin_lock(&swap_lock);\n\tret = __frontswap_shrink(target_pages, &pages_to_unuse, &type);\n\tspin_unlock(&swap_lock);\n\tif (ret == 0)\n\t\ttry_to_unuse(type, true, pages_to_unuse);\n\treturn;\n}"
  },
  {
    "function_name": "__frontswap_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "421-437",
    "snippet": "static int __frontswap_shrink(unsigned long target_pages,\n\t\t\t\tunsigned long *pages_to_unuse,\n\t\t\t\tint *type)\n{\n\tunsigned long total_pages = 0, total_pages_to_unuse;\n\n\tassert_spin_locked(&swap_lock);\n\n\ttotal_pages = __frontswap_curr_pages();\n\tif (total_pages <= target_pages) {\n\t\t/* Nothing to do */\n\t\t*pages_to_unuse = 0;\n\t\treturn 1;\n\t}\n\ttotal_pages_to_unuse = total_pages - target_pages;\n\treturn __frontswap_unuse_pages(total_pages_to_unuse, pages_to_unuse, type);\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__frontswap_unuse_pages",
          "args": [
            "total_pages_to_unuse",
            "pages_to_unuse",
            "type"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_unuse_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "383-414",
          "snippet": "static int __frontswap_unuse_pages(unsigned long total, unsigned long *unused,\n\t\t\t\t\tint *swapid)\n{\n\tint ret = -EINVAL;\n\tstruct swap_info_struct *si = NULL;\n\tint si_frontswap_pages;\n\tunsigned long total_pages_to_unuse = total;\n\tunsigned long pages = 0, pages_to_unuse = 0;\n\n\tassert_spin_locked(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list) {\n\t\tsi_frontswap_pages = atomic_read(&si->frontswap_pages);\n\t\tif (total_pages_to_unuse < si_frontswap_pages) {\n\t\t\tpages = pages_to_unuse = total_pages_to_unuse;\n\t\t} else {\n\t\t\tpages = si_frontswap_pages;\n\t\t\tpages_to_unuse = 0; /* unuse all */\n\t\t}\n\t\t/* ensure there is enough RAM to fetch pages from frontswap */\n\t\tif (security_vm_enough_memory_mm(current->mm, pages)) {\n\t\t\tret = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\tvm_unacct_memory(pages);\n\t\t*unused = pages_to_unuse;\n\t\t*swapid = si->type;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic int __frontswap_unuse_pages(unsigned long total, unsigned long *unused,\n\t\t\t\t\tint *swapid)\n{\n\tint ret = -EINVAL;\n\tstruct swap_info_struct *si = NULL;\n\tint si_frontswap_pages;\n\tunsigned long total_pages_to_unuse = total;\n\tunsigned long pages = 0, pages_to_unuse = 0;\n\n\tassert_spin_locked(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list) {\n\t\tsi_frontswap_pages = atomic_read(&si->frontswap_pages);\n\t\tif (total_pages_to_unuse < si_frontswap_pages) {\n\t\t\tpages = pages_to_unuse = total_pages_to_unuse;\n\t\t} else {\n\t\t\tpages = si_frontswap_pages;\n\t\t\tpages_to_unuse = 0; /* unuse all */\n\t\t}\n\t\t/* ensure there is enough RAM to fetch pages from frontswap */\n\t\tif (security_vm_enough_memory_mm(current->mm, pages)) {\n\t\t\tret = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\tvm_unacct_memory(pages);\n\t\t*unused = pages_to_unuse;\n\t\t*swapid = si->type;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__frontswap_curr_pages",
          "args": [],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_curr_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "372-381",
          "snippet": "static unsigned long __frontswap_curr_pages(void)\n{\n\tunsigned long totalpages = 0;\n\tstruct swap_info_struct *si = NULL;\n\n\tassert_spin_locked(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list)\n\t\ttotalpages += atomic_read(&si->frontswap_pages);\n\treturn totalpages;\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic unsigned long __frontswap_curr_pages(void)\n{\n\tunsigned long totalpages = 0;\n\tstruct swap_info_struct *si = NULL;\n\n\tassert_spin_locked(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list)\n\t\ttotalpages += atomic_read(&si->frontswap_pages);\n\treturn totalpages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&swap_lock"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic int __frontswap_shrink(unsigned long target_pages,\n\t\t\t\tunsigned long *pages_to_unuse,\n\t\t\t\tint *type)\n{\n\tunsigned long total_pages = 0, total_pages_to_unuse;\n\n\tassert_spin_locked(&swap_lock);\n\n\ttotal_pages = __frontswap_curr_pages();\n\tif (total_pages <= target_pages) {\n\t\t/* Nothing to do */\n\t\t*pages_to_unuse = 0;\n\t\treturn 1;\n\t}\n\ttotal_pages_to_unuse = total_pages - target_pages;\n\treturn __frontswap_unuse_pages(total_pages_to_unuse, pages_to_unuse, type);\n}"
  },
  {
    "function_name": "__frontswap_unuse_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "383-414",
    "snippet": "static int __frontswap_unuse_pages(unsigned long total, unsigned long *unused,\n\t\t\t\t\tint *swapid)\n{\n\tint ret = -EINVAL;\n\tstruct swap_info_struct *si = NULL;\n\tint si_frontswap_pages;\n\tunsigned long total_pages_to_unuse = total;\n\tunsigned long pages = 0, pages_to_unuse = 0;\n\n\tassert_spin_locked(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list) {\n\t\tsi_frontswap_pages = atomic_read(&si->frontswap_pages);\n\t\tif (total_pages_to_unuse < si_frontswap_pages) {\n\t\t\tpages = pages_to_unuse = total_pages_to_unuse;\n\t\t} else {\n\t\t\tpages = si_frontswap_pages;\n\t\t\tpages_to_unuse = 0; /* unuse all */\n\t\t}\n\t\t/* ensure there is enough RAM to fetch pages from frontswap */\n\t\tif (security_vm_enough_memory_mm(current->mm, pages)) {\n\t\t\tret = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\tvm_unacct_memory(pages);\n\t\t*unused = pages_to_unuse;\n\t\t*swapid = si->type;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_unacct_memory",
          "args": [
            "pages"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_vm_enough_memory_mm",
          "args": [
            "current->mm",
            "pages"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&si->frontswap_pages"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_for_each_entry",
          "args": [
            "si",
            "&swap_active_head",
            "list"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&swap_lock"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic int __frontswap_unuse_pages(unsigned long total, unsigned long *unused,\n\t\t\t\t\tint *swapid)\n{\n\tint ret = -EINVAL;\n\tstruct swap_info_struct *si = NULL;\n\tint si_frontswap_pages;\n\tunsigned long total_pages_to_unuse = total;\n\tunsigned long pages = 0, pages_to_unuse = 0;\n\n\tassert_spin_locked(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list) {\n\t\tsi_frontswap_pages = atomic_read(&si->frontswap_pages);\n\t\tif (total_pages_to_unuse < si_frontswap_pages) {\n\t\t\tpages = pages_to_unuse = total_pages_to_unuse;\n\t\t} else {\n\t\t\tpages = si_frontswap_pages;\n\t\t\tpages_to_unuse = 0; /* unuse all */\n\t\t}\n\t\t/* ensure there is enough RAM to fetch pages from frontswap */\n\t\tif (security_vm_enough_memory_mm(current->mm, pages)) {\n\t\t\tret = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\tvm_unacct_memory(pages);\n\t\t*unused = pages_to_unuse;\n\t\t*swapid = si->type;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__frontswap_curr_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "372-381",
    "snippet": "static unsigned long __frontswap_curr_pages(void)\n{\n\tunsigned long totalpages = 0;\n\tstruct swap_info_struct *si = NULL;\n\n\tassert_spin_locked(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list)\n\t\ttotalpages += atomic_read(&si->frontswap_pages);\n\treturn totalpages;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&si->frontswap_pages"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_for_each_entry",
          "args": [
            "si",
            "&swap_active_head",
            "list"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&swap_lock"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic unsigned long __frontswap_curr_pages(void)\n{\n\tunsigned long totalpages = 0;\n\tstruct swap_info_struct *si = NULL;\n\n\tassert_spin_locked(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list)\n\t\ttotalpages += atomic_read(&si->frontswap_pages);\n\treturn totalpages;\n}"
  },
  {
    "function_name": "__frontswap_invalidate_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "354-369",
    "snippet": "void __frontswap_invalidate_area(unsigned type)\n{\n\tstruct swap_info_struct *sis = swap_info[type];\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(sis == NULL);\n\n\tif (sis->frontswap_map == NULL)\n\t\treturn;\n\n\tfor_each_frontswap_ops(ops)\n\t\tops->invalidate_area(type);\n\tatomic_set(&sis->frontswap_pages, 0);\n\tbitmap_zero(sis->frontswap_map, sis->max);\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct frontswap_ops *frontswap_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "sis->frontswap_map",
            "sis->max"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sis->frontswap_pages",
            "0"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "sis == NULL"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!frontswap_ops"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic struct frontswap_ops *frontswap_ops;\n\nvoid __frontswap_invalidate_area(unsigned type)\n{\n\tstruct swap_info_struct *sis = swap_info[type];\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(sis == NULL);\n\n\tif (sis->frontswap_map == NULL)\n\t\treturn;\n\n\tfor_each_frontswap_ops(ops)\n\t\tops->invalidate_area(type);\n\tatomic_set(&sis->frontswap_pages, 0);\n\tbitmap_zero(sis->frontswap_map, sis->max);\n}"
  },
  {
    "function_name": "__frontswap_invalidate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "332-347",
    "snippet": "void __frontswap_invalidate_page(unsigned type, pgoff_t offset)\n{\n\tstruct swap_info_struct *sis = swap_info[type];\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(sis == NULL);\n\n\tif (!__frontswap_test(sis, offset))\n\t\treturn;\n\n\tfor_each_frontswap_ops(ops)\n\t\tops->invalidate_page(type, offset);\n\t__frontswap_clear(sis, offset);\n\tinc_frontswap_invalidates();\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct frontswap_ops *frontswap_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_frontswap_invalidates",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "inc_frontswap_invalidates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "80-80",
          "snippet": "static inline void inc_frontswap_invalidates(void) { }",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_invalidates(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "__frontswap_clear",
          "args": [
            "sis",
            "offset"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "232-237",
          "snippet": "static inline void __frontswap_clear(struct swap_info_struct *sis,\n\t\t\t\t     pgoff_t offset)\n{\n\tclear_bit(offset, sis->frontswap_map);\n\tatomic_dec(&sis->frontswap_pages);\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void __frontswap_clear(struct swap_info_struct *sis,\n\t\t\t\t     pgoff_t offset)\n{\n\tclear_bit(offset, sis->frontswap_map);\n\tatomic_dec(&sis->frontswap_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__frontswap_test",
          "args": [
            "sis",
            "offset"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "216-222",
          "snippet": "bool __frontswap_test(struct swap_info_struct *sis,\n\t\t\t\tpgoff_t offset)\n{\n\tif (sis->frontswap_map)\n\t\treturn test_bit(offset, sis->frontswap_map);\n\treturn false;\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nbool __frontswap_test(struct swap_info_struct *sis,\n\t\t\t\tpgoff_t offset)\n{\n\tif (sis->frontswap_map)\n\t\treturn test_bit(offset, sis->frontswap_map);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "sis == NULL"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!frontswap_ops"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic struct frontswap_ops *frontswap_ops;\n\nvoid __frontswap_invalidate_page(unsigned type, pgoff_t offset)\n{\n\tstruct swap_info_struct *sis = swap_info[type];\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(sis == NULL);\n\n\tif (!__frontswap_test(sis, offset))\n\t\treturn;\n\n\tfor_each_frontswap_ops(ops)\n\t\tops->invalidate_page(type, offset);\n\t__frontswap_clear(sis, offset);\n\tinc_frontswap_invalidates();\n}"
  },
  {
    "function_name": "__frontswap_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "295-325",
    "snippet": "int __frontswap_load(struct page *page)\n{\n\tint ret = -1;\n\tswp_entry_t entry = { .val = page_private(page), };\n\tint type = swp_type(entry);\n\tstruct swap_info_struct *sis = swap_info[type];\n\tpgoff_t offset = swp_offset(entry);\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(!PageLocked(page));\n\tVM_BUG_ON(sis == NULL);\n\n\tif (!__frontswap_test(sis, offset))\n\t\treturn -1;\n\n\t/* Try loading from each implementation, until one succeeds. */\n\tfor_each_frontswap_ops(ops) {\n\t\tret = ops->load(type, offset, page);\n\t\tif (!ret) /* successful load */\n\t\t\tbreak;\n\t}\n\tif (ret == 0) {\n\t\tinc_frontswap_loads();\n\t\tif (frontswap_tmem_exclusive_gets_enabled) {\n\t\t\tSetPageDirty(page);\n\t\t\t__frontswap_clear(sis, offset);\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct frontswap_ops *frontswap_ops",
      "static bool frontswap_tmem_exclusive_gets_enabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__frontswap_clear",
          "args": [
            "sis",
            "offset"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "232-237",
          "snippet": "static inline void __frontswap_clear(struct swap_info_struct *sis,\n\t\t\t\t     pgoff_t offset)\n{\n\tclear_bit(offset, sis->frontswap_map);\n\tatomic_dec(&sis->frontswap_pages);\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void __frontswap_clear(struct swap_info_struct *sis,\n\t\t\t\t     pgoff_t offset)\n{\n\tclear_bit(offset, sis->frontswap_map);\n\tatomic_dec(&sis->frontswap_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "page"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_frontswap_loads",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "inc_frontswap_loads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "77-77",
          "snippet": "static inline void inc_frontswap_loads(void) { }",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_loads(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "ops->load",
          "args": [
            "type",
            "offset",
            "page"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__frontswap_test",
          "args": [
            "sis",
            "offset"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "216-222",
          "snippet": "bool __frontswap_test(struct swap_info_struct *sis,\n\t\t\t\tpgoff_t offset)\n{\n\tif (sis->frontswap_map)\n\t\treturn test_bit(offset, sis->frontswap_map);\n\treturn false;\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nbool __frontswap_test(struct swap_info_struct *sis,\n\t\t\t\tpgoff_t offset)\n{\n\tif (sis->frontswap_map)\n\t\treturn test_bit(offset, sis->frontswap_map);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "sis == NULL"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!frontswap_ops"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_type",
          "args": [
            "entry"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic struct frontswap_ops *frontswap_ops;\nstatic bool frontswap_tmem_exclusive_gets_enabled;\n\nint __frontswap_load(struct page *page)\n{\n\tint ret = -1;\n\tswp_entry_t entry = { .val = page_private(page), };\n\tint type = swp_type(entry);\n\tstruct swap_info_struct *sis = swap_info[type];\n\tpgoff_t offset = swp_offset(entry);\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(!PageLocked(page));\n\tVM_BUG_ON(sis == NULL);\n\n\tif (!__frontswap_test(sis, offset))\n\t\treturn -1;\n\n\t/* Try loading from each implementation, until one succeeds. */\n\tfor_each_frontswap_ops(ops) {\n\t\tret = ops->load(type, offset, page);\n\t\tif (!ret) /* successful load */\n\t\t\tbreak;\n\t}\n\tif (ret == 0) {\n\t\tinc_frontswap_loads();\n\t\tif (frontswap_tmem_exclusive_gets_enabled) {\n\t\t\tSetPageDirty(page);\n\t\t\t__frontswap_clear(sis, offset);\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__frontswap_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "246-287",
    "snippet": "int __frontswap_store(struct page *page)\n{\n\tint ret = -1;\n\tswp_entry_t entry = { .val = page_private(page), };\n\tint type = swp_type(entry);\n\tstruct swap_info_struct *sis = swap_info[type];\n\tpgoff_t offset = swp_offset(entry);\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(!PageLocked(page));\n\tVM_BUG_ON(sis == NULL);\n\n\t/*\n\t * If a dup, we must remove the old page first; we can't leave the\n\t * old page no matter if the store of the new page succeeds or fails,\n\t * and we can't rely on the new page replacing the old page as we may\n\t * not store to the same implementation that contains the old page.\n\t */\n\tif (__frontswap_test(sis, offset)) {\n\t\t__frontswap_clear(sis, offset);\n\t\tfor_each_frontswap_ops(ops)\n\t\t\tops->invalidate_page(type, offset);\n\t}\n\n\t/* Try to store in each implementation, until one succeeds. */\n\tfor_each_frontswap_ops(ops) {\n\t\tret = ops->store(type, offset, page);\n\t\tif (!ret) /* successful store */\n\t\t\tbreak;\n\t}\n\tif (ret == 0) {\n\t\t__frontswap_set(sis, offset);\n\t\tinc_frontswap_succ_stores();\n\t} else {\n\t\tinc_frontswap_failed_stores();\n\t}\n\tif (frontswap_writethrough_enabled)\n\t\t/* report failure so swap also writes to swap device */\n\t\tret = -1;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct frontswap_ops *frontswap_ops",
      "static bool frontswap_writethrough_enabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_frontswap_failed_stores",
          "args": [],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "inc_frontswap_failed_stores",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "79-79",
          "snippet": "static inline void inc_frontswap_failed_stores(void) { }",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_failed_stores(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "inc_frontswap_succ_stores",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "inc_frontswap_succ_stores",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "78-78",
          "snippet": "static inline void inc_frontswap_succ_stores(void) { }",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_succ_stores(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "__frontswap_set",
          "args": [
            "sis",
            "offset"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "225-230",
          "snippet": "static inline void __frontswap_set(struct swap_info_struct *sis,\n\t\t\t\t   pgoff_t offset)\n{\n\tset_bit(offset, sis->frontswap_map);\n\tatomic_inc(&sis->frontswap_pages);\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void __frontswap_set(struct swap_info_struct *sis,\n\t\t\t\t   pgoff_t offset)\n{\n\tset_bit(offset, sis->frontswap_map);\n\tatomic_inc(&sis->frontswap_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->store",
          "args": [
            "type",
            "offset",
            "page"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__frontswap_clear",
          "args": [
            "sis",
            "offset"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "232-237",
          "snippet": "static inline void __frontswap_clear(struct swap_info_struct *sis,\n\t\t\t\t     pgoff_t offset)\n{\n\tclear_bit(offset, sis->frontswap_map);\n\tatomic_dec(&sis->frontswap_pages);\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void __frontswap_clear(struct swap_info_struct *sis,\n\t\t\t\t     pgoff_t offset)\n{\n\tclear_bit(offset, sis->frontswap_map);\n\tatomic_dec(&sis->frontswap_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__frontswap_test",
          "args": [
            "sis",
            "offset"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "216-222",
          "snippet": "bool __frontswap_test(struct swap_info_struct *sis,\n\t\t\t\tpgoff_t offset)\n{\n\tif (sis->frontswap_map)\n\t\treturn test_bit(offset, sis->frontswap_map);\n\treturn false;\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nbool __frontswap_test(struct swap_info_struct *sis,\n\t\t\t\tpgoff_t offset)\n{\n\tif (sis->frontswap_map)\n\t\treturn test_bit(offset, sis->frontswap_map);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "sis == NULL"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!frontswap_ops"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_type",
          "args": [
            "entry"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic struct frontswap_ops *frontswap_ops;\nstatic bool frontswap_writethrough_enabled;\n\nint __frontswap_store(struct page *page)\n{\n\tint ret = -1;\n\tswp_entry_t entry = { .val = page_private(page), };\n\tint type = swp_type(entry);\n\tstruct swap_info_struct *sis = swap_info[type];\n\tpgoff_t offset = swp_offset(entry);\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(!PageLocked(page));\n\tVM_BUG_ON(sis == NULL);\n\n\t/*\n\t * If a dup, we must remove the old page first; we can't leave the\n\t * old page no matter if the store of the new page succeeds or fails,\n\t * and we can't rely on the new page replacing the old page as we may\n\t * not store to the same implementation that contains the old page.\n\t */\n\tif (__frontswap_test(sis, offset)) {\n\t\t__frontswap_clear(sis, offset);\n\t\tfor_each_frontswap_ops(ops)\n\t\t\tops->invalidate_page(type, offset);\n\t}\n\n\t/* Try to store in each implementation, until one succeeds. */\n\tfor_each_frontswap_ops(ops) {\n\t\tret = ops->store(type, offset, page);\n\t\tif (!ret) /* successful store */\n\t\t\tbreak;\n\t}\n\tif (ret == 0) {\n\t\t__frontswap_set(sis, offset);\n\t\tinc_frontswap_succ_stores();\n\t} else {\n\t\tinc_frontswap_failed_stores();\n\t}\n\tif (frontswap_writethrough_enabled)\n\t\t/* report failure so swap also writes to swap device */\n\t\tret = -1;\n\treturn ret;\n}"
  },
  {
    "function_name": "__frontswap_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "232-237",
    "snippet": "static inline void __frontswap_clear(struct swap_info_struct *sis,\n\t\t\t\t     pgoff_t offset)\n{\n\tclear_bit(offset, sis->frontswap_map);\n\tatomic_dec(&sis->frontswap_pages);\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&sis->frontswap_pages"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "offset",
            "sis->frontswap_map"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void __frontswap_clear(struct swap_info_struct *sis,\n\t\t\t\t     pgoff_t offset)\n{\n\tclear_bit(offset, sis->frontswap_map);\n\tatomic_dec(&sis->frontswap_pages);\n}"
  },
  {
    "function_name": "__frontswap_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "225-230",
    "snippet": "static inline void __frontswap_set(struct swap_info_struct *sis,\n\t\t\t\t   pgoff_t offset)\n{\n\tset_bit(offset, sis->frontswap_map);\n\tatomic_inc(&sis->frontswap_pages);\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sis->frontswap_pages"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "offset",
            "sis->frontswap_map"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void __frontswap_set(struct swap_info_struct *sis,\n\t\t\t\t   pgoff_t offset)\n{\n\tset_bit(offset, sis->frontswap_map);\n\tatomic_inc(&sis->frontswap_pages);\n}"
  },
  {
    "function_name": "__frontswap_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "216-222",
    "snippet": "bool __frontswap_test(struct swap_info_struct *sis,\n\t\t\t\tpgoff_t offset)\n{\n\tif (sis->frontswap_map)\n\t\treturn test_bit(offset, sis->frontswap_map);\n\treturn false;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "offset",
            "sis->frontswap_map"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nbool __frontswap_test(struct swap_info_struct *sis,\n\t\t\t\tpgoff_t offset)\n{\n\tif (sis->frontswap_map)\n\t\treturn test_bit(offset, sis->frontswap_map);\n\treturn false;\n}"
  },
  {
    "function_name": "__frontswap_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "191-213",
    "snippet": "void __frontswap_init(unsigned type, unsigned long *map)\n{\n\tstruct swap_info_struct *sis = swap_info[type];\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(sis == NULL);\n\n\t/*\n\t * p->frontswap is a bitmap that we MUST have to figure out which page\n\t * has gone in frontswap. Without it there is no point of continuing.\n\t */\n\tif (WARN_ON(!map))\n\t\treturn;\n\t/*\n\t * Irregardless of whether the frontswap backend has been loaded\n\t * before this function or it will be later, we _MUST_ have the\n\t * p->frontswap set to something valid to work properly.\n\t */\n\tfrontswap_map_set(sis, map);\n\n\tfor_each_frontswap_ops(ops)\n\t\tops->init(type);\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct frontswap_ops *frontswap_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "frontswap_map_set",
          "args": [
            "sis",
            "map"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!map"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "sis == NULL"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic struct frontswap_ops *frontswap_ops;\n\nvoid __frontswap_init(unsigned type, unsigned long *map)\n{\n\tstruct swap_info_struct *sis = swap_info[type];\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(sis == NULL);\n\n\t/*\n\t * p->frontswap is a bitmap that we MUST have to figure out which page\n\t * has gone in frontswap. Without it there is no point of continuing.\n\t */\n\tif (WARN_ON(!map))\n\t\treturn;\n\t/*\n\t * Irregardless of whether the frontswap backend has been loaded\n\t * before this function or it will be later, we _MUST_ have the\n\t * p->frontswap set to something valid to work properly.\n\t */\n\tfrontswap_map_set(sis, map);\n\n\tfor_each_frontswap_ops(ops)\n\t\tops->init(type);\n}"
  },
  {
    "function_name": "frontswap_tmem_exclusive_gets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "182-185",
    "snippet": "void frontswap_tmem_exclusive_gets(bool enable)\n{\n\tfrontswap_tmem_exclusive_gets_enabled = enable;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool frontswap_tmem_exclusive_gets_enabled"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic bool frontswap_tmem_exclusive_gets_enabled;\n\nvoid frontswap_tmem_exclusive_gets(bool enable)\n{\n\tfrontswap_tmem_exclusive_gets_enabled = enable;\n}"
  },
  {
    "function_name": "frontswap_writethrough",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "173-176",
    "snippet": "void frontswap_writethrough(bool enable)\n{\n\tfrontswap_writethrough_enabled = enable;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool frontswap_writethrough_enabled"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic bool frontswap_writethrough_enabled;\n\nvoid frontswap_writethrough(bool enable)\n{\n\tfrontswap_writethrough_enabled = enable;\n}"
  },
  {
    "function_name": "frontswap_register_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "114-167",
    "snippet": "void frontswap_register_ops(struct frontswap_ops *ops)\n{\n\tDECLARE_BITMAP(a, MAX_SWAPFILES);\n\tDECLARE_BITMAP(b, MAX_SWAPFILES);\n\tstruct swap_info_struct *si;\n\tunsigned int i;\n\n\tbitmap_zero(a, MAX_SWAPFILES);\n\tbitmap_zero(b, MAX_SWAPFILES);\n\n\tspin_lock(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list) {\n\t\tif (!WARN_ON(!si->frontswap_map))\n\t\t\tset_bit(si->type, a);\n\t}\n\tspin_unlock(&swap_lock);\n\n\t/* the new ops needs to know the currently active swap devices */\n\tfor_each_set_bit(i, a, MAX_SWAPFILES)\n\t\tops->init(i);\n\n\t/*\n\t * Setting frontswap_ops must happen after the ops->init() calls\n\t * above; cmpxchg implies smp_mb() which will ensure the init is\n\t * complete at this point.\n\t */\n\tdo {\n\t\tops->next = frontswap_ops;\n\t} while (cmpxchg(&frontswap_ops, ops->next, ops) != ops->next);\n\n\tstatic_branch_inc(&frontswap_enabled_key);\n\n\tspin_lock(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list) {\n\t\tif (si->frontswap_map)\n\t\t\tset_bit(si->type, b);\n\t}\n\tspin_unlock(&swap_lock);\n\n\t/*\n\t * On the very unlikely chance that a swap device was added or\n\t * removed between setting the \"a\" list bits and the ops init\n\t * calls, we re-check and do init or invalidate for any changed\n\t * bits.\n\t */\n\tif (unlikely(!bitmap_equal(a, b, MAX_SWAPFILES))) {\n\t\tfor (i = 0; i < MAX_SWAPFILES; i++) {\n\t\t\tif (!test_bit(i, a) && test_bit(i, b))\n\t\t\t\tops->init(i);\n\t\t\telse if (test_bit(i, a) && !test_bit(i, b))\n\t\t\t\tops->invalidate_area(i);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct frontswap_ops *frontswap_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->invalidate_area",
          "args": [
            "i"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "b"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "a"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->init",
          "args": [
            "i"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "b"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "a"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bitmap_equal(a, b, MAX_SWAPFILES)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_equal",
          "args": [
            "a",
            "b",
            "MAX_SWAPFILES"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "si->type",
            "b"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_for_each_entry",
          "args": [
            "si",
            "&swap_active_head",
            "list"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_lock"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&frontswap_enabled_key"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&frontswap_ops",
            "ops->next",
            "ops"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "note_cmpxchg_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1992-2014",
          "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "a",
            "MAX_SWAPFILES"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "si->type",
            "a"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!si->frontswap_map"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_for_each_entry",
          "args": [
            "si",
            "&swap_active_head",
            "list"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_lock"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "b",
            "MAX_SWAPFILES"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "a",
            "MAX_SWAPFILES"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_BITMAP",
          "args": [
            "b",
            "MAX_SWAPFILES"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_BITMAP",
          "args": [
            "a",
            "MAX_SWAPFILES"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic struct frontswap_ops *frontswap_ops;\n\nvoid frontswap_register_ops(struct frontswap_ops *ops)\n{\n\tDECLARE_BITMAP(a, MAX_SWAPFILES);\n\tDECLARE_BITMAP(b, MAX_SWAPFILES);\n\tstruct swap_info_struct *si;\n\tunsigned int i;\n\n\tbitmap_zero(a, MAX_SWAPFILES);\n\tbitmap_zero(b, MAX_SWAPFILES);\n\n\tspin_lock(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list) {\n\t\tif (!WARN_ON(!si->frontswap_map))\n\t\t\tset_bit(si->type, a);\n\t}\n\tspin_unlock(&swap_lock);\n\n\t/* the new ops needs to know the currently active swap devices */\n\tfor_each_set_bit(i, a, MAX_SWAPFILES)\n\t\tops->init(i);\n\n\t/*\n\t * Setting frontswap_ops must happen after the ops->init() calls\n\t * above; cmpxchg implies smp_mb() which will ensure the init is\n\t * complete at this point.\n\t */\n\tdo {\n\t\tops->next = frontswap_ops;\n\t} while (cmpxchg(&frontswap_ops, ops->next, ops) != ops->next);\n\n\tstatic_branch_inc(&frontswap_enabled_key);\n\n\tspin_lock(&swap_lock);\n\tplist_for_each_entry(si, &swap_active_head, list) {\n\t\tif (si->frontswap_map)\n\t\t\tset_bit(si->type, b);\n\t}\n\tspin_unlock(&swap_lock);\n\n\t/*\n\t * On the very unlikely chance that a swap device was added or\n\t * removed between setting the \"a\" list bits and the ops init\n\t * calls, we re-check and do init or invalidate for any changed\n\t * bits.\n\t */\n\tif (unlikely(!bitmap_equal(a, b, MAX_SWAPFILES))) {\n\t\tfor (i = 0; i < MAX_SWAPFILES; i++) {\n\t\t\tif (!test_bit(i, a) && test_bit(i, b))\n\t\t\t\tops->init(i);\n\t\t\telse if (test_bit(i, a) && !test_bit(i, b))\n\t\t\t\tops->invalidate_area(i);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "inc_frontswap_invalidates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "80-80",
    "snippet": "static inline void inc_frontswap_invalidates(void) { }",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_invalidates(void) { }"
  },
  {
    "function_name": "inc_frontswap_failed_stores",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "79-79",
    "snippet": "static inline void inc_frontswap_failed_stores(void) { }",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_failed_stores(void) { }"
  },
  {
    "function_name": "inc_frontswap_succ_stores",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "78-78",
    "snippet": "static inline void inc_frontswap_succ_stores(void) { }",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_succ_stores(void) { }"
  },
  {
    "function_name": "inc_frontswap_loads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "77-77",
    "snippet": "static inline void inc_frontswap_loads(void) { }",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_loads(void) { }"
  },
  {
    "function_name": "inc_frontswap_invalidates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "73-75",
    "snippet": "static inline void inc_frontswap_invalidates(void) {\n\tfrontswap_invalidates++;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_invalidates(void) {\n\tfrontswap_invalidates++;\n}"
  },
  {
    "function_name": "inc_frontswap_failed_stores",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "70-72",
    "snippet": "static inline void inc_frontswap_failed_stores(void) {\n\tfrontswap_failed_stores++;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_failed_stores(void) {\n\tfrontswap_failed_stores++;\n}"
  },
  {
    "function_name": "inc_frontswap_succ_stores",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "67-69",
    "snippet": "static inline void inc_frontswap_succ_stores(void) {\n\tfrontswap_succ_stores++;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_succ_stores(void) {\n\tfrontswap_succ_stores++;\n}"
  },
  {
    "function_name": "inc_frontswap_loads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
    "lines": "64-66",
    "snippet": "static inline void inc_frontswap_loads(void) {\n\tfrontswap_loads++;\n}",
    "includes": [
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic inline void inc_frontswap_loads(void) {\n\tfrontswap_loads++;\n}"
  }
]