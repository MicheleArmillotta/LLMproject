[
  {
    "function_name": "move_hugetlb_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4918-4949",
    "snippet": "void move_hugetlb_state(struct page *oldpage, struct page *newpage, int reason)\n{\n\tstruct hstate *h = page_hstate(oldpage);\n\n\thugetlb_cgroup_migrate(oldpage, newpage);\n\tset_page_owner_migrate_reason(newpage, reason);\n\n\t/*\n\t * transfer temporary state of the new huge page. This is\n\t * reverse to other transitions because the newpage is going to\n\t * be final while the old one will be freed so it takes over\n\t * the temporary status.\n\t *\n\t * Also note that we have to transfer the per-node surplus state\n\t * here as well otherwise the global surplus count will not match\n\t * the per-node's.\n\t */\n\tif (PageHugeTemporary(newpage)) {\n\t\tint old_nid = page_to_nid(oldpage);\n\t\tint new_nid = page_to_nid(newpage);\n\n\t\tSetPageHugeTemporary(oldpage);\n\t\tClearPageHugeTemporary(newpage);\n\n\t\tspin_lock(&hugetlb_lock);\n\t\tif (h->surplus_huge_pages_node[old_nid]) {\n\t\t\th->surplus_huge_pages_node[old_nid]--;\n\t\t\th->surplus_huge_pages_node[new_nid]++;\n\t\t}\n\t\tspin_unlock(&hugetlb_lock);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 4947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 4942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageHugeTemporary",
          "args": [
            "newpage"
          ],
          "line": 4940
        },
        "resolved": true,
        "details": {
          "function_name": "ClearPageHugeTemporary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1234-1237",
          "snippet": "static inline void ClearPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void ClearPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageHugeTemporary",
          "args": [
            "oldpage"
          ],
          "line": 4939
        },
        "resolved": true,
        "details": {
          "function_name": "SetPageHugeTemporary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1229-1232",
          "snippet": "static inline void SetPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = (void *)-1U;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void SetPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = (void *)-1U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "newpage"
          ],
          "line": 4937
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_owner_migrate_reason",
          "args": [
            "newpage",
            "reason"
          ],
          "line": 4923
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_owner_migrate_reason",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "199-209",
          "snippet": "void __set_page_owner_migrate_reason(struct page *page, int reason)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->last_migrate_reason = reason;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid __set_page_owner_migrate_reason(struct page *page, int reason)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->last_migrate_reason = reason;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_migrate",
          "args": [
            "oldpage",
            "newpage"
          ],
          "line": 4922
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "416-434",
          "snippet": "void hugetlb_cgroup_migrate(struct page *oldhpage, struct page *newhpage)\n{\n\tstruct hugetlb_cgroup *h_cg;\n\tstruct hstate *h = page_hstate(oldhpage);\n\n\tif (hugetlb_cgroup_disabled())\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageHuge(oldhpage), oldhpage);\n\tspin_lock(&hugetlb_lock);\n\th_cg = hugetlb_cgroup_from_page(oldhpage);\n\tset_hugetlb_cgroup(oldhpage, NULL);\n\n\t/* move the h_cg details to new cgroup */\n\tset_hugetlb_cgroup(newhpage, h_cg);\n\tlist_move(&newhpage->lru, &h->hugepage_activelist);\n\tspin_unlock(&hugetlb_lock);\n\treturn;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nvoid hugetlb_cgroup_migrate(struct page *oldhpage, struct page *newhpage)\n{\n\tstruct hugetlb_cgroup *h_cg;\n\tstruct hstate *h = page_hstate(oldhpage);\n\n\tif (hugetlb_cgroup_disabled())\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageHuge(oldhpage), oldhpage);\n\tspin_lock(&hugetlb_lock);\n\th_cg = hugetlb_cgroup_from_page(oldhpage);\n\tset_hugetlb_cgroup(oldhpage, NULL);\n\n\t/* move the h_cg details to new cgroup */\n\tset_hugetlb_cgroup(newhpage, h_cg);\n\tlist_move(&newhpage->lru, &h->hugepage_activelist);\n\tspin_unlock(&hugetlb_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "oldpage"
          ],
          "line": 4920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid move_hugetlb_state(struct page *oldpage, struct page *newpage, int reason)\n{\n\tstruct hstate *h = page_hstate(oldpage);\n\n\thugetlb_cgroup_migrate(oldpage, newpage);\n\tset_page_owner_migrate_reason(newpage, reason);\n\n\t/*\n\t * transfer temporary state of the new huge page. This is\n\t * reverse to other transitions because the newpage is going to\n\t * be final while the old one will be freed so it takes over\n\t * the temporary status.\n\t *\n\t * Also note that we have to transfer the per-node surplus state\n\t * here as well otherwise the global surplus count will not match\n\t * the per-node's.\n\t */\n\tif (PageHugeTemporary(newpage)) {\n\t\tint old_nid = page_to_nid(oldpage);\n\t\tint new_nid = page_to_nid(newpage);\n\n\t\tSetPageHugeTemporary(oldpage);\n\t\tClearPageHugeTemporary(newpage);\n\n\t\tspin_lock(&hugetlb_lock);\n\t\tif (h->surplus_huge_pages_node[old_nid]) {\n\t\t\th->surplus_huge_pages_node[old_nid]--;\n\t\t\th->surplus_huge_pages_node[new_nid]++;\n\t\t}\n\t\tspin_unlock(&hugetlb_lock);\n\t}\n}"
  },
  {
    "function_name": "putback_active_hugepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4908-4916",
    "snippet": "void putback_active_hugepage(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tset_page_huge_active(page);\n\tlist_move_tail(&page->lru, &(page_hstate(page))->hugepage_activelist);\n\tspin_unlock(&hugetlb_lock);\n\tput_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 4915
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 4914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&page->lru",
            "&(page_hstate(page))->hugepage_activelist"
          ],
          "line": 4913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "page"
          ],
          "line": 4913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_huge_active",
          "args": [
            "page"
          ],
          "line": 4912
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_huge_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1205-1209",
          "snippet": "static void set_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tSetPagePrivate(&page[1]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tSetPagePrivate(&page[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 4911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHead(page)",
            "page"
          ],
          "line": 4910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 4910
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid putback_active_hugepage(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tset_page_huge_active(page);\n\tlist_move_tail(&page->lru, &(page_hstate(page))->hugepage_activelist);\n\tspin_unlock(&hugetlb_lock);\n\tput_page(page);\n}"
  },
  {
    "function_name": "isolate_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4891-4906",
    "snippet": "bool isolate_huge_page(struct page *page, struct list_head *list)\n{\n\tbool ret = true;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tif (!page_huge_active(page) || !get_page_unless_zero(page)) {\n\t\tret = false;\n\t\tgoto unlock;\n\t}\n\tclear_page_huge_active(page);\n\tlist_move_tail(&page->lru, list);\nunlock:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 4904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&page->lru",
            "list"
          ],
          "line": 4902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_huge_active",
          "args": [
            "page"
          ],
          "line": 4901
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_huge_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1211-1215",
          "snippet": "static void clear_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tClearPagePrivate(&page[1]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void clear_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tClearPagePrivate(&page[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 4897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 4896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHead(page)",
            "page"
          ],
          "line": 4895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 4895
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nbool isolate_huge_page(struct page *page, struct list_head *list)\n{\n\tbool ret = true;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tif (!page_huge_active(page) || !get_page_unless_zero(page)) {\n\t\tret = false;\n\t\tgoto unlock;\n\t}\n\tclear_page_huge_active(page);\n\tlist_move_tail(&page->lru, list);\nunlock:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "follow_huge_pgd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4882-4889",
    "snippet": "struct page * __weak\nfollow_huge_pgd(struct mm_struct *mm, unsigned long address, pgd_t *pgd, int flags)\n{\n\tif (flags & FOLL_GET)\n\t\treturn NULL;\n\n\treturn pte_page(*(pte_t *)pgd) + ((address & ~PGDIR_MASK) >> PAGE_SHIFT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "*(pte_t *)pgd"
          ],
          "line": 4888
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_pgd(struct mm_struct *mm, unsigned long address, pgd_t *pgd, int flags)\n{\n\tif (flags & FOLL_GET)\n\t\treturn NULL;\n\n\treturn pte_page(*(pte_t *)pgd) + ((address & ~PGDIR_MASK) >> PAGE_SHIFT);\n}"
  },
  {
    "function_name": "follow_huge_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4872-4880",
    "snippet": "struct page * __weak\nfollow_huge_pud(struct mm_struct *mm, unsigned long address,\n\t\tpud_t *pud, int flags)\n{\n\tif (flags & FOLL_GET)\n\t\treturn NULL;\n\n\treturn pte_page(*(pte_t *)pud) + ((address & ~PUD_MASK) >> PAGE_SHIFT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "*(pte_t *)pud"
          ],
          "line": 4879
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_pud(struct mm_struct *mm, unsigned long address,\n\t\tpud_t *pud, int flags)\n{\n\tif (flags & FOLL_GET)\n\t\treturn NULL;\n\n\treturn pte_page(*(pte_t *)pud) + ((address & ~PUD_MASK) >> PAGE_SHIFT);\n}"
  },
  {
    "function_name": "follow_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4835-4870",
    "snippet": "struct page * __weak\nfollow_huge_pmd(struct mm_struct *mm, unsigned long address,\n\t\tpmd_t *pmd, int flags)\n{\n\tstruct page *page = NULL;\n\tspinlock_t *ptl;\n\tpte_t pte;\nretry:\n\tptl = pmd_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\t/*\n\t * make sure that the address range covered by this pmd is not\n\t * unmapped from other threads.\n\t */\n\tif (!pmd_huge(*pmd))\n\t\tgoto out;\n\tpte = huge_ptep_get((pte_t *)pmd);\n\tif (pte_present(pte)) {\n\t\tpage = pmd_page(*pmd) + ((address & ~PMD_MASK) >> PAGE_SHIFT);\n\t\tif (flags & FOLL_GET)\n\t\t\tget_page(page);\n\t} else {\n\t\tif (is_hugetlb_entry_migration(pte)) {\n\t\t\tspin_unlock(ptl);\n\t\t\t__migration_entry_wait(mm, (pte_t *)pmd, ptl);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * hwpoisoned entry is treated as no_page_table in\n\t\t * follow_page_mask().\n\t\t */\n\t}\nout:\n\tspin_unlock(ptl);\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__migration_entry_wait",
          "args": [
            "mm",
            "(pte_t *)pmd",
            "ptl"
          ],
          "line": 4859
        },
        "resolved": true,
        "details": {
          "function_name": "__migration_entry_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "310-343",
          "snippet": "void __migration_entry_wait(struct mm_struct *mm, pte_t *ptep,\n\t\t\t\tspinlock_t *ptl)\n{\n\tpte_t pte;\n\tswp_entry_t entry;\n\tstruct page *page;\n\n\tspin_lock(ptl);\n\tpte = *ptep;\n\tif (!is_swap_pte(pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(pte);\n\tif (!is_migration_entry(entry))\n\t\tgoto out;\n\n\tpage = migration_entry_to_page(entry);\n\n\t/*\n\t * Once page cache replacement of page migration started, page_count\n\t * *must* be zero. And, we don't want to call wait_on_page_locked()\n\t * against a page without get_page().\n\t * So, we use get_page_unless_zero(), here. Even failed, page fault\n\t * will occur again.\n\t */\n\tif (!get_page_unless_zero(page))\n\t\tgoto out;\n\tpte_unmap_unlock(ptep, ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nout:\n\tpte_unmap_unlock(ptep, ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid __migration_entry_wait(struct mm_struct *mm, pte_t *ptep,\n\t\t\t\tspinlock_t *ptl)\n{\n\tpte_t pte;\n\tswp_entry_t entry;\n\tstruct page *page;\n\n\tspin_lock(ptl);\n\tpte = *ptep;\n\tif (!is_swap_pte(pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(pte);\n\tif (!is_migration_entry(entry))\n\t\tgoto out;\n\n\tpage = migration_entry_to_page(entry);\n\n\t/*\n\t * Once page cache replacement of page migration started, page_count\n\t * *must* be zero. And, we don't want to call wait_on_page_locked()\n\t * against a page without get_page().\n\t * So, we use get_page_unless_zero(), here. Even failed, page fault\n\t * will occur again.\n\t */\n\tif (!get_page_unless_zero(page))\n\t\tgoto out;\n\tpte_unmap_unlock(ptep, ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nout:\n\tpte_unmap_unlock(ptep, ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugetlb_entry_migration",
          "args": [
            "pte"
          ],
          "line": 4857
        },
        "resolved": true,
        "details": {
          "function_name": "is_hugetlb_entry_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3207-3218",
          "snippet": "bool is_hugetlb_entry_migration(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn false;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_migration_entry(swp))\n\t\treturn true;\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nbool is_hugetlb_entry_migration(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn false;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_migration_entry(swp))\n\t\treturn true;\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 4855
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "*pmd"
          ],
          "line": 4853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 4852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "(pte_t *)pmd"
          ],
          "line": 4851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_huge",
          "args": [
            "*pmd"
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "ptl"
          ],
          "line": 4844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lockptr",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 4843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_pmd(struct mm_struct *mm, unsigned long address,\n\t\tpmd_t *pmd, int flags)\n{\n\tstruct page *page = NULL;\n\tspinlock_t *ptl;\n\tpte_t pte;\nretry:\n\tptl = pmd_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\t/*\n\t * make sure that the address range covered by this pmd is not\n\t * unmapped from other threads.\n\t */\n\tif (!pmd_huge(*pmd))\n\t\tgoto out;\n\tpte = huge_ptep_get((pte_t *)pmd);\n\tif (pte_present(pte)) {\n\t\tpage = pmd_page(*pmd) + ((address & ~PMD_MASK) >> PAGE_SHIFT);\n\t\tif (flags & FOLL_GET)\n\t\t\tget_page(page);\n\t} else {\n\t\tif (is_hugetlb_entry_migration(pte)) {\n\t\t\tspin_unlock(ptl);\n\t\t\t__migration_entry_wait(mm, (pte_t *)pmd, ptl);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * hwpoisoned entry is treated as no_page_table in\n\t\t * follow_page_mask().\n\t\t */\n\t}\nout:\n\tspin_unlock(ptl);\n\treturn page;\n}"
  },
  {
    "function_name": "follow_huge_pd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4827-4833",
    "snippet": "struct page * __weak\nfollow_huge_pd(struct vm_area_struct *vma,\n\t       unsigned long address, hugepd_t hpd, int flags, int pdshift)\n{\n\tWARN(1, \"hugepd follow called with no support for hugepage directory format\\n\");\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"hugepd follow called with no support for hugepage directory format\\n\""
          ],
          "line": 4831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_pd(struct vm_area_struct *vma,\n\t       unsigned long address, hugepd_t hpd, int flags, int pdshift)\n{\n\tWARN(1, \"hugepd follow called with no support for hugepage directory format\\n\");\n\treturn NULL;\n}"
  },
  {
    "function_name": "follow_huge_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4820-4825",
    "snippet": "struct page * __weak\nfollow_huge_addr(struct mm_struct *mm, unsigned long address,\n\t\t\t      int write)\n{\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 4824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page * __weak\nfollow_huge_addr(struct mm_struct *mm, unsigned long address,\n\t\t\t      int write)\n{\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "huge_pte_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4782-4812",
    "snippet": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "*pmd"
          ],
          "line": 4808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_huge",
          "args": [
            "*pmd"
          ],
          "line": 4808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 4805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "addr"
          ],
          "line": 4804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_present",
          "args": [
            "*pud"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_huge",
          "args": [
            "*pud"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_none",
          "args": [
            "*pud"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "addr"
          ],
          "line": 4797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_present",
          "args": [
            "*p4d"
          ],
          "line": 4794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "addr"
          ],
          "line": 4793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_present",
          "args": [
            "*pgd"
          ],
          "line": 4791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "addr"
          ],
          "line": 4790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "huge_pte_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4744-4771",
    "snippet": "pte_t *huge_pte_alloc(struct mm_struct *mm,\n\t\t\tunsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpte_t *pte = NULL;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (pud) {\n\t\tif (sz == PUD_SIZE) {\n\t\t\tpte = (pte_t *)pud;\n\t\t} else {\n\t\t\tBUG_ON(sz != PMD_SIZE);\n\t\t\tif (want_pmd_share() && pud_none(*pud))\n\t\t\t\tpte = huge_pmd_share(mm, addr, pud);\n\t\t\telse\n\t\t\t\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\t\t}\n\t}\n\tBUG_ON(pte && pte_present(*pte) && !pte_huge(*pte));\n\n\treturn pte;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pte && pte_present(*pte) && !pte_huge(*pte)"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_huge",
          "args": [
            "*pte"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "*pte"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_alloc",
          "args": [
            "mm",
            "pud",
            "addr"
          ],
          "line": 4765
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4004-4029",
          "snippet": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pmd_share",
          "args": [
            "mm",
            "addr",
            "pud"
          ],
          "line": 4763
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pmd_share",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4726-4729",
          "snippet": "pte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_none",
          "args": [
            "*pud"
          ],
          "line": 4762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "want_pmd_share",
          "args": [],
          "line": 4762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sz != PMD_SIZE"
          ],
          "line": 4761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_alloc",
          "args": [
            "mm",
            "p4d",
            "addr"
          ],
          "line": 4756
        },
        "resolved": true,
        "details": {
          "function_name": "__pud_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3972-3996",
          "snippet": "int __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_alloc",
          "args": [
            "mm",
            "pgd",
            "addr"
          ],
          "line": 4753
        },
        "resolved": true,
        "details": {
          "function_name": "__p4d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3949-3964",
          "snippet": "int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "addr"
          ],
          "line": 4752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_alloc(struct mm_struct *mm,\n\t\t\tunsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpte_t *pte = NULL;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (pud) {\n\t\tif (sz == PUD_SIZE) {\n\t\t\tpte = (pte_t *)pud;\n\t\t} else {\n\t\t\tBUG_ON(sz != PMD_SIZE);\n\t\t\tif (want_pmd_share() && pud_none(*pud))\n\t\t\t\tpte = huge_pmd_share(mm, addr, pud);\n\t\t\telse\n\t\t\t\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\t\t}\n\t}\n\tBUG_ON(pte && pte_present(*pte) && !pte_huge(*pte));\n\n\treturn pte;\n}"
  },
  {
    "function_name": "adjust_range_if_pmd_sharing_possible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4736-4739",
    "snippet": "void adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n}"
  },
  {
    "function_name": "huge_pmd_unshare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4731-4734",
    "snippet": "int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "huge_pmd_share",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4726-4729",
    "snippet": "pte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "huge_pmd_unshare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4708-4723",
    "snippet": "int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)\n{\n\tpgd_t *pgd = pgd_offset(mm, *addr);\n\tp4d_t *p4d = p4d_offset(pgd, *addr);\n\tpud_t *pud = pud_offset(p4d, *addr);\n\n\tBUG_ON(page_count(virt_to_page(ptep)) == 0);\n\tif (page_count(virt_to_page(ptep)) == 1)\n\t\treturn 0;\n\n\tpud_clear(pud);\n\tput_page(virt_to_page(ptep));\n\tmm_dec_nr_pmds(mm);\n\t*addr = ALIGN(*addr, HPAGE_SIZE * PTRS_PER_PTE) - HPAGE_SIZE;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "*addr",
            "HPAGE_SIZE * PTRS_PER_PTE"
          ],
          "line": 4721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_dec_nr_pmds",
          "args": [
            "mm"
          ],
          "line": 4720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "virt_to_page(ptep)"
          ],
          "line": 4719
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "ptep"
          ],
          "line": 4719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_clear",
          "args": [
            "pud"
          ],
          "line": 4718
        },
        "resolved": true,
        "details": {
          "function_name": "pud_clear_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "33-37",
          "snippet": "void pud_clear_bad(pud_t *pud)\n{\n\tpud_ERROR(*pud);\n\tpud_clear(pud);\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid pud_clear_bad(pud_t *pud)\n{\n\tpud_ERROR(*pud);\n\tpud_clear(pud);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "virt_to_page(ptep)"
          ],
          "line": 4715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "ptep"
          ],
          "line": 4715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_count(virt_to_page(ptep)) == 0"
          ],
          "line": 4714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "virt_to_page(ptep)"
          ],
          "line": 4714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "ptep"
          ],
          "line": 4714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "*addr"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "*addr"
          ],
          "line": 4711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "*addr"
          ],
          "line": 4710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)\n{\n\tpgd_t *pgd = pgd_offset(mm, *addr);\n\tp4d_t *p4d = p4d_offset(pgd, *addr);\n\tpud_t *pud = pud_offset(p4d, *addr);\n\n\tBUG_ON(page_count(virt_to_page(ptep)) == 0);\n\tif (page_count(virt_to_page(ptep)) == 1)\n\t\treturn 0;\n\n\tpud_clear(pud);\n\tput_page(virt_to_page(ptep));\n\tmm_dec_nr_pmds(mm);\n\t*addr = ALIGN(*addr, HPAGE_SIZE * PTRS_PER_PTE) - HPAGE_SIZE;\n\treturn 1;\n}"
  },
  {
    "function_name": "huge_pmd_share",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4647-4694",
    "snippet": "pte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud)\n{\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tpgoff_t idx = ((addr - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\tvma->vm_pgoff;\n\tstruct vm_area_struct *svma;\n\tunsigned long saddr;\n\tpte_t *spte = NULL;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tif (!vma_shareable(vma, addr))\n\t\treturn (pte_t *)pmd_alloc(mm, pud, addr);\n\n\ti_mmap_lock_write(mapping);\n\tvma_interval_tree_foreach(svma, &mapping->i_mmap, idx, idx) {\n\t\tif (svma == vma)\n\t\t\tcontinue;\n\n\t\tsaddr = page_table_shareable(svma, vma, addr, idx);\n\t\tif (saddr) {\n\t\t\tspte = huge_pte_offset(svma->vm_mm, saddr,\n\t\t\t\t\t       vma_mmu_pagesize(svma));\n\t\t\tif (spte) {\n\t\t\t\tget_page(virt_to_page(spte));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!spte)\n\t\tgoto out;\n\n\tptl = huge_pte_lock(hstate_vma(vma), mm, spte);\n\tif (pud_none(*pud)) {\n\t\tpud_populate(mm, pud,\n\t\t\t\t(pmd_t *)((unsigned long)spte & PAGE_MASK));\n\t\tmm_inc_nr_pmds(mm);\n\t} else {\n\t\tput_page(virt_to_page(spte));\n\t}\n\tspin_unlock(ptl);\nout:\n\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\ti_mmap_unlock_write(mapping);\n\treturn pte;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "mapping"
          ],
          "line": 4692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_alloc",
          "args": [
            "mm",
            "pud",
            "addr"
          ],
          "line": 4691
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4004-4029",
          "snippet": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "virt_to_page(spte)"
          ],
          "line": 4687
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "spte"
          ],
          "line": 4687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_inc_nr_pmds",
          "args": [
            "mm"
          ],
          "line": 4685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_populate",
          "args": [
            "mm",
            "pud",
            "(pmd_t *)((unsigned long)spte & PAGE_MASK)"
          ],
          "line": 4683
        },
        "resolved": true,
        "details": {
          "function_name": "zero_pud_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan_init.c",
          "lines": "137-170",
          "snippet": "static int __ref zero_pud_populate(p4d_t *p4d, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpud_t *pud = pud_offset(p4d, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (IS_ALIGNED(addr, PUD_SIZE) && end - addr >= PUD_SIZE) {\n\t\t\tpmd_t *pmd;\n\n\t\t\tpud_populate(&init_mm, pud, lm_alias(kasan_zero_pmd));\n\t\t\tpmd = pmd_offset(pud, addr);\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pud_none(*pud)) {\n\t\t\tpmd_t *p;\n\n\t\t\tif (slab_is_available()) {\n\t\t\t\tp = pmd_alloc(&init_mm, pud, addr);\n\t\t\t\tif (!p)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t} else {\n\t\t\t\tpud_populate(&init_mm, pud,\n\t\t\t\t\tearly_alloc(PAGE_SIZE, NUMA_NO_NODE));\n\t\t\t}\n\t\t}\n\t\tzero_pmd_populate(pud, addr, next);\n\t} while (pud++, addr = next, addr != end);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/page.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pte_t kasan_zero_pte[PTRS_PER_PTE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include <asm/pgalloc.h>\n#include <asm/page.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n\npte_t kasan_zero_pte[PTRS_PER_PTE];\n\nstatic int __ref zero_pud_populate(p4d_t *p4d, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpud_t *pud = pud_offset(p4d, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (IS_ALIGNED(addr, PUD_SIZE) && end - addr >= PUD_SIZE) {\n\t\t\tpmd_t *pmd;\n\n\t\t\tpud_populate(&init_mm, pud, lm_alias(kasan_zero_pmd));\n\t\t\tpmd = pmd_offset(pud, addr);\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pud_none(*pud)) {\n\t\t\tpmd_t *p;\n\n\t\t\tif (slab_is_available()) {\n\t\t\t\tp = pmd_alloc(&init_mm, pud, addr);\n\t\t\t\tif (!p)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t} else {\n\t\t\t\tpud_populate(&init_mm, pud,\n\t\t\t\t\tearly_alloc(PAGE_SIZE, NUMA_NO_NODE));\n\t\t\t}\n\t\t}\n\t\tzero_pmd_populate(pud, addr, next);\n\t} while (pud++, addr = next, addr != end);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_none",
          "args": [
            "*pud"
          ],
          "line": 4682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_lock",
          "args": [
            "hstate_vma(vma)",
            "mm",
            "spte"
          ],
          "line": 4681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 4681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "virt_to_page(spte)"
          ],
          "line": 4672
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "spte"
          ],
          "line": 4672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_offset",
          "args": [
            "svma->vm_mm",
            "saddr",
            "vma_mmu_pagesize(svma)"
          ],
          "line": 4669
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4782-4812",
          "snippet": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_mmu_pagesize",
          "args": [
            "svma"
          ],
          "line": 4670
        },
        "resolved": true,
        "details": {
          "function_name": "vma_mmu_pagesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "652-655",
          "snippet": "__weak unsigned long vma_mmu_pagesize(struct vm_area_struct *vma)\n{\n\treturn vma_kernel_pagesize(vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n__weak unsigned long vma_mmu_pagesize(struct vm_area_struct *vma)\n{\n\treturn vma_kernel_pagesize(vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_table_shareable",
          "args": [
            "svma",
            "vma",
            "addr",
            "idx"
          ],
          "line": 4667
        },
        "resolved": true,
        "details": {
          "function_name": "page_table_shareable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4571-4594",
          "snippet": "static unsigned long page_table_shareable(struct vm_area_struct *svma,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, pgoff_t idx)\n{\n\tunsigned long saddr = ((idx - svma->vm_pgoff) << PAGE_SHIFT) +\n\t\t\t\tsvma->vm_start;\n\tunsigned long sbase = saddr & PUD_MASK;\n\tunsigned long s_end = sbase + PUD_SIZE;\n\n\t/* Allow segments to share if only one is marked locked */\n\tunsigned long vm_flags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tunsigned long svm_flags = svma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\n\t/*\n\t * match the virtual addresses, permission and the alignment of the\n\t * page table page.\n\t */\n\tif (pmd_index(addr) != pmd_index(saddr) ||\n\t    vm_flags != svm_flags ||\n\t    sbase < svma->vm_start || svma->vm_end < s_end)\n\t\treturn 0;\n\n\treturn saddr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned long page_table_shareable(struct vm_area_struct *svma,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, pgoff_t idx)\n{\n\tunsigned long saddr = ((idx - svma->vm_pgoff) << PAGE_SHIFT) +\n\t\t\t\tsvma->vm_start;\n\tunsigned long sbase = saddr & PUD_MASK;\n\tunsigned long s_end = sbase + PUD_SIZE;\n\n\t/* Allow segments to share if only one is marked locked */\n\tunsigned long vm_flags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tunsigned long svm_flags = svma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\n\t/*\n\t * match the virtual addresses, permission and the alignment of the\n\t * page table page.\n\t */\n\tif (pmd_index(addr) != pmd_index(saddr) ||\n\t    vm_flags != svm_flags ||\n\t    sbase < svma->vm_start || svma->vm_end < s_end)\n\t\treturn 0;\n\n\treturn saddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_foreach",
          "args": [
            "svma",
            "&mapping->i_mmap",
            "idx",
            "idx"
          ],
          "line": 4663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_write",
          "args": [
            "mapping"
          ],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_shareable",
          "args": [
            "vma",
            "addr"
          ],
          "line": 4659
        },
        "resolved": true,
        "details": {
          "function_name": "vma_shareable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4596-4607",
          "snippet": "static bool vma_shareable(struct vm_area_struct *vma, unsigned long addr)\n{\n\tunsigned long base = addr & PUD_MASK;\n\tunsigned long end = base + PUD_SIZE;\n\n\t/*\n\t * check on proper vm_flags and page table alignment\n\t */\n\tif (vma->vm_flags & VM_MAYSHARE && range_in_vma(vma, base, end))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic bool vma_shareable(struct vm_area_struct *vma, unsigned long addr)\n{\n\tunsigned long base = addr & PUD_MASK;\n\tunsigned long end = base + PUD_SIZE;\n\n\t/*\n\t * check on proper vm_flags and page table alignment\n\t */\n\tif (vma->vm_flags & VM_MAYSHARE && range_in_vma(vma, base, end))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 4649
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud)\n{\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tpgoff_t idx = ((addr - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\tvma->vm_pgoff;\n\tstruct vm_area_struct *svma;\n\tunsigned long saddr;\n\tpte_t *spte = NULL;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tif (!vma_shareable(vma, addr))\n\t\treturn (pte_t *)pmd_alloc(mm, pud, addr);\n\n\ti_mmap_lock_write(mapping);\n\tvma_interval_tree_foreach(svma, &mapping->i_mmap, idx, idx) {\n\t\tif (svma == vma)\n\t\t\tcontinue;\n\n\t\tsaddr = page_table_shareable(svma, vma, addr, idx);\n\t\tif (saddr) {\n\t\t\tspte = huge_pte_offset(svma->vm_mm, saddr,\n\t\t\t\t\t       vma_mmu_pagesize(svma));\n\t\t\tif (spte) {\n\t\t\t\tget_page(virt_to_page(spte));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!spte)\n\t\tgoto out;\n\n\tptl = huge_pte_lock(hstate_vma(vma), mm, spte);\n\tif (pud_none(*pud)) {\n\t\tpud_populate(mm, pud,\n\t\t\t\t(pmd_t *)((unsigned long)spte & PAGE_MASK));\n\t\tmm_inc_nr_pmds(mm);\n\t} else {\n\t\tput_page(virt_to_page(spte));\n\t}\n\tspin_unlock(ptl);\nout:\n\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\ti_mmap_unlock_write(mapping);\n\treturn pte;\n}"
  },
  {
    "function_name": "adjust_range_if_pmd_sharing_possible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4614-4636",
    "snippet": "void adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n\tunsigned long check_addr = *start;\n\n\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\treturn;\n\n\tfor (check_addr = *start; check_addr < *end; check_addr += PUD_SIZE) {\n\t\tunsigned long a_start = check_addr & PUD_MASK;\n\t\tunsigned long a_end = a_start + PUD_SIZE;\n\n\t\t/*\n\t\t * If sharing is possible, adjust start/end if necessary.\n\t\t */\n\t\tif (range_in_vma(vma, a_start, a_end)) {\n\t\t\tif (a_start < *start)\n\t\t\t\t*start = a_start;\n\t\t\tif (a_end > *end)\n\t\t\t\t*end = a_end;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_in_vma",
          "args": [
            "vma",
            "a_start",
            "a_end"
          ],
          "line": 4629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n\tunsigned long check_addr = *start;\n\n\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\treturn;\n\n\tfor (check_addr = *start; check_addr < *end; check_addr += PUD_SIZE) {\n\t\tunsigned long a_start = check_addr & PUD_MASK;\n\t\tunsigned long a_end = a_start + PUD_SIZE;\n\n\t\t/*\n\t\t * If sharing is possible, adjust start/end if necessary.\n\t\t */\n\t\tif (range_in_vma(vma, a_start, a_end)) {\n\t\t\tif (a_start < *start)\n\t\t\t\t*start = a_start;\n\t\t\tif (a_end > *end)\n\t\t\t\t*end = a_end;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "vma_shareable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4596-4607",
    "snippet": "static bool vma_shareable(struct vm_area_struct *vma, unsigned long addr)\n{\n\tunsigned long base = addr & PUD_MASK;\n\tunsigned long end = base + PUD_SIZE;\n\n\t/*\n\t * check on proper vm_flags and page table alignment\n\t */\n\tif (vma->vm_flags & VM_MAYSHARE && range_in_vma(vma, base, end))\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_in_vma",
          "args": [
            "vma",
            "base",
            "end"
          ],
          "line": 4604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic bool vma_shareable(struct vm_area_struct *vma, unsigned long addr)\n{\n\tunsigned long base = addr & PUD_MASK;\n\tunsigned long end = base + PUD_SIZE;\n\n\t/*\n\t * check on proper vm_flags and page table alignment\n\t */\n\tif (vma->vm_flags & VM_MAYSHARE && range_in_vma(vma, base, end))\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "page_table_shareable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4571-4594",
    "snippet": "static unsigned long page_table_shareable(struct vm_area_struct *svma,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, pgoff_t idx)\n{\n\tunsigned long saddr = ((idx - svma->vm_pgoff) << PAGE_SHIFT) +\n\t\t\t\tsvma->vm_start;\n\tunsigned long sbase = saddr & PUD_MASK;\n\tunsigned long s_end = sbase + PUD_SIZE;\n\n\t/* Allow segments to share if only one is marked locked */\n\tunsigned long vm_flags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tunsigned long svm_flags = svma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\n\t/*\n\t * match the virtual addresses, permission and the alignment of the\n\t * page table page.\n\t */\n\tif (pmd_index(addr) != pmd_index(saddr) ||\n\t    vm_flags != svm_flags ||\n\t    sbase < svma->vm_start || svma->vm_end < s_end)\n\t\treturn 0;\n\n\treturn saddr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmd_index",
          "args": [
            "saddr"
          ],
          "line": 4588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_index",
          "args": [
            "addr"
          ],
          "line": 4588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned long page_table_shareable(struct vm_area_struct *svma,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, pgoff_t idx)\n{\n\tunsigned long saddr = ((idx - svma->vm_pgoff) << PAGE_SHIFT) +\n\t\t\t\tsvma->vm_start;\n\tunsigned long sbase = saddr & PUD_MASK;\n\tunsigned long s_end = sbase + PUD_SIZE;\n\n\t/* Allow segments to share if only one is marked locked */\n\tunsigned long vm_flags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tunsigned long svm_flags = svma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\n\t/*\n\t * match the virtual addresses, permission and the alignment of the\n\t * page table page.\n\t */\n\tif (pmd_index(addr) != pmd_index(saddr) ||\n\t    vm_flags != svm_flags ||\n\t    sbase < svma->vm_start || svma->vm_end < s_end)\n\t\treturn 0;\n\n\treturn saddr;\n}"
  },
  {
    "function_name": "hugetlb_unreserve_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4536-4568",
    "snippet": "long hugetlb_unreserve_pages(struct inode *inode, long start, long end,\n\t\t\t\t\t\t\t\tlong freed)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct resv_map *resv_map = inode_resv_map(inode);\n\tlong chg = 0;\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tlong gbl_reserve;\n\n\tif (resv_map) {\n\t\tchg = region_del(resv_map, start, end);\n\t\t/*\n\t\t * region_del() can fail in the rare case where a region\n\t\t * must be split and another region descriptor can not be\n\t\t * allocated.  If end == LONG_MAX, it will not fail.\n\t\t */\n\t\tif (chg < 0)\n\t\t\treturn chg;\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n\tspin_unlock(&inode->i_lock);\n\n\t/*\n\t * If the subpool has a minimum size, the number of global\n\t * reservations to be released may be adjusted.\n\t */\n\tgbl_reserve = hugepage_subpool_put_pages(spool, (chg - freed));\n\thugetlb_acct_memory(h, -gbl_reserve);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_acct_memory",
          "args": [
            "h",
            "-gbl_reserve"
          ],
          "line": 4565
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_acct_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3052-3091",
          "snippet": "static int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugepage_subpool_put_pages",
          "args": [
            "spool",
            "(chg - freed)"
          ],
          "line": 4564
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_subpool_put_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "176-208",
          "snippet": "static long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 4558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocks_per_huge_page",
          "args": [
            "h"
          ],
          "line": 4557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 4556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "region_del",
          "args": [
            "resv_map",
            "start",
            "end"
          ],
          "line": 4546
        },
        "resolved": true,
        "details": {
          "function_name": "region_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "482-561",
          "snippet": "static long region_del(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *trg;\n\tstruct file_region *nrg = NULL;\n\tlong del = 0;\n\nretry:\n\tspin_lock(&resv->lock);\n\tlist_for_each_entry_safe(rg, trg, head, link) {\n\t\t/*\n\t\t * Skip regions before the range to be deleted.  file_region\n\t\t * ranges are normally of the form [from, to).  However, there\n\t\t * may be a \"placeholder\" entry in the map which is of the form\n\t\t * (from, to) with from == to.  Check for placeholder entries\n\t\t * at the beginning of the range to be deleted.\n\t\t */\n\t\tif (rg->to <= f && (rg->to != rg->from || rg->to != f))\n\t\t\tcontinue;\n\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tif (f > rg->from && t < rg->to) { /* Must split region */\n\t\t\t/*\n\t\t\t * Check for an entry in the cache before dropping\n\t\t\t * lock and attempting allocation.\n\t\t\t */\n\t\t\tif (!nrg &&\n\t\t\t    resv->region_cache_count > resv->adds_in_progress) {\n\t\t\t\tnrg = list_first_entry(&resv->region_cache,\n\t\t\t\t\t\t\tstruct file_region,\n\t\t\t\t\t\t\tlink);\n\t\t\t\tlist_del(&nrg->link);\n\t\t\t\tresv->region_cache_count--;\n\t\t\t}\n\n\t\t\tif (!nrg) {\n\t\t\t\tspin_unlock(&resv->lock);\n\t\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\t\tif (!nrg)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tdel += t - f;\n\n\t\t\t/* New entry for end of split region */\n\t\t\tnrg->from = t;\n\t\t\tnrg->to = rg->to;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\n\t\t\t/* Original entry is trimmed */\n\t\t\trg->to = f;\n\n\t\t\tlist_add(&nrg->link, &rg->link);\n\t\t\tnrg = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (f <= rg->from && t >= rg->to) { /* Remove entire region */\n\t\t\tdel += rg->to - rg->from;\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (f <= rg->from) {\t/* Trim beginning of region */\n\t\t\tdel += t - rg->from;\n\t\t\trg->from = t;\n\t\t} else {\t\t/* Trim end of region */\n\t\t\tdel += rg->to - f;\n\t\t\trg->to = f;\n\t\t}\n\t}\n\n\tspin_unlock(&resv->lock);\n\tkfree(nrg);\n\treturn del;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_del(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *trg;\n\tstruct file_region *nrg = NULL;\n\tlong del = 0;\n\nretry:\n\tspin_lock(&resv->lock);\n\tlist_for_each_entry_safe(rg, trg, head, link) {\n\t\t/*\n\t\t * Skip regions before the range to be deleted.  file_region\n\t\t * ranges are normally of the form [from, to).  However, there\n\t\t * may be a \"placeholder\" entry in the map which is of the form\n\t\t * (from, to) with from == to.  Check for placeholder entries\n\t\t * at the beginning of the range to be deleted.\n\t\t */\n\t\tif (rg->to <= f && (rg->to != rg->from || rg->to != f))\n\t\t\tcontinue;\n\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tif (f > rg->from && t < rg->to) { /* Must split region */\n\t\t\t/*\n\t\t\t * Check for an entry in the cache before dropping\n\t\t\t * lock and attempting allocation.\n\t\t\t */\n\t\t\tif (!nrg &&\n\t\t\t    resv->region_cache_count > resv->adds_in_progress) {\n\t\t\t\tnrg = list_first_entry(&resv->region_cache,\n\t\t\t\t\t\t\tstruct file_region,\n\t\t\t\t\t\t\tlink);\n\t\t\t\tlist_del(&nrg->link);\n\t\t\t\tresv->region_cache_count--;\n\t\t\t}\n\n\t\t\tif (!nrg) {\n\t\t\t\tspin_unlock(&resv->lock);\n\t\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\t\tif (!nrg)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tdel += t - f;\n\n\t\t\t/* New entry for end of split region */\n\t\t\tnrg->from = t;\n\t\t\tnrg->to = rg->to;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\n\t\t\t/* Original entry is trimmed */\n\t\t\trg->to = f;\n\n\t\t\tlist_add(&nrg->link, &rg->link);\n\t\t\tnrg = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (f <= rg->from && t >= rg->to) { /* Remove entire region */\n\t\t\tdel += rg->to - rg->from;\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (f <= rg->from) {\t/* Trim beginning of region */\n\t\t\tdel += t - rg->from;\n\t\t\trg->from = t;\n\t\t} else {\t\t/* Trim end of region */\n\t\t\tdel += rg->to - f;\n\t\t\trg->to = f;\n\t\t}\n\t}\n\n\tspin_unlock(&resv->lock);\n\tkfree(nrg);\n\treturn del;\n}"
        }
      },
      {
        "call_info": {
          "callee": "subpool_inode",
          "args": [
            "inode"
          ],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "subpool_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "210-213",
          "snippet": "static inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n{\n\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n{\n\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_resv_map",
          "args": [
            "inode"
          ],
          "line": 4540
        },
        "resolved": true,
        "details": {
          "function_name": "inode_resv_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "740-743",
          "snippet": "static inline struct resv_map *inode_resv_map(struct inode *inode)\n{\n\treturn inode->i_mapping->private_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct resv_map *inode_resv_map(struct inode *inode)\n{\n\treturn inode->i_mapping->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_inode",
          "args": [
            "inode"
          ],
          "line": 4539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nlong hugetlb_unreserve_pages(struct inode *inode, long start, long end,\n\t\t\t\t\t\t\t\tlong freed)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct resv_map *resv_map = inode_resv_map(inode);\n\tlong chg = 0;\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tlong gbl_reserve;\n\n\tif (resv_map) {\n\t\tchg = region_del(resv_map, start, end);\n\t\t/*\n\t\t * region_del() can fail in the rare case where a region\n\t\t * must be split and another region descriptor can not be\n\t\t * allocated.  If end == LONG_MAX, it will not fail.\n\t\t */\n\t\tif (chg < 0)\n\t\t\treturn chg;\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n\tspin_unlock(&inode->i_lock);\n\n\t/*\n\t * If the subpool has a minimum size, the number of global\n\t * reservations to be released may be adjusted.\n\t */\n\tgbl_reserve = hugepage_subpool_put_pages(spool, (chg - freed));\n\thugetlb_acct_memory(h, -gbl_reserve);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hugetlb_reserve_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4422-4534",
    "snippet": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tstruct resv_map *resv_map;\n\tlong gbl_reserve;\n\n\t/* This should never happen */\n\tif (from > to) {\n\t\tVM_WARN(1, \"%s called with a negative range\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Only apply hugepage reservation if asked. At fault time, an\n\t * attempt will be made for VM_NORESERVE to allocate a page\n\t * without using reserves\n\t */\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tresv_map = inode_resv_map(inode);\n\n\t\tchg = region_chg(resv_map, from, to);\n\n\t} else {\n\t\tresv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\n\tif (chg < 0) {\n\t\tret = chg;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * There must be enough pages in the subpool for the mapping. If\n\t * the subpool has a minimum size, there may be some global\n\t * reservations already in place (gbl_reserve).\n\t */\n\tgbl_reserve = hugepage_subpool_get_pages(spool, chg);\n\tif (gbl_reserve < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Check enough hugepages are available for the reservation.\n\t * Hand the pages back to the subpool if there are not\n\t */\n\tret = hugetlb_acct_memory(h, gbl_reserve);\n\tif (ret < 0) {\n\t\t/* put back original number of pages, chg */\n\t\t(void)hugepage_subpool_put_pages(spool, chg);\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tlong add = region_add(resv_map, from, to);\n\n\t\tif (unlikely(chg > add)) {\n\t\t\t/*\n\t\t\t * pages in this range were added to the reserve\n\t\t\t * map between region_chg and region_add.  This\n\t\t\t * indicates a race with alloc_huge_page.  Adjust\n\t\t\t * the subpool and reserve counts modified above\n\t\t\t * based on the difference.\n\t\t\t */\n\t\t\tlong rsv_adjust;\n\n\t\t\trsv_adjust = hugepage_subpool_put_pages(spool,\n\t\t\t\t\t\t\t\tchg - add);\n\t\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t\t}\n\t}\n\treturn 0;\nout_err:\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\t/* Don't call region_abort if region_chg failed */\n\t\tif (chg >= 0)\n\t\t\tregion_abort(resv_map, from, to);\n\tif (vma && is_vma_resv_set(vma, HPAGE_RESV_OWNER))\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define HPAGE_RESV_OWNER    (1UL << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&resv_map->refs",
            "resv_map_release"
          ],
          "line": 4532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vma_resv_set",
          "args": [
            "vma",
            "HPAGE_RESV_OWNER"
          ],
          "line": 4531
        },
        "resolved": true,
        "details": {
          "function_name": "is_vma_resv_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "777-782",
          "snippet": "static int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "region_abort",
          "args": [
            "resv_map",
            "from",
            "to"
          ],
          "line": 4530
        },
        "resolved": true,
        "details": {
          "function_name": "region_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "460-466",
          "snippet": "static void region_abort(struct resv_map *resv, long f, long t)\n{\n\tspin_lock(&resv->lock);\n\tVM_BUG_ON(!resv->region_cache_count);\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void region_abort(struct resv_map *resv, long f, long t)\n{\n\tspin_lock(&resv->lock);\n\tVM_BUG_ON(!resv->region_cache_count);\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_acct_memory",
          "args": [
            "h",
            "-rsv_adjust"
          ],
          "line": 4522
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_acct_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3052-3091",
          "snippet": "static int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugepage_subpool_put_pages",
          "args": [
            "spool",
            "chg - add"
          ],
          "line": 4520
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_subpool_put_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "176-208",
          "snippet": "static long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "chg > add"
          ],
          "line": 4510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "region_add",
          "args": [
            "resv_map",
            "from",
            "to"
          ],
          "line": 4508
        },
        "resolved": true,
        "details": {
          "function_name": "region_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "259-331",
          "snippet": "static long region_add(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg, *trg;\n\tlong add = 0;\n\n\tspin_lock(&resv->lock);\n\t/* Locate the region we are either in or before. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/*\n\t * If no region exists which can be expanded to include the\n\t * specified range, the list must have been modified by an\n\t * interleving call to region_del().  Pull a region descriptor\n\t * from the cache and use it for this range.\n\t */\n\tif (&rg->link == head || t < rg->from) {\n\t\tVM_BUG_ON(resv->region_cache_count <= 0);\n\n\t\tresv->region_cache_count--;\n\t\tnrg = list_first_entry(&resv->region_cache, struct file_region,\n\t\t\t\t\tlink);\n\t\tlist_del(&nrg->link);\n\n\t\tnrg->from = f;\n\t\tnrg->to = t;\n\t\tlist_add(&nrg->link, rg->link.prev);\n\n\t\tadd += t - f;\n\t\tgoto out_locked;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tnrg = rg;\n\tlist_for_each_entry_safe(rg, trg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tbreak;\n\n\t\t/* If this area reaches higher then extend our area to\n\t\t * include it completely.  If this is not the first area\n\t\t * which we intend to reuse, free it. */\n\t\tif (rg->to > t)\n\t\t\tt = rg->to;\n\t\tif (rg != nrg) {\n\t\t\t/* Decrement return value by the deleted range.\n\t\t\t * Another range will span this area so that by\n\t\t\t * end of routine add will be >= zero\n\t\t\t */\n\t\t\tadd -= (rg->to - rg->from);\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t}\n\t}\n\n\tadd += (nrg->from - f);\t\t/* Added to beginning of region */\n\tnrg->from = f;\n\tadd += t - nrg->to;\t\t/* Added to end of region */\n\tnrg->to = t;\n\nout_locked:\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n\tVM_BUG_ON(add < 0);\n\treturn add;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_add(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg, *trg;\n\tlong add = 0;\n\n\tspin_lock(&resv->lock);\n\t/* Locate the region we are either in or before. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/*\n\t * If no region exists which can be expanded to include the\n\t * specified range, the list must have been modified by an\n\t * interleving call to region_del().  Pull a region descriptor\n\t * from the cache and use it for this range.\n\t */\n\tif (&rg->link == head || t < rg->from) {\n\t\tVM_BUG_ON(resv->region_cache_count <= 0);\n\n\t\tresv->region_cache_count--;\n\t\tnrg = list_first_entry(&resv->region_cache, struct file_region,\n\t\t\t\t\tlink);\n\t\tlist_del(&nrg->link);\n\n\t\tnrg->from = f;\n\t\tnrg->to = t;\n\t\tlist_add(&nrg->link, rg->link.prev);\n\n\t\tadd += t - f;\n\t\tgoto out_locked;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tnrg = rg;\n\tlist_for_each_entry_safe(rg, trg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tbreak;\n\n\t\t/* If this area reaches higher then extend our area to\n\t\t * include it completely.  If this is not the first area\n\t\t * which we intend to reuse, free it. */\n\t\tif (rg->to > t)\n\t\t\tt = rg->to;\n\t\tif (rg != nrg) {\n\t\t\t/* Decrement return value by the deleted range.\n\t\t\t * Another range will span this area so that by\n\t\t\t * end of routine add will be >= zero\n\t\t\t */\n\t\t\tadd -= (rg->to - rg->from);\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t}\n\t}\n\n\tadd += (nrg->from - f);\t\t/* Added to beginning of region */\n\tnrg->from = f;\n\tadd += t - nrg->to;\t\t/* Added to end of region */\n\tnrg->to = t;\n\nout_locked:\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n\tVM_BUG_ON(add < 0);\n\treturn add;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugepage_subpool_get_pages",
          "args": [
            "spool",
            "chg"
          ],
          "line": 4479
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_subpool_get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "131-168",
          "snippet": "static long hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n\t\t\t\t      long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn ret;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1) {\t\t/* maximum size accounting */\n\t\tif ((spool->used_hpages + delta) <= spool->max_hpages)\n\t\t\tspool->used_hpages += delta;\n\t\telse {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_ret;\n\t\t}\n\t}\n\n\t/* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->rsv_hpages) {\n\t\tif (delta > spool->rsv_hpages) {\n\t\t\t/*\n\t\t\t * Asking for more reserves than those already taken on\n\t\t\t * behalf of subpool.  Return difference.\n\t\t\t */\n\t\t\tret = delta - spool->rsv_hpages;\n\t\t\tspool->rsv_hpages = 0;\n\t\t} else {\n\t\t\tret = 0;\t/* reserves already accounted for */\n\t\t\tspool->rsv_hpages -= delta;\n\t\t}\n\t}\n\nunlock_ret:\n\tspin_unlock(&spool->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic long hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n\t\t\t\t      long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn ret;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1) {\t\t/* maximum size accounting */\n\t\tif ((spool->used_hpages + delta) <= spool->max_hpages)\n\t\t\tspool->used_hpages += delta;\n\t\telse {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_ret;\n\t\t}\n\t}\n\n\t/* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->rsv_hpages) {\n\t\tif (delta > spool->rsv_hpages) {\n\t\t\t/*\n\t\t\t * Asking for more reserves than those already taken on\n\t\t\t * behalf of subpool.  Return difference.\n\t\t\t */\n\t\t\tret = delta - spool->rsv_hpages;\n\t\t\tspool->rsv_hpages = 0;\n\t\t} else {\n\t\t\tret = 0;\t/* reserves already accounted for */\n\t\t\tspool->rsv_hpages -= delta;\n\t\t}\n\t}\n\nunlock_ret:\n\tspin_unlock(&spool->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_vma_resv_flags",
          "args": [
            "vma",
            "HPAGE_RESV_OWNER"
          ],
          "line": 4466
        },
        "resolved": true,
        "details": {
          "function_name": "set_vma_resv_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "769-775",
          "snippet": "static void set_vma_resv_flags(struct vm_area_struct *vma, unsigned long flags)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, get_vma_private_data(vma) | flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_vma_resv_flags(struct vm_area_struct *vma, unsigned long flags)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, get_vma_private_data(vma) | flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_vma_resv_map",
          "args": [
            "vma",
            "resv_map"
          ],
          "line": 4465
        },
        "resolved": true,
        "details": {
          "function_name": "set_vma_resv_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "760-767",
          "snippet": "static void set_vma_resv_map(struct vm_area_struct *vma, struct resv_map *map)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, (get_vma_private_data(vma) &\n\t\t\t\tHPAGE_RESV_MASK) | (unsigned long)map);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)\n\nstatic void set_vma_resv_map(struct vm_area_struct *vma, struct resv_map *map)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, (get_vma_private_data(vma) &\n\t\t\t\tHPAGE_RESV_MASK) | (unsigned long)map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resv_map_alloc",
          "args": [],
          "line": 4459
        },
        "resolved": true,
        "details": {
          "function_name": "resv_map_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "696-718",
          "snippet": "struct resv_map *resv_map_alloc(void)\n{\n\tstruct resv_map *resv_map = kmalloc(sizeof(*resv_map), GFP_KERNEL);\n\tstruct file_region *rg = kmalloc(sizeof(*rg), GFP_KERNEL);\n\n\tif (!resv_map || !rg) {\n\t\tkfree(resv_map);\n\t\tkfree(rg);\n\t\treturn NULL;\n\t}\n\n\tkref_init(&resv_map->refs);\n\tspin_lock_init(&resv_map->lock);\n\tINIT_LIST_HEAD(&resv_map->regions);\n\n\tresv_map->adds_in_progress = 0;\n\n\tINIT_LIST_HEAD(&resv_map->region_cache);\n\tlist_add(&rg->link, &resv_map->region_cache);\n\tresv_map->region_cache_count = 1;\n\n\treturn resv_map;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct resv_map *resv_map_alloc(void)\n{\n\tstruct resv_map *resv_map = kmalloc(sizeof(*resv_map), GFP_KERNEL);\n\tstruct file_region *rg = kmalloc(sizeof(*rg), GFP_KERNEL);\n\n\tif (!resv_map || !rg) {\n\t\tkfree(resv_map);\n\t\tkfree(rg);\n\t\treturn NULL;\n\t}\n\n\tkref_init(&resv_map->refs);\n\tspin_lock_init(&resv_map->lock);\n\tINIT_LIST_HEAD(&resv_map->regions);\n\n\tresv_map->adds_in_progress = 0;\n\n\tINIT_LIST_HEAD(&resv_map->region_cache);\n\tlist_add(&rg->link, &resv_map->region_cache);\n\tresv_map->region_cache_count = 1;\n\n\treturn resv_map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "region_chg",
          "args": [
            "resv_map",
            "from",
            "to"
          ],
          "line": 4456
        },
        "resolved": true,
        "details": {
          "function_name": "region_chg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "355-447",
          "snippet": "static long region_chg(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg = NULL;\n\tlong chg = 0;\n\nretry:\n\tspin_lock(&resv->lock);\nretry_locked:\n\tresv->adds_in_progress++;\n\n\t/*\n\t * Check for sufficient descriptors in the cache to accommodate\n\t * the number of in progress add operations.\n\t */\n\tif (resv->adds_in_progress > resv->region_cache_count) {\n\t\tstruct file_region *trg;\n\n\t\tVM_BUG_ON(resv->adds_in_progress - resv->region_cache_count > 1);\n\t\t/* Must drop lock to allocate a new descriptor. */\n\t\tresv->adds_in_progress--;\n\t\tspin_unlock(&resv->lock);\n\n\t\ttrg = kmalloc(sizeof(*trg), GFP_KERNEL);\n\t\tif (!trg) {\n\t\t\tkfree(nrg);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tspin_lock(&resv->lock);\n\t\tlist_add(&trg->link, &resv->region_cache);\n\t\tresv->region_cache_count++;\n\t\tgoto retry_locked;\n\t}\n\n\t/* Locate the region we are before or in. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/* If we are below the current region then a new region is required.\n\t * Subtle, allocate a new region at the position but make it zero\n\t * size such that we can guarantee to record the reservation. */\n\tif (&rg->link == head || t < rg->from) {\n\t\tif (!nrg) {\n\t\t\tresv->adds_in_progress--;\n\t\t\tspin_unlock(&resv->lock);\n\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\tif (!nrg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnrg->from = f;\n\t\t\tnrg->to   = f;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tlist_add(&nrg->link, rg->link.prev);\n\t\tchg = t - f;\n\t\tgoto out_nrg;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\tchg = t - f;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tlist_for_each_entry(rg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tgoto out;\n\n\t\t/* We overlap with this area, if it extends further than\n\t\t * us then we must extend ourselves.  Account for its\n\t\t * existing reservation. */\n\t\tif (rg->to > t) {\n\t\t\tchg += rg->to - t;\n\t\t\tt = rg->to;\n\t\t}\n\t\tchg -= rg->to - rg->from;\n\t}\n\nout:\n\tspin_unlock(&resv->lock);\n\t/*  We already know we raced and no longer need the new region */\n\tkfree(nrg);\n\treturn chg;\nout_nrg:\n\tspin_unlock(&resv->lock);\n\treturn chg;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_chg(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg = NULL;\n\tlong chg = 0;\n\nretry:\n\tspin_lock(&resv->lock);\nretry_locked:\n\tresv->adds_in_progress++;\n\n\t/*\n\t * Check for sufficient descriptors in the cache to accommodate\n\t * the number of in progress add operations.\n\t */\n\tif (resv->adds_in_progress > resv->region_cache_count) {\n\t\tstruct file_region *trg;\n\n\t\tVM_BUG_ON(resv->adds_in_progress - resv->region_cache_count > 1);\n\t\t/* Must drop lock to allocate a new descriptor. */\n\t\tresv->adds_in_progress--;\n\t\tspin_unlock(&resv->lock);\n\n\t\ttrg = kmalloc(sizeof(*trg), GFP_KERNEL);\n\t\tif (!trg) {\n\t\t\tkfree(nrg);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tspin_lock(&resv->lock);\n\t\tlist_add(&trg->link, &resv->region_cache);\n\t\tresv->region_cache_count++;\n\t\tgoto retry_locked;\n\t}\n\n\t/* Locate the region we are before or in. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/* If we are below the current region then a new region is required.\n\t * Subtle, allocate a new region at the position but make it zero\n\t * size such that we can guarantee to record the reservation. */\n\tif (&rg->link == head || t < rg->from) {\n\t\tif (!nrg) {\n\t\t\tresv->adds_in_progress--;\n\t\t\tspin_unlock(&resv->lock);\n\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\tif (!nrg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnrg->from = f;\n\t\t\tnrg->to   = f;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tlist_add(&nrg->link, rg->link.prev);\n\t\tchg = t - f;\n\t\tgoto out_nrg;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\tchg = t - f;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tlist_for_each_entry(rg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tgoto out;\n\n\t\t/* We overlap with this area, if it extends further than\n\t\t * us then we must extend ourselves.  Account for its\n\t\t * existing reservation. */\n\t\tif (rg->to > t) {\n\t\t\tchg += rg->to - t;\n\t\t\tt = rg->to;\n\t\t}\n\t\tchg -= rg->to - rg->from;\n\t}\n\nout:\n\tspin_unlock(&resv->lock);\n\t/*  We already know we raced and no longer need the new region */\n\tkfree(nrg);\n\treturn chg;\nout_nrg:\n\tspin_unlock(&resv->lock);\n\treturn chg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_resv_map",
          "args": [
            "inode"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "inode_resv_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "740-743",
          "snippet": "static inline struct resv_map *inode_resv_map(struct inode *inode)\n{\n\treturn inode->i_mapping->private_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct resv_map *inode_resv_map(struct inode *inode)\n{\n\treturn inode->i_mapping->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN",
          "args": [
            "1",
            "\"%s called with a negative range\\n\"",
            "__func__"
          ],
          "line": 4435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subpool_inode",
          "args": [
            "inode"
          ],
          "line": 4429
        },
        "resolved": true,
        "details": {
          "function_name": "subpool_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "210-213",
          "snippet": "static inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n{\n\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n{\n\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_inode",
          "args": [
            "inode"
          ],
          "line": 4428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nint hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tstruct resv_map *resv_map;\n\tlong gbl_reserve;\n\n\t/* This should never happen */\n\tif (from > to) {\n\t\tVM_WARN(1, \"%s called with a negative range\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Only apply hugepage reservation if asked. At fault time, an\n\t * attempt will be made for VM_NORESERVE to allocate a page\n\t * without using reserves\n\t */\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tresv_map = inode_resv_map(inode);\n\n\t\tchg = region_chg(resv_map, from, to);\n\n\t} else {\n\t\tresv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\n\tif (chg < 0) {\n\t\tret = chg;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * There must be enough pages in the subpool for the mapping. If\n\t * the subpool has a minimum size, there may be some global\n\t * reservations already in place (gbl_reserve).\n\t */\n\tgbl_reserve = hugepage_subpool_get_pages(spool, chg);\n\tif (gbl_reserve < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Check enough hugepages are available for the reservation.\n\t * Hand the pages back to the subpool if there are not\n\t */\n\tret = hugetlb_acct_memory(h, gbl_reserve);\n\tif (ret < 0) {\n\t\t/* put back original number of pages, chg */\n\t\t(void)hugepage_subpool_put_pages(spool, chg);\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tlong add = region_add(resv_map, from, to);\n\n\t\tif (unlikely(chg > add)) {\n\t\t\t/*\n\t\t\t * pages in this range were added to the reserve\n\t\t\t * map between region_chg and region_add.  This\n\t\t\t * indicates a race with alloc_huge_page.  Adjust\n\t\t\t * the subpool and reserve counts modified above\n\t\t\t * based on the difference.\n\t\t\t */\n\t\t\tlong rsv_adjust;\n\n\t\t\trsv_adjust = hugepage_subpool_put_pages(spool,\n\t\t\t\t\t\t\t\tchg - add);\n\t\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t\t}\n\t}\n\treturn 0;\nout_err:\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\t/* Don't call region_abort if region_chg failed */\n\t\tif (chg >= 0)\n\t\t\tregion_abort(resv_map, from, to);\n\tif (vma && is_vma_resv_set(vma, HPAGE_RESV_OWNER))\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\treturn ret;\n}"
  },
  {
    "function_name": "hugetlb_change_protection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4333-4420",
    "snippet": "unsigned long hugetlb_change_protection(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned long end, pgprot_t newprot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long start = address;\n\tpte_t *ptep;\n\tpte_t pte;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long pages = 0;\n\tunsigned long f_start = start;\n\tunsigned long f_end = end;\n\tbool shared_pmd = false;\n\n\t/*\n\t * In the case of shared PMDs, the area to flush could be beyond\n\t * start/end.  Set f_start/f_end to cover the maximum possible\n\t * range if PMD sharing is possible.\n\t */\n\tadjust_range_if_pmd_sharing_possible(vma, &f_start, &f_end);\n\n\tBUG_ON(address >= end);\n\tflush_cache_range(vma, f_start, f_end);\n\n\tmmu_notifier_invalidate_range_start(mm, f_start, f_end);\n\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\tfor (; address < end; address += huge_page_size(h)) {\n\t\tspinlock_t *ptl;\n\t\tptep = huge_pte_offset(mm, address, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\tcontinue;\n\t\tptl = huge_pte_lock(h, mm, ptep);\n\t\tif (huge_pmd_unshare(mm, &address, ptep)) {\n\t\t\tpages++;\n\t\t\tspin_unlock(ptl);\n\t\t\tshared_pmd = true;\n\t\t\tcontinue;\n\t\t}\n\t\tpte = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_hwpoisoned(pte))) {\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(is_hugetlb_entry_migration(pte))) {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\tif (is_write_migration_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tset_huge_swap_pte_at(mm, address, ptep,\n\t\t\t\t\t\t     newpte, huge_page_size(h));\n\t\t\t\tpages++;\n\t\t\t}\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!huge_pte_none(pte)) {\n\t\t\tpte = huge_ptep_get_and_clear(mm, address, ptep);\n\t\t\tpte = pte_mkhuge(huge_pte_modify(pte, newprot));\n\t\t\tpte = arch_make_huge_pte(pte, vma, NULL, 0);\n\t\t\tset_huge_pte_at(mm, address, ptep, pte);\n\t\t\tpages++;\n\t\t}\n\t\tspin_unlock(ptl);\n\t}\n\t/*\n\t * Must flush TLB before releasing i_mmap_rwsem: x86's huge_pmd_unshare\n\t * may have cleared our pud entry and done put_page on the page table:\n\t * once we release i_mmap_rwsem, another task can do the final put_page\n\t * and that page table be reused and filled with junk.  If we actually\n\t * did unshare a page of pmds, flush the range corresponding to the pud.\n\t */\n\tif (shared_pmd)\n\t\tflush_hugetlb_tlb_range(vma, f_start, f_end);\n\telse\n\t\tflush_hugetlb_tlb_range(vma, start, end);\n\t/*\n\t * No need to call mmu_notifier_invalidate_range() we are downgrading\n\t * page table protection not changing it to point to a new page.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\tmmu_notifier_invalidate_range_end(mm, f_start, f_end);\n\n\treturn pages << h->order;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "f_start",
            "f_end"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "vma->vm_file->f_mapping"
          ],
          "line": 4416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_hugetlb_tlb_range",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 4409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_hugetlb_tlb_range",
          "args": [
            "vma",
            "f_start",
            "f_end"
          ],
          "line": 4407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_huge_pte_at",
          "args": [
            "mm",
            "address",
            "ptep",
            "pte"
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_make_huge_pte",
          "args": [
            "pte",
            "vma",
            "NULL",
            "0"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkhuge",
          "args": [
            "huge_pte_modify(pte, newprot)"
          ],
          "line": 4392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_modify",
          "args": [
            "pte",
            "newprot"
          ],
          "line": 4392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get_and_clear",
          "args": [
            "mm",
            "address",
            "ptep"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "pte"
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_huge_swap_pte_at",
          "args": [
            "mm",
            "address",
            "ptep",
            "newpte",
            "huge_page_size(h)"
          ],
          "line": 4383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 4382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_migration_entry_read",
          "args": [
            "&entry"
          ],
          "line": 4381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_migration_entry",
          "args": [
            "entry"
          ],
          "line": 4378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pte"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_hugetlb_entry_migration(pte)"
          ],
          "line": 4375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugetlb_entry_migration",
          "args": [
            "pte"
          ],
          "line": 4375
        },
        "resolved": true,
        "details": {
          "function_name": "is_hugetlb_entry_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3207-3218",
          "snippet": "bool is_hugetlb_entry_migration(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn false;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_migration_entry(swp))\n\t\treturn true;\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nbool is_hugetlb_entry_migration(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn false;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_migration_entry(swp))\n\t\treturn true;\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_hugetlb_entry_hwpoisoned(pte)"
          ],
          "line": 4371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugetlb_entry_hwpoisoned",
          "args": [
            "pte"
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "is_hugetlb_entry_hwpoisoned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3220-3231",
          "snippet": "static int is_hugetlb_entry_hwpoisoned(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn 0;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_hwpoison_entry(swp))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_hugetlb_entry_hwpoisoned(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn 0;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_hwpoison_entry(swp))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "ptep"
          ],
          "line": 4370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pmd_unshare",
          "args": [
            "mm",
            "&address",
            "ptep"
          ],
          "line": 4364
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pmd_unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4731-4734",
          "snippet": "int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_lock",
          "args": [
            "h",
            "mm",
            "ptep"
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_offset",
          "args": [
            "mm",
            "address",
            "huge_page_size(h)"
          ],
          "line": 4360
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4782-4812",
          "snippet": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 4360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 4358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_write",
          "args": [
            "vma->vm_file->f_mapping"
          ],
          "line": 4357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "f_start",
            "f_end"
          ],
          "line": 4356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_range",
          "args": [
            "vma",
            "f_start",
            "f_end"
          ],
          "line": 4354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "address >= end"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_range_if_pmd_sharing_possible",
          "args": [
            "vma",
            "&f_start",
            "&f_end"
          ],
          "line": 4351
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_range_if_pmd_sharing_possible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4736-4739",
          "snippet": "void adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 4340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nunsigned long hugetlb_change_protection(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned long end, pgprot_t newprot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long start = address;\n\tpte_t *ptep;\n\tpte_t pte;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long pages = 0;\n\tunsigned long f_start = start;\n\tunsigned long f_end = end;\n\tbool shared_pmd = false;\n\n\t/*\n\t * In the case of shared PMDs, the area to flush could be beyond\n\t * start/end.  Set f_start/f_end to cover the maximum possible\n\t * range if PMD sharing is possible.\n\t */\n\tadjust_range_if_pmd_sharing_possible(vma, &f_start, &f_end);\n\n\tBUG_ON(address >= end);\n\tflush_cache_range(vma, f_start, f_end);\n\n\tmmu_notifier_invalidate_range_start(mm, f_start, f_end);\n\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\tfor (; address < end; address += huge_page_size(h)) {\n\t\tspinlock_t *ptl;\n\t\tptep = huge_pte_offset(mm, address, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\tcontinue;\n\t\tptl = huge_pte_lock(h, mm, ptep);\n\t\tif (huge_pmd_unshare(mm, &address, ptep)) {\n\t\t\tpages++;\n\t\t\tspin_unlock(ptl);\n\t\t\tshared_pmd = true;\n\t\t\tcontinue;\n\t\t}\n\t\tpte = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_hwpoisoned(pte))) {\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(is_hugetlb_entry_migration(pte))) {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\tif (is_write_migration_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tset_huge_swap_pte_at(mm, address, ptep,\n\t\t\t\t\t\t     newpte, huge_page_size(h));\n\t\t\t\tpages++;\n\t\t\t}\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!huge_pte_none(pte)) {\n\t\t\tpte = huge_ptep_get_and_clear(mm, address, ptep);\n\t\t\tpte = pte_mkhuge(huge_pte_modify(pte, newprot));\n\t\t\tpte = arch_make_huge_pte(pte, vma, NULL, 0);\n\t\t\tset_huge_pte_at(mm, address, ptep, pte);\n\t\t\tpages++;\n\t\t}\n\t\tspin_unlock(ptl);\n\t}\n\t/*\n\t * Must flush TLB before releasing i_mmap_rwsem: x86's huge_pmd_unshare\n\t * may have cleared our pud entry and done put_page on the page table:\n\t * once we release i_mmap_rwsem, another task can do the final put_page\n\t * and that page table be reused and filled with junk.  If we actually\n\t * did unshare a page of pmds, flush the range corresponding to the pud.\n\t */\n\tif (shared_pmd)\n\t\tflush_hugetlb_tlb_range(vma, f_start, f_end);\n\telse\n\t\tflush_hugetlb_tlb_range(vma, start, end);\n\t/*\n\t * No need to call mmu_notifier_invalidate_range() we are downgrading\n\t * page table protection not changing it to point to a new page.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\tmmu_notifier_invalidate_range_end(mm, f_start, f_end);\n\n\treturn pages << h->order;\n}"
  },
  {
    "function_name": "follow_hugetlb_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4181-4323",
    "snippet": "long follow_hugetlb_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t struct page **pages, struct vm_area_struct **vmas,\n\t\t\t unsigned long *position, unsigned long *nr_pages,\n\t\t\t long i, unsigned int flags, int *nonblocking)\n{\n\tunsigned long pfn_offset;\n\tunsigned long vaddr = *position;\n\tunsigned long remainder = *nr_pages;\n\tstruct hstate *h = hstate_vma(vma);\n\tint err = -EFAULT;\n\n\twhile (vaddr < vma->vm_end && remainder) {\n\t\tpte_t *pte;\n\t\tspinlock_t *ptl = NULL;\n\t\tint absent;\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * If we have a pending SIGKILL, don't keep faulting pages and\n\t\t * potentially allocating memory.\n\t\t */\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Some archs (sparc64, sh*) have multiple pte_ts to\n\t\t * each hugepage.  We have to make sure we get the\n\t\t * first, for the page indexing below to work.\n\t\t *\n\t\t * Note that page table lock is not held when pte is null.\n\t\t */\n\t\tpte = huge_pte_offset(mm, vaddr & huge_page_mask(h),\n\t\t\t\t      huge_page_size(h));\n\t\tif (pte)\n\t\t\tptl = huge_pte_lock(h, mm, pte);\n\t\tabsent = !pte || huge_pte_none(huge_ptep_get(pte));\n\n\t\t/*\n\t\t * When coredumping, it suits get_dump_page if we just return\n\t\t * an error where there's an empty slot with no huge pagecache\n\t\t * to back it.  This way, we avoid allocating a hugepage, and\n\t\t * the sparse dumpfile avoids allocating disk blocks, but its\n\t\t * huge holes still show up with zeroes where they need to be.\n\t\t */\n\t\tif (absent && (flags & FOLL_DUMP) &&\n\t\t    !hugetlbfs_pagecache_present(h, vma, vaddr)) {\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need call hugetlb_fault for both hugepages under migration\n\t\t * (in which case hugetlb_fault waits for the migration,) and\n\t\t * hwpoisoned hugepages (in which case we need to prevent the\n\t\t * caller from accessing to them.) In order to do this, we use\n\t\t * here is_swap_pte instead of is_hugetlb_entry_migration and\n\t\t * is_hugetlb_entry_hwpoisoned. This is because it simply covers\n\t\t * both cases, and because we can't follow correct pages\n\t\t * directly from any kind of swap entries.\n\t\t */\n\t\tif (absent || is_swap_pte(huge_ptep_get(pte)) ||\n\t\t    ((flags & FOLL_WRITE) &&\n\t\t      !huge_pte_write(huge_ptep_get(pte)))) {\n\t\t\tvm_fault_t ret;\n\t\t\tunsigned int fault_flags = 0;\n\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tif (flags & FOLL_WRITE)\n\t\t\t\tfault_flags |= FAULT_FLAG_WRITE;\n\t\t\tif (nonblocking)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\t\t\tif (flags & FOLL_NOWAIT)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY |\n\t\t\t\t\tFAULT_FLAG_RETRY_NOWAIT;\n\t\t\tif (flags & FOLL_TRIED) {\n\t\t\t\tVM_WARN_ON_ONCE(fault_flags &\n\t\t\t\t\t\tFAULT_FLAG_ALLOW_RETRY);\n\t\t\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t\t\t}\n\t\t\tret = hugetlb_fault(mm, vma, vaddr, fault_flags);\n\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\terr = vm_fault_to_errno(ret, flags);\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\t\tif (nonblocking)\n\t\t\t\t\t*nonblocking = 0;\n\t\t\t\t*nr_pages = 0;\n\t\t\t\t/*\n\t\t\t\t * VM_FAULT_RETRY must not return an\n\t\t\t\t * error, it will return zero\n\t\t\t\t * instead.\n\t\t\t\t *\n\t\t\t\t * No need to update \"position\" as the\n\t\t\t\t * caller will not check it after\n\t\t\t\t * *nr_pages is set to 0.\n\t\t\t\t */\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn_offset = (vaddr & ~huge_page_mask(h)) >> PAGE_SHIFT;\n\t\tpage = pte_page(huge_ptep_get(pte));\nsame_page:\n\t\tif (pages) {\n\t\t\tpages[i] = mem_map_offset(page, pfn_offset);\n\t\t\tget_page(pages[i]);\n\t\t}\n\n\t\tif (vmas)\n\t\t\tvmas[i] = vma;\n\n\t\tvaddr += PAGE_SIZE;\n\t\t++pfn_offset;\n\t\t--remainder;\n\t\t++i;\n\t\tif (vaddr < vma->vm_end && remainder &&\n\t\t\t\tpfn_offset < pages_per_huge_page(h)) {\n\t\t\t/*\n\t\t\t * We use pfn_offset to avoid touching the pageframes\n\t\t\t * of this compound page.\n\t\t\t */\n\t\t\tgoto same_page;\n\t\t}\n\t\tspin_unlock(ptl);\n\t}\n\t*nr_pages = remainder;\n\t/*\n\t * setting position is actually required only if remainder is\n\t * not zero but it's faster not to add a \"if (remainder)\"\n\t * branch.\n\t */\n\t*position = vaddr;\n\n\treturn i ? i : err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 4305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "pages[i]"
          ],
          "line": 4294
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_map_offset",
          "args": [
            "page",
            "pfn_offset"
          ],
          "line": 4293
        },
        "resolved": true,
        "details": {
          "function_name": "mem_map_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "369-374",
          "snippet": "static inline struct page *mem_map_offset(struct page *base, int offset)\n{\n\tif (unlikely(offset >= MAX_ORDER_NR_PAGES))\n\t\treturn nth_page(base, offset);\n\treturn base + offset;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct page *mem_map_offset(struct page *base, int offset)\n{\n\tif (unlikely(offset >= MAX_ORDER_NR_PAGES))\n\t\treturn nth_page(base, offset);\n\treturn base + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "huge_ptep_get(pte)"
          ],
          "line": 4290
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "pte"
          ],
          "line": 4290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 4289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_fault_to_errno",
          "args": [
            "ret",
            "flags"
          ],
          "line": 4267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_fault",
          "args": [
            "mm",
            "vma",
            "vaddr",
            "fault_flags"
          ],
          "line": 4265
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3913-4048",
          "snippet": "vm_fault_t hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tunsigned long address, unsigned int flags)\n{\n\tpte_t *ptep, entry;\n\tspinlock_t *ptl;\n\tvm_fault_t ret;\n\tu32 hash;\n\tpgoff_t idx;\n\tstruct page *page = NULL;\n\tstruct page *pagecache_page = NULL;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct address_space *mapping;\n\tint need_wait_lock = 0;\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (ptep) {\n\t\tentry = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_migration(entry))) {\n\t\t\tmigration_entry_wait_huge(vma, mm, ptep);\n\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))\n\t\t\treturn VM_FAULT_HWPOISON_LARGE |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t} else {\n\t\tptep = huge_pte_alloc(mm, haddr, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\treturn VM_FAULT_OOM;\n\t}\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, haddr);\n\n\t/*\n\t * Serialize hugepage allocation and instantiation, so that we don't\n\t * get spurious allocation failures if two CPUs race to instantiate\n\t * the same page in the page cache.\n\t */\n\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping, idx, haddr);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\n\tentry = huge_ptep_get(ptep);\n\tif (huge_pte_none(entry)) {\n\t\tret = hugetlb_no_page(mm, vma, mapping, idx, address, ptep, flags);\n\t\tgoto out_mutex;\n\t}\n\n\tret = 0;\n\n\t/*\n\t * entry could be a migration/hwpoison entry at this point, so this\n\t * check prevents the kernel from going below assuming that we have\n\t * a active hugepage in pagecache. This goto expects the 2nd page fault,\n\t * and is_hugetlb_entry_(migration|hwpoisoned) check will properly\n\t * handle it.\n\t */\n\tif (!pte_present(entry))\n\t\tgoto out_mutex;\n\n\t/*\n\t * If we are going to COW the mapping later, we examine the pending\n\t * reservations for this page now. This will ensure that any\n\t * allocations necessary to record that reservation occur outside the\n\t * spinlock. For private mappings, we also lookup the pagecache\n\t * page now as it is used to determine if a reservation has been\n\t * consumed.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !huge_pte_write(entry)) {\n\t\tif (vma_needs_reservation(h, vma, haddr) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out_mutex;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, haddr);\n\n\t\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\t\tpagecache_page = hugetlbfs_pagecache_page(h,\n\t\t\t\t\t\t\t\tvma, haddr);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\n\t/* Check for a racing update before calling hugetlb_cow */\n\tif (unlikely(!pte_same(entry, huge_ptep_get(ptep))))\n\t\tgoto out_ptl;\n\n\t/*\n\t * hugetlb_cow() requires page locks of pte_page(entry) and\n\t * pagecache_page, so here we need take the former one\n\t * when page != pagecache_page or !pagecache_page.\n\t */\n\tpage = pte_page(entry);\n\tif (page != pagecache_page)\n\t\tif (!trylock_page(page)) {\n\t\t\tneed_wait_lock = 1;\n\t\t\tgoto out_ptl;\n\t\t}\n\n\tget_page(page);\n\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!huge_pte_write(entry)) {\n\t\t\tret = hugetlb_cow(mm, vma, address, ptep,\n\t\t\t\t\t  pagecache_page, ptl);\n\t\t\tgoto out_put_page;\n\t\t}\n\t\tentry = huge_pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (huge_ptep_set_access_flags(vma, haddr, ptep, entry,\n\t\t\t\t\t\tflags & FAULT_FLAG_WRITE))\n\t\tupdate_mmu_cache(vma, haddr, ptep);\nout_put_page:\n\tif (page != pagecache_page)\n\t\tunlock_page(page);\n\tput_page(page);\nout_ptl:\n\tspin_unlock(ptl);\n\n\tif (pagecache_page) {\n\t\tunlock_page(pagecache_page);\n\t\tput_page(pagecache_page);\n\t}\nout_mutex:\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t/*\n\t * Generally it's safe to hold refcount during waiting page lock. But\n\t * here we just wait to defer the next page fault to avoid busy loop and\n\t * the page is not used after unlocked before returning from the current\n\t * page fault. So we are safe from accessing freed page, even if we wait\n\t * here without taking refcount.\n\t */\n\tif (need_wait_lock)\n\t\twait_on_page_locked(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mutex *hugetlb_fault_mutex_table"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct mutex *hugetlb_fault_mutex_table;\n\nvm_fault_t hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tunsigned long address, unsigned int flags)\n{\n\tpte_t *ptep, entry;\n\tspinlock_t *ptl;\n\tvm_fault_t ret;\n\tu32 hash;\n\tpgoff_t idx;\n\tstruct page *page = NULL;\n\tstruct page *pagecache_page = NULL;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct address_space *mapping;\n\tint need_wait_lock = 0;\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (ptep) {\n\t\tentry = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_migration(entry))) {\n\t\t\tmigration_entry_wait_huge(vma, mm, ptep);\n\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))\n\t\t\treturn VM_FAULT_HWPOISON_LARGE |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t} else {\n\t\tptep = huge_pte_alloc(mm, haddr, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\treturn VM_FAULT_OOM;\n\t}\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, haddr);\n\n\t/*\n\t * Serialize hugepage allocation and instantiation, so that we don't\n\t * get spurious allocation failures if two CPUs race to instantiate\n\t * the same page in the page cache.\n\t */\n\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping, idx, haddr);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\n\tentry = huge_ptep_get(ptep);\n\tif (huge_pte_none(entry)) {\n\t\tret = hugetlb_no_page(mm, vma, mapping, idx, address, ptep, flags);\n\t\tgoto out_mutex;\n\t}\n\n\tret = 0;\n\n\t/*\n\t * entry could be a migration/hwpoison entry at this point, so this\n\t * check prevents the kernel from going below assuming that we have\n\t * a active hugepage in pagecache. This goto expects the 2nd page fault,\n\t * and is_hugetlb_entry_(migration|hwpoisoned) check will properly\n\t * handle it.\n\t */\n\tif (!pte_present(entry))\n\t\tgoto out_mutex;\n\n\t/*\n\t * If we are going to COW the mapping later, we examine the pending\n\t * reservations for this page now. This will ensure that any\n\t * allocations necessary to record that reservation occur outside the\n\t * spinlock. For private mappings, we also lookup the pagecache\n\t * page now as it is used to determine if a reservation has been\n\t * consumed.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !huge_pte_write(entry)) {\n\t\tif (vma_needs_reservation(h, vma, haddr) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out_mutex;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, haddr);\n\n\t\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\t\tpagecache_page = hugetlbfs_pagecache_page(h,\n\t\t\t\t\t\t\t\tvma, haddr);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\n\t/* Check for a racing update before calling hugetlb_cow */\n\tif (unlikely(!pte_same(entry, huge_ptep_get(ptep))))\n\t\tgoto out_ptl;\n\n\t/*\n\t * hugetlb_cow() requires page locks of pte_page(entry) and\n\t * pagecache_page, so here we need take the former one\n\t * when page != pagecache_page or !pagecache_page.\n\t */\n\tpage = pte_page(entry);\n\tif (page != pagecache_page)\n\t\tif (!trylock_page(page)) {\n\t\t\tneed_wait_lock = 1;\n\t\t\tgoto out_ptl;\n\t\t}\n\n\tget_page(page);\n\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!huge_pte_write(entry)) {\n\t\t\tret = hugetlb_cow(mm, vma, address, ptep,\n\t\t\t\t\t  pagecache_page, ptl);\n\t\t\tgoto out_put_page;\n\t\t}\n\t\tentry = huge_pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (huge_ptep_set_access_flags(vma, haddr, ptep, entry,\n\t\t\t\t\t\tflags & FAULT_FLAG_WRITE))\n\t\tupdate_mmu_cache(vma, haddr, ptep);\nout_put_page:\n\tif (page != pagecache_page)\n\t\tunlock_page(page);\n\tput_page(page);\nout_ptl:\n\tspin_unlock(ptl);\n\n\tif (pagecache_page) {\n\t\tunlock_page(pagecache_page);\n\t\tput_page(pagecache_page);\n\t}\nout_mutex:\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t/*\n\t * Generally it's safe to hold refcount during waiting page lock. But\n\t * here we just wait to defer the next page fault to avoid busy loop and\n\t * the page is not used after unlocked before returning from the current\n\t * page fault. So we are safe from accessing freed page, even if we wait\n\t * here without taking refcount.\n\t */\n\tif (need_wait_lock)\n\t\twait_on_page_locked(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON_ONCE",
          "args": [
            "fault_flags &\n\t\t\t\t\t\tFAULT_FLAG_ALLOW_RETRY"
          ],
          "line": 4261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_write",
          "args": [
            "huge_ptep_get(pte)"
          ],
          "line": 4247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "pte"
          ],
          "line": 4247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "huge_ptep_get(pte)"
          ],
          "line": 4245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "pte"
          ],
          "line": 4245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlbfs_pagecache_present",
          "args": [
            "h",
            "vma",
            "vaddr"
          ],
          "line": 4228
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_pagecache_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3681-3695",
          "snippet": "static bool hugetlbfs_pagecache_present(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tstruct page *page;\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\n\tpage = find_get_page(mapping, idx);\n\tif (page)\n\t\tput_page(page);\n\treturn page != NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic bool hugetlbfs_pagecache_present(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tstruct page *page;\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\n\tpage = find_get_page(mapping, idx);\n\tif (page)\n\t\tput_page(page);\n\treturn page != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "huge_ptep_get(pte)"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "pte"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_lock",
          "args": [
            "h",
            "mm",
            "pte"
          ],
          "line": 4217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_offset",
          "args": [
            "mm",
            "vaddr & huge_page_mask(h)",
            "huge_page_size(h)"
          ],
          "line": 4214
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4782-4812",
          "snippet": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fatal_signal_pending(current)"
          ],
          "line": 4202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 4202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 4189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nlong follow_hugetlb_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t struct page **pages, struct vm_area_struct **vmas,\n\t\t\t unsigned long *position, unsigned long *nr_pages,\n\t\t\t long i, unsigned int flags, int *nonblocking)\n{\n\tunsigned long pfn_offset;\n\tunsigned long vaddr = *position;\n\tunsigned long remainder = *nr_pages;\n\tstruct hstate *h = hstate_vma(vma);\n\tint err = -EFAULT;\n\n\twhile (vaddr < vma->vm_end && remainder) {\n\t\tpte_t *pte;\n\t\tspinlock_t *ptl = NULL;\n\t\tint absent;\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * If we have a pending SIGKILL, don't keep faulting pages and\n\t\t * potentially allocating memory.\n\t\t */\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Some archs (sparc64, sh*) have multiple pte_ts to\n\t\t * each hugepage.  We have to make sure we get the\n\t\t * first, for the page indexing below to work.\n\t\t *\n\t\t * Note that page table lock is not held when pte is null.\n\t\t */\n\t\tpte = huge_pte_offset(mm, vaddr & huge_page_mask(h),\n\t\t\t\t      huge_page_size(h));\n\t\tif (pte)\n\t\t\tptl = huge_pte_lock(h, mm, pte);\n\t\tabsent = !pte || huge_pte_none(huge_ptep_get(pte));\n\n\t\t/*\n\t\t * When coredumping, it suits get_dump_page if we just return\n\t\t * an error where there's an empty slot with no huge pagecache\n\t\t * to back it.  This way, we avoid allocating a hugepage, and\n\t\t * the sparse dumpfile avoids allocating disk blocks, but its\n\t\t * huge holes still show up with zeroes where they need to be.\n\t\t */\n\t\tif (absent && (flags & FOLL_DUMP) &&\n\t\t    !hugetlbfs_pagecache_present(h, vma, vaddr)) {\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need call hugetlb_fault for both hugepages under migration\n\t\t * (in which case hugetlb_fault waits for the migration,) and\n\t\t * hwpoisoned hugepages (in which case we need to prevent the\n\t\t * caller from accessing to them.) In order to do this, we use\n\t\t * here is_swap_pte instead of is_hugetlb_entry_migration and\n\t\t * is_hugetlb_entry_hwpoisoned. This is because it simply covers\n\t\t * both cases, and because we can't follow correct pages\n\t\t * directly from any kind of swap entries.\n\t\t */\n\t\tif (absent || is_swap_pte(huge_ptep_get(pte)) ||\n\t\t    ((flags & FOLL_WRITE) &&\n\t\t      !huge_pte_write(huge_ptep_get(pte)))) {\n\t\t\tvm_fault_t ret;\n\t\t\tunsigned int fault_flags = 0;\n\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tif (flags & FOLL_WRITE)\n\t\t\t\tfault_flags |= FAULT_FLAG_WRITE;\n\t\t\tif (nonblocking)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\t\t\tif (flags & FOLL_NOWAIT)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY |\n\t\t\t\t\tFAULT_FLAG_RETRY_NOWAIT;\n\t\t\tif (flags & FOLL_TRIED) {\n\t\t\t\tVM_WARN_ON_ONCE(fault_flags &\n\t\t\t\t\t\tFAULT_FLAG_ALLOW_RETRY);\n\t\t\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t\t\t}\n\t\t\tret = hugetlb_fault(mm, vma, vaddr, fault_flags);\n\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\terr = vm_fault_to_errno(ret, flags);\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\t\tif (nonblocking)\n\t\t\t\t\t*nonblocking = 0;\n\t\t\t\t*nr_pages = 0;\n\t\t\t\t/*\n\t\t\t\t * VM_FAULT_RETRY must not return an\n\t\t\t\t * error, it will return zero\n\t\t\t\t * instead.\n\t\t\t\t *\n\t\t\t\t * No need to update \"position\" as the\n\t\t\t\t * caller will not check it after\n\t\t\t\t * *nr_pages is set to 0.\n\t\t\t\t */\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn_offset = (vaddr & ~huge_page_mask(h)) >> PAGE_SHIFT;\n\t\tpage = pte_page(huge_ptep_get(pte));\nsame_page:\n\t\tif (pages) {\n\t\t\tpages[i] = mem_map_offset(page, pfn_offset);\n\t\t\tget_page(pages[i]);\n\t\t}\n\n\t\tif (vmas)\n\t\t\tvmas[i] = vma;\n\n\t\tvaddr += PAGE_SIZE;\n\t\t++pfn_offset;\n\t\t--remainder;\n\t\t++i;\n\t\tif (vaddr < vma->vm_end && remainder &&\n\t\t\t\tpfn_offset < pages_per_huge_page(h)) {\n\t\t\t/*\n\t\t\t * We use pfn_offset to avoid touching the pageframes\n\t\t\t * of this compound page.\n\t\t\t */\n\t\t\tgoto same_page;\n\t\t}\n\t\tspin_unlock(ptl);\n\t}\n\t*nr_pages = remainder;\n\t/*\n\t * setting position is actually required only if remainder is\n\t * not zero but it's faster not to add a \"if (remainder)\"\n\t * branch.\n\t */\n\t*position = vaddr;\n\n\treturn i ? i : err;\n}"
  },
  {
    "function_name": "hugetlb_mcopy_atomic_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "4054-4179",
    "snippet": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -ENOENT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mutex *hugetlb_fault_mutex_table"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 4177
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 4175
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "dst_vma",
            "dst_addr",
            "dst_pte"
          ],
          "line": 4164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_count_add",
          "args": [
            "pages_per_huge_page(h)",
            "dst_mm"
          ],
          "line": 4161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 4161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_set_access_flags",
          "args": [
            "dst_vma",
            "dst_addr",
            "dst_pte",
            "_dst_pte",
            "dst_vma->vm_flags & VM_WRITE"
          ],
          "line": 4159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_huge_pte_at",
          "args": [
            "dst_mm",
            "dst_addr",
            "dst_pte",
            "_dst_pte"
          ],
          "line": 4157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkyoung",
          "args": [
            "_dst_pte"
          ],
          "line": 4155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_mkdirty",
          "args": [
            "_dst_pte"
          ],
          "line": 4154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_huge_pte",
          "args": [
            "dst_vma",
            "page",
            "dst_vma->vm_flags & VM_WRITE"
          ],
          "line": 4152
        },
        "resolved": true,
        "details": {
          "function_name": "make_huge_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3178-3195",
          "snippet": "static pte_t make_huge_pte(struct vm_area_struct *vma, struct page *page,\n\t\t\t\tint writable)\n{\n\tpte_t entry;\n\n\tif (writable) {\n\t\tentry = huge_pte_mkwrite(huge_pte_mkdirty(mk_huge_pte(page,\n\t\t\t\t\t vma->vm_page_prot)));\n\t} else {\n\t\tentry = huge_pte_wrprotect(mk_huge_pte(page,\n\t\t\t\t\t   vma->vm_page_prot));\n\t}\n\tentry = pte_mkyoung(entry);\n\tentry = pte_mkhuge(entry);\n\tentry = arch_make_huge_pte(entry, vma, page, writable);\n\n\treturn entry;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pte_t make_huge_pte(struct vm_area_struct *vma, struct page *page,\n\t\t\t\tint writable)\n{\n\tpte_t entry;\n\n\tif (writable) {\n\t\tentry = huge_pte_mkwrite(huge_pte_mkdirty(mk_huge_pte(page,\n\t\t\t\t\t vma->vm_page_prot)));\n\t} else {\n\t\tentry = huge_pte_wrprotect(mk_huge_pte(page,\n\t\t\t\t\t   vma->vm_page_prot));\n\t}\n\tentry = pte_mkyoung(entry);\n\tentry = pte_mkhuge(entry);\n\tentry = arch_make_huge_pte(entry, vma, page, writable);\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugepage_add_new_anon_rmap",
          "args": [
            "page",
            "dst_vma",
            "dst_addr"
          ],
          "line": 4149
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1955-1961",
          "snippet": "void hugepage_add_new_anon_rmap(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tBUG_ON(address < vma->vm_start || address >= vma->vm_end);\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\t__hugepage_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid hugepage_add_new_anon_rmap(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tBUG_ON(address < vma->vm_start || address >= vma->vm_end);\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\t__hugepage_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 4148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_dup_rmap",
          "args": [
            "page",
            "true"
          ],
          "line": 4146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "huge_ptep_get(dst_pte)"
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "dst_pte"
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 4136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 4136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "ptl"
          ],
          "line": 4125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_lockptr",
          "args": [
            "h",
            "dst_mm",
            "dst_pte"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_add_to_page_cache",
          "args": [
            "page",
            "mapping",
            "idx"
          ],
          "line": 4119
        },
        "resolved": true,
        "details": {
          "function_name": "huge_add_to_page_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3697-3718",
          "snippet": "int huge_add_to_page_cache(struct page *page, struct address_space *mapping,\n\t\t\t   pgoff_t idx)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct hstate *h = hstate_inode(inode);\n\tint err = add_to_page_cache(page, mapping, idx, GFP_KERNEL);\n\n\tif (err)\n\t\treturn err;\n\tClearPagePrivate(page);\n\n\t/*\n\t * set page dirty so that it will not be removed from cache/file\n\t * by non-hugetlbfs specific code paths.\n\t */\n\tset_page_dirty(page);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks += blocks_per_huge_page(h);\n\tspin_unlock(&inode->i_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint huge_add_to_page_cache(struct page *page, struct address_space *mapping,\n\t\t\t   pgoff_t idx)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct hstate *h = hstate_inode(inode);\n\tint err = add_to_page_cache(page, mapping, idx, GFP_KERNEL);\n\n\tif (err)\n\t\treturn err;\n\tClearPagePrivate(page);\n\n\t/*\n\t * set page dirty so that it will not be removed from cache/file\n\t * by non-hugetlbfs specific code paths.\n\t */\n\tset_page_dirty(page);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks += blocks_per_huge_page(h);\n\tspin_unlock(&inode->i_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 4108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 4108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_hugecache_offset",
          "args": [
            "h",
            "dst_vma",
            "dst_addr"
          ],
          "line": 4102
        },
        "resolved": true,
        "details": {
          "function_name": "vma_hugecache_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "620-625",
          "snippet": "static pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_huge_active",
          "args": [
            "page"
          ],
          "line": 4099
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_huge_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1205-1209",
          "snippet": "static void set_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tSetPagePrivate(&page[1]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tSetPagePrivate(&page[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 4082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_huge_page_from_user",
          "args": [
            "page",
            "(const void __user *) src_addr",
            "pages_per_huge_page(h)",
            "false"
          ],
          "line": 4077
        },
        "resolved": true,
        "details": {
          "function_name": "copy_huge_page_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4508-4538",
          "snippet": "long copy_huge_page_from_user(struct page *dst_page,\n\t\t\t\tconst void __user *usr_src,\n\t\t\t\tunsigned int pages_per_huge_page,\n\t\t\t\tbool allow_pagefault)\n{\n\tvoid *src = (void *)usr_src;\n\tvoid *page_kaddr;\n\tunsigned long i, rc = 0;\n\tunsigned long ret_val = pages_per_huge_page * PAGE_SIZE;\n\n\tfor (i = 0; i < pages_per_huge_page; i++) {\n\t\tif (allow_pagefault)\n\t\t\tpage_kaddr = kmap(dst_page + i);\n\t\telse\n\t\t\tpage_kaddr = kmap_atomic(dst_page + i);\n\t\trc = copy_from_user(page_kaddr,\n\t\t\t\t(const void __user *)(src + i * PAGE_SIZE),\n\t\t\t\tPAGE_SIZE);\n\t\tif (allow_pagefault)\n\t\t\tkunmap(dst_page + i);\n\t\telse\n\t\t\tkunmap_atomic(page_kaddr);\n\n\t\tret_val -= (PAGE_SIZE - rc);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\treturn ret_val;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nlong copy_huge_page_from_user(struct page *dst_page,\n\t\t\t\tconst void __user *usr_src,\n\t\t\t\tunsigned int pages_per_huge_page,\n\t\t\t\tbool allow_pagefault)\n{\n\tvoid *src = (void *)usr_src;\n\tvoid *page_kaddr;\n\tunsigned long i, rc = 0;\n\tunsigned long ret_val = pages_per_huge_page * PAGE_SIZE;\n\n\tfor (i = 0; i < pages_per_huge_page; i++) {\n\t\tif (allow_pagefault)\n\t\t\tpage_kaddr = kmap(dst_page + i);\n\t\telse\n\t\t\tpage_kaddr = kmap_atomic(dst_page + i);\n\t\trc = copy_from_user(page_kaddr,\n\t\t\t\t(const void __user *)(src + i * PAGE_SIZE),\n\t\t\t\tPAGE_SIZE);\n\t\tif (allow_pagefault)\n\t\t\tkunmap(dst_page + i);\n\t\telse\n\t\t\tkunmap_atomic(page_kaddr);\n\n\t\tret_val -= (PAGE_SIZE - rc);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\treturn ret_val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_huge_page",
          "args": [
            "dst_vma",
            "dst_addr",
            "0"
          ],
          "line": 4073
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1990-2091",
          "snippet": "struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong map_chg, map_commit;\n\tlong gbl_chg;\n\tint ret, idx;\n\tstruct hugetlb_cgroup *h_cg;\n\n\tidx = hstate_index(h);\n\t/*\n\t * Examine the region/reserve map to determine if the process\n\t * has a reservation for the page to be allocated.  A return\n\t * code of zero indicates a reservation exists (no change).\n\t */\n\tmap_chg = gbl_chg = vma_needs_reservation(h, vma, addr);\n\tif (map_chg < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Processes that did not create the mapping will have no\n\t * reserves as indicated by the region/reserve map. Check\n\t * that the allocation will not exceed the subpool limit.\n\t * Allocations for MAP_NORESERVE mappings also need to be\n\t * checked against any subpool limit.\n\t */\n\tif (map_chg || avoid_reserve) {\n\t\tgbl_chg = hugepage_subpool_get_pages(spool, 1);\n\t\tif (gbl_chg < 0) {\n\t\t\tvma_end_reservation(h, vma, addr);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\n\t\t/*\n\t\t * Even though there was no reservation in the region/reserve\n\t\t * map, there could be reservations associated with the\n\t\t * subpool that can be used.  This would be indicated if the\n\t\t * return value of hugepage_subpool_get_pages() is zero.\n\t\t * However, if avoid_reserve is specified we still avoid even\n\t\t * the subpool reservations.\n\t\t */\n\t\tif (avoid_reserve)\n\t\t\tgbl_chg = 1;\n\t}\n\n\tret = hugetlb_cgroup_charge_cgroup(idx, pages_per_huge_page(h), &h_cg);\n\tif (ret)\n\t\tgoto out_subpool_put;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * glb_chg is passed to indicate whether or not a page must be taken\n\t * from the global free pool (global change).  gbl_chg == 0 indicates\n\t * a reservation exists for the allocation.\n\t */\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve, gbl_chg);\n\tif (!page) {\n\t\tspin_unlock(&hugetlb_lock);\n\t\tpage = alloc_buddy_huge_page_with_mpol(h, vma, addr);\n\t\tif (!page)\n\t\t\tgoto out_uncharge_cgroup;\n\t\tif (!avoid_reserve && vma_has_reserves(vma, gbl_chg)) {\n\t\t\tSetPagePrivate(page);\n\t\t\th->resv_huge_pages--;\n\t\t}\n\t\tspin_lock(&hugetlb_lock);\n\t\tlist_move(&page->lru, &h->hugepage_activelist);\n\t\t/* Fall through */\n\t}\n\thugetlb_cgroup_commit_charge(idx, pages_per_huge_page(h), h_cg, page);\n\tspin_unlock(&hugetlb_lock);\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tmap_commit = vma_commit_reservation(h, vma, addr);\n\tif (unlikely(map_chg > map_commit)) {\n\t\t/*\n\t\t * The page was added to the reservation map between\n\t\t * vma_needs_reservation and vma_commit_reservation.\n\t\t * This indicates a race with hugetlb_reserve_pages.\n\t\t * Adjust for the subpool count incremented above AND\n\t\t * in hugetlb_reserve_pages for the same page.  Also,\n\t\t * the reservation count added in hugetlb_reserve_pages\n\t\t * no longer applies.\n\t\t */\n\t\tlong rsv_adjust;\n\n\t\trsv_adjust = hugepage_subpool_put_pages(spool, 1);\n\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t}\n\treturn page;\n\nout_uncharge_cgroup:\n\thugetlb_cgroup_uncharge_cgroup(idx, pages_per_huge_page(h), h_cg);\nout_subpool_put:\n\tif (map_chg || avoid_reserve)\n\t\thugepage_subpool_put_pages(spool, 1);\n\tvma_end_reservation(h, vma, addr);\n\treturn ERR_PTR(-ENOSPC);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong map_chg, map_commit;\n\tlong gbl_chg;\n\tint ret, idx;\n\tstruct hugetlb_cgroup *h_cg;\n\n\tidx = hstate_index(h);\n\t/*\n\t * Examine the region/reserve map to determine if the process\n\t * has a reservation for the page to be allocated.  A return\n\t * code of zero indicates a reservation exists (no change).\n\t */\n\tmap_chg = gbl_chg = vma_needs_reservation(h, vma, addr);\n\tif (map_chg < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Processes that did not create the mapping will have no\n\t * reserves as indicated by the region/reserve map. Check\n\t * that the allocation will not exceed the subpool limit.\n\t * Allocations for MAP_NORESERVE mappings also need to be\n\t * checked against any subpool limit.\n\t */\n\tif (map_chg || avoid_reserve) {\n\t\tgbl_chg = hugepage_subpool_get_pages(spool, 1);\n\t\tif (gbl_chg < 0) {\n\t\t\tvma_end_reservation(h, vma, addr);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\n\t\t/*\n\t\t * Even though there was no reservation in the region/reserve\n\t\t * map, there could be reservations associated with the\n\t\t * subpool that can be used.  This would be indicated if the\n\t\t * return value of hugepage_subpool_get_pages() is zero.\n\t\t * However, if avoid_reserve is specified we still avoid even\n\t\t * the subpool reservations.\n\t\t */\n\t\tif (avoid_reserve)\n\t\t\tgbl_chg = 1;\n\t}\n\n\tret = hugetlb_cgroup_charge_cgroup(idx, pages_per_huge_page(h), &h_cg);\n\tif (ret)\n\t\tgoto out_subpool_put;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * glb_chg is passed to indicate whether or not a page must be taken\n\t * from the global free pool (global change).  gbl_chg == 0 indicates\n\t * a reservation exists for the allocation.\n\t */\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve, gbl_chg);\n\tif (!page) {\n\t\tspin_unlock(&hugetlb_lock);\n\t\tpage = alloc_buddy_huge_page_with_mpol(h, vma, addr);\n\t\tif (!page)\n\t\t\tgoto out_uncharge_cgroup;\n\t\tif (!avoid_reserve && vma_has_reserves(vma, gbl_chg)) {\n\t\t\tSetPagePrivate(page);\n\t\t\th->resv_huge_pages--;\n\t\t}\n\t\tspin_lock(&hugetlb_lock);\n\t\tlist_move(&page->lru, &h->hugepage_activelist);\n\t\t/* Fall through */\n\t}\n\thugetlb_cgroup_commit_charge(idx, pages_per_huge_page(h), h_cg, page);\n\tspin_unlock(&hugetlb_lock);\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tmap_commit = vma_commit_reservation(h, vma, addr);\n\tif (unlikely(map_chg > map_commit)) {\n\t\t/*\n\t\t * The page was added to the reservation map between\n\t\t * vma_needs_reservation and vma_commit_reservation.\n\t\t * This indicates a race with hugetlb_reserve_pages.\n\t\t * Adjust for the subpool count incremented above AND\n\t\t * in hugetlb_reserve_pages for the same page.  Also,\n\t\t * the reservation count added in hugetlb_reserve_pages\n\t\t * no longer applies.\n\t\t */\n\t\tlong rsv_adjust;\n\n\t\trsv_adjust = hugepage_subpool_put_pages(spool, 1);\n\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t}\n\treturn page;\n\nout_uncharge_cgroup:\n\thugetlb_cgroup_uncharge_cgroup(idx, pages_per_huge_page(h), h_cg);\nout_subpool_put:\n\tif (map_chg || avoid_reserve)\n\t\thugepage_subpool_put_pages(spool, 1);\n\tvma_end_reservation(h, vma, addr);\n\treturn ERR_PTR(-ENOSPC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "dst_vma"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct mutex *hugetlb_fault_mutex_table;\n\nint hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -ENOENT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}"
  },
  {
    "function_name": "hugetlb_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3913-4048",
    "snippet": "vm_fault_t hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tunsigned long address, unsigned int flags)\n{\n\tpte_t *ptep, entry;\n\tspinlock_t *ptl;\n\tvm_fault_t ret;\n\tu32 hash;\n\tpgoff_t idx;\n\tstruct page *page = NULL;\n\tstruct page *pagecache_page = NULL;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct address_space *mapping;\n\tint need_wait_lock = 0;\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (ptep) {\n\t\tentry = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_migration(entry))) {\n\t\t\tmigration_entry_wait_huge(vma, mm, ptep);\n\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))\n\t\t\treturn VM_FAULT_HWPOISON_LARGE |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t} else {\n\t\tptep = huge_pte_alloc(mm, haddr, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\treturn VM_FAULT_OOM;\n\t}\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, haddr);\n\n\t/*\n\t * Serialize hugepage allocation and instantiation, so that we don't\n\t * get spurious allocation failures if two CPUs race to instantiate\n\t * the same page in the page cache.\n\t */\n\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping, idx, haddr);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\n\tentry = huge_ptep_get(ptep);\n\tif (huge_pte_none(entry)) {\n\t\tret = hugetlb_no_page(mm, vma, mapping, idx, address, ptep, flags);\n\t\tgoto out_mutex;\n\t}\n\n\tret = 0;\n\n\t/*\n\t * entry could be a migration/hwpoison entry at this point, so this\n\t * check prevents the kernel from going below assuming that we have\n\t * a active hugepage in pagecache. This goto expects the 2nd page fault,\n\t * and is_hugetlb_entry_(migration|hwpoisoned) check will properly\n\t * handle it.\n\t */\n\tif (!pte_present(entry))\n\t\tgoto out_mutex;\n\n\t/*\n\t * If we are going to COW the mapping later, we examine the pending\n\t * reservations for this page now. This will ensure that any\n\t * allocations necessary to record that reservation occur outside the\n\t * spinlock. For private mappings, we also lookup the pagecache\n\t * page now as it is used to determine if a reservation has been\n\t * consumed.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !huge_pte_write(entry)) {\n\t\tif (vma_needs_reservation(h, vma, haddr) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out_mutex;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, haddr);\n\n\t\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\t\tpagecache_page = hugetlbfs_pagecache_page(h,\n\t\t\t\t\t\t\t\tvma, haddr);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\n\t/* Check for a racing update before calling hugetlb_cow */\n\tif (unlikely(!pte_same(entry, huge_ptep_get(ptep))))\n\t\tgoto out_ptl;\n\n\t/*\n\t * hugetlb_cow() requires page locks of pte_page(entry) and\n\t * pagecache_page, so here we need take the former one\n\t * when page != pagecache_page or !pagecache_page.\n\t */\n\tpage = pte_page(entry);\n\tif (page != pagecache_page)\n\t\tif (!trylock_page(page)) {\n\t\t\tneed_wait_lock = 1;\n\t\t\tgoto out_ptl;\n\t\t}\n\n\tget_page(page);\n\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!huge_pte_write(entry)) {\n\t\t\tret = hugetlb_cow(mm, vma, address, ptep,\n\t\t\t\t\t  pagecache_page, ptl);\n\t\t\tgoto out_put_page;\n\t\t}\n\t\tentry = huge_pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (huge_ptep_set_access_flags(vma, haddr, ptep, entry,\n\t\t\t\t\t\tflags & FAULT_FLAG_WRITE))\n\t\tupdate_mmu_cache(vma, haddr, ptep);\nout_put_page:\n\tif (page != pagecache_page)\n\t\tunlock_page(page);\n\tput_page(page);\nout_ptl:\n\tspin_unlock(ptl);\n\n\tif (pagecache_page) {\n\t\tunlock_page(pagecache_page);\n\t\tput_page(pagecache_page);\n\t}\nout_mutex:\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t/*\n\t * Generally it's safe to hold refcount during waiting page lock. But\n\t * here we just wait to defer the next page fault to avoid busy loop and\n\t * the page is not used after unlocked before returning from the current\n\t * page fault. So we are safe from accessing freed page, even if we wait\n\t * here without taking refcount.\n\t */\n\tif (need_wait_lock)\n\t\twait_on_page_locked(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mutex *hugetlb_fault_mutex_table"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 4046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hugetlb_fault_mutex_table[hash]"
          ],
          "line": 4037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pagecache_page"
          ],
          "line": 4034
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pagecache_page"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "haddr",
            "ptep"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_set_access_flags",
          "args": [
            "vma",
            "haddr",
            "ptep",
            "entry",
            "flags & FAULT_FLAG_WRITE"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkyoung",
          "args": [
            "entry"
          ],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_mkdirty",
          "args": [
            "entry"
          ],
          "line": 4019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cow",
          "args": [
            "mm",
            "vma",
            "address",
            "ptep",
            "pagecache_page",
            "ptl"
          ],
          "line": 4015
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3539-3662",
          "snippet": "static vm_fault_t hugetlb_cow(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t       unsigned long address, pte_t *ptep,\n\t\t       struct page *pagecache_page, spinlock_t *ptl)\n{\n\tpte_t pte;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *old_page, *new_page;\n\tint outside_reserve = 0;\n\tvm_fault_t ret = 0;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tpte = huge_ptep_get(ptep);\n\told_page = pte_page(pte);\n\nretry_avoidcopy:\n\t/* If no-one else is actually using this page, avoid the copy\n\t * and just make the page writable */\n\tif (page_mapcount(old_page) == 1 && PageAnon(old_page)) {\n\t\tpage_move_anon_rmap(old_page, vma);\n\t\tset_huge_ptep_writable(vma, haddr, ptep);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the process that created a MAP_PRIVATE mapping is about to\n\t * perform a COW due to a shared page count, attempt to satisfy\n\t * the allocation without using the existing reserves. The pagecache\n\t * page is used to determine if the reserve at this address was\n\t * consumed or not. If reserves were used, a partial faulted mapping\n\t * at the time of fork() could consume its reserves on COW instead\n\t * of the full address range.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER) &&\n\t\t\told_page != pagecache_page)\n\t\toutside_reserve = 1;\n\n\tget_page(old_page);\n\n\t/*\n\t * Drop page table lock as buddy allocator may be called. It will\n\t * be acquired again before returning to the caller, as expected.\n\t */\n\tspin_unlock(ptl);\n\tnew_page = alloc_huge_page(vma, haddr, outside_reserve);\n\n\tif (IS_ERR(new_page)) {\n\t\t/*\n\t\t * If a process owning a MAP_PRIVATE mapping fails to COW,\n\t\t * it is due to references held by a child and an insufficient\n\t\t * huge page pool. To guarantee the original mappers\n\t\t * reliability, unmap the page from child processes. The child\n\t\t * may get SIGKILLed if it later faults.\n\t\t */\n\t\tif (outside_reserve) {\n\t\t\tput_page(old_page);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tunmap_ref_private(mm, vma, old_page, haddr);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tspin_lock(ptl);\n\t\t\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\t\t\tif (likely(ptep &&\n\t\t\t\t   pte_same(huge_ptep_get(ptep), pte)))\n\t\t\t\tgoto retry_avoidcopy;\n\t\t\t/*\n\t\t\t * race occurs while re-acquiring page table\n\t\t\t * lock, and our job is done.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = vmf_error(PTR_ERR(new_page));\n\t\tgoto out_release_old;\n\t}\n\n\t/*\n\t * When the original hugepage is shared one, it does not have\n\t * anon_vma prepared.\n\t */\n\tif (unlikely(anon_vma_prepare(vma))) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_release_all;\n\t}\n\n\tcopy_user_huge_page(new_page, old_page, address, vma,\n\t\t\t    pages_per_huge_page(h));\n\t__SetPageUptodate(new_page);\n\tset_page_huge_active(new_page);\n\n\tmmun_start = haddr;\n\tmmun_end = mmun_start + huge_page_size(h);\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Retake the page table lock to check for racing updates\n\t * before the page tables are altered\n\t */\n\tspin_lock(ptl);\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (likely(ptep && pte_same(huge_ptep_get(ptep), pte))) {\n\t\tClearPagePrivate(new_page);\n\n\t\t/* Break COW */\n\t\thuge_ptep_clear_flush(vma, haddr, ptep);\n\t\tmmu_notifier_invalidate_range(mm, mmun_start, mmun_end);\n\t\tset_huge_pte_at(mm, haddr, ptep,\n\t\t\t\tmake_huge_pte(vma, new_page, 1));\n\t\tpage_remove_rmap(old_page, true);\n\t\thugepage_add_new_anon_rmap(new_page, vma, haddr);\n\t\t/* Make the old page be freed below */\n\t\tnew_page = old_page;\n\t}\n\tspin_unlock(ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout_release_all:\n\trestore_reserve_on_error(h, vma, haddr, new_page);\n\tput_page(new_page);\nout_release_old:\n\tput_page(old_page);\n\n\tspin_lock(ptl); /* Caller expects lock to be held */\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_OWNER    (1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic vm_fault_t hugetlb_cow(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t       unsigned long address, pte_t *ptep,\n\t\t       struct page *pagecache_page, spinlock_t *ptl)\n{\n\tpte_t pte;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *old_page, *new_page;\n\tint outside_reserve = 0;\n\tvm_fault_t ret = 0;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tpte = huge_ptep_get(ptep);\n\told_page = pte_page(pte);\n\nretry_avoidcopy:\n\t/* If no-one else is actually using this page, avoid the copy\n\t * and just make the page writable */\n\tif (page_mapcount(old_page) == 1 && PageAnon(old_page)) {\n\t\tpage_move_anon_rmap(old_page, vma);\n\t\tset_huge_ptep_writable(vma, haddr, ptep);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the process that created a MAP_PRIVATE mapping is about to\n\t * perform a COW due to a shared page count, attempt to satisfy\n\t * the allocation without using the existing reserves. The pagecache\n\t * page is used to determine if the reserve at this address was\n\t * consumed or not. If reserves were used, a partial faulted mapping\n\t * at the time of fork() could consume its reserves on COW instead\n\t * of the full address range.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER) &&\n\t\t\told_page != pagecache_page)\n\t\toutside_reserve = 1;\n\n\tget_page(old_page);\n\n\t/*\n\t * Drop page table lock as buddy allocator may be called. It will\n\t * be acquired again before returning to the caller, as expected.\n\t */\n\tspin_unlock(ptl);\n\tnew_page = alloc_huge_page(vma, haddr, outside_reserve);\n\n\tif (IS_ERR(new_page)) {\n\t\t/*\n\t\t * If a process owning a MAP_PRIVATE mapping fails to COW,\n\t\t * it is due to references held by a child and an insufficient\n\t\t * huge page pool. To guarantee the original mappers\n\t\t * reliability, unmap the page from child processes. The child\n\t\t * may get SIGKILLed if it later faults.\n\t\t */\n\t\tif (outside_reserve) {\n\t\t\tput_page(old_page);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tunmap_ref_private(mm, vma, old_page, haddr);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tspin_lock(ptl);\n\t\t\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\t\t\tif (likely(ptep &&\n\t\t\t\t   pte_same(huge_ptep_get(ptep), pte)))\n\t\t\t\tgoto retry_avoidcopy;\n\t\t\t/*\n\t\t\t * race occurs while re-acquiring page table\n\t\t\t * lock, and our job is done.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = vmf_error(PTR_ERR(new_page));\n\t\tgoto out_release_old;\n\t}\n\n\t/*\n\t * When the original hugepage is shared one, it does not have\n\t * anon_vma prepared.\n\t */\n\tif (unlikely(anon_vma_prepare(vma))) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_release_all;\n\t}\n\n\tcopy_user_huge_page(new_page, old_page, address, vma,\n\t\t\t    pages_per_huge_page(h));\n\t__SetPageUptodate(new_page);\n\tset_page_huge_active(new_page);\n\n\tmmun_start = haddr;\n\tmmun_end = mmun_start + huge_page_size(h);\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Retake the page table lock to check for racing updates\n\t * before the page tables are altered\n\t */\n\tspin_lock(ptl);\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (likely(ptep && pte_same(huge_ptep_get(ptep), pte))) {\n\t\tClearPagePrivate(new_page);\n\n\t\t/* Break COW */\n\t\thuge_ptep_clear_flush(vma, haddr, ptep);\n\t\tmmu_notifier_invalidate_range(mm, mmun_start, mmun_end);\n\t\tset_huge_pte_at(mm, haddr, ptep,\n\t\t\t\tmake_huge_pte(vma, new_page, 1));\n\t\tpage_remove_rmap(old_page, true);\n\t\thugepage_add_new_anon_rmap(new_page, vma, haddr);\n\t\t/* Make the old page be freed below */\n\t\tnew_page = old_page;\n\t}\n\tspin_unlock(ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout_release_all:\n\trestore_reserve_on_error(h, vma, haddr, new_page);\n\tput_page(new_page);\nout_release_old:\n\tput_page(old_page);\n\n\tspin_lock(ptl); /* Caller expects lock to be held */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_write",
          "args": [
            "entry"
          ],
          "line": 4014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 4011
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "entry"
          ],
          "line": 4004
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pte_same(entry, huge_ptep_get(ptep))"
          ],
          "line": 3996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "entry",
            "huge_ptep_get(ptep)"
          ],
          "line": 3996
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "ptep"
          ],
          "line": 3996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_lock",
          "args": [
            "h",
            "mm",
            "ptep"
          ],
          "line": 3993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlbfs_pagecache_page",
          "args": [
            "h",
            "vma",
            "haddr"
          ],
          "line": 3989
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_pagecache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3665-3675",
          "snippet": "static struct page *hugetlbfs_pagecache_page(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\n\treturn find_lock_page(mapping, idx);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *hugetlbfs_pagecache_page(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\n\treturn find_lock_page(mapping, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_end_reservation",
          "args": [
            "h",
            "vma",
            "haddr"
          ],
          "line": 3986
        },
        "resolved": true,
        "details": {
          "function_name": "vma_end_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1934-1938",
          "snippet": "static void vma_end_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\t(void)__vma_reservation_common(h, vma, addr, VMA_END_RESV);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void vma_end_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\t(void)__vma_reservation_common(h, vma, addr, VMA_END_RESV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_needs_reservation",
          "args": [
            "h",
            "vma",
            "haddr"
          ],
          "line": 3981
        },
        "resolved": true,
        "details": {
          "function_name": "vma_needs_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1922-1926",
          "snippet": "static long vma_needs_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_NEEDS_RESV);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long vma_needs_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_NEEDS_RESV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_write",
          "args": [
            "entry"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "entry"
          ],
          "line": 3969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_no_page",
          "args": [
            "mm",
            "vma",
            "mapping",
            "idx",
            "address",
            "ptep",
            "flags"
          ],
          "line": 3956
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_no_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3720-3876",
          "snippet": "static vm_fault_t hugetlb_no_page(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma,\n\t\t\tstruct address_space *mapping, pgoff_t idx,\n\t\t\tunsigned long address, pte_t *ptep, unsigned int flags)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tvm_fault_t ret = VM_FAULT_SIGBUS;\n\tint anon_rmap = 0;\n\tunsigned long size;\n\tstruct page *page;\n\tpte_t new_pte;\n\tspinlock_t *ptl;\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\t/*\n\t * Currently, we are forced to kill the process in the event the\n\t * original mapper has unmapped pages from the child due to a failed\n\t * COW. Warn that such a situation has occurred as it may not be obvious\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_UNMAPPED)) {\n\t\tpr_warn_ratelimited(\"PID %d killed due to inadequate hugepage pool\\n\",\n\t\t\t   current->pid);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Use page lock to guard against racing truncation\n\t * before we get page_table_lock.\n\t */\nretry:\n\tpage = find_lock_page(mapping, idx);\n\tif (!page) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tif (idx >= size)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Check for page in userfault range\n\t\t */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tu32 hash;\n\t\t\tstruct vm_fault vmf = {\n\t\t\t\t.vma = vma,\n\t\t\t\t.address = haddr,\n\t\t\t\t.flags = flags,\n\t\t\t\t/*\n\t\t\t\t * Hard to debug if it ends up being\n\t\t\t\t * used by a callee that assumes\n\t\t\t\t * something about the other\n\t\t\t\t * uninitialized fields... same as in\n\t\t\t\t * memory.c\n\t\t\t\t */\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * hugetlb_fault_mutex must be dropped before\n\t\t\t * handling userfault.  Reacquire after handling\n\t\t\t * fault to make calling code simpler.\n\t\t\t */\n\t\t\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping,\n\t\t\t\t\t\t\tidx, haddr);\n\t\t\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tret = handle_userfault(&vmf, VM_UFFD_MISSING);\n\t\t\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = alloc_huge_page(vma, haddr, 0);\n\t\tif (IS_ERR(page)) {\n\t\t\tret = vmf_error(PTR_ERR(page));\n\t\t\tgoto out;\n\t\t}\n\t\tclear_huge_page(page, address, pages_per_huge_page(h));\n\t\t__SetPageUptodate(page);\n\t\tset_page_huge_active(page);\n\n\t\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\t\tint err = huge_add_to_page_cache(page, mapping, idx);\n\t\t\tif (err) {\n\t\t\t\tput_page(page);\n\t\t\t\tif (err == -EEXIST)\n\t\t\t\t\tgoto retry;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t\tif (unlikely(anon_vma_prepare(vma))) {\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\t\tgoto backout_unlocked;\n\t\t\t}\n\t\t\tanon_rmap = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If memory error occurs between mmap() and fault, some process\n\t\t * don't have hwpoisoned swap entry for errored virtual address.\n\t\t * So we need to block hugepage fault by PG_hwpoison bit check.\n\t\t */\n\t\tif (unlikely(PageHWPoison(page))) {\n\t\t\tret = VM_FAULT_HWPOISON |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t\t\tgoto backout_unlocked;\n\t\t}\n\t}\n\n\t/*\n\t * If we are going to COW a private mapping later, we examine the\n\t * pending reservations for this page now. This will ensure that\n\t * any allocations necessary to record that reservation occur outside\n\t * the spinlock.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\t\tif (vma_needs_reservation(h, vma, haddr) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto backout_unlocked;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, haddr);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tif (idx >= size)\n\t\tgoto backout;\n\n\tret = 0;\n\tif (!huge_pte_none(huge_ptep_get(ptep)))\n\t\tgoto backout;\n\n\tif (anon_rmap) {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, vma, haddr);\n\t} else\n\t\tpage_dup_rmap(page, true);\n\tnew_pte = make_huge_pte(vma, page, ((vma->vm_flags & VM_WRITE)\n\t\t\t\t&& (vma->vm_flags & VM_SHARED)));\n\tset_huge_pte_at(mm, haddr, ptep, new_pte);\n\n\thugetlb_count_add(pages_per_huge_page(h), mm);\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\t\t/* Optimization, do the COW without a second fault */\n\t\tret = hugetlb_cow(mm, vma, address, ptep, page, ptl);\n\t}\n\n\tspin_unlock(ptl);\n\tunlock_page(page);\nout:\n\treturn ret;\n\nbackout:\n\tspin_unlock(ptl);\nbackout_unlocked:\n\tunlock_page(page);\n\trestore_reserve_on_error(h, vma, haddr, page);\n\tput_page(page);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_UNMAPPED (1UL << 1)"
          ],
          "globals_used": [
            "struct mutex *hugetlb_fault_mutex_table"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_UNMAPPED (1UL << 1)\n\nstruct mutex *hugetlb_fault_mutex_table;\n\nstatic vm_fault_t hugetlb_no_page(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma,\n\t\t\tstruct address_space *mapping, pgoff_t idx,\n\t\t\tunsigned long address, pte_t *ptep, unsigned int flags)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tvm_fault_t ret = VM_FAULT_SIGBUS;\n\tint anon_rmap = 0;\n\tunsigned long size;\n\tstruct page *page;\n\tpte_t new_pte;\n\tspinlock_t *ptl;\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\t/*\n\t * Currently, we are forced to kill the process in the event the\n\t * original mapper has unmapped pages from the child due to a failed\n\t * COW. Warn that such a situation has occurred as it may not be obvious\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_UNMAPPED)) {\n\t\tpr_warn_ratelimited(\"PID %d killed due to inadequate hugepage pool\\n\",\n\t\t\t   current->pid);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Use page lock to guard against racing truncation\n\t * before we get page_table_lock.\n\t */\nretry:\n\tpage = find_lock_page(mapping, idx);\n\tif (!page) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tif (idx >= size)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Check for page in userfault range\n\t\t */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tu32 hash;\n\t\t\tstruct vm_fault vmf = {\n\t\t\t\t.vma = vma,\n\t\t\t\t.address = haddr,\n\t\t\t\t.flags = flags,\n\t\t\t\t/*\n\t\t\t\t * Hard to debug if it ends up being\n\t\t\t\t * used by a callee that assumes\n\t\t\t\t * something about the other\n\t\t\t\t * uninitialized fields... same as in\n\t\t\t\t * memory.c\n\t\t\t\t */\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * hugetlb_fault_mutex must be dropped before\n\t\t\t * handling userfault.  Reacquire after handling\n\t\t\t * fault to make calling code simpler.\n\t\t\t */\n\t\t\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping,\n\t\t\t\t\t\t\tidx, haddr);\n\t\t\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tret = handle_userfault(&vmf, VM_UFFD_MISSING);\n\t\t\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = alloc_huge_page(vma, haddr, 0);\n\t\tif (IS_ERR(page)) {\n\t\t\tret = vmf_error(PTR_ERR(page));\n\t\t\tgoto out;\n\t\t}\n\t\tclear_huge_page(page, address, pages_per_huge_page(h));\n\t\t__SetPageUptodate(page);\n\t\tset_page_huge_active(page);\n\n\t\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\t\tint err = huge_add_to_page_cache(page, mapping, idx);\n\t\t\tif (err) {\n\t\t\t\tput_page(page);\n\t\t\t\tif (err == -EEXIST)\n\t\t\t\t\tgoto retry;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t\tif (unlikely(anon_vma_prepare(vma))) {\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\t\tgoto backout_unlocked;\n\t\t\t}\n\t\t\tanon_rmap = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If memory error occurs between mmap() and fault, some process\n\t\t * don't have hwpoisoned swap entry for errored virtual address.\n\t\t * So we need to block hugepage fault by PG_hwpoison bit check.\n\t\t */\n\t\tif (unlikely(PageHWPoison(page))) {\n\t\t\tret = VM_FAULT_HWPOISON |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t\t\tgoto backout_unlocked;\n\t\t}\n\t}\n\n\t/*\n\t * If we are going to COW a private mapping later, we examine the\n\t * pending reservations for this page now. This will ensure that\n\t * any allocations necessary to record that reservation occur outside\n\t * the spinlock.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\t\tif (vma_needs_reservation(h, vma, haddr) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto backout_unlocked;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, haddr);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tif (idx >= size)\n\t\tgoto backout;\n\n\tret = 0;\n\tif (!huge_pte_none(huge_ptep_get(ptep)))\n\t\tgoto backout;\n\n\tif (anon_rmap) {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, vma, haddr);\n\t} else\n\t\tpage_dup_rmap(page, true);\n\tnew_pte = make_huge_pte(vma, page, ((vma->vm_flags & VM_WRITE)\n\t\t\t\t&& (vma->vm_flags & VM_SHARED)));\n\tset_huge_pte_at(mm, haddr, ptep, new_pte);\n\n\thugetlb_count_add(pages_per_huge_page(h), mm);\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\t\t/* Optimization, do the COW without a second fault */\n\t\tret = hugetlb_cow(mm, vma, address, ptep, page, ptl);\n\t}\n\n\tspin_unlock(ptl);\n\tunlock_page(page);\nout:\n\treturn ret;\n\nbackout:\n\tspin_unlock(ptl);\nbackout_unlocked:\n\tunlock_page(page);\n\trestore_reserve_on_error(h, vma, haddr, page);\n\tput_page(page);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "entry"
          ],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "ptep"
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hugetlb_fault_mutex_table[hash]"
          ],
          "line": 3952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_fault_mutex_hash",
          "args": [
            "h",
            "mm",
            "vma",
            "mapping",
            "idx",
            "haddr"
          ],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_fault_mutex_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3904-3910",
          "snippet": "u32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,\n\t\t\t    struct vm_area_struct *vma,\n\t\t\t    struct address_space *mapping,\n\t\t\t    pgoff_t idx, unsigned long address)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nu32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,\n\t\t\t    struct vm_area_struct *vma,\n\t\t\t    struct address_space *mapping,\n\t\t\t    pgoff_t idx, unsigned long address)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_hugecache_offset",
          "args": [
            "h",
            "vma",
            "haddr"
          ],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "vma_hugecache_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "620-625",
          "snippet": "static pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_alloc",
          "args": [
            "mm",
            "haddr",
            "huge_page_size(h)"
          ],
          "line": 3938
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4744-4771",
          "snippet": "pte_t *huge_pte_alloc(struct mm_struct *mm,\n\t\t\tunsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpte_t *pte = NULL;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (pud) {\n\t\tif (sz == PUD_SIZE) {\n\t\t\tpte = (pte_t *)pud;\n\t\t} else {\n\t\t\tBUG_ON(sz != PMD_SIZE);\n\t\t\tif (want_pmd_share() && pud_none(*pud))\n\t\t\t\tpte = huge_pmd_share(mm, addr, pud);\n\t\t\telse\n\t\t\t\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\t\t}\n\t}\n\tBUG_ON(pte && pte_present(*pte) && !pte_huge(*pte));\n\n\treturn pte;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_alloc(struct mm_struct *mm,\n\t\t\tunsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpte_t *pte = NULL;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (pud) {\n\t\tif (sz == PUD_SIZE) {\n\t\t\tpte = (pte_t *)pud;\n\t\t} else {\n\t\t\tBUG_ON(sz != PMD_SIZE);\n\t\t\tif (want_pmd_share() && pud_none(*pud))\n\t\t\t\tpte = huge_pmd_share(mm, addr, pud);\n\t\t\telse\n\t\t\t\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\t\t}\n\t}\n\tBUG_ON(pte && pte_present(*pte) && !pte_huge(*pte));\n\n\treturn pte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_FAULT_SET_HINDEX",
          "args": [
            "hstate_index(h)"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_index",
          "args": [
            "h"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_hugetlb_entry_hwpoisoned(entry)"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugetlb_entry_hwpoisoned",
          "args": [
            "entry"
          ],
          "line": 3934
        },
        "resolved": true,
        "details": {
          "function_name": "is_hugetlb_entry_hwpoisoned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3220-3231",
          "snippet": "static int is_hugetlb_entry_hwpoisoned(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn 0;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_hwpoison_entry(swp))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_hugetlb_entry_hwpoisoned(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn 0;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_hwpoison_entry(swp))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "migration_entry_wait_huge",
          "args": [
            "vma",
            "mm",
            "ptep"
          ],
          "line": 3932
        },
        "resolved": true,
        "details": {
          "function_name": "migration_entry_wait_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "353-358",
          "snippet": "void migration_entry_wait_huge(struct vm_area_struct *vma,\n\t\tstruct mm_struct *mm, pte_t *pte)\n{\n\tspinlock_t *ptl = huge_pte_lockptr(hstate_vma(vma), mm, pte);\n\t__migration_entry_wait(mm, pte, ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migration_entry_wait_huge(struct vm_area_struct *vma,\n\t\tstruct mm_struct *mm, pte_t *pte)\n{\n\tspinlock_t *ptl = huge_pte_lockptr(hstate_vma(vma), mm, pte);\n\t__migration_entry_wait(mm, pte, ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_hugetlb_entry_migration(entry)"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugetlb_entry_migration",
          "args": [
            "entry"
          ],
          "line": 3931
        },
        "resolved": true,
        "details": {
          "function_name": "is_hugetlb_entry_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3207-3218",
          "snippet": "bool is_hugetlb_entry_migration(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn false;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_migration_entry(swp))\n\t\treturn true;\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nbool is_hugetlb_entry_migration(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn false;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_migration_entry(swp))\n\t\treturn true;\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "ptep"
          ],
          "line": 3930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_offset",
          "args": [
            "mm",
            "haddr",
            "huge_page_size(h)"
          ],
          "line": 3928
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4782-4812",
          "snippet": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct mutex *hugetlb_fault_mutex_table;\n\nvm_fault_t hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tunsigned long address, unsigned int flags)\n{\n\tpte_t *ptep, entry;\n\tspinlock_t *ptl;\n\tvm_fault_t ret;\n\tu32 hash;\n\tpgoff_t idx;\n\tstruct page *page = NULL;\n\tstruct page *pagecache_page = NULL;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct address_space *mapping;\n\tint need_wait_lock = 0;\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (ptep) {\n\t\tentry = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_migration(entry))) {\n\t\t\tmigration_entry_wait_huge(vma, mm, ptep);\n\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))\n\t\t\treturn VM_FAULT_HWPOISON_LARGE |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t} else {\n\t\tptep = huge_pte_alloc(mm, haddr, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\treturn VM_FAULT_OOM;\n\t}\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, haddr);\n\n\t/*\n\t * Serialize hugepage allocation and instantiation, so that we don't\n\t * get spurious allocation failures if two CPUs race to instantiate\n\t * the same page in the page cache.\n\t */\n\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping, idx, haddr);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\n\tentry = huge_ptep_get(ptep);\n\tif (huge_pte_none(entry)) {\n\t\tret = hugetlb_no_page(mm, vma, mapping, idx, address, ptep, flags);\n\t\tgoto out_mutex;\n\t}\n\n\tret = 0;\n\n\t/*\n\t * entry could be a migration/hwpoison entry at this point, so this\n\t * check prevents the kernel from going below assuming that we have\n\t * a active hugepage in pagecache. This goto expects the 2nd page fault,\n\t * and is_hugetlb_entry_(migration|hwpoisoned) check will properly\n\t * handle it.\n\t */\n\tif (!pte_present(entry))\n\t\tgoto out_mutex;\n\n\t/*\n\t * If we are going to COW the mapping later, we examine the pending\n\t * reservations for this page now. This will ensure that any\n\t * allocations necessary to record that reservation occur outside the\n\t * spinlock. For private mappings, we also lookup the pagecache\n\t * page now as it is used to determine if a reservation has been\n\t * consumed.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !huge_pte_write(entry)) {\n\t\tif (vma_needs_reservation(h, vma, haddr) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out_mutex;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, haddr);\n\n\t\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\t\tpagecache_page = hugetlbfs_pagecache_page(h,\n\t\t\t\t\t\t\t\tvma, haddr);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\n\t/* Check for a racing update before calling hugetlb_cow */\n\tif (unlikely(!pte_same(entry, huge_ptep_get(ptep))))\n\t\tgoto out_ptl;\n\n\t/*\n\t * hugetlb_cow() requires page locks of pte_page(entry) and\n\t * pagecache_page, so here we need take the former one\n\t * when page != pagecache_page or !pagecache_page.\n\t */\n\tpage = pte_page(entry);\n\tif (page != pagecache_page)\n\t\tif (!trylock_page(page)) {\n\t\t\tneed_wait_lock = 1;\n\t\t\tgoto out_ptl;\n\t\t}\n\n\tget_page(page);\n\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!huge_pte_write(entry)) {\n\t\t\tret = hugetlb_cow(mm, vma, address, ptep,\n\t\t\t\t\t  pagecache_page, ptl);\n\t\t\tgoto out_put_page;\n\t\t}\n\t\tentry = huge_pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (huge_ptep_set_access_flags(vma, haddr, ptep, entry,\n\t\t\t\t\t\tflags & FAULT_FLAG_WRITE))\n\t\tupdate_mmu_cache(vma, haddr, ptep);\nout_put_page:\n\tif (page != pagecache_page)\n\t\tunlock_page(page);\n\tput_page(page);\nout_ptl:\n\tspin_unlock(ptl);\n\n\tif (pagecache_page) {\n\t\tunlock_page(pagecache_page);\n\t\tput_page(pagecache_page);\n\t}\nout_mutex:\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t/*\n\t * Generally it's safe to hold refcount during waiting page lock. But\n\t * here we just wait to defer the next page fault to avoid busy loop and\n\t * the page is not used after unlocked before returning from the current\n\t * page fault. So we are safe from accessing freed page, even if we wait\n\t * here without taking refcount.\n\t */\n\tif (need_wait_lock)\n\t\twait_on_page_locked(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "hugetlb_fault_mutex_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3904-3910",
    "snippet": "u32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,\n\t\t\t    struct vm_area_struct *vma,\n\t\t\t    struct address_space *mapping,\n\t\t\t    pgoff_t idx, unsigned long address)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nu32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,\n\t\t\t    struct vm_area_struct *vma,\n\t\t\t    struct address_space *mapping,\n\t\t\t    pgoff_t idx, unsigned long address)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "hugetlb_fault_mutex_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3879-3898",
    "snippet": "u32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,\n\t\t\t    struct vm_area_struct *vma,\n\t\t\t    struct address_space *mapping,\n\t\t\t    pgoff_t idx, unsigned long address)\n{\n\tunsigned long key[2];\n\tu32 hash;\n\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tkey[0] = (unsigned long) mapping;\n\t\tkey[1] = idx;\n\t} else {\n\t\tkey[0] = (unsigned long) mm;\n\t\tkey[1] = address >> huge_page_shift(h);\n\t}\n\n\thash = jhash2((u32 *)&key, sizeof(key)/sizeof(u32), 0);\n\n\treturn hash & (num_fault_mutexes - 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int num_fault_mutexes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash2",
          "args": [
            "(u32 *)&key",
            "sizeof(key)/sizeof(u32)",
            "0"
          ],
          "line": 3895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int num_fault_mutexes;\n\nu32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,\n\t\t\t    struct vm_area_struct *vma,\n\t\t\t    struct address_space *mapping,\n\t\t\t    pgoff_t idx, unsigned long address)\n{\n\tunsigned long key[2];\n\tu32 hash;\n\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tkey[0] = (unsigned long) mapping;\n\t\tkey[1] = idx;\n\t} else {\n\t\tkey[0] = (unsigned long) mm;\n\t\tkey[1] = address >> huge_page_shift(h);\n\t}\n\n\thash = jhash2((u32 *)&key, sizeof(key)/sizeof(u32), 0);\n\n\treturn hash & (num_fault_mutexes - 1);\n}"
  },
  {
    "function_name": "hugetlb_no_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3720-3876",
    "snippet": "static vm_fault_t hugetlb_no_page(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma,\n\t\t\tstruct address_space *mapping, pgoff_t idx,\n\t\t\tunsigned long address, pte_t *ptep, unsigned int flags)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tvm_fault_t ret = VM_FAULT_SIGBUS;\n\tint anon_rmap = 0;\n\tunsigned long size;\n\tstruct page *page;\n\tpte_t new_pte;\n\tspinlock_t *ptl;\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\t/*\n\t * Currently, we are forced to kill the process in the event the\n\t * original mapper has unmapped pages from the child due to a failed\n\t * COW. Warn that such a situation has occurred as it may not be obvious\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_UNMAPPED)) {\n\t\tpr_warn_ratelimited(\"PID %d killed due to inadequate hugepage pool\\n\",\n\t\t\t   current->pid);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Use page lock to guard against racing truncation\n\t * before we get page_table_lock.\n\t */\nretry:\n\tpage = find_lock_page(mapping, idx);\n\tif (!page) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tif (idx >= size)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Check for page in userfault range\n\t\t */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tu32 hash;\n\t\t\tstruct vm_fault vmf = {\n\t\t\t\t.vma = vma,\n\t\t\t\t.address = haddr,\n\t\t\t\t.flags = flags,\n\t\t\t\t/*\n\t\t\t\t * Hard to debug if it ends up being\n\t\t\t\t * used by a callee that assumes\n\t\t\t\t * something about the other\n\t\t\t\t * uninitialized fields... same as in\n\t\t\t\t * memory.c\n\t\t\t\t */\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * hugetlb_fault_mutex must be dropped before\n\t\t\t * handling userfault.  Reacquire after handling\n\t\t\t * fault to make calling code simpler.\n\t\t\t */\n\t\t\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping,\n\t\t\t\t\t\t\tidx, haddr);\n\t\t\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tret = handle_userfault(&vmf, VM_UFFD_MISSING);\n\t\t\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = alloc_huge_page(vma, haddr, 0);\n\t\tif (IS_ERR(page)) {\n\t\t\tret = vmf_error(PTR_ERR(page));\n\t\t\tgoto out;\n\t\t}\n\t\tclear_huge_page(page, address, pages_per_huge_page(h));\n\t\t__SetPageUptodate(page);\n\t\tset_page_huge_active(page);\n\n\t\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\t\tint err = huge_add_to_page_cache(page, mapping, idx);\n\t\t\tif (err) {\n\t\t\t\tput_page(page);\n\t\t\t\tif (err == -EEXIST)\n\t\t\t\t\tgoto retry;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t\tif (unlikely(anon_vma_prepare(vma))) {\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\t\tgoto backout_unlocked;\n\t\t\t}\n\t\t\tanon_rmap = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If memory error occurs between mmap() and fault, some process\n\t\t * don't have hwpoisoned swap entry for errored virtual address.\n\t\t * So we need to block hugepage fault by PG_hwpoison bit check.\n\t\t */\n\t\tif (unlikely(PageHWPoison(page))) {\n\t\t\tret = VM_FAULT_HWPOISON |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t\t\tgoto backout_unlocked;\n\t\t}\n\t}\n\n\t/*\n\t * If we are going to COW a private mapping later, we examine the\n\t * pending reservations for this page now. This will ensure that\n\t * any allocations necessary to record that reservation occur outside\n\t * the spinlock.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\t\tif (vma_needs_reservation(h, vma, haddr) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto backout_unlocked;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, haddr);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tif (idx >= size)\n\t\tgoto backout;\n\n\tret = 0;\n\tif (!huge_pte_none(huge_ptep_get(ptep)))\n\t\tgoto backout;\n\n\tif (anon_rmap) {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, vma, haddr);\n\t} else\n\t\tpage_dup_rmap(page, true);\n\tnew_pte = make_huge_pte(vma, page, ((vma->vm_flags & VM_WRITE)\n\t\t\t\t&& (vma->vm_flags & VM_SHARED)));\n\tset_huge_pte_at(mm, haddr, ptep, new_pte);\n\n\thugetlb_count_add(pages_per_huge_page(h), mm);\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\t\t/* Optimization, do the COW without a second fault */\n\t\tret = hugetlb_cow(mm, vma, address, ptep, page, ptl);\n\t}\n\n\tspin_unlock(ptl);\n\tunlock_page(page);\nout:\n\treturn ret;\n\nbackout:\n\tspin_unlock(ptl);\nbackout_unlocked:\n\tunlock_page(page);\n\trestore_reserve_on_error(h, vma, haddr, page);\n\tput_page(page);\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define HPAGE_RESV_UNMAPPED (1UL << 1)"
    ],
    "globals_used": [
      "struct mutex *hugetlb_fault_mutex_table"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 3874
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_reserve_on_error",
          "args": [
            "h",
            "vma",
            "haddr",
            "page"
          ],
          "line": 3873
        },
        "resolved": true,
        "details": {
          "function_name": "restore_reserve_on_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1957-1988",
          "snippet": "static void restore_reserve_on_error(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address,\n\t\t\tstruct page *page)\n{\n\tif (unlikely(PagePrivate(page))) {\n\t\tlong rc = vma_needs_reservation(h, vma, address);\n\n\t\tif (unlikely(rc < 0)) {\n\t\t\t/*\n\t\t\t * Rare out of memory condition in reserve map\n\t\t\t * manipulation.  Clear PagePrivate so that\n\t\t\t * global reserve count will not be incremented\n\t\t\t * by free_huge_page.  This will make it appear\n\t\t\t * as though the reservation for this page was\n\t\t\t * consumed.  This may prevent the task from\n\t\t\t * faulting in the page at a later time.  This\n\t\t\t * is better than inconsistent global huge page\n\t\t\t * accounting of reserve counts.\n\t\t\t */\n\t\t\tClearPagePrivate(page);\n\t\t} else if (rc) {\n\t\t\trc = vma_add_reservation(h, vma, address);\n\t\t\tif (unlikely(rc < 0))\n\t\t\t\t/*\n\t\t\t\t * See above comment about rare out of\n\t\t\t\t * memory condition.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t} else\n\t\t\tvma_end_reservation(h, vma, address);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void restore_reserve_on_error(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address,\n\t\t\tstruct page *page)\n{\n\tif (unlikely(PagePrivate(page))) {\n\t\tlong rc = vma_needs_reservation(h, vma, address);\n\n\t\tif (unlikely(rc < 0)) {\n\t\t\t/*\n\t\t\t * Rare out of memory condition in reserve map\n\t\t\t * manipulation.  Clear PagePrivate so that\n\t\t\t * global reserve count will not be incremented\n\t\t\t * by free_huge_page.  This will make it appear\n\t\t\t * as though the reservation for this page was\n\t\t\t * consumed.  This may prevent the task from\n\t\t\t * faulting in the page at a later time.  This\n\t\t\t * is better than inconsistent global huge page\n\t\t\t * accounting of reserve counts.\n\t\t\t */\n\t\t\tClearPagePrivate(page);\n\t\t} else if (rc) {\n\t\t\trc = vma_add_reservation(h, vma, address);\n\t\t\tif (unlikely(rc < 0))\n\t\t\t\t/*\n\t\t\t\t * See above comment about rare out of\n\t\t\t\t * memory condition.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t} else\n\t\t\tvma_end_reservation(h, vma, address);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3872
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 3864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cow",
          "args": [
            "mm",
            "vma",
            "address",
            "ptep",
            "page",
            "ptl"
          ],
          "line": 3861
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3539-3662",
          "snippet": "static vm_fault_t hugetlb_cow(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t       unsigned long address, pte_t *ptep,\n\t\t       struct page *pagecache_page, spinlock_t *ptl)\n{\n\tpte_t pte;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *old_page, *new_page;\n\tint outside_reserve = 0;\n\tvm_fault_t ret = 0;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tpte = huge_ptep_get(ptep);\n\told_page = pte_page(pte);\n\nretry_avoidcopy:\n\t/* If no-one else is actually using this page, avoid the copy\n\t * and just make the page writable */\n\tif (page_mapcount(old_page) == 1 && PageAnon(old_page)) {\n\t\tpage_move_anon_rmap(old_page, vma);\n\t\tset_huge_ptep_writable(vma, haddr, ptep);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the process that created a MAP_PRIVATE mapping is about to\n\t * perform a COW due to a shared page count, attempt to satisfy\n\t * the allocation without using the existing reserves. The pagecache\n\t * page is used to determine if the reserve at this address was\n\t * consumed or not. If reserves were used, a partial faulted mapping\n\t * at the time of fork() could consume its reserves on COW instead\n\t * of the full address range.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER) &&\n\t\t\told_page != pagecache_page)\n\t\toutside_reserve = 1;\n\n\tget_page(old_page);\n\n\t/*\n\t * Drop page table lock as buddy allocator may be called. It will\n\t * be acquired again before returning to the caller, as expected.\n\t */\n\tspin_unlock(ptl);\n\tnew_page = alloc_huge_page(vma, haddr, outside_reserve);\n\n\tif (IS_ERR(new_page)) {\n\t\t/*\n\t\t * If a process owning a MAP_PRIVATE mapping fails to COW,\n\t\t * it is due to references held by a child and an insufficient\n\t\t * huge page pool. To guarantee the original mappers\n\t\t * reliability, unmap the page from child processes. The child\n\t\t * may get SIGKILLed if it later faults.\n\t\t */\n\t\tif (outside_reserve) {\n\t\t\tput_page(old_page);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tunmap_ref_private(mm, vma, old_page, haddr);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tspin_lock(ptl);\n\t\t\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\t\t\tif (likely(ptep &&\n\t\t\t\t   pte_same(huge_ptep_get(ptep), pte)))\n\t\t\t\tgoto retry_avoidcopy;\n\t\t\t/*\n\t\t\t * race occurs while re-acquiring page table\n\t\t\t * lock, and our job is done.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = vmf_error(PTR_ERR(new_page));\n\t\tgoto out_release_old;\n\t}\n\n\t/*\n\t * When the original hugepage is shared one, it does not have\n\t * anon_vma prepared.\n\t */\n\tif (unlikely(anon_vma_prepare(vma))) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_release_all;\n\t}\n\n\tcopy_user_huge_page(new_page, old_page, address, vma,\n\t\t\t    pages_per_huge_page(h));\n\t__SetPageUptodate(new_page);\n\tset_page_huge_active(new_page);\n\n\tmmun_start = haddr;\n\tmmun_end = mmun_start + huge_page_size(h);\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Retake the page table lock to check for racing updates\n\t * before the page tables are altered\n\t */\n\tspin_lock(ptl);\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (likely(ptep && pte_same(huge_ptep_get(ptep), pte))) {\n\t\tClearPagePrivate(new_page);\n\n\t\t/* Break COW */\n\t\thuge_ptep_clear_flush(vma, haddr, ptep);\n\t\tmmu_notifier_invalidate_range(mm, mmun_start, mmun_end);\n\t\tset_huge_pte_at(mm, haddr, ptep,\n\t\t\t\tmake_huge_pte(vma, new_page, 1));\n\t\tpage_remove_rmap(old_page, true);\n\t\thugepage_add_new_anon_rmap(new_page, vma, haddr);\n\t\t/* Make the old page be freed below */\n\t\tnew_page = old_page;\n\t}\n\tspin_unlock(ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout_release_all:\n\trestore_reserve_on_error(h, vma, haddr, new_page);\n\tput_page(new_page);\nout_release_old:\n\tput_page(old_page);\n\n\tspin_lock(ptl); /* Caller expects lock to be held */\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_OWNER    (1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic vm_fault_t hugetlb_cow(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t       unsigned long address, pte_t *ptep,\n\t\t       struct page *pagecache_page, spinlock_t *ptl)\n{\n\tpte_t pte;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *old_page, *new_page;\n\tint outside_reserve = 0;\n\tvm_fault_t ret = 0;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tpte = huge_ptep_get(ptep);\n\told_page = pte_page(pte);\n\nretry_avoidcopy:\n\t/* If no-one else is actually using this page, avoid the copy\n\t * and just make the page writable */\n\tif (page_mapcount(old_page) == 1 && PageAnon(old_page)) {\n\t\tpage_move_anon_rmap(old_page, vma);\n\t\tset_huge_ptep_writable(vma, haddr, ptep);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the process that created a MAP_PRIVATE mapping is about to\n\t * perform a COW due to a shared page count, attempt to satisfy\n\t * the allocation without using the existing reserves. The pagecache\n\t * page is used to determine if the reserve at this address was\n\t * consumed or not. If reserves were used, a partial faulted mapping\n\t * at the time of fork() could consume its reserves on COW instead\n\t * of the full address range.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER) &&\n\t\t\told_page != pagecache_page)\n\t\toutside_reserve = 1;\n\n\tget_page(old_page);\n\n\t/*\n\t * Drop page table lock as buddy allocator may be called. It will\n\t * be acquired again before returning to the caller, as expected.\n\t */\n\tspin_unlock(ptl);\n\tnew_page = alloc_huge_page(vma, haddr, outside_reserve);\n\n\tif (IS_ERR(new_page)) {\n\t\t/*\n\t\t * If a process owning a MAP_PRIVATE mapping fails to COW,\n\t\t * it is due to references held by a child and an insufficient\n\t\t * huge page pool. To guarantee the original mappers\n\t\t * reliability, unmap the page from child processes. The child\n\t\t * may get SIGKILLed if it later faults.\n\t\t */\n\t\tif (outside_reserve) {\n\t\t\tput_page(old_page);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tunmap_ref_private(mm, vma, old_page, haddr);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tspin_lock(ptl);\n\t\t\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\t\t\tif (likely(ptep &&\n\t\t\t\t   pte_same(huge_ptep_get(ptep), pte)))\n\t\t\t\tgoto retry_avoidcopy;\n\t\t\t/*\n\t\t\t * race occurs while re-acquiring page table\n\t\t\t * lock, and our job is done.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = vmf_error(PTR_ERR(new_page));\n\t\tgoto out_release_old;\n\t}\n\n\t/*\n\t * When the original hugepage is shared one, it does not have\n\t * anon_vma prepared.\n\t */\n\tif (unlikely(anon_vma_prepare(vma))) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_release_all;\n\t}\n\n\tcopy_user_huge_page(new_page, old_page, address, vma,\n\t\t\t    pages_per_huge_page(h));\n\t__SetPageUptodate(new_page);\n\tset_page_huge_active(new_page);\n\n\tmmun_start = haddr;\n\tmmun_end = mmun_start + huge_page_size(h);\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Retake the page table lock to check for racing updates\n\t * before the page tables are altered\n\t */\n\tspin_lock(ptl);\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (likely(ptep && pte_same(huge_ptep_get(ptep), pte))) {\n\t\tClearPagePrivate(new_page);\n\n\t\t/* Break COW */\n\t\thuge_ptep_clear_flush(vma, haddr, ptep);\n\t\tmmu_notifier_invalidate_range(mm, mmun_start, mmun_end);\n\t\tset_huge_pte_at(mm, haddr, ptep,\n\t\t\t\tmake_huge_pte(vma, new_page, 1));\n\t\tpage_remove_rmap(old_page, true);\n\t\thugepage_add_new_anon_rmap(new_page, vma, haddr);\n\t\t/* Make the old page be freed below */\n\t\tnew_page = old_page;\n\t}\n\tspin_unlock(ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout_release_all:\n\trestore_reserve_on_error(h, vma, haddr, new_page);\n\tput_page(new_page);\nout_release_old:\n\tput_page(old_page);\n\n\tspin_lock(ptl); /* Caller expects lock to be held */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_count_add",
          "args": [
            "pages_per_huge_page(h)",
            "mm"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_huge_pte_at",
          "args": [
            "mm",
            "haddr",
            "ptep",
            "new_pte"
          ],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_huge_pte",
          "args": [
            "vma",
            "page",
            "((vma->vm_flags & VM_WRITE)\n\t\t\t\t&& (vma->vm_flags & VM_SHARED))"
          ],
          "line": 3854
        },
        "resolved": true,
        "details": {
          "function_name": "make_huge_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3178-3195",
          "snippet": "static pte_t make_huge_pte(struct vm_area_struct *vma, struct page *page,\n\t\t\t\tint writable)\n{\n\tpte_t entry;\n\n\tif (writable) {\n\t\tentry = huge_pte_mkwrite(huge_pte_mkdirty(mk_huge_pte(page,\n\t\t\t\t\t vma->vm_page_prot)));\n\t} else {\n\t\tentry = huge_pte_wrprotect(mk_huge_pte(page,\n\t\t\t\t\t   vma->vm_page_prot));\n\t}\n\tentry = pte_mkyoung(entry);\n\tentry = pte_mkhuge(entry);\n\tentry = arch_make_huge_pte(entry, vma, page, writable);\n\n\treturn entry;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pte_t make_huge_pte(struct vm_area_struct *vma, struct page *page,\n\t\t\t\tint writable)\n{\n\tpte_t entry;\n\n\tif (writable) {\n\t\tentry = huge_pte_mkwrite(huge_pte_mkdirty(mk_huge_pte(page,\n\t\t\t\t\t vma->vm_page_prot)));\n\t} else {\n\t\tentry = huge_pte_wrprotect(mk_huge_pte(page,\n\t\t\t\t\t   vma->vm_page_prot));\n\t}\n\tentry = pte_mkyoung(entry);\n\tentry = pte_mkhuge(entry);\n\tentry = arch_make_huge_pte(entry, vma, page, writable);\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_dup_rmap",
          "args": [
            "page",
            "true"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_add_new_anon_rmap",
          "args": [
            "page",
            "vma",
            "haddr"
          ],
          "line": 3851
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1955-1961",
          "snippet": "void hugepage_add_new_anon_rmap(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tBUG_ON(address < vma->vm_start || address >= vma->vm_end);\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\t__hugepage_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid hugepage_add_new_anon_rmap(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tBUG_ON(address < vma->vm_start || address >= vma->vm_end);\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\t__hugepage_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "huge_ptep_get(ptep)"
          ],
          "line": 3846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "ptep"
          ],
          "line": 3846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_lock",
          "args": [
            "h",
            "mm",
            "ptep"
          ],
          "line": 3840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_end_reservation",
          "args": [
            "h",
            "vma",
            "haddr"
          ],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "vma_end_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1934-1938",
          "snippet": "static void vma_end_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\t(void)__vma_reservation_common(h, vma, addr, VMA_END_RESV);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void vma_end_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\t(void)__vma_reservation_common(h, vma, addr, VMA_END_RESV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_needs_reservation",
          "args": [
            "h",
            "vma",
            "haddr"
          ],
          "line": 3832
        },
        "resolved": true,
        "details": {
          "function_name": "vma_needs_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1922-1926",
          "snippet": "static long vma_needs_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_NEEDS_RESV);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long vma_needs_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_NEEDS_RESV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_FAULT_SET_HINDEX",
          "args": [
            "hstate_index(h)"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_index",
          "args": [
            "h"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageHWPoison(page)"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "anon_vma_prepare(vma)"
          ],
          "line": 3806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_prepare",
          "args": [
            "vma"
          ],
          "line": 3806
        },
        "resolved": true,
        "details": {
          "function_name": "__anon_vma_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "175-221",
          "snippet": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_add_to_page_cache",
          "args": [
            "page",
            "mapping",
            "idx"
          ],
          "line": 3797
        },
        "resolved": true,
        "details": {
          "function_name": "huge_add_to_page_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3697-3718",
          "snippet": "int huge_add_to_page_cache(struct page *page, struct address_space *mapping,\n\t\t\t   pgoff_t idx)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct hstate *h = hstate_inode(inode);\n\tint err = add_to_page_cache(page, mapping, idx, GFP_KERNEL);\n\n\tif (err)\n\t\treturn err;\n\tClearPagePrivate(page);\n\n\t/*\n\t * set page dirty so that it will not be removed from cache/file\n\t * by non-hugetlbfs specific code paths.\n\t */\n\tset_page_dirty(page);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks += blocks_per_huge_page(h);\n\tspin_unlock(&inode->i_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint huge_add_to_page_cache(struct page *page, struct address_space *mapping,\n\t\t\t   pgoff_t idx)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct hstate *h = hstate_inode(inode);\n\tint err = add_to_page_cache(page, mapping, idx, GFP_KERNEL);\n\n\tif (err)\n\t\treturn err;\n\tClearPagePrivate(page);\n\n\t/*\n\t * set page dirty so that it will not be removed from cache/file\n\t * by non-hugetlbfs specific code paths.\n\t */\n\tset_page_dirty(page);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks += blocks_per_huge_page(h);\n\tspin_unlock(&inode->i_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_huge_active",
          "args": [
            "page"
          ],
          "line": 3794
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_huge_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1205-1209",
          "snippet": "static void set_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tSetPagePrivate(&page[1]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tSetPagePrivate(&page[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_huge_page",
          "args": [
            "page",
            "address",
            "pages_per_huge_page(h)"
          ],
          "line": 3792
        },
        "resolved": true,
        "details": {
          "function_name": "clear_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4440-4452",
          "snippet": "void clear_huge_page(struct page *page,\n\t\t     unsigned long addr_hint, unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tclear_gigantic_page(page, addr, pages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, clear_subpage, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid clear_huge_page(struct page *page,\n\t\t     unsigned long addr_hint, unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tclear_gigantic_page(page, addr, pages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, clear_subpage, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmf_error",
          "args": [
            "PTR_ERR(page)"
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 3788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_huge_page",
          "args": [
            "vma",
            "haddr",
            "0"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1990-2091",
          "snippet": "struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong map_chg, map_commit;\n\tlong gbl_chg;\n\tint ret, idx;\n\tstruct hugetlb_cgroup *h_cg;\n\n\tidx = hstate_index(h);\n\t/*\n\t * Examine the region/reserve map to determine if the process\n\t * has a reservation for the page to be allocated.  A return\n\t * code of zero indicates a reservation exists (no change).\n\t */\n\tmap_chg = gbl_chg = vma_needs_reservation(h, vma, addr);\n\tif (map_chg < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Processes that did not create the mapping will have no\n\t * reserves as indicated by the region/reserve map. Check\n\t * that the allocation will not exceed the subpool limit.\n\t * Allocations for MAP_NORESERVE mappings also need to be\n\t * checked against any subpool limit.\n\t */\n\tif (map_chg || avoid_reserve) {\n\t\tgbl_chg = hugepage_subpool_get_pages(spool, 1);\n\t\tif (gbl_chg < 0) {\n\t\t\tvma_end_reservation(h, vma, addr);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\n\t\t/*\n\t\t * Even though there was no reservation in the region/reserve\n\t\t * map, there could be reservations associated with the\n\t\t * subpool that can be used.  This would be indicated if the\n\t\t * return value of hugepage_subpool_get_pages() is zero.\n\t\t * However, if avoid_reserve is specified we still avoid even\n\t\t * the subpool reservations.\n\t\t */\n\t\tif (avoid_reserve)\n\t\t\tgbl_chg = 1;\n\t}\n\n\tret = hugetlb_cgroup_charge_cgroup(idx, pages_per_huge_page(h), &h_cg);\n\tif (ret)\n\t\tgoto out_subpool_put;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * glb_chg is passed to indicate whether or not a page must be taken\n\t * from the global free pool (global change).  gbl_chg == 0 indicates\n\t * a reservation exists for the allocation.\n\t */\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve, gbl_chg);\n\tif (!page) {\n\t\tspin_unlock(&hugetlb_lock);\n\t\tpage = alloc_buddy_huge_page_with_mpol(h, vma, addr);\n\t\tif (!page)\n\t\t\tgoto out_uncharge_cgroup;\n\t\tif (!avoid_reserve && vma_has_reserves(vma, gbl_chg)) {\n\t\t\tSetPagePrivate(page);\n\t\t\th->resv_huge_pages--;\n\t\t}\n\t\tspin_lock(&hugetlb_lock);\n\t\tlist_move(&page->lru, &h->hugepage_activelist);\n\t\t/* Fall through */\n\t}\n\thugetlb_cgroup_commit_charge(idx, pages_per_huge_page(h), h_cg, page);\n\tspin_unlock(&hugetlb_lock);\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tmap_commit = vma_commit_reservation(h, vma, addr);\n\tif (unlikely(map_chg > map_commit)) {\n\t\t/*\n\t\t * The page was added to the reservation map between\n\t\t * vma_needs_reservation and vma_commit_reservation.\n\t\t * This indicates a race with hugetlb_reserve_pages.\n\t\t * Adjust for the subpool count incremented above AND\n\t\t * in hugetlb_reserve_pages for the same page.  Also,\n\t\t * the reservation count added in hugetlb_reserve_pages\n\t\t * no longer applies.\n\t\t */\n\t\tlong rsv_adjust;\n\n\t\trsv_adjust = hugepage_subpool_put_pages(spool, 1);\n\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t}\n\treturn page;\n\nout_uncharge_cgroup:\n\thugetlb_cgroup_uncharge_cgroup(idx, pages_per_huge_page(h), h_cg);\nout_subpool_put:\n\tif (map_chg || avoid_reserve)\n\t\thugepage_subpool_put_pages(spool, 1);\n\tvma_end_reservation(h, vma, addr);\n\treturn ERR_PTR(-ENOSPC);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong map_chg, map_commit;\n\tlong gbl_chg;\n\tint ret, idx;\n\tstruct hugetlb_cgroup *h_cg;\n\n\tidx = hstate_index(h);\n\t/*\n\t * Examine the region/reserve map to determine if the process\n\t * has a reservation for the page to be allocated.  A return\n\t * code of zero indicates a reservation exists (no change).\n\t */\n\tmap_chg = gbl_chg = vma_needs_reservation(h, vma, addr);\n\tif (map_chg < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Processes that did not create the mapping will have no\n\t * reserves as indicated by the region/reserve map. Check\n\t * that the allocation will not exceed the subpool limit.\n\t * Allocations for MAP_NORESERVE mappings also need to be\n\t * checked against any subpool limit.\n\t */\n\tif (map_chg || avoid_reserve) {\n\t\tgbl_chg = hugepage_subpool_get_pages(spool, 1);\n\t\tif (gbl_chg < 0) {\n\t\t\tvma_end_reservation(h, vma, addr);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\n\t\t/*\n\t\t * Even though there was no reservation in the region/reserve\n\t\t * map, there could be reservations associated with the\n\t\t * subpool that can be used.  This would be indicated if the\n\t\t * return value of hugepage_subpool_get_pages() is zero.\n\t\t * However, if avoid_reserve is specified we still avoid even\n\t\t * the subpool reservations.\n\t\t */\n\t\tif (avoid_reserve)\n\t\t\tgbl_chg = 1;\n\t}\n\n\tret = hugetlb_cgroup_charge_cgroup(idx, pages_per_huge_page(h), &h_cg);\n\tif (ret)\n\t\tgoto out_subpool_put;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * glb_chg is passed to indicate whether or not a page must be taken\n\t * from the global free pool (global change).  gbl_chg == 0 indicates\n\t * a reservation exists for the allocation.\n\t */\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve, gbl_chg);\n\tif (!page) {\n\t\tspin_unlock(&hugetlb_lock);\n\t\tpage = alloc_buddy_huge_page_with_mpol(h, vma, addr);\n\t\tif (!page)\n\t\t\tgoto out_uncharge_cgroup;\n\t\tif (!avoid_reserve && vma_has_reserves(vma, gbl_chg)) {\n\t\t\tSetPagePrivate(page);\n\t\t\th->resv_huge_pages--;\n\t\t}\n\t\tspin_lock(&hugetlb_lock);\n\t\tlist_move(&page->lru, &h->hugepage_activelist);\n\t\t/* Fall through */\n\t}\n\thugetlb_cgroup_commit_charge(idx, pages_per_huge_page(h), h_cg, page);\n\tspin_unlock(&hugetlb_lock);\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tmap_commit = vma_commit_reservation(h, vma, addr);\n\tif (unlikely(map_chg > map_commit)) {\n\t\t/*\n\t\t * The page was added to the reservation map between\n\t\t * vma_needs_reservation and vma_commit_reservation.\n\t\t * This indicates a race with hugetlb_reserve_pages.\n\t\t * Adjust for the subpool count incremented above AND\n\t\t * in hugetlb_reserve_pages for the same page.  Also,\n\t\t * the reservation count added in hugetlb_reserve_pages\n\t\t * no longer applies.\n\t\t */\n\t\tlong rsv_adjust;\n\n\t\trsv_adjust = hugepage_subpool_put_pages(spool, 1);\n\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t}\n\treturn page;\n\nout_uncharge_cgroup:\n\thugetlb_cgroup_uncharge_cgroup(idx, pages_per_huge_page(h), h_cg);\nout_subpool_put:\n\tif (map_chg || avoid_reserve)\n\t\thugepage_subpool_put_pages(spool, 1);\n\tvma_end_reservation(h, vma, addr);\n\treturn ERR_PTR(-ENOSPC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hugetlb_fault_mutex_table[hash]"
          ],
          "line": 3783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_userfault",
          "args": [
            "&vmf",
            "VM_UFFD_MISSING"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hugetlb_fault_mutex_table[hash]"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_fault_mutex_hash",
          "args": [
            "h",
            "mm",
            "vma",
            "mapping",
            "idx",
            "haddr"
          ],
          "line": 3779
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_fault_mutex_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3904-3910",
          "snippet": "u32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,\n\t\t\t    struct vm_area_struct *vma,\n\t\t\t    struct address_space *mapping,\n\t\t\t    pgoff_t idx, unsigned long address)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nu32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,\n\t\t\t    struct vm_area_struct *vma,\n\t\t\t    struct address_space *mapping,\n\t\t\t    pgoff_t idx, unsigned long address)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_missing",
          "args": [
            "vma"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "mapping",
            "idx"
          ],
          "line": 3750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"PID %d killed due to inadequate hugepage pool\\n\"",
            "current->pid"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vma_resv_set",
          "args": [
            "vma",
            "HPAGE_RESV_UNMAPPED"
          ],
          "line": 3739
        },
        "resolved": true,
        "details": {
          "function_name": "is_vma_resv_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "777-782",
          "snippet": "static int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 3732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_UNMAPPED (1UL << 1)\n\nstruct mutex *hugetlb_fault_mutex_table;\n\nstatic vm_fault_t hugetlb_no_page(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma,\n\t\t\tstruct address_space *mapping, pgoff_t idx,\n\t\t\tunsigned long address, pte_t *ptep, unsigned int flags)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tvm_fault_t ret = VM_FAULT_SIGBUS;\n\tint anon_rmap = 0;\n\tunsigned long size;\n\tstruct page *page;\n\tpte_t new_pte;\n\tspinlock_t *ptl;\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\t/*\n\t * Currently, we are forced to kill the process in the event the\n\t * original mapper has unmapped pages from the child due to a failed\n\t * COW. Warn that such a situation has occurred as it may not be obvious\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_UNMAPPED)) {\n\t\tpr_warn_ratelimited(\"PID %d killed due to inadequate hugepage pool\\n\",\n\t\t\t   current->pid);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Use page lock to guard against racing truncation\n\t * before we get page_table_lock.\n\t */\nretry:\n\tpage = find_lock_page(mapping, idx);\n\tif (!page) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tif (idx >= size)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Check for page in userfault range\n\t\t */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tu32 hash;\n\t\t\tstruct vm_fault vmf = {\n\t\t\t\t.vma = vma,\n\t\t\t\t.address = haddr,\n\t\t\t\t.flags = flags,\n\t\t\t\t/*\n\t\t\t\t * Hard to debug if it ends up being\n\t\t\t\t * used by a callee that assumes\n\t\t\t\t * something about the other\n\t\t\t\t * uninitialized fields... same as in\n\t\t\t\t * memory.c\n\t\t\t\t */\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * hugetlb_fault_mutex must be dropped before\n\t\t\t * handling userfault.  Reacquire after handling\n\t\t\t * fault to make calling code simpler.\n\t\t\t */\n\t\t\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping,\n\t\t\t\t\t\t\tidx, haddr);\n\t\t\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tret = handle_userfault(&vmf, VM_UFFD_MISSING);\n\t\t\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = alloc_huge_page(vma, haddr, 0);\n\t\tif (IS_ERR(page)) {\n\t\t\tret = vmf_error(PTR_ERR(page));\n\t\t\tgoto out;\n\t\t}\n\t\tclear_huge_page(page, address, pages_per_huge_page(h));\n\t\t__SetPageUptodate(page);\n\t\tset_page_huge_active(page);\n\n\t\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\t\tint err = huge_add_to_page_cache(page, mapping, idx);\n\t\t\tif (err) {\n\t\t\t\tput_page(page);\n\t\t\t\tif (err == -EEXIST)\n\t\t\t\t\tgoto retry;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t\tif (unlikely(anon_vma_prepare(vma))) {\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\t\tgoto backout_unlocked;\n\t\t\t}\n\t\t\tanon_rmap = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If memory error occurs between mmap() and fault, some process\n\t\t * don't have hwpoisoned swap entry for errored virtual address.\n\t\t * So we need to block hugepage fault by PG_hwpoison bit check.\n\t\t */\n\t\tif (unlikely(PageHWPoison(page))) {\n\t\t\tret = VM_FAULT_HWPOISON |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t\t\tgoto backout_unlocked;\n\t\t}\n\t}\n\n\t/*\n\t * If we are going to COW a private mapping later, we examine the\n\t * pending reservations for this page now. This will ensure that\n\t * any allocations necessary to record that reservation occur outside\n\t * the spinlock.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\t\tif (vma_needs_reservation(h, vma, haddr) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto backout_unlocked;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, haddr);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tif (idx >= size)\n\t\tgoto backout;\n\n\tret = 0;\n\tif (!huge_pte_none(huge_ptep_get(ptep)))\n\t\tgoto backout;\n\n\tif (anon_rmap) {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, vma, haddr);\n\t} else\n\t\tpage_dup_rmap(page, true);\n\tnew_pte = make_huge_pte(vma, page, ((vma->vm_flags & VM_WRITE)\n\t\t\t\t&& (vma->vm_flags & VM_SHARED)));\n\tset_huge_pte_at(mm, haddr, ptep, new_pte);\n\n\thugetlb_count_add(pages_per_huge_page(h), mm);\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\t\t/* Optimization, do the COW without a second fault */\n\t\tret = hugetlb_cow(mm, vma, address, ptep, page, ptl);\n\t}\n\n\tspin_unlock(ptl);\n\tunlock_page(page);\nout:\n\treturn ret;\n\nbackout:\n\tspin_unlock(ptl);\nbackout_unlocked:\n\tunlock_page(page);\n\trestore_reserve_on_error(h, vma, haddr, page);\n\tput_page(page);\n\tgoto out;\n}"
  },
  {
    "function_name": "huge_add_to_page_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3697-3718",
    "snippet": "int huge_add_to_page_cache(struct page *page, struct address_space *mapping,\n\t\t\t   pgoff_t idx)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct hstate *h = hstate_inode(inode);\n\tint err = add_to_page_cache(page, mapping, idx, GFP_KERNEL);\n\n\tif (err)\n\t\treturn err;\n\tClearPagePrivate(page);\n\n\t/*\n\t * set page dirty so that it will not be removed from cache/file\n\t * by non-hugetlbfs specific code paths.\n\t */\n\tset_page_dirty(page);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks += blocks_per_huge_page(h);\n\tspin_unlock(&inode->i_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 3716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocks_per_huge_page",
          "args": [
            "h"
          ],
          "line": 3715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 3714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache",
          "args": [
            "page",
            "mapping",
            "idx",
            "GFP_KERNEL"
          ],
          "line": 3702
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_page_cache_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "879-905",
          "snippet": "int add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_inode",
          "args": [
            "inode"
          ],
          "line": 3701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint huge_add_to_page_cache(struct page *page, struct address_space *mapping,\n\t\t\t   pgoff_t idx)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct hstate *h = hstate_inode(inode);\n\tint err = add_to_page_cache(page, mapping, idx, GFP_KERNEL);\n\n\tif (err)\n\t\treturn err;\n\tClearPagePrivate(page);\n\n\t/*\n\t * set page dirty so that it will not be removed from cache/file\n\t * by non-hugetlbfs specific code paths.\n\t */\n\tset_page_dirty(page);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks += blocks_per_huge_page(h);\n\tspin_unlock(&inode->i_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "hugetlbfs_pagecache_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3681-3695",
    "snippet": "static bool hugetlbfs_pagecache_present(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tstruct page *page;\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\n\tpage = find_get_page(mapping, idx);\n\tif (page)\n\t\tput_page(page);\n\treturn page != NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 3693
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "idx"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_hugecache_offset",
          "args": [
            "h",
            "vma",
            "address"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "vma_hugecache_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "620-625",
          "snippet": "static pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic bool hugetlbfs_pagecache_present(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tstruct page *page;\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\n\tpage = find_get_page(mapping, idx);\n\tif (page)\n\t\tput_page(page);\n\treturn page != NULL;\n}"
  },
  {
    "function_name": "hugetlbfs_pagecache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3665-3675",
    "snippet": "static struct page *hugetlbfs_pagecache_page(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\n\treturn find_lock_page(mapping, idx);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "mapping",
            "idx"
          ],
          "line": 3674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_hugecache_offset",
          "args": [
            "h",
            "vma",
            "address"
          ],
          "line": 3672
        },
        "resolved": true,
        "details": {
          "function_name": "vma_hugecache_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "620-625",
          "snippet": "static pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *hugetlbfs_pagecache_page(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\n\treturn find_lock_page(mapping, idx);\n}"
  },
  {
    "function_name": "hugetlb_cow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3539-3662",
    "snippet": "static vm_fault_t hugetlb_cow(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t       unsigned long address, pte_t *ptep,\n\t\t       struct page *pagecache_page, spinlock_t *ptl)\n{\n\tpte_t pte;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *old_page, *new_page;\n\tint outside_reserve = 0;\n\tvm_fault_t ret = 0;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tpte = huge_ptep_get(ptep);\n\told_page = pte_page(pte);\n\nretry_avoidcopy:\n\t/* If no-one else is actually using this page, avoid the copy\n\t * and just make the page writable */\n\tif (page_mapcount(old_page) == 1 && PageAnon(old_page)) {\n\t\tpage_move_anon_rmap(old_page, vma);\n\t\tset_huge_ptep_writable(vma, haddr, ptep);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the process that created a MAP_PRIVATE mapping is about to\n\t * perform a COW due to a shared page count, attempt to satisfy\n\t * the allocation without using the existing reserves. The pagecache\n\t * page is used to determine if the reserve at this address was\n\t * consumed or not. If reserves were used, a partial faulted mapping\n\t * at the time of fork() could consume its reserves on COW instead\n\t * of the full address range.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER) &&\n\t\t\told_page != pagecache_page)\n\t\toutside_reserve = 1;\n\n\tget_page(old_page);\n\n\t/*\n\t * Drop page table lock as buddy allocator may be called. It will\n\t * be acquired again before returning to the caller, as expected.\n\t */\n\tspin_unlock(ptl);\n\tnew_page = alloc_huge_page(vma, haddr, outside_reserve);\n\n\tif (IS_ERR(new_page)) {\n\t\t/*\n\t\t * If a process owning a MAP_PRIVATE mapping fails to COW,\n\t\t * it is due to references held by a child and an insufficient\n\t\t * huge page pool. To guarantee the original mappers\n\t\t * reliability, unmap the page from child processes. The child\n\t\t * may get SIGKILLed if it later faults.\n\t\t */\n\t\tif (outside_reserve) {\n\t\t\tput_page(old_page);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tunmap_ref_private(mm, vma, old_page, haddr);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tspin_lock(ptl);\n\t\t\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\t\t\tif (likely(ptep &&\n\t\t\t\t   pte_same(huge_ptep_get(ptep), pte)))\n\t\t\t\tgoto retry_avoidcopy;\n\t\t\t/*\n\t\t\t * race occurs while re-acquiring page table\n\t\t\t * lock, and our job is done.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = vmf_error(PTR_ERR(new_page));\n\t\tgoto out_release_old;\n\t}\n\n\t/*\n\t * When the original hugepage is shared one, it does not have\n\t * anon_vma prepared.\n\t */\n\tif (unlikely(anon_vma_prepare(vma))) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_release_all;\n\t}\n\n\tcopy_user_huge_page(new_page, old_page, address, vma,\n\t\t\t    pages_per_huge_page(h));\n\t__SetPageUptodate(new_page);\n\tset_page_huge_active(new_page);\n\n\tmmun_start = haddr;\n\tmmun_end = mmun_start + huge_page_size(h);\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Retake the page table lock to check for racing updates\n\t * before the page tables are altered\n\t */\n\tspin_lock(ptl);\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (likely(ptep && pte_same(huge_ptep_get(ptep), pte))) {\n\t\tClearPagePrivate(new_page);\n\n\t\t/* Break COW */\n\t\thuge_ptep_clear_flush(vma, haddr, ptep);\n\t\tmmu_notifier_invalidate_range(mm, mmun_start, mmun_end);\n\t\tset_huge_pte_at(mm, haddr, ptep,\n\t\t\t\tmake_huge_pte(vma, new_page, 1));\n\t\tpage_remove_rmap(old_page, true);\n\t\thugepage_add_new_anon_rmap(new_page, vma, haddr);\n\t\t/* Make the old page be freed below */\n\t\tnew_page = old_page;\n\t}\n\tspin_unlock(ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout_release_all:\n\trestore_reserve_on_error(h, vma, haddr, new_page);\n\tput_page(new_page);\nout_release_old:\n\tput_page(old_page);\n\n\tspin_lock(ptl); /* Caller expects lock to be held */\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define HPAGE_RESV_OWNER    (1UL << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "ptl"
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "old_page"
          ],
          "line": 3658
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_reserve_on_error",
          "args": [
            "h",
            "vma",
            "haddr",
            "new_page"
          ],
          "line": 3655
        },
        "resolved": true,
        "details": {
          "function_name": "restore_reserve_on_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1957-1988",
          "snippet": "static void restore_reserve_on_error(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address,\n\t\t\tstruct page *page)\n{\n\tif (unlikely(PagePrivate(page))) {\n\t\tlong rc = vma_needs_reservation(h, vma, address);\n\n\t\tif (unlikely(rc < 0)) {\n\t\t\t/*\n\t\t\t * Rare out of memory condition in reserve map\n\t\t\t * manipulation.  Clear PagePrivate so that\n\t\t\t * global reserve count will not be incremented\n\t\t\t * by free_huge_page.  This will make it appear\n\t\t\t * as though the reservation for this page was\n\t\t\t * consumed.  This may prevent the task from\n\t\t\t * faulting in the page at a later time.  This\n\t\t\t * is better than inconsistent global huge page\n\t\t\t * accounting of reserve counts.\n\t\t\t */\n\t\t\tClearPagePrivate(page);\n\t\t} else if (rc) {\n\t\t\trc = vma_add_reservation(h, vma, address);\n\t\t\tif (unlikely(rc < 0))\n\t\t\t\t/*\n\t\t\t\t * See above comment about rare out of\n\t\t\t\t * memory condition.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t} else\n\t\t\tvma_end_reservation(h, vma, address);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void restore_reserve_on_error(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address,\n\t\t\tstruct page *page)\n{\n\tif (unlikely(PagePrivate(page))) {\n\t\tlong rc = vma_needs_reservation(h, vma, address);\n\n\t\tif (unlikely(rc < 0)) {\n\t\t\t/*\n\t\t\t * Rare out of memory condition in reserve map\n\t\t\t * manipulation.  Clear PagePrivate so that\n\t\t\t * global reserve count will not be incremented\n\t\t\t * by free_huge_page.  This will make it appear\n\t\t\t * as though the reservation for this page was\n\t\t\t * consumed.  This may prevent the task from\n\t\t\t * faulting in the page at a later time.  This\n\t\t\t * is better than inconsistent global huge page\n\t\t\t * accounting of reserve counts.\n\t\t\t */\n\t\t\tClearPagePrivate(page);\n\t\t} else if (rc) {\n\t\t\trc = vma_add_reservation(h, vma, address);\n\t\t\tif (unlikely(rc < 0))\n\t\t\t\t/*\n\t\t\t\t * See above comment about rare out of\n\t\t\t\t * memory condition.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t} else\n\t\t\tvma_end_reservation(h, vma, address);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_add_new_anon_rmap",
          "args": [
            "new_page",
            "vma",
            "haddr"
          ],
          "line": 3648
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1955-1961",
          "snippet": "void hugepage_add_new_anon_rmap(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tBUG_ON(address < vma->vm_start || address >= vma->vm_end);\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\t__hugepage_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid hugepage_add_new_anon_rmap(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tBUG_ON(address < vma->vm_start || address >= vma->vm_end);\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\t__hugepage_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "old_page",
            "true"
          ],
          "line": 3647
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_huge_pte_at",
          "args": [
            "mm",
            "haddr",
            "ptep",
            "make_huge_pte(vma, new_page, 1)"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_huge_pte",
          "args": [
            "vma",
            "new_page",
            "1"
          ],
          "line": 3646
        },
        "resolved": true,
        "details": {
          "function_name": "make_huge_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3178-3195",
          "snippet": "static pte_t make_huge_pte(struct vm_area_struct *vma, struct page *page,\n\t\t\t\tint writable)\n{\n\tpte_t entry;\n\n\tif (writable) {\n\t\tentry = huge_pte_mkwrite(huge_pte_mkdirty(mk_huge_pte(page,\n\t\t\t\t\t vma->vm_page_prot)));\n\t} else {\n\t\tentry = huge_pte_wrprotect(mk_huge_pte(page,\n\t\t\t\t\t   vma->vm_page_prot));\n\t}\n\tentry = pte_mkyoung(entry);\n\tentry = pte_mkhuge(entry);\n\tentry = arch_make_huge_pte(entry, vma, page, writable);\n\n\treturn entry;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pte_t make_huge_pte(struct vm_area_struct *vma, struct page *page,\n\t\t\t\tint writable)\n{\n\tpte_t entry;\n\n\tif (writable) {\n\t\tentry = huge_pte_mkwrite(huge_pte_mkdirty(mk_huge_pte(page,\n\t\t\t\t\t vma->vm_page_prot)));\n\t} else {\n\t\tentry = huge_pte_wrprotect(mk_huge_pte(page,\n\t\t\t\t\t   vma->vm_page_prot));\n\t}\n\tentry = pte_mkyoung(entry);\n\tentry = pte_mkhuge(entry);\n\tentry = arch_make_huge_pte(entry, vma, page, writable);\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 3644
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_notifier_invalidate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
          "lines": "235-247",
          "snippet": "void __mmu_notifier_invalidate_range(struct mm_struct *mm,\n\t\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->invalidate_range)\n\t\t\tmn->ops->invalidate_range(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/srcu.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid __mmu_notifier_invalidate_range(struct mm_struct *mm,\n\t\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->invalidate_range)\n\t\t\tmn->ops->invalidate_range(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_ptep_clear_flush",
          "args": [
            "vma",
            "haddr",
            "ptep"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "new_page"
          ],
          "line": 3640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ptep && pte_same(huge_ptep_get(ptep), pte)"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "huge_ptep_get(ptep)",
            "pte"
          ],
          "line": 3639
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "ptep"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_offset",
          "args": [
            "mm",
            "haddr",
            "huge_page_size(h)"
          ],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4782-4812",
          "snippet": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 3638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "ptl"
          ],
          "line": 3637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_huge_active",
          "args": [
            "new_page"
          ],
          "line": 3627
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_huge_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1205-1209",
          "snippet": "static void set_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tSetPagePrivate(&page[1]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tSetPagePrivate(&page[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "new_page"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_user_huge_page",
          "args": [
            "new_page",
            "old_page",
            "address",
            "vma",
            "pages_per_huge_page(h)"
          ],
          "line": 3624
        },
        "resolved": true,
        "details": {
          "function_name": "copy_user_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4487-4506",
          "snippet": "void copy_user_huge_page(struct page *dst, struct page *src,\n\t\t\t unsigned long addr_hint, struct vm_area_struct *vma,\n\t\t\t unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\tstruct copy_subpage_arg arg = {\n\t\t.dst = dst,\n\t\t.src = src,\n\t\t.vma = vma,\n\t};\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tcopy_user_gigantic_page(dst, src, addr, vma,\n\t\t\t\t\tpages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, copy_subpage, &arg);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid copy_user_huge_page(struct page *dst, struct page *src,\n\t\t\t unsigned long addr_hint, struct vm_area_struct *vma,\n\t\t\t unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\tstruct copy_subpage_arg arg = {\n\t\t.dst = dst,\n\t\t.src = src,\n\t\t.vma = vma,\n\t};\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tcopy_user_gigantic_page(dst, src, addr, vma,\n\t\t\t\t\tpages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, copy_subpage, &arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 3625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "anon_vma_prepare(vma)"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_prepare",
          "args": [
            "vma"
          ],
          "line": 3619
        },
        "resolved": true,
        "details": {
          "function_name": "__anon_vma_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "175-221",
          "snippet": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmf_error",
          "args": [
            "PTR_ERR(new_page)"
          ],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_page"
          ],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ptep &&\n\t\t\t\t   pte_same(huge_ptep_get(ptep), pte)"
          ],
          "line": 3601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "ptep"
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "ptl"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "huge_pte_none(pte)"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "pte"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_ref_private",
          "args": [
            "mm",
            "vma",
            "old_page",
            "haddr"
          ],
          "line": 3597
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_ref_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3483-3531",
          "snippet": "static void unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t      struct page *page, unsigned long address)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct vm_area_struct *iter_vma;\n\tstruct address_space *mapping;\n\tpgoff_t pgoff;\n\n\t/*\n\t * vm_pgoff is in PAGE_SIZE units, hence the different calculation\n\t * from page cache lookup which is in HPAGE_SIZE units.\n\t */\n\taddress = address & huge_page_mask(h);\n\tpgoff = ((address - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\tvma->vm_pgoff;\n\tmapping = vma->vm_file->f_mapping;\n\n\t/*\n\t * Take the mapping lock for the duration of the table walk. As\n\t * this mapping should be shared between all the VMAs,\n\t * __unmap_hugepage_range() is called as the lock is already held\n\t */\n\ti_mmap_lock_write(mapping);\n\tvma_interval_tree_foreach(iter_vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\t/* Do not unmap the current VMA */\n\t\tif (iter_vma == vma)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Shared VMAs have their own reserves and do not affect\n\t\t * MAP_PRIVATE accounting but it is possible that a shared\n\t\t * VMA is using the same page so check and skip such VMAs.\n\t\t */\n\t\tif (iter_vma->vm_flags & VM_MAYSHARE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Unmap the page from other VMAs without their own reserves.\n\t\t * They get marked to be SIGKILLed if they fault in these\n\t\t * areas. This is because a future no-page fault on this VMA\n\t\t * could insert a zeroed page instead of the data existing\n\t\t * from the time of fork. This would look like data corruption\n\t\t */\n\t\tif (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))\n\t\t\tunmap_hugepage_range(iter_vma, address,\n\t\t\t\t\t     address + huge_page_size(h), page);\n\t}\n\ti_mmap_unlock_write(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_OWNER    (1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic void unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t      struct page *page, unsigned long address)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct vm_area_struct *iter_vma;\n\tstruct address_space *mapping;\n\tpgoff_t pgoff;\n\n\t/*\n\t * vm_pgoff is in PAGE_SIZE units, hence the different calculation\n\t * from page cache lookup which is in HPAGE_SIZE units.\n\t */\n\taddress = address & huge_page_mask(h);\n\tpgoff = ((address - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\tvma->vm_pgoff;\n\tmapping = vma->vm_file->f_mapping;\n\n\t/*\n\t * Take the mapping lock for the duration of the table walk. As\n\t * this mapping should be shared between all the VMAs,\n\t * __unmap_hugepage_range() is called as the lock is already held\n\t */\n\ti_mmap_lock_write(mapping);\n\tvma_interval_tree_foreach(iter_vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\t/* Do not unmap the current VMA */\n\t\tif (iter_vma == vma)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Shared VMAs have their own reserves and do not affect\n\t\t * MAP_PRIVATE accounting but it is possible that a shared\n\t\t * VMA is using the same page so check and skip such VMAs.\n\t\t */\n\t\tif (iter_vma->vm_flags & VM_MAYSHARE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Unmap the page from other VMAs without their own reserves.\n\t\t * They get marked to be SIGKILLed if they fault in these\n\t\t * areas. This is because a future no-page fault on this VMA\n\t\t * could insert a zeroed page instead of the data existing\n\t\t * from the time of fork. This would look like data corruption\n\t\t */\n\t\tif (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))\n\t\t\tunmap_hugepage_range(iter_vma, address,\n\t\t\t\t\t     address + huge_page_size(h), page);\n\t}\n\ti_mmap_unlock_write(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "huge_pte_none(pte)"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "pte"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_page"
          ],
          "line": 3586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_huge_page",
          "args": [
            "vma",
            "haddr",
            "outside_reserve"
          ],
          "line": 3584
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1990-2091",
          "snippet": "struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong map_chg, map_commit;\n\tlong gbl_chg;\n\tint ret, idx;\n\tstruct hugetlb_cgroup *h_cg;\n\n\tidx = hstate_index(h);\n\t/*\n\t * Examine the region/reserve map to determine if the process\n\t * has a reservation for the page to be allocated.  A return\n\t * code of zero indicates a reservation exists (no change).\n\t */\n\tmap_chg = gbl_chg = vma_needs_reservation(h, vma, addr);\n\tif (map_chg < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Processes that did not create the mapping will have no\n\t * reserves as indicated by the region/reserve map. Check\n\t * that the allocation will not exceed the subpool limit.\n\t * Allocations for MAP_NORESERVE mappings also need to be\n\t * checked against any subpool limit.\n\t */\n\tif (map_chg || avoid_reserve) {\n\t\tgbl_chg = hugepage_subpool_get_pages(spool, 1);\n\t\tif (gbl_chg < 0) {\n\t\t\tvma_end_reservation(h, vma, addr);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\n\t\t/*\n\t\t * Even though there was no reservation in the region/reserve\n\t\t * map, there could be reservations associated with the\n\t\t * subpool that can be used.  This would be indicated if the\n\t\t * return value of hugepage_subpool_get_pages() is zero.\n\t\t * However, if avoid_reserve is specified we still avoid even\n\t\t * the subpool reservations.\n\t\t */\n\t\tif (avoid_reserve)\n\t\t\tgbl_chg = 1;\n\t}\n\n\tret = hugetlb_cgroup_charge_cgroup(idx, pages_per_huge_page(h), &h_cg);\n\tif (ret)\n\t\tgoto out_subpool_put;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * glb_chg is passed to indicate whether or not a page must be taken\n\t * from the global free pool (global change).  gbl_chg == 0 indicates\n\t * a reservation exists for the allocation.\n\t */\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve, gbl_chg);\n\tif (!page) {\n\t\tspin_unlock(&hugetlb_lock);\n\t\tpage = alloc_buddy_huge_page_with_mpol(h, vma, addr);\n\t\tif (!page)\n\t\t\tgoto out_uncharge_cgroup;\n\t\tif (!avoid_reserve && vma_has_reserves(vma, gbl_chg)) {\n\t\t\tSetPagePrivate(page);\n\t\t\th->resv_huge_pages--;\n\t\t}\n\t\tspin_lock(&hugetlb_lock);\n\t\tlist_move(&page->lru, &h->hugepage_activelist);\n\t\t/* Fall through */\n\t}\n\thugetlb_cgroup_commit_charge(idx, pages_per_huge_page(h), h_cg, page);\n\tspin_unlock(&hugetlb_lock);\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tmap_commit = vma_commit_reservation(h, vma, addr);\n\tif (unlikely(map_chg > map_commit)) {\n\t\t/*\n\t\t * The page was added to the reservation map between\n\t\t * vma_needs_reservation and vma_commit_reservation.\n\t\t * This indicates a race with hugetlb_reserve_pages.\n\t\t * Adjust for the subpool count incremented above AND\n\t\t * in hugetlb_reserve_pages for the same page.  Also,\n\t\t * the reservation count added in hugetlb_reserve_pages\n\t\t * no longer applies.\n\t\t */\n\t\tlong rsv_adjust;\n\n\t\trsv_adjust = hugepage_subpool_put_pages(spool, 1);\n\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t}\n\treturn page;\n\nout_uncharge_cgroup:\n\thugetlb_cgroup_uncharge_cgroup(idx, pages_per_huge_page(h), h_cg);\nout_subpool_put:\n\tif (map_chg || avoid_reserve)\n\t\thugepage_subpool_put_pages(spool, 1);\n\tvma_end_reservation(h, vma, addr);\n\treturn ERR_PTR(-ENOSPC);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong map_chg, map_commit;\n\tlong gbl_chg;\n\tint ret, idx;\n\tstruct hugetlb_cgroup *h_cg;\n\n\tidx = hstate_index(h);\n\t/*\n\t * Examine the region/reserve map to determine if the process\n\t * has a reservation for the page to be allocated.  A return\n\t * code of zero indicates a reservation exists (no change).\n\t */\n\tmap_chg = gbl_chg = vma_needs_reservation(h, vma, addr);\n\tif (map_chg < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Processes that did not create the mapping will have no\n\t * reserves as indicated by the region/reserve map. Check\n\t * that the allocation will not exceed the subpool limit.\n\t * Allocations for MAP_NORESERVE mappings also need to be\n\t * checked against any subpool limit.\n\t */\n\tif (map_chg || avoid_reserve) {\n\t\tgbl_chg = hugepage_subpool_get_pages(spool, 1);\n\t\tif (gbl_chg < 0) {\n\t\t\tvma_end_reservation(h, vma, addr);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\n\t\t/*\n\t\t * Even though there was no reservation in the region/reserve\n\t\t * map, there could be reservations associated with the\n\t\t * subpool that can be used.  This would be indicated if the\n\t\t * return value of hugepage_subpool_get_pages() is zero.\n\t\t * However, if avoid_reserve is specified we still avoid even\n\t\t * the subpool reservations.\n\t\t */\n\t\tif (avoid_reserve)\n\t\t\tgbl_chg = 1;\n\t}\n\n\tret = hugetlb_cgroup_charge_cgroup(idx, pages_per_huge_page(h), &h_cg);\n\tif (ret)\n\t\tgoto out_subpool_put;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * glb_chg is passed to indicate whether or not a page must be taken\n\t * from the global free pool (global change).  gbl_chg == 0 indicates\n\t * a reservation exists for the allocation.\n\t */\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve, gbl_chg);\n\tif (!page) {\n\t\tspin_unlock(&hugetlb_lock);\n\t\tpage = alloc_buddy_huge_page_with_mpol(h, vma, addr);\n\t\tif (!page)\n\t\t\tgoto out_uncharge_cgroup;\n\t\tif (!avoid_reserve && vma_has_reserves(vma, gbl_chg)) {\n\t\t\tSetPagePrivate(page);\n\t\t\th->resv_huge_pages--;\n\t\t}\n\t\tspin_lock(&hugetlb_lock);\n\t\tlist_move(&page->lru, &h->hugepage_activelist);\n\t\t/* Fall through */\n\t}\n\thugetlb_cgroup_commit_charge(idx, pages_per_huge_page(h), h_cg, page);\n\tspin_unlock(&hugetlb_lock);\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tmap_commit = vma_commit_reservation(h, vma, addr);\n\tif (unlikely(map_chg > map_commit)) {\n\t\t/*\n\t\t * The page was added to the reservation map between\n\t\t * vma_needs_reservation and vma_commit_reservation.\n\t\t * This indicates a race with hugetlb_reserve_pages.\n\t\t * Adjust for the subpool count incremented above AND\n\t\t * in hugetlb_reserve_pages for the same page.  Also,\n\t\t * the reservation count added in hugetlb_reserve_pages\n\t\t * no longer applies.\n\t\t */\n\t\tlong rsv_adjust;\n\n\t\trsv_adjust = hugepage_subpool_put_pages(spool, 1);\n\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t}\n\treturn page;\n\nout_uncharge_cgroup:\n\thugetlb_cgroup_uncharge_cgroup(idx, pages_per_huge_page(h), h_cg);\nout_subpool_put:\n\tif (map_chg || avoid_reserve)\n\t\thugepage_subpool_put_pages(spool, 1);\n\tvma_end_reservation(h, vma, addr);\n\treturn ERR_PTR(-ENOSPC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "old_page"
          ],
          "line": 3577
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vma_resv_set",
          "args": [
            "vma",
            "HPAGE_RESV_OWNER"
          ],
          "line": 3573
        },
        "resolved": true,
        "details": {
          "function_name": "is_vma_resv_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "777-782",
          "snippet": "static int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_huge_ptep_writable",
          "args": [
            "vma",
            "haddr",
            "ptep"
          ],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "set_huge_ptep_writable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3197-3205",
          "snippet": "static void set_huge_ptep_writable(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address, pte_t *ptep)\n{\n\tpte_t entry;\n\n\tentry = huge_pte_mkwrite(huge_pte_mkdirty(huge_ptep_get(ptep)));\n\tif (huge_ptep_set_access_flags(vma, address, ptep, entry, 1))\n\t\tupdate_mmu_cache(vma, address, ptep);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_huge_ptep_writable(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address, pte_t *ptep)\n{\n\tpte_t entry;\n\n\tentry = huge_pte_mkwrite(huge_pte_mkdirty(huge_ptep_get(ptep)));\n\tif (huge_ptep_set_access_flags(vma, address, ptep, entry, 1))\n\t\tupdate_mmu_cache(vma, address, ptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_move_anon_rmap",
          "args": [
            "old_page",
            "vma"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "page_move_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1000-1016",
          "snippet": "void page_move_anon_rmap(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tpage = compound_head(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_VMA(!anon_vma, vma);\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\t/*\n\t * Ensure that anon_vma and the PAGE_MAPPING_ANON bit are written\n\t * simultaneously, so a concurrent reader (eg page_referenced()'s\n\t * PageAnon()) will not see one without the other.\n\t */\n\tWRITE_ONCE(page->mapping, (struct address_space *) anon_vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_move_anon_rmap(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tpage = compound_head(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_VMA(!anon_vma, vma);\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\t/*\n\t * Ensure that anon_vma and the PAGE_MAPPING_ANON bit are written\n\t * simultaneously, so a concurrent reader (eg page_referenced()'s\n\t * PageAnon()) will not see one without the other.\n\t */\n\tWRITE_ONCE(page->mapping, (struct address_space *) anon_vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "old_page"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "old_page"
          ],
          "line": 3558
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "pte"
          ],
          "line": 3553
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "ptep"
          ],
          "line": 3552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 3544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic vm_fault_t hugetlb_cow(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t       unsigned long address, pte_t *ptep,\n\t\t       struct page *pagecache_page, spinlock_t *ptl)\n{\n\tpte_t pte;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *old_page, *new_page;\n\tint outside_reserve = 0;\n\tvm_fault_t ret = 0;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tpte = huge_ptep_get(ptep);\n\told_page = pte_page(pte);\n\nretry_avoidcopy:\n\t/* If no-one else is actually using this page, avoid the copy\n\t * and just make the page writable */\n\tif (page_mapcount(old_page) == 1 && PageAnon(old_page)) {\n\t\tpage_move_anon_rmap(old_page, vma);\n\t\tset_huge_ptep_writable(vma, haddr, ptep);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the process that created a MAP_PRIVATE mapping is about to\n\t * perform a COW due to a shared page count, attempt to satisfy\n\t * the allocation without using the existing reserves. The pagecache\n\t * page is used to determine if the reserve at this address was\n\t * consumed or not. If reserves were used, a partial faulted mapping\n\t * at the time of fork() could consume its reserves on COW instead\n\t * of the full address range.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER) &&\n\t\t\told_page != pagecache_page)\n\t\toutside_reserve = 1;\n\n\tget_page(old_page);\n\n\t/*\n\t * Drop page table lock as buddy allocator may be called. It will\n\t * be acquired again before returning to the caller, as expected.\n\t */\n\tspin_unlock(ptl);\n\tnew_page = alloc_huge_page(vma, haddr, outside_reserve);\n\n\tif (IS_ERR(new_page)) {\n\t\t/*\n\t\t * If a process owning a MAP_PRIVATE mapping fails to COW,\n\t\t * it is due to references held by a child and an insufficient\n\t\t * huge page pool. To guarantee the original mappers\n\t\t * reliability, unmap the page from child processes. The child\n\t\t * may get SIGKILLed if it later faults.\n\t\t */\n\t\tif (outside_reserve) {\n\t\t\tput_page(old_page);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tunmap_ref_private(mm, vma, old_page, haddr);\n\t\t\tBUG_ON(huge_pte_none(pte));\n\t\t\tspin_lock(ptl);\n\t\t\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\t\t\tif (likely(ptep &&\n\t\t\t\t   pte_same(huge_ptep_get(ptep), pte)))\n\t\t\t\tgoto retry_avoidcopy;\n\t\t\t/*\n\t\t\t * race occurs while re-acquiring page table\n\t\t\t * lock, and our job is done.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = vmf_error(PTR_ERR(new_page));\n\t\tgoto out_release_old;\n\t}\n\n\t/*\n\t * When the original hugepage is shared one, it does not have\n\t * anon_vma prepared.\n\t */\n\tif (unlikely(anon_vma_prepare(vma))) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_release_all;\n\t}\n\n\tcopy_user_huge_page(new_page, old_page, address, vma,\n\t\t\t    pages_per_huge_page(h));\n\t__SetPageUptodate(new_page);\n\tset_page_huge_active(new_page);\n\n\tmmun_start = haddr;\n\tmmun_end = mmun_start + huge_page_size(h);\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Retake the page table lock to check for racing updates\n\t * before the page tables are altered\n\t */\n\tspin_lock(ptl);\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (likely(ptep && pte_same(huge_ptep_get(ptep), pte))) {\n\t\tClearPagePrivate(new_page);\n\n\t\t/* Break COW */\n\t\thuge_ptep_clear_flush(vma, haddr, ptep);\n\t\tmmu_notifier_invalidate_range(mm, mmun_start, mmun_end);\n\t\tset_huge_pte_at(mm, haddr, ptep,\n\t\t\t\tmake_huge_pte(vma, new_page, 1));\n\t\tpage_remove_rmap(old_page, true);\n\t\thugepage_add_new_anon_rmap(new_page, vma, haddr);\n\t\t/* Make the old page be freed below */\n\t\tnew_page = old_page;\n\t}\n\tspin_unlock(ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout_release_all:\n\trestore_reserve_on_error(h, vma, haddr, new_page);\n\tput_page(new_page);\nout_release_old:\n\tput_page(old_page);\n\n\tspin_lock(ptl); /* Caller expects lock to be held */\n\treturn ret;\n}"
  },
  {
    "function_name": "unmap_ref_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3483-3531",
    "snippet": "static void unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t      struct page *page, unsigned long address)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct vm_area_struct *iter_vma;\n\tstruct address_space *mapping;\n\tpgoff_t pgoff;\n\n\t/*\n\t * vm_pgoff is in PAGE_SIZE units, hence the different calculation\n\t * from page cache lookup which is in HPAGE_SIZE units.\n\t */\n\taddress = address & huge_page_mask(h);\n\tpgoff = ((address - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\tvma->vm_pgoff;\n\tmapping = vma->vm_file->f_mapping;\n\n\t/*\n\t * Take the mapping lock for the duration of the table walk. As\n\t * this mapping should be shared between all the VMAs,\n\t * __unmap_hugepage_range() is called as the lock is already held\n\t */\n\ti_mmap_lock_write(mapping);\n\tvma_interval_tree_foreach(iter_vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\t/* Do not unmap the current VMA */\n\t\tif (iter_vma == vma)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Shared VMAs have their own reserves and do not affect\n\t\t * MAP_PRIVATE accounting but it is possible that a shared\n\t\t * VMA is using the same page so check and skip such VMAs.\n\t\t */\n\t\tif (iter_vma->vm_flags & VM_MAYSHARE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Unmap the page from other VMAs without their own reserves.\n\t\t * They get marked to be SIGKILLed if they fault in these\n\t\t * areas. This is because a future no-page fault on this VMA\n\t\t * could insert a zeroed page instead of the data existing\n\t\t * from the time of fork. This would look like data corruption\n\t\t */\n\t\tif (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))\n\t\t\tunmap_hugepage_range(iter_vma, address,\n\t\t\t\t\t     address + huge_page_size(h), page);\n\t}\n\ti_mmap_unlock_write(mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define HPAGE_RESV_OWNER    (1UL << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "mapping"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_hugepage_range",
          "args": [
            "iter_vma",
            "address",
            "address + huge_page_size(h)",
            "page"
          ],
          "line": 3527
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_hugepage_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3453-3475",
          "snippet": "void unmap_hugepage_range(struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\tstruct mm_struct *mm;\n\tstruct mmu_gather tlb;\n\tunsigned long tlb_start = start;\n\tunsigned long tlb_end = end;\n\n\t/*\n\t * If shared PMDs were possibly used within this vma range, adjust\n\t * start/end for worst case tlb flushing.\n\t * Note that we can not be sure if PMDs are shared until we try to\n\t * unmap pages.  However, we want to make sure TLB flushing covers\n\t * the largest possible range.\n\t */\n\tadjust_range_if_pmd_sharing_possible(vma, &tlb_start, &tlb_end);\n\n\tmm = vma->vm_mm;\n\n\ttlb_gather_mmu(&tlb, mm, tlb_start, tlb_end);\n\t__unmap_hugepage_range(&tlb, vma, start, end, ref_page);\n\ttlb_finish_mmu(&tlb, tlb_start, tlb_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid unmap_hugepage_range(struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\tstruct mm_struct *mm;\n\tstruct mmu_gather tlb;\n\tunsigned long tlb_start = start;\n\tunsigned long tlb_end = end;\n\n\t/*\n\t * If shared PMDs were possibly used within this vma range, adjust\n\t * start/end for worst case tlb flushing.\n\t * Note that we can not be sure if PMDs are shared until we try to\n\t * unmap pages.  However, we want to make sure TLB flushing covers\n\t * the largest possible range.\n\t */\n\tadjust_range_if_pmd_sharing_possible(vma, &tlb_start, &tlb_end);\n\n\tmm = vma->vm_mm;\n\n\ttlb_gather_mmu(&tlb, mm, tlb_start, tlb_end);\n\t__unmap_hugepage_range(&tlb, vma, start, end, ref_page);\n\ttlb_finish_mmu(&tlb, tlb_start, tlb_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 3528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vma_resv_set",
          "args": [
            "iter_vma",
            "HPAGE_RESV_OWNER"
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "is_vma_resv_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "777-782",
          "snippet": "static int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_foreach",
          "args": [
            "iter_vma",
            "&mapping->i_mmap",
            "pgoff",
            "pgoff"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_write",
          "args": [
            "mapping"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic void unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t      struct page *page, unsigned long address)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct vm_area_struct *iter_vma;\n\tstruct address_space *mapping;\n\tpgoff_t pgoff;\n\n\t/*\n\t * vm_pgoff is in PAGE_SIZE units, hence the different calculation\n\t * from page cache lookup which is in HPAGE_SIZE units.\n\t */\n\taddress = address & huge_page_mask(h);\n\tpgoff = ((address - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\tvma->vm_pgoff;\n\tmapping = vma->vm_file->f_mapping;\n\n\t/*\n\t * Take the mapping lock for the duration of the table walk. As\n\t * this mapping should be shared between all the VMAs,\n\t * __unmap_hugepage_range() is called as the lock is already held\n\t */\n\ti_mmap_lock_write(mapping);\n\tvma_interval_tree_foreach(iter_vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\t/* Do not unmap the current VMA */\n\t\tif (iter_vma == vma)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Shared VMAs have their own reserves and do not affect\n\t\t * MAP_PRIVATE accounting but it is possible that a shared\n\t\t * VMA is using the same page so check and skip such VMAs.\n\t\t */\n\t\tif (iter_vma->vm_flags & VM_MAYSHARE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Unmap the page from other VMAs without their own reserves.\n\t\t * They get marked to be SIGKILLed if they fault in these\n\t\t * areas. This is because a future no-page fault on this VMA\n\t\t * could insert a zeroed page instead of the data existing\n\t\t * from the time of fork. This would look like data corruption\n\t\t */\n\t\tif (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))\n\t\t\tunmap_hugepage_range(iter_vma, address,\n\t\t\t\t\t     address + huge_page_size(h), page);\n\t}\n\ti_mmap_unlock_write(mapping);\n}"
  },
  {
    "function_name": "unmap_hugepage_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3453-3475",
    "snippet": "void unmap_hugepage_range(struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\tstruct mm_struct *mm;\n\tstruct mmu_gather tlb;\n\tunsigned long tlb_start = start;\n\tunsigned long tlb_end = end;\n\n\t/*\n\t * If shared PMDs were possibly used within this vma range, adjust\n\t * start/end for worst case tlb flushing.\n\t * Note that we can not be sure if PMDs are shared until we try to\n\t * unmap pages.  However, we want to make sure TLB flushing covers\n\t * the largest possible range.\n\t */\n\tadjust_range_if_pmd_sharing_possible(vma, &tlb_start, &tlb_end);\n\n\tmm = vma->vm_mm;\n\n\ttlb_gather_mmu(&tlb, mm, tlb_start, tlb_end);\n\t__unmap_hugepage_range(&tlb, vma, start, end, ref_page);\n\ttlb_finish_mmu(&tlb, tlb_start, tlb_end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_finish_mmu",
          "args": [
            "&tlb",
            "tlb_start",
            "tlb_end"
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_finish_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "247-261",
          "snippet": "void tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unmap_hugepage_range",
          "args": [
            "&tlb",
            "vma",
            "start",
            "end",
            "ref_page"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "__unmap_hugepage_range_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3434-3451",
          "snippet": "void __unmap_hugepage_range_final(struct mmu_gather *tlb,\n\t\t\t  struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\t__unmap_hugepage_range(tlb, vma, start, end, ref_page);\n\n\t/*\n\t * Clear this flag so that x86's huge_pmd_share page_table_shareable\n\t * test will fail on a vma being torn down, and not grab a page table\n\t * on its way out.  We're lucky that the flag has such an appropriate\n\t * name, and can in fact be safely cleared here. We could clear it\n\t * before the __unmap_hugepage_range above, but all that's necessary\n\t * is to clear it before releasing the i_mmap_rwsem. This works\n\t * because in the context this is called, the VMA is about to be\n\t * destroyed and the i_mmap_rwsem is held.\n\t */\n\tvma->vm_flags &= ~VM_MAYSHARE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid __unmap_hugepage_range_final(struct mmu_gather *tlb,\n\t\t\t  struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\t__unmap_hugepage_range(tlb, vma, start, end, ref_page);\n\n\t/*\n\t * Clear this flag so that x86's huge_pmd_share page_table_shareable\n\t * test will fail on a vma being torn down, and not grab a page table\n\t * on its way out.  We're lucky that the flag has such an appropriate\n\t * name, and can in fact be safely cleared here. We could clear it\n\t * before the __unmap_hugepage_range above, but all that's necessary\n\t * is to clear it before releasing the i_mmap_rwsem. This works\n\t * because in the context this is called, the VMA is about to be\n\t * destroyed and the i_mmap_rwsem is held.\n\t */\n\tvma->vm_flags &= ~VM_MAYSHARE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_gather_mmu",
          "args": [
            "&tlb",
            "mm",
            "tlb_start",
            "tlb_end"
          ],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_gather_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "240-245",
          "snippet": "void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjust_range_if_pmd_sharing_possible",
          "args": [
            "vma",
            "&tlb_start",
            "&tlb_end"
          ],
          "line": 3468
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_range_if_pmd_sharing_possible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4736-4739",
          "snippet": "void adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid unmap_hugepage_range(struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\tstruct mm_struct *mm;\n\tstruct mmu_gather tlb;\n\tunsigned long tlb_start = start;\n\tunsigned long tlb_end = end;\n\n\t/*\n\t * If shared PMDs were possibly used within this vma range, adjust\n\t * start/end for worst case tlb flushing.\n\t * Note that we can not be sure if PMDs are shared until we try to\n\t * unmap pages.  However, we want to make sure TLB flushing covers\n\t * the largest possible range.\n\t */\n\tadjust_range_if_pmd_sharing_possible(vma, &tlb_start, &tlb_end);\n\n\tmm = vma->vm_mm;\n\n\ttlb_gather_mmu(&tlb, mm, tlb_start, tlb_end);\n\t__unmap_hugepage_range(&tlb, vma, start, end, ref_page);\n\ttlb_finish_mmu(&tlb, tlb_start, tlb_end);\n}"
  },
  {
    "function_name": "__unmap_hugepage_range_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3434-3451",
    "snippet": "void __unmap_hugepage_range_final(struct mmu_gather *tlb,\n\t\t\t  struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\t__unmap_hugepage_range(tlb, vma, start, end, ref_page);\n\n\t/*\n\t * Clear this flag so that x86's huge_pmd_share page_table_shareable\n\t * test will fail on a vma being torn down, and not grab a page table\n\t * on its way out.  We're lucky that the flag has such an appropriate\n\t * name, and can in fact be safely cleared here. We could clear it\n\t * before the __unmap_hugepage_range above, but all that's necessary\n\t * is to clear it before releasing the i_mmap_rwsem. This works\n\t * because in the context this is called, the VMA is about to be\n\t * destroyed and the i_mmap_rwsem is held.\n\t */\n\tvma->vm_flags &= ~VM_MAYSHARE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__unmap_hugepage_range",
          "args": [
            "tlb",
            "vma",
            "start",
            "end",
            "ref_page"
          ],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "__unmap_hugepage_range_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3434-3451",
          "snippet": "void __unmap_hugepage_range_final(struct mmu_gather *tlb,\n\t\t\t  struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\t__unmap_hugepage_range(tlb, vma, start, end, ref_page);\n\n\t/*\n\t * Clear this flag so that x86's huge_pmd_share page_table_shareable\n\t * test will fail on a vma being torn down, and not grab a page table\n\t * on its way out.  We're lucky that the flag has such an appropriate\n\t * name, and can in fact be safely cleared here. We could clear it\n\t * before the __unmap_hugepage_range above, but all that's necessary\n\t * is to clear it before releasing the i_mmap_rwsem. This works\n\t * because in the context this is called, the VMA is about to be\n\t * destroyed and the i_mmap_rwsem is held.\n\t */\n\tvma->vm_flags &= ~VM_MAYSHARE;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid __unmap_hugepage_range_final(struct mmu_gather *tlb,\n\t\t\t  struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\t__unmap_hugepage_range(tlb, vma, start, end, ref_page);\n\n\t/*\n\t * Clear this flag so that x86's huge_pmd_share page_table_shareable\n\t * test will fail on a vma being torn down, and not grab a page table\n\t * on its way out.  We're lucky that the flag has such an appropriate\n\t * name, and can in fact be safely cleared here. We could clear it\n\t * before the __unmap_hugepage_range above, but all that's necessary\n\t * is to clear it before releasing the i_mmap_rwsem. This works\n\t * because in the context this is called, the VMA is about to be\n\t * destroyed and the i_mmap_rwsem is held.\n\t */\n\tvma->vm_flags &= ~VM_MAYSHARE;\n}"
  },
  {
    "function_name": "__unmap_hugepage_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3332-3432",
    "snippet": "void __unmap_hugepage_range(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t\t    unsigned long start, unsigned long end,\n\t\t\t    struct page *ref_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address;\n\tpte_t *ptep;\n\tpte_t pte;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long sz = huge_page_size(h);\n\tunsigned long mmun_start = start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end   = end;\t\t/* For mmu_notifiers */\n\n\tWARN_ON(!is_vm_hugetlb_page(vma));\n\tBUG_ON(start & ~huge_page_mask(h));\n\tBUG_ON(end & ~huge_page_mask(h));\n\n\t/*\n\t * This is a hugetlb vma, all the pte entries should point\n\t * to huge page.\n\t */\n\ttlb_remove_check_page_size_change(tlb, sz);\n\ttlb_start_vma(tlb, vma);\n\n\t/*\n\t * If sharing possible, alert mmu notifiers of worst case.\n\t */\n\tadjust_range_if_pmd_sharing_possible(vma, &mmun_start, &mmun_end);\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\taddress = start;\n\tfor (; address < end; address += sz) {\n\t\tptep = huge_pte_offset(mm, address, sz);\n\t\tif (!ptep)\n\t\t\tcontinue;\n\n\t\tptl = huge_pte_lock(h, mm, ptep);\n\t\tif (huge_pmd_unshare(mm, &address, ptep)) {\n\t\t\tspin_unlock(ptl);\n\t\t\t/*\n\t\t\t * We just unmapped a page of PMDs by clearing a PUD.\n\t\t\t * The caller's TLB flush range should cover this area.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tpte = huge_ptep_get(ptep);\n\t\tif (huge_pte_none(pte)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Migrating hugepage or HWPoisoned hugepage is already\n\t\t * unmapped and its refcount is dropped, so just clear pte here.\n\t\t */\n\t\tif (unlikely(!pte_present(pte))) {\n\t\t\thuge_pte_clear(mm, address, ptep, sz);\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = pte_page(pte);\n\t\t/*\n\t\t * If a reference page is supplied, it is because a specific\n\t\t * page is being unmapped, not a range. Ensure the page we\n\t\t * are about to unmap is the actual page of interest.\n\t\t */\n\t\tif (ref_page) {\n\t\t\tif (page != ref_page) {\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Mark the VMA as having unmapped its page so that\n\t\t\t * future faults in this VMA will fail rather than\n\t\t\t * looking like data was lost\n\t\t\t */\n\t\t\tset_vma_resv_flags(vma, HPAGE_RESV_UNMAPPED);\n\t\t}\n\n\t\tpte = huge_ptep_get_and_clear(mm, address, ptep);\n\t\ttlb_remove_huge_tlb_entry(h, tlb, ptep, address);\n\t\tif (huge_pte_dirty(pte))\n\t\t\tset_page_dirty(page);\n\n\t\thugetlb_count_sub(pages_per_huge_page(h), mm);\n\t\tpage_remove_rmap(page, true);\n\n\t\tspin_unlock(ptl);\n\t\ttlb_remove_page_size(tlb, page, huge_page_size(h));\n\t\t/*\n\t\t * Bail out after unmapping reference page if supplied\n\t\t */\n\t\tif (ref_page)\n\t\t\tbreak;\n\t}\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\ttlb_end_vma(tlb, vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define HPAGE_RESV_UNMAPPED (1UL << 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_end_vma",
          "args": [
            "tlb",
            "vma"
          ],
          "line": 3431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_remove_page_size",
          "args": [
            "tlb",
            "page",
            "huge_page_size(h)"
          ],
          "line": 3423
        },
        "resolved": true,
        "details": {
          "function_name": "__tlb_remove_page_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "119-140",
          "snippet": "bool __tlb_remove_page_size(struct mmu_gather *tlb, struct page *page, int page_size)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tVM_BUG_ON(!tlb->end);\n\tVM_WARN_ON(tlb->page_size != page_size);\n\n\tbatch = tlb->active;\n\t/*\n\t * Add the page and check if we are full. If so\n\t * force a flush.\n\t */\n\tbatch->pages[batch->nr++] = page;\n\tif (batch->nr == batch->max) {\n\t\tif (!tlb_next_batch(tlb))\n\t\t\treturn true;\n\t\tbatch = tlb->active;\n\t}\n\tVM_BUG_ON_PAGE(batch->nr > batch->max, page);\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nbool __tlb_remove_page_size(struct mmu_gather *tlb, struct page *page, int page_size)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tVM_BUG_ON(!tlb->end);\n\tVM_WARN_ON(tlb->page_size != page_size);\n\n\tbatch = tlb->active;\n\t/*\n\t * Add the page and check if we are full. If so\n\t * force a flush.\n\t */\n\tbatch->pages[batch->nr++] = page;\n\tif (batch->nr == batch->max) {\n\t\tif (!tlb_next_batch(tlb))\n\t\t\treturn true;\n\t\tbatch = tlb->active;\n\t}\n\tVM_BUG_ON_PAGE(batch->nr > batch->max, page);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "page",
            "true"
          ],
          "line": 3420
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_count_sub",
          "args": [
            "pages_per_huge_page(h)",
            "mm"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 3417
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_dirty",
          "args": [
            "pte"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_remove_huge_tlb_entry",
          "args": [
            "h",
            "tlb",
            "ptep",
            "address"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get_and_clear",
          "args": [
            "mm",
            "address",
            "ptep"
          ],
          "line": 3414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_vma_resv_flags",
          "args": [
            "vma",
            "HPAGE_RESV_UNMAPPED"
          ],
          "line": 3411
        },
        "resolved": true,
        "details": {
          "function_name": "set_vma_resv_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "769-775",
          "snippet": "static void set_vma_resv_flags(struct vm_area_struct *vma, unsigned long flags)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, get_vma_private_data(vma) | flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_vma_resv_flags(struct vm_area_struct *vma, unsigned long flags)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, get_vma_private_data(vma) | flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "pte"
          ],
          "line": 3395
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 3391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_clear",
          "args": [
            "mm",
            "address",
            "ptep",
            "sz"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pte_present(pte)"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "pte"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "ptep"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pmd_unshare",
          "args": [
            "mm",
            "&address",
            "ptep"
          ],
          "line": 3370
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pmd_unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4731-4734",
          "snippet": "int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_lock",
          "args": [
            "h",
            "mm",
            "ptep"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_offset",
          "args": [
            "mm",
            "address",
            "sz"
          ],
          "line": 3365
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4782-4812",
          "snippet": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_range_if_pmd_sharing_possible",
          "args": [
            "vma",
            "&mmun_start",
            "&mmun_end"
          ],
          "line": 3361
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_range_if_pmd_sharing_possible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4736-4739",
          "snippet": "void adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_start_vma",
          "args": [
            "tlb",
            "vma"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_remove_check_page_size_change",
          "args": [
            "tlb",
            "sz"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end & ~huge_page_mask(h)"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start & ~huge_page_mask(h)"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!is_vm_hugetlb_page(vma)"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_UNMAPPED (1UL << 1)\n\nvoid __unmap_hugepage_range(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t\t    unsigned long start, unsigned long end,\n\t\t\t    struct page *ref_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address;\n\tpte_t *ptep;\n\tpte_t pte;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long sz = huge_page_size(h);\n\tunsigned long mmun_start = start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end   = end;\t\t/* For mmu_notifiers */\n\n\tWARN_ON(!is_vm_hugetlb_page(vma));\n\tBUG_ON(start & ~huge_page_mask(h));\n\tBUG_ON(end & ~huge_page_mask(h));\n\n\t/*\n\t * This is a hugetlb vma, all the pte entries should point\n\t * to huge page.\n\t */\n\ttlb_remove_check_page_size_change(tlb, sz);\n\ttlb_start_vma(tlb, vma);\n\n\t/*\n\t * If sharing possible, alert mmu notifiers of worst case.\n\t */\n\tadjust_range_if_pmd_sharing_possible(vma, &mmun_start, &mmun_end);\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\taddress = start;\n\tfor (; address < end; address += sz) {\n\t\tptep = huge_pte_offset(mm, address, sz);\n\t\tif (!ptep)\n\t\t\tcontinue;\n\n\t\tptl = huge_pte_lock(h, mm, ptep);\n\t\tif (huge_pmd_unshare(mm, &address, ptep)) {\n\t\t\tspin_unlock(ptl);\n\t\t\t/*\n\t\t\t * We just unmapped a page of PMDs by clearing a PUD.\n\t\t\t * The caller's TLB flush range should cover this area.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tpte = huge_ptep_get(ptep);\n\t\tif (huge_pte_none(pte)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Migrating hugepage or HWPoisoned hugepage is already\n\t\t * unmapped and its refcount is dropped, so just clear pte here.\n\t\t */\n\t\tif (unlikely(!pte_present(pte))) {\n\t\t\thuge_pte_clear(mm, address, ptep, sz);\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = pte_page(pte);\n\t\t/*\n\t\t * If a reference page is supplied, it is because a specific\n\t\t * page is being unmapped, not a range. Ensure the page we\n\t\t * are about to unmap is the actual page of interest.\n\t\t */\n\t\tif (ref_page) {\n\t\t\tif (page != ref_page) {\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Mark the VMA as having unmapped its page so that\n\t\t\t * future faults in this VMA will fail rather than\n\t\t\t * looking like data was lost\n\t\t\t */\n\t\t\tset_vma_resv_flags(vma, HPAGE_RESV_UNMAPPED);\n\t\t}\n\n\t\tpte = huge_ptep_get_and_clear(mm, address, ptep);\n\t\ttlb_remove_huge_tlb_entry(h, tlb, ptep, address);\n\t\tif (huge_pte_dirty(pte))\n\t\t\tset_page_dirty(page);\n\n\t\thugetlb_count_sub(pages_per_huge_page(h), mm);\n\t\tpage_remove_rmap(page, true);\n\n\t\tspin_unlock(ptl);\n\t\ttlb_remove_page_size(tlb, page, huge_page_size(h));\n\t\t/*\n\t\t * Bail out after unmapping reference page if supplied\n\t\t */\n\t\tif (ref_page)\n\t\t\tbreak;\n\t}\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\ttlb_end_vma(tlb, vma);\n}"
  },
  {
    "function_name": "copy_hugetlb_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3233-3330",
    "snippet": "int copy_hugetlb_page_range(struct mm_struct *dst, struct mm_struct *src,\n\t\t\t    struct vm_area_struct *vma)\n{\n\tpte_t *src_pte, *dst_pte, entry, dst_entry;\n\tstruct page *ptepage;\n\tunsigned long addr;\n\tint cow;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long sz = huge_page_size(h);\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tint ret = 0;\n\n\tcow = (vma->vm_flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n\n\tmmun_start = vma->vm_start;\n\tmmun_end = vma->vm_end;\n\tif (cow)\n\t\tmmu_notifier_invalidate_range_start(src, mmun_start, mmun_end);\n\n\tfor (addr = vma->vm_start; addr < vma->vm_end; addr += sz) {\n\t\tspinlock_t *src_ptl, *dst_ptl;\n\t\tsrc_pte = huge_pte_offset(src, addr, sz);\n\t\tif (!src_pte)\n\t\t\tcontinue;\n\t\tdst_pte = huge_pte_alloc(dst, addr, sz);\n\t\tif (!dst_pte) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If the pagetables are shared don't copy or take references.\n\t\t * dst_pte == src_pte is the common case of src/dest sharing.\n\t\t *\n\t\t * However, src could have 'unshared' and dst shares with\n\t\t * another vma.  If dst_pte !none, this implies sharing.\n\t\t * Check here before taking page table lock, and once again\n\t\t * after taking the lock below.\n\t\t */\n\t\tdst_entry = huge_ptep_get(dst_pte);\n\t\tif ((dst_pte == src_pte) || !huge_pte_none(dst_entry))\n\t\t\tcontinue;\n\n\t\tdst_ptl = huge_pte_lock(h, dst, dst_pte);\n\t\tsrc_ptl = huge_pte_lockptr(h, src, src_pte);\n\t\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\t\tentry = huge_ptep_get(src_pte);\n\t\tdst_entry = huge_ptep_get(dst_pte);\n\t\tif (huge_pte_none(entry) || !huge_pte_none(dst_entry)) {\n\t\t\t/*\n\t\t\t * Skip if src entry none.  Also, skip in the\n\t\t\t * unlikely case dst entry !none as this implies\n\t\t\t * sharing with another vma.\n\t\t\t */\n\t\t\t;\n\t\t} else if (unlikely(is_hugetlb_entry_migration(entry) ||\n\t\t\t\t    is_hugetlb_entry_hwpoisoned(entry))) {\n\t\t\tswp_entry_t swp_entry = pte_to_swp_entry(entry);\n\n\t\t\tif (is_write_migration_entry(swp_entry) && cow) {\n\t\t\t\t/*\n\t\t\t\t * COW mappings require pages in both\n\t\t\t\t * parent and child to be set to read.\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&swp_entry);\n\t\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t\t\tset_huge_swap_pte_at(src, addr, src_pte,\n\t\t\t\t\t\t     entry, sz);\n\t\t\t}\n\t\t\tset_huge_swap_pte_at(dst, addr, dst_pte, entry, sz);\n\t\t} else {\n\t\t\tif (cow) {\n\t\t\t\t/*\n\t\t\t\t * No need to notify as we are downgrading page\n\t\t\t\t * table protection not changing it to point\n\t\t\t\t * to a new page.\n\t\t\t\t *\n\t\t\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t\t\t */\n\t\t\t\thuge_ptep_set_wrprotect(src, addr, src_pte);\n\t\t\t}\n\t\t\tentry = huge_ptep_get(src_pte);\n\t\t\tptepage = pte_page(entry);\n\t\t\tget_page(ptepage);\n\t\t\tpage_dup_rmap(ptepage, true);\n\t\t\tset_huge_pte_at(dst, addr, dst_pte, entry);\n\t\t\thugetlb_count_add(pages_per_huge_page(h), dst);\n\t\t}\n\t\tspin_unlock(src_ptl);\n\t\tspin_unlock(dst_ptl);\n\t}\n\n\tif (cow)\n\t\tmmu_notifier_invalidate_range_end(src, mmun_start, mmun_end);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "src",
            "mmun_start",
            "mmun_end"
          ],
          "line": 3327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "dst_ptl"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "src_ptl"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_count_add",
          "args": [
            "pages_per_huge_page(h)",
            "dst"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_huge_pte_at",
          "args": [
            "dst",
            "addr",
            "dst_pte",
            "entry"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_dup_rmap",
          "args": [
            "ptepage",
            "true"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "ptepage"
          ],
          "line": 3317
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "entry"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "src_pte"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_set_wrprotect",
          "args": [
            "src",
            "addr",
            "src_pte"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_huge_swap_pte_at",
          "args": [
            "dst",
            "addr",
            "dst_pte",
            "entry",
            "sz"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_huge_swap_pte_at",
          "args": [
            "src",
            "addr",
            "src_pte",
            "entry",
            "sz"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "swp_entry"
          ],
          "line": 3299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_migration_entry_read",
          "args": [
            "&swp_entry"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_migration_entry",
          "args": [
            "swp_entry"
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "entry"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_hugetlb_entry_migration(entry) ||\n\t\t\t\t    is_hugetlb_entry_hwpoisoned(entry)"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugetlb_entry_hwpoisoned",
          "args": [
            "entry"
          ],
          "line": 3290
        },
        "resolved": true,
        "details": {
          "function_name": "is_hugetlb_entry_hwpoisoned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3220-3231",
          "snippet": "static int is_hugetlb_entry_hwpoisoned(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn 0;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_hwpoison_entry(swp))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_hugetlb_entry_hwpoisoned(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn 0;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_hwpoison_entry(swp))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_hugetlb_entry_migration",
          "args": [
            "entry"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "is_hugetlb_entry_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3207-3218",
          "snippet": "bool is_hugetlb_entry_migration(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn false;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_migration_entry(swp))\n\t\treturn true;\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nbool is_hugetlb_entry_migration(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn false;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_migration_entry(swp))\n\t\treturn true;\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "dst_entry"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "entry"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "dst_pte"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "src_pte"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "src_ptl",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_lockptr",
          "args": [
            "h",
            "src",
            "src_pte"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_lock",
          "args": [
            "h",
            "dst",
            "dst_pte"
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "dst_entry"
          ],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "dst_pte"
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_alloc",
          "args": [
            "dst",
            "addr",
            "sz"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4744-4771",
          "snippet": "pte_t *huge_pte_alloc(struct mm_struct *mm,\n\t\t\tunsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpte_t *pte = NULL;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (pud) {\n\t\tif (sz == PUD_SIZE) {\n\t\t\tpte = (pte_t *)pud;\n\t\t} else {\n\t\t\tBUG_ON(sz != PMD_SIZE);\n\t\t\tif (want_pmd_share() && pud_none(*pud))\n\t\t\t\tpte = huge_pmd_share(mm, addr, pud);\n\t\t\telse\n\t\t\t\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\t\t}\n\t}\n\tBUG_ON(pte && pte_present(*pte) && !pte_huge(*pte));\n\n\treturn pte;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_alloc(struct mm_struct *mm,\n\t\t\tunsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpte_t *pte = NULL;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (pud) {\n\t\tif (sz == PUD_SIZE) {\n\t\t\tpte = (pte_t *)pud;\n\t\t} else {\n\t\t\tBUG_ON(sz != PMD_SIZE);\n\t\t\tif (want_pmd_share() && pud_none(*pud))\n\t\t\t\tpte = huge_pmd_share(mm, addr, pud);\n\t\t\telse\n\t\t\t\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\t\t}\n\t}\n\tBUG_ON(pte && pte_present(*pte) && !pte_huge(*pte));\n\n\treturn pte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_offset",
          "args": [
            "src",
            "addr",
            "sz"
          ],
          "line": 3255
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4782-4812",
          "snippet": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "src",
            "mmun_start",
            "mmun_end"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint copy_hugetlb_page_range(struct mm_struct *dst, struct mm_struct *src,\n\t\t\t    struct vm_area_struct *vma)\n{\n\tpte_t *src_pte, *dst_pte, entry, dst_entry;\n\tstruct page *ptepage;\n\tunsigned long addr;\n\tint cow;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long sz = huge_page_size(h);\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tint ret = 0;\n\n\tcow = (vma->vm_flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n\n\tmmun_start = vma->vm_start;\n\tmmun_end = vma->vm_end;\n\tif (cow)\n\t\tmmu_notifier_invalidate_range_start(src, mmun_start, mmun_end);\n\n\tfor (addr = vma->vm_start; addr < vma->vm_end; addr += sz) {\n\t\tspinlock_t *src_ptl, *dst_ptl;\n\t\tsrc_pte = huge_pte_offset(src, addr, sz);\n\t\tif (!src_pte)\n\t\t\tcontinue;\n\t\tdst_pte = huge_pte_alloc(dst, addr, sz);\n\t\tif (!dst_pte) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If the pagetables are shared don't copy or take references.\n\t\t * dst_pte == src_pte is the common case of src/dest sharing.\n\t\t *\n\t\t * However, src could have 'unshared' and dst shares with\n\t\t * another vma.  If dst_pte !none, this implies sharing.\n\t\t * Check here before taking page table lock, and once again\n\t\t * after taking the lock below.\n\t\t */\n\t\tdst_entry = huge_ptep_get(dst_pte);\n\t\tif ((dst_pte == src_pte) || !huge_pte_none(dst_entry))\n\t\t\tcontinue;\n\n\t\tdst_ptl = huge_pte_lock(h, dst, dst_pte);\n\t\tsrc_ptl = huge_pte_lockptr(h, src, src_pte);\n\t\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\t\tentry = huge_ptep_get(src_pte);\n\t\tdst_entry = huge_ptep_get(dst_pte);\n\t\tif (huge_pte_none(entry) || !huge_pte_none(dst_entry)) {\n\t\t\t/*\n\t\t\t * Skip if src entry none.  Also, skip in the\n\t\t\t * unlikely case dst entry !none as this implies\n\t\t\t * sharing with another vma.\n\t\t\t */\n\t\t\t;\n\t\t} else if (unlikely(is_hugetlb_entry_migration(entry) ||\n\t\t\t\t    is_hugetlb_entry_hwpoisoned(entry))) {\n\t\t\tswp_entry_t swp_entry = pte_to_swp_entry(entry);\n\n\t\t\tif (is_write_migration_entry(swp_entry) && cow) {\n\t\t\t\t/*\n\t\t\t\t * COW mappings require pages in both\n\t\t\t\t * parent and child to be set to read.\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&swp_entry);\n\t\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t\t\tset_huge_swap_pte_at(src, addr, src_pte,\n\t\t\t\t\t\t     entry, sz);\n\t\t\t}\n\t\t\tset_huge_swap_pte_at(dst, addr, dst_pte, entry, sz);\n\t\t} else {\n\t\t\tif (cow) {\n\t\t\t\t/*\n\t\t\t\t * No need to notify as we are downgrading page\n\t\t\t\t * table protection not changing it to point\n\t\t\t\t * to a new page.\n\t\t\t\t *\n\t\t\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t\t\t */\n\t\t\t\thuge_ptep_set_wrprotect(src, addr, src_pte);\n\t\t\t}\n\t\t\tentry = huge_ptep_get(src_pte);\n\t\t\tptepage = pte_page(entry);\n\t\t\tget_page(ptepage);\n\t\t\tpage_dup_rmap(ptepage, true);\n\t\t\tset_huge_pte_at(dst, addr, dst_pte, entry);\n\t\t\thugetlb_count_add(pages_per_huge_page(h), dst);\n\t\t}\n\t\tspin_unlock(src_ptl);\n\t\tspin_unlock(dst_ptl);\n\t}\n\n\tif (cow)\n\t\tmmu_notifier_invalidate_range_end(src, mmun_start, mmun_end);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "is_hugetlb_entry_hwpoisoned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3220-3231",
    "snippet": "static int is_hugetlb_entry_hwpoisoned(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn 0;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_hwpoison_entry(swp))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_hwpoison_entry",
          "args": [
            "swp"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "swp"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pte"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 3224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "pte"
          ],
          "line": 3224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_hugetlb_entry_hwpoisoned(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn 0;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_hwpoison_entry(swp))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "is_hugetlb_entry_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3207-3218",
    "snippet": "bool is_hugetlb_entry_migration(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn false;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_migration_entry(swp))\n\t\treturn true;\n\telse\n\t\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_migration_entry",
          "args": [
            "swp"
          ],
          "line": 3214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "swp"
          ],
          "line": 3214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pte"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "pte"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nbool is_hugetlb_entry_migration(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn false;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_migration_entry(swp))\n\t\treturn true;\n\telse\n\t\treturn false;\n}"
  },
  {
    "function_name": "set_huge_ptep_writable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3197-3205",
    "snippet": "static void set_huge_ptep_writable(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address, pte_t *ptep)\n{\n\tpte_t entry;\n\n\tentry = huge_pte_mkwrite(huge_pte_mkdirty(huge_ptep_get(ptep)));\n\tif (huge_ptep_set_access_flags(vma, address, ptep, entry, 1))\n\t\tupdate_mmu_cache(vma, address, ptep);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "address",
            "ptep"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_set_access_flags",
          "args": [
            "vma",
            "address",
            "ptep",
            "entry",
            "1"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_mkwrite",
          "args": [
            "huge_pte_mkdirty(huge_ptep_get(ptep))"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_mkdirty",
          "args": [
            "huge_ptep_get(ptep)"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "ptep"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_huge_ptep_writable(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address, pte_t *ptep)\n{\n\tpte_t entry;\n\n\tentry = huge_pte_mkwrite(huge_pte_mkdirty(huge_ptep_get(ptep)));\n\tif (huge_ptep_set_access_flags(vma, address, ptep, entry, 1))\n\t\tupdate_mmu_cache(vma, address, ptep);\n}"
  },
  {
    "function_name": "make_huge_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3178-3195",
    "snippet": "static pte_t make_huge_pte(struct vm_area_struct *vma, struct page *page,\n\t\t\t\tint writable)\n{\n\tpte_t entry;\n\n\tif (writable) {\n\t\tentry = huge_pte_mkwrite(huge_pte_mkdirty(mk_huge_pte(page,\n\t\t\t\t\t vma->vm_page_prot)));\n\t} else {\n\t\tentry = huge_pte_wrprotect(mk_huge_pte(page,\n\t\t\t\t\t   vma->vm_page_prot));\n\t}\n\tentry = pte_mkyoung(entry);\n\tentry = pte_mkhuge(entry);\n\tentry = arch_make_huge_pte(entry, vma, page, writable);\n\n\treturn entry;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_make_huge_pte",
          "args": [
            "entry",
            "vma",
            "page",
            "writable"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkhuge",
          "args": [
            "entry"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkyoung",
          "args": [
            "entry"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_wrprotect",
          "args": [
            "mk_huge_pte(page,\n\t\t\t\t\t   vma->vm_page_prot)"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_huge_pte",
          "args": [
            "page",
            "vma->vm_page_prot"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_mkwrite",
          "args": [
            "huge_pte_mkdirty(mk_huge_pte(page,\n\t\t\t\t\t vma->vm_page_prot))"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_mkdirty",
          "args": [
            "mk_huge_pte(page,\n\t\t\t\t\t vma->vm_page_prot)"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_huge_pte",
          "args": [
            "page",
            "vma->vm_page_prot"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pte_t make_huge_pte(struct vm_area_struct *vma, struct page *page,\n\t\t\t\tint writable)\n{\n\tpte_t entry;\n\n\tif (writable) {\n\t\tentry = huge_pte_mkwrite(huge_pte_mkdirty(mk_huge_pte(page,\n\t\t\t\t\t vma->vm_page_prot)));\n\t} else {\n\t\tentry = huge_pte_wrprotect(mk_huge_pte(page,\n\t\t\t\t\t   vma->vm_page_prot));\n\t}\n\tentry = pte_mkyoung(entry);\n\tentry = pte_mkhuge(entry);\n\tentry = arch_make_huge_pte(entry, vma, page, writable);\n\n\treturn entry;\n}"
  },
  {
    "function_name": "hugetlb_vm_op_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3157-3161",
    "snippet": "static vm_fault_t hugetlb_vm_op_fault(struct vm_fault *vmf)\n{\n\tBUG();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic vm_fault_t hugetlb_vm_op_fault(struct vm_fault *vmf)\n{\n\tBUG();\n\treturn 0;\n}"
  },
  {
    "function_name": "hugetlb_vm_op_pagesize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3144-3149",
    "snippet": "static unsigned long hugetlb_vm_op_pagesize(struct vm_area_struct *vma)\n{\n\tstruct hstate *hstate = hstate_vma(vma);\n\n\treturn 1UL << huge_page_shift(hstate);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "hstate"
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 3146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned long hugetlb_vm_op_pagesize(struct vm_area_struct *vma)\n{\n\tstruct hstate *hstate = hstate_vma(vma);\n\n\treturn 1UL << huge_page_shift(hstate);\n}"
  },
  {
    "function_name": "hugetlb_vm_op_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3137-3142",
    "snippet": "static int hugetlb_vm_op_split(struct vm_area_struct *vma, unsigned long addr)\n{\n\tif (addr & ~(huge_page_mask(hstate_vma(vma))))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "hstate_vma(vma)"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_vm_op_split(struct vm_area_struct *vma, unsigned long addr)\n{\n\tif (addr & ~(huge_page_mask(hstate_vma(vma))))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "hugetlb_vm_op_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3109-3135",
    "snippet": "static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *resv = vma_resv_map(vma);\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tunsigned long reserve, start, end;\n\tlong gbl_reserve;\n\n\tif (!resv || !is_vma_resv_set(vma, HPAGE_RESV_OWNER))\n\t\treturn;\n\n\tstart = vma_hugecache_offset(h, vma, vma->vm_start);\n\tend = vma_hugecache_offset(h, vma, vma->vm_end);\n\n\treserve = (end - start) - region_count(resv, start, end);\n\n\tkref_put(&resv->refs, resv_map_release);\n\n\tif (reserve) {\n\t\t/*\n\t\t * Decrement reserve counts.  The global reserve count may be\n\t\t * adjusted if the subpool has a minimum size.\n\t\t */\n\t\tgbl_reserve = hugepage_subpool_put_pages(spool, reserve);\n\t\thugetlb_acct_memory(h, -gbl_reserve);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define HPAGE_RESV_OWNER    (1UL << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_acct_memory",
          "args": [
            "h",
            "-gbl_reserve"
          ],
          "line": 3133
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_acct_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3052-3091",
          "snippet": "static int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugepage_subpool_put_pages",
          "args": [
            "spool",
            "reserve"
          ],
          "line": 3132
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_subpool_put_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "176-208",
          "snippet": "static long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&resv->refs",
            "resv_map_release"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "region_count",
          "args": [
            "resv",
            "start",
            "end"
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "region_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "589-614",
          "snippet": "static long region_count(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg;\n\tlong chg = 0;\n\n\tspin_lock(&resv->lock);\n\t/* Locate each segment we overlap with, and count that overlap. */\n\tlist_for_each_entry(rg, head, link) {\n\t\tlong seg_from;\n\t\tlong seg_to;\n\n\t\tif (rg->to <= f)\n\t\t\tcontinue;\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tseg_from = max(rg->from, f);\n\t\tseg_to = min(rg->to, t);\n\n\t\tchg += seg_to - seg_from;\n\t}\n\tspin_unlock(&resv->lock);\n\n\treturn chg;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_count(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg;\n\tlong chg = 0;\n\n\tspin_lock(&resv->lock);\n\t/* Locate each segment we overlap with, and count that overlap. */\n\tlist_for_each_entry(rg, head, link) {\n\t\tlong seg_from;\n\t\tlong seg_to;\n\n\t\tif (rg->to <= f)\n\t\t\tcontinue;\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tseg_from = max(rg->from, f);\n\t\tseg_to = min(rg->to, t);\n\n\t\tchg += seg_to - seg_from;\n\t}\n\tspin_unlock(&resv->lock);\n\n\treturn chg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_hugecache_offset",
          "args": [
            "h",
            "vma",
            "vma->vm_end"
          ],
          "line": 3121
        },
        "resolved": true,
        "details": {
          "function_name": "vma_hugecache_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "620-625",
          "snippet": "static pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vma_resv_set",
          "args": [
            "vma",
            "HPAGE_RESV_OWNER"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "is_vma_resv_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "777-782",
          "snippet": "static int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "subpool_vma",
          "args": [
            "vma"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "subpool_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "215-218",
          "snippet": "static inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)\n{\n\treturn subpool_inode(file_inode(vma->vm_file));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)\n{\n\treturn subpool_inode(file_inode(vma->vm_file));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_resv_map",
          "args": [
            "vma"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "vma_resv_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "745-758",
          "snippet": "static struct resv_map *vma_resv_map(struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\t\tstruct inode *inode = mapping->host;\n\n\t\treturn inode_resv_map(inode);\n\n\t} else {\n\t\treturn (struct resv_map *)(get_vma_private_data(vma) &\n\t\t\t\t\t\t\t~HPAGE_RESV_MASK);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)\n\nstatic struct resv_map *vma_resv_map(struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\t\tstruct inode *inode = mapping->host;\n\n\t\treturn inode_resv_map(inode);\n\n\t} else {\n\t\treturn (struct resv_map *)(get_vma_private_data(vma) &\n\t\t\t\t\t\t\t~HPAGE_RESV_MASK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *resv = vma_resv_map(vma);\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tunsigned long reserve, start, end;\n\tlong gbl_reserve;\n\n\tif (!resv || !is_vma_resv_set(vma, HPAGE_RESV_OWNER))\n\t\treturn;\n\n\tstart = vma_hugecache_offset(h, vma, vma->vm_start);\n\tend = vma_hugecache_offset(h, vma, vma->vm_end);\n\n\treserve = (end - start) - region_count(resv, start, end);\n\n\tkref_put(&resv->refs, resv_map_release);\n\n\tif (reserve) {\n\t\t/*\n\t\t * Decrement reserve counts.  The global reserve count may be\n\t\t * adjusted if the subpool has a minimum size.\n\t\t */\n\t\tgbl_reserve = hugepage_subpool_put_pages(spool, reserve);\n\t\thugetlb_acct_memory(h, -gbl_reserve);\n\t}\n}"
  },
  {
    "function_name": "hugetlb_vm_op_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3093-3107",
    "snippet": "static void hugetlb_vm_op_open(struct vm_area_struct *vma)\n{\n\tstruct resv_map *resv = vma_resv_map(vma);\n\n\t/*\n\t * This new VMA should share its siblings reservation map if present.\n\t * The VMA will only ever have a valid reservation map pointer where\n\t * it is being copied for another still existing VMA.  As that VMA\n\t * has a reference to the reservation map it cannot disappear until\n\t * after this open call completes.  It is therefore safe to take a\n\t * new reference here without additional locking.\n\t */\n\tif (resv && is_vma_resv_set(vma, HPAGE_RESV_OWNER))\n\t\tkref_get(&resv->refs);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define HPAGE_RESV_OWNER    (1UL << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&resv->refs"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vma_resv_set",
          "args": [
            "vma",
            "HPAGE_RESV_OWNER"
          ],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "is_vma_resv_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "777-782",
          "snippet": "static int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_resv_map",
          "args": [
            "vma"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "vma_resv_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "745-758",
          "snippet": "static struct resv_map *vma_resv_map(struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\t\tstruct inode *inode = mapping->host;\n\n\t\treturn inode_resv_map(inode);\n\n\t} else {\n\t\treturn (struct resv_map *)(get_vma_private_data(vma) &\n\t\t\t\t\t\t\t~HPAGE_RESV_MASK);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)\n\nstatic struct resv_map *vma_resv_map(struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\t\tstruct inode *inode = mapping->host;\n\n\t\treturn inode_resv_map(inode);\n\n\t} else {\n\t\treturn (struct resv_map *)(get_vma_private_data(vma) &\n\t\t\t\t\t\t\t~HPAGE_RESV_MASK);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic void hugetlb_vm_op_open(struct vm_area_struct *vma)\n{\n\tstruct resv_map *resv = vma_resv_map(vma);\n\n\t/*\n\t * This new VMA should share its siblings reservation map if present.\n\t * The VMA will only ever have a valid reservation map pointer where\n\t * it is being copied for another still existing VMA.  As that VMA\n\t * has a reference to the reservation map it cannot disappear until\n\t * after this open call completes.  It is therefore safe to take a\n\t * new reference here without additional locking.\n\t */\n\tif (resv && is_vma_resv_set(vma, HPAGE_RESV_OWNER))\n\t\tkref_get(&resv->refs);\n}"
  },
  {
    "function_name": "hugetlb_acct_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3052-3091",
    "snippet": "static int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int hugetlb_acct_memory(struct hstate *h, long delta);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return_unused_surplus_pages",
          "args": [
            "h",
            "(unsigned long) -delta"
          ],
          "line": 3086
        },
        "resolved": true,
        "details": {
          "function_name": "return_unused_surplus_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1790-1828",
          "snippet": "static void return_unused_surplus_pages(struct hstate *h,\n\t\t\t\t\tunsigned long unused_resv_pages)\n{\n\tunsigned long nr_pages;\n\n\t/* Cannot return gigantic pages currently */\n\tif (hstate_is_gigantic(h))\n\t\tgoto out;\n\n\t/*\n\t * Part (or even all) of the reservation could have been backed\n\t * by pre-allocated pages. Only free surplus pages.\n\t */\n\tnr_pages = min(unused_resv_pages, h->surplus_huge_pages);\n\n\t/*\n\t * We want to release as many surplus pages as possible, spread\n\t * evenly across all nodes with memory. Iterate across these nodes\n\t * until we can no longer free unreserved surplus pages. This occurs\n\t * when the nodes with surplus pages have no free pages.\n\t * free_pool_huge_page() will balance the the freed pages across the\n\t * on-line nodes with memory and will handle the hstate accounting.\n\t *\n\t * Note that we decrement resv_huge_pages as we free the pages.  If\n\t * we drop the lock, resv_huge_pages will still be sufficiently large\n\t * to cover subsequent pages we may free.\n\t */\n\twhile (nr_pages--) {\n\t\th->resv_huge_pages--;\n\t\tunused_resv_pages--;\n\t\tif (!free_pool_huge_page(h, &node_states[N_MEMORY], 1))\n\t\t\tgoto out;\n\t\tcond_resched_lock(&hugetlb_lock);\n\t}\n\nout:\n\t/* Fully uncommit the reservation */\n\th->resv_huge_pages -= unused_resv_pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void return_unused_surplus_pages(struct hstate *h,\n\t\t\t\t\tunsigned long unused_resv_pages)\n{\n\tunsigned long nr_pages;\n\n\t/* Cannot return gigantic pages currently */\n\tif (hstate_is_gigantic(h))\n\t\tgoto out;\n\n\t/*\n\t * Part (or even all) of the reservation could have been backed\n\t * by pre-allocated pages. Only free surplus pages.\n\t */\n\tnr_pages = min(unused_resv_pages, h->surplus_huge_pages);\n\n\t/*\n\t * We want to release as many surplus pages as possible, spread\n\t * evenly across all nodes with memory. Iterate across these nodes\n\t * until we can no longer free unreserved surplus pages. This occurs\n\t * when the nodes with surplus pages have no free pages.\n\t * free_pool_huge_page() will balance the the freed pages across the\n\t * on-line nodes with memory and will handle the hstate accounting.\n\t *\n\t * Note that we decrement resv_huge_pages as we free the pages.  If\n\t * we drop the lock, resv_huge_pages will still be sufficiently large\n\t * to cover subsequent pages we may free.\n\t */\n\twhile (nr_pages--) {\n\t\th->resv_huge_pages--;\n\t\tunused_resv_pages--;\n\t\tif (!free_pool_huge_page(h, &node_states[N_MEMORY], 1))\n\t\t\tgoto out;\n\t\tcond_resched_lock(&hugetlb_lock);\n\t}\n\nout:\n\t/* Fully uncommit the reservation */\n\th->resv_huge_pages -= unused_resv_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_mems_nr",
          "args": [
            "h->free_huge_pages_node"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_mems_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2887-2896",
          "snippet": "static unsigned int cpuset_mems_nr(unsigned int *array)\n{\n\tint node;\n\tunsigned int nr = 0;\n\n\tfor_each_node_mask(node, cpuset_current_mems_allowed)\n\t\tnr += array[node];\n\n\treturn nr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned int cpuset_mems_nr(unsigned int *array)\n{\n\tint node;\n\tunsigned int nr = 0;\n\n\tfor_each_node_mask(node, cpuset_current_mems_allowed)\n\t\tnr += array[node];\n\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gather_surplus_pages",
          "args": [
            "h",
            "delta"
          ],
          "line": 3075
        },
        "resolved": true,
        "details": {
          "function_name": "gather_surplus_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1692-1774",
          "snippet": "static int gather_surplus_pages(struct hstate *h, int delta)\n{\n\tstruct list_head surplus_list;\n\tstruct page *page, *tmp;\n\tint ret, i;\n\tint needed, allocated;\n\tbool alloc_ok = true;\n\n\tneeded = (h->resv_huge_pages + delta) - h->free_huge_pages;\n\tif (needed <= 0) {\n\t\th->resv_huge_pages += delta;\n\t\treturn 0;\n\t}\n\n\tallocated = 0;\n\tINIT_LIST_HEAD(&surplus_list);\n\n\tret = -ENOMEM;\nretry:\n\tspin_unlock(&hugetlb_lock);\n\tfor (i = 0; i < needed; i++) {\n\t\tpage = alloc_surplus_huge_page(h, htlb_alloc_mask(h),\n\t\t\t\tNUMA_NO_NODE, NULL);\n\t\tif (!page) {\n\t\t\talloc_ok = false;\n\t\t\tbreak;\n\t\t}\n\t\tlist_add(&page->lru, &surplus_list);\n\t\tcond_resched();\n\t}\n\tallocated += i;\n\n\t/*\n\t * After retaking hugetlb_lock, we need to recalculate 'needed'\n\t * because either resv_huge_pages or free_huge_pages may have changed.\n\t */\n\tspin_lock(&hugetlb_lock);\n\tneeded = (h->resv_huge_pages + delta) -\n\t\t\t(h->free_huge_pages + allocated);\n\tif (needed > 0) {\n\t\tif (alloc_ok)\n\t\t\tgoto retry;\n\t\t/*\n\t\t * We were not able to allocate enough pages to\n\t\t * satisfy the entire reservation so we free what\n\t\t * we've allocated so far.\n\t\t */\n\t\tgoto free;\n\t}\n\t/*\n\t * The surplus_list now contains _at_least_ the number of extra pages\n\t * needed to accommodate the reservation.  Add the appropriate number\n\t * of pages to the hugetlb pool and free the extras back to the buddy\n\t * allocator.  Commit the entire reservation here to prevent another\n\t * process from stealing the pages as they are added to the pool but\n\t * before they are reserved.\n\t */\n\tneeded += allocated;\n\th->resv_huge_pages += delta;\n\tret = 0;\n\n\t/* Free the needed pages to the hugetlb pool */\n\tlist_for_each_entry_safe(page, tmp, &surplus_list, lru) {\n\t\tif ((--needed) < 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * This page is now managed by the hugetlb allocator and has\n\t\t * no users -- drop the buddy allocator's reference.\n\t\t */\n\t\tput_page_testzero(page);\n\t\tVM_BUG_ON_PAGE(page_count(page), page);\n\t\tenqueue_huge_page(h, page);\n\t}\nfree:\n\tspin_unlock(&hugetlb_lock);\n\n\t/* Free unnecessary surplus pages to the buddy allocator */\n\tlist_for_each_entry_safe(page, tmp, &surplus_list, lru)\n\t\tput_page(page);\n\tspin_lock(&hugetlb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int gather_surplus_pages(struct hstate *h, int delta)\n{\n\tstruct list_head surplus_list;\n\tstruct page *page, *tmp;\n\tint ret, i;\n\tint needed, allocated;\n\tbool alloc_ok = true;\n\n\tneeded = (h->resv_huge_pages + delta) - h->free_huge_pages;\n\tif (needed <= 0) {\n\t\th->resv_huge_pages += delta;\n\t\treturn 0;\n\t}\n\n\tallocated = 0;\n\tINIT_LIST_HEAD(&surplus_list);\n\n\tret = -ENOMEM;\nretry:\n\tspin_unlock(&hugetlb_lock);\n\tfor (i = 0; i < needed; i++) {\n\t\tpage = alloc_surplus_huge_page(h, htlb_alloc_mask(h),\n\t\t\t\tNUMA_NO_NODE, NULL);\n\t\tif (!page) {\n\t\t\talloc_ok = false;\n\t\t\tbreak;\n\t\t}\n\t\tlist_add(&page->lru, &surplus_list);\n\t\tcond_resched();\n\t}\n\tallocated += i;\n\n\t/*\n\t * After retaking hugetlb_lock, we need to recalculate 'needed'\n\t * because either resv_huge_pages or free_huge_pages may have changed.\n\t */\n\tspin_lock(&hugetlb_lock);\n\tneeded = (h->resv_huge_pages + delta) -\n\t\t\t(h->free_huge_pages + allocated);\n\tif (needed > 0) {\n\t\tif (alloc_ok)\n\t\t\tgoto retry;\n\t\t/*\n\t\t * We were not able to allocate enough pages to\n\t\t * satisfy the entire reservation so we free what\n\t\t * we've allocated so far.\n\t\t */\n\t\tgoto free;\n\t}\n\t/*\n\t * The surplus_list now contains _at_least_ the number of extra pages\n\t * needed to accommodate the reservation.  Add the appropriate number\n\t * of pages to the hugetlb pool and free the extras back to the buddy\n\t * allocator.  Commit the entire reservation here to prevent another\n\t * process from stealing the pages as they are added to the pool but\n\t * before they are reserved.\n\t */\n\tneeded += allocated;\n\th->resv_huge_pages += delta;\n\tret = 0;\n\n\t/* Free the needed pages to the hugetlb pool */\n\tlist_for_each_entry_safe(page, tmp, &surplus_list, lru) {\n\t\tif ((--needed) < 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * This page is now managed by the hugetlb allocator and has\n\t\t * no users -- drop the buddy allocator's reference.\n\t\t */\n\t\tput_page_testzero(page);\n\t\tVM_BUG_ON_PAGE(page_count(page), page);\n\t\tenqueue_huge_page(h, page);\n\t}\nfree:\n\tspin_unlock(&hugetlb_lock);\n\n\t/* Free unnecessary surplus pages to the buddy allocator */\n\tlist_for_each_entry_safe(page, tmp, &surplus_list, lru)\n\t\tput_page(page);\n\tspin_lock(&hugetlb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "hugetlb_total_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3042-3050",
    "snippet": "unsigned long hugetlb_total_pages(void)\n{\n\tstruct hstate *h;\n\tunsigned long nr_total_pages = 0;\n\n\tfor_each_hstate(h)\n\t\tnr_total_pages += h->nr_huge_pages * pages_per_huge_page(h);\n\treturn nr_total_pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nunsigned long hugetlb_total_pages(void)\n{\n\tstruct hstate *h;\n\tunsigned long nr_total_pages = 0;\n\n\tfor_each_hstate(h)\n\t\tnr_total_pages += h->nr_huge_pages * pages_per_huge_page(h);\n\treturn nr_total_pages;\n}"
  },
  {
    "function_name": "hugetlb_report_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3035-3039",
    "snippet": "void hugetlb_report_usage(struct seq_file *m, struct mm_struct *mm)\n{\n\tseq_printf(m, \"HugetlbPages:\\t%8lu kB\\n\",\n\t\t   atomic_long_read(&mm->hugetlb_usage) << (PAGE_SHIFT - 10));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"HugetlbPages:\\t%8lu kB\\n\"",
            "atomic_long_read(&mm->hugetlb_usage) << (PAGE_SHIFT - 10)"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&mm->hugetlb_usage"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid hugetlb_report_usage(struct seq_file *m, struct mm_struct *mm)\n{\n\tseq_printf(m, \"HugetlbPages:\\t%8lu kB\\n\",\n\t\t   atomic_long_read(&mm->hugetlb_usage) << (PAGE_SHIFT - 10));\n}"
  },
  {
    "function_name": "hugetlb_show_meminfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3017-3033",
    "snippet": "void hugetlb_show_meminfo(void)\n{\n\tstruct hstate *h;\n\tint nid;\n\n\tif (!hugepages_supported())\n\t\treturn;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tfor_each_hstate(h)\n\t\t\tpr_info(\"Node %d hugepages_total=%u hugepages_free=%u hugepages_surp=%u hugepages_size=%lukB\\n\",\n\t\t\t\tnid,\n\t\t\t\th->nr_huge_pages_node[nid],\n\t\t\t\th->free_huge_pages_node[nid],\n\t\t\t\th->surplus_huge_pages_node[nid],\n\t\t\t\t1UL << (huge_page_order(h) + PAGE_SHIFT - 10));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepages_supported",
          "args": [],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid hugetlb_show_meminfo(void)\n{\n\tstruct hstate *h;\n\tint nid;\n\n\tif (!hugepages_supported())\n\t\treturn;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tfor_each_hstate(h)\n\t\t\tpr_info(\"Node %d hugepages_total=%u hugepages_free=%u hugepages_surp=%u hugepages_size=%lukB\\n\",\n\t\t\t\tnid,\n\t\t\t\th->nr_huge_pages_node[nid],\n\t\t\t\th->free_huge_pages_node[nid],\n\t\t\t\th->surplus_huge_pages_node[nid],\n\t\t\t\t1UL << (huge_page_order(h) + PAGE_SHIFT - 10));\n}"
  },
  {
    "function_name": "hugetlb_report_node_meminfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "3003-3015",
    "snippet": "int hugetlb_report_node_meminfo(int nid, char *buf)\n{\n\tstruct hstate *h = &default_hstate;\n\tif (!hugepages_supported())\n\t\treturn 0;\n\treturn sprintf(buf,\n\t\t\"Node %d HugePages_Total: %5u\\n\"\n\t\t\"Node %d HugePages_Free:  %5u\\n\"\n\t\t\"Node %d HugePages_Surp:  %5u\\n\",\n\t\tnid, h->nr_huge_pages_node[nid],\n\t\tnid, h->free_huge_pages_node[nid],\n\t\tnid, h->surplus_huge_pages_node[nid]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"Node %d HugePages_Total: %5u\\n\"\n\t\t\"Node %d HugePages_Free:  %5u\\n\"\n\t\t\"Node %d HugePages_Surp:  %5u\\n\"",
            "nid",
            "h->nr_huge_pages_node[nid]",
            "nid",
            "h->free_huge_pages_node[nid]",
            "nid",
            "h->surplus_huge_pages_node[nid]"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepages_supported",
          "args": [],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint hugetlb_report_node_meminfo(int nid, char *buf)\n{\n\tstruct hstate *h = &default_hstate;\n\tif (!hugepages_supported())\n\t\treturn 0;\n\treturn sprintf(buf,\n\t\t\"Node %d HugePages_Total: %5u\\n\"\n\t\t\"Node %d HugePages_Free:  %5u\\n\"\n\t\t\"Node %d HugePages_Surp:  %5u\\n\",\n\t\tnid, h->nr_huge_pages_node[nid],\n\t\tnid, h->free_huge_pages_node[nid],\n\t\tnid, h->surplus_huge_pages_node[nid]);\n}"
  },
  {
    "function_name": "hugetlb_report_meminfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2973-3001",
    "snippet": "void hugetlb_report_meminfo(struct seq_file *m)\n{\n\tstruct hstate *h;\n\tunsigned long total = 0;\n\n\tif (!hugepages_supported())\n\t\treturn;\n\n\tfor_each_hstate(h) {\n\t\tunsigned long count = h->nr_huge_pages;\n\n\t\ttotal += (PAGE_SIZE << huge_page_order(h)) * count;\n\n\t\tif (h == &default_hstate)\n\t\t\tseq_printf(m,\n\t\t\t\t   \"HugePages_Total:   %5lu\\n\"\n\t\t\t\t   \"HugePages_Free:    %5lu\\n\"\n\t\t\t\t   \"HugePages_Rsvd:    %5lu\\n\"\n\t\t\t\t   \"HugePages_Surp:    %5lu\\n\"\n\t\t\t\t   \"Hugepagesize:   %8lu kB\\n\",\n\t\t\t\t   count,\n\t\t\t\t   h->free_huge_pages,\n\t\t\t\t   h->resv_huge_pages,\n\t\t\t\t   h->surplus_huge_pages,\n\t\t\t\t   (PAGE_SIZE << huge_page_order(h)) / 1024);\n\t}\n\n\tseq_printf(m, \"Hugetlb:        %8lu kB\\n\", total / 1024);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Hugetlb:        %8lu kB\\n\"",
            "total / 1024"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"HugePages_Total:   %5lu\\n\"\n\t\t\t\t   \"HugePages_Free:    %5lu\\n\"\n\t\t\t\t   \"HugePages_Rsvd:    %5lu\\n\"\n\t\t\t\t   \"HugePages_Surp:    %5lu\\n\"\n\t\t\t\t   \"Hugepagesize:   %8lu kB\\n\"",
            "count",
            "h->free_huge_pages",
            "h->resv_huge_pages",
            "h->surplus_huge_pages",
            "(PAGE_SIZE << huge_page_order(h)) / 1024"
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepages_supported",
          "args": [],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid hugetlb_report_meminfo(struct seq_file *m)\n{\n\tstruct hstate *h;\n\tunsigned long total = 0;\n\n\tif (!hugepages_supported())\n\t\treturn;\n\n\tfor_each_hstate(h) {\n\t\tunsigned long count = h->nr_huge_pages;\n\n\t\ttotal += (PAGE_SIZE << huge_page_order(h)) * count;\n\n\t\tif (h == &default_hstate)\n\t\t\tseq_printf(m,\n\t\t\t\t   \"HugePages_Total:   %5lu\\n\"\n\t\t\t\t   \"HugePages_Free:    %5lu\\n\"\n\t\t\t\t   \"HugePages_Rsvd:    %5lu\\n\"\n\t\t\t\t   \"HugePages_Surp:    %5lu\\n\"\n\t\t\t\t   \"Hugepagesize:   %8lu kB\\n\",\n\t\t\t\t   count,\n\t\t\t\t   h->free_huge_pages,\n\t\t\t\t   h->resv_huge_pages,\n\t\t\t\t   h->surplus_huge_pages,\n\t\t\t\t   (PAGE_SIZE << huge_page_order(h)) / 1024);\n\t}\n\n\tseq_printf(m, \"Hugetlb:        %8lu kB\\n\", total / 1024);\n}"
  },
  {
    "function_name": "hugetlb_overcommit_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2940-2969",
    "snippet": "int hugetlb_overcommit_handler(struct ctl_table *table, int write,\n\t\t\tvoid __user *buffer,\n\t\t\tsize_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttmp = h->nr_overcommit_huge_pages;\n\n\tif (write && hstate_is_gigantic(h))\n\t\treturn -EINVAL;\n\n\ttable->data = &tmp;\n\ttable->maxlen = sizeof(unsigned long);\n\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write) {\n\t\tspin_lock(&hugetlb_lock);\n\t\th->nr_overcommit_huge_pages = tmp;\n\t\tspin_unlock(&hugetlb_lock);\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepages_supported",
          "args": [],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint hugetlb_overcommit_handler(struct ctl_table *table, int write,\n\t\t\tvoid __user *buffer,\n\t\t\tsize_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttmp = h->nr_overcommit_huge_pages;\n\n\tif (write && hstate_is_gigantic(h))\n\t\treturn -EINVAL;\n\n\ttable->data = &tmp;\n\ttable->maxlen = sizeof(unsigned long);\n\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write) {\n\t\tspin_lock(&hugetlb_lock);\n\t\th->nr_overcommit_huge_pages = tmp;\n\t\tspin_unlock(&hugetlb_lock);\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "hugetlb_mempolicy_sysctl_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2932-2937",
    "snippet": "int hugetlb_mempolicy_sysctl_handler(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *length, loff_t *ppos)\n{\n\treturn hugetlb_sysctl_handler_common(true, table, write,\n\t\t\t\t\t\t\tbuffer, length, ppos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_sysctl_handler_common",
          "args": [
            "true",
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_sysctl_handler_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2899-2921",
          "snippet": "static int hugetlb_sysctl_handler_common(bool obey_mempolicy,\n\t\t\t struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp = h->max_huge_pages;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttable->data = &tmp;\n\ttable->maxlen = sizeof(unsigned long);\n\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write)\n\t\tret = __nr_hugepages_store_common(obey_mempolicy, h,\n\t\t\t\t\t\t  NUMA_NO_NODE, tmp, *length);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_sysctl_handler_common(bool obey_mempolicy,\n\t\t\t struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp = h->max_huge_pages;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttable->data = &tmp;\n\ttable->maxlen = sizeof(unsigned long);\n\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write)\n\t\tret = __nr_hugepages_store_common(obey_mempolicy, h,\n\t\t\t\t\t\t  NUMA_NO_NODE, tmp, *length);\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint hugetlb_mempolicy_sysctl_handler(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *length, loff_t *ppos)\n{\n\treturn hugetlb_sysctl_handler_common(true, table, write,\n\t\t\t\t\t\t\tbuffer, length, ppos);\n}"
  },
  {
    "function_name": "hugetlb_sysctl_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2923-2929",
    "snippet": "int hugetlb_sysctl_handler(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *length, loff_t *ppos)\n{\n\n\treturn hugetlb_sysctl_handler_common(false, table, write,\n\t\t\t\t\t\t\tbuffer, length, ppos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_sysctl_handler_common",
          "args": [
            "false",
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_sysctl_handler_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2899-2921",
          "snippet": "static int hugetlb_sysctl_handler_common(bool obey_mempolicy,\n\t\t\t struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp = h->max_huge_pages;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttable->data = &tmp;\n\ttable->maxlen = sizeof(unsigned long);\n\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write)\n\t\tret = __nr_hugepages_store_common(obey_mempolicy, h,\n\t\t\t\t\t\t  NUMA_NO_NODE, tmp, *length);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_sysctl_handler_common(bool obey_mempolicy,\n\t\t\t struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp = h->max_huge_pages;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttable->data = &tmp;\n\ttable->maxlen = sizeof(unsigned long);\n\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write)\n\t\tret = __nr_hugepages_store_common(obey_mempolicy, h,\n\t\t\t\t\t\t  NUMA_NO_NODE, tmp, *length);\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint hugetlb_sysctl_handler(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *length, loff_t *ppos)\n{\n\n\treturn hugetlb_sysctl_handler_common(false, table, write,\n\t\t\t\t\t\t\tbuffer, length, ppos);\n}"
  },
  {
    "function_name": "hugetlb_sysctl_handler_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2899-2921",
    "snippet": "static int hugetlb_sysctl_handler_common(bool obey_mempolicy,\n\t\t\t struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp = h->max_huge_pages;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttable->data = &tmp;\n\ttable->maxlen = sizeof(unsigned long);\n\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write)\n\t\tret = __nr_hugepages_store_common(obey_mempolicy, h,\n\t\t\t\t\t\t  NUMA_NO_NODE, tmp, *length);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nr_hugepages_store_common",
          "args": [
            "obey_mempolicy",
            "h",
            "NUMA_NO_NODE",
            "tmp",
            "*length"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "__nr_hugepages_store_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2399-2439",
          "snippet": "static ssize_t __nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t   struct hstate *h, int nid,\n\t\t\t\t\t   unsigned long count, size_t len)\n{\n\tint err;\n\tNODEMASK_ALLOC(nodemask_t, nodes_allowed, GFP_KERNEL | __GFP_NORETRY);\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported()) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (nid == NUMA_NO_NODE) {\n\t\t/*\n\t\t * global hstate attribute\n\t\t */\n\t\tif (!(obey_mempolicy &&\n\t\t\t\tinit_nodemask_of_mempolicy(nodes_allowed))) {\n\t\t\tNODEMASK_FREE(nodes_allowed);\n\t\t\tnodes_allowed = &node_states[N_MEMORY];\n\t\t}\n\t} else if (nodes_allowed) {\n\t\t/*\n\t\t * per node hstate attribute: adjust count to global,\n\t\t * but restrict alloc/free to the specified node.\n\t\t */\n\t\tcount += h->nr_huge_pages - h->nr_huge_pages_node[nid];\n\t\tinit_nodemask_of_node(nodes_allowed, nid);\n\t} else\n\t\tnodes_allowed = &node_states[N_MEMORY];\n\n\th->max_huge_pages = set_max_huge_pages(h, count, nodes_allowed);\n\n\tif (nodes_allowed != &node_states[N_MEMORY])\n\t\tNODEMASK_FREE(nodes_allowed);\n\n\treturn len;\nout:\n\tNODEMASK_FREE(nodes_allowed);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t __nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t   struct hstate *h, int nid,\n\t\t\t\t\t   unsigned long count, size_t len)\n{\n\tint err;\n\tNODEMASK_ALLOC(nodemask_t, nodes_allowed, GFP_KERNEL | __GFP_NORETRY);\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported()) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (nid == NUMA_NO_NODE) {\n\t\t/*\n\t\t * global hstate attribute\n\t\t */\n\t\tif (!(obey_mempolicy &&\n\t\t\t\tinit_nodemask_of_mempolicy(nodes_allowed))) {\n\t\t\tNODEMASK_FREE(nodes_allowed);\n\t\t\tnodes_allowed = &node_states[N_MEMORY];\n\t\t}\n\t} else if (nodes_allowed) {\n\t\t/*\n\t\t * per node hstate attribute: adjust count to global,\n\t\t * but restrict alloc/free to the specified node.\n\t\t */\n\t\tcount += h->nr_huge_pages - h->nr_huge_pages_node[nid];\n\t\tinit_nodemask_of_node(nodes_allowed, nid);\n\t} else\n\t\tnodes_allowed = &node_states[N_MEMORY];\n\n\th->max_huge_pages = set_max_huge_pages(h, count, nodes_allowed);\n\n\tif (nodes_allowed != &node_states[N_MEMORY])\n\t\tNODEMASK_FREE(nodes_allowed);\n\n\treturn len;\nout:\n\tNODEMASK_FREE(nodes_allowed);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepages_supported",
          "args": [],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_sysctl_handler_common(bool obey_mempolicy,\n\t\t\t struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp = h->max_huge_pages;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttable->data = &tmp;\n\ttable->maxlen = sizeof(unsigned long);\n\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write)\n\t\tret = __nr_hugepages_store_common(obey_mempolicy, h,\n\t\t\t\t\t\t  NUMA_NO_NODE, tmp, *length);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuset_mems_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2887-2896",
    "snippet": "static unsigned int cpuset_mems_nr(unsigned int *array)\n{\n\tint node;\n\tunsigned int nr = 0;\n\n\tfor_each_node_mask(node, cpuset_current_mems_allowed)\n\t\tnr += array[node];\n\n\treturn nr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_node_mask",
          "args": [
            "node",
            "cpuset_current_mems_allowed"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned int cpuset_mems_nr(unsigned int *array)\n{\n\tint node;\n\tunsigned int nr = 0;\n\n\tfor_each_node_mask(node, cpuset_current_mems_allowed)\n\t\tnr += array[node];\n\n\treturn nr;\n}"
  },
  {
    "function_name": "hugetlb_default_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2880-2884",
    "snippet": "static int __init hugetlb_default_setup(char *s)\n{\n\tdefault_hstate_size = memparse(s, &s);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long __initdata default_hstate_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "s",
            "&s"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned long __initdata default_hstate_size;\n\nstatic int __init hugetlb_default_setup(char *s)\n{\n\tdefault_hstate_size = memparse(s, &s);\n\treturn 1;\n}"
  },
  {
    "function_name": "hugetlb_nrpages_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2838-2877",
    "snippet": "static int __init hugetlb_nrpages_setup(char *s)\n{\n\tunsigned long *mhp;\n\tstatic unsigned long *last_mhp;\n\n\tif (!parsed_valid_hugepagesz) {\n\t\tpr_warn(\"hugepages = %s preceded by \"\n\t\t\t\"an unsupported hugepagesz, ignoring\\n\", s);\n\t\tparsed_valid_hugepagesz = true;\n\t\treturn 1;\n\t}\n\t/*\n\t * !hugetlb_max_hstate means we haven't parsed a hugepagesz= parameter yet,\n\t * so this hugepages= parameter goes to the \"default hstate\".\n\t */\n\telse if (!hugetlb_max_hstate)\n\t\tmhp = &default_hstate_max_huge_pages;\n\telse\n\t\tmhp = &parsed_hstate->max_huge_pages;\n\n\tif (mhp == last_mhp) {\n\t\tpr_warn(\"hugepages= specified twice without interleaving hugepagesz=, ignoring\\n\");\n\t\treturn 1;\n\t}\n\n\tif (sscanf(s, \"%lu\", mhp) <= 0)\n\t\t*mhp = 0;\n\n\t/*\n\t * Global state is always initialized later in hugetlb_init.\n\t * But we need to allocate >= MAX_ORDER hstates here early to still\n\t * use the bootmem allocator.\n\t */\n\tif (hugetlb_max_hstate && parsed_hstate->order >= MAX_ORDER)\n\t\thugetlb_hstate_alloc_pages(parsed_hstate);\n\n\tlast_mhp = mhp;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int hugetlb_max_hstate",
      "struct hstate hstates[HUGE_MAX_HSTATE];",
      "static unsigned long __initdata default_hstate_max_huge_pages;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_hstate_alloc_pages",
          "args": [
            "parsed_hstate"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_hstate_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2163-2184",
          "snippet": "static void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "s",
            "\"%lu\"",
            "mhp"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"hugepages= specified twice without interleaving hugepagesz=, ignoring\\n\""
          ],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"hugepages = %s preceded by \"\n\t\t\t\"an unsupported hugepagesz, ignoring\\n\"",
            "s"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint hugetlb_max_hstate;\nstruct hstate hstates[HUGE_MAX_HSTATE];\nstatic unsigned long __initdata default_hstate_max_huge_pages;\n\nstatic int __init hugetlb_nrpages_setup(char *s)\n{\n\tunsigned long *mhp;\n\tstatic unsigned long *last_mhp;\n\n\tif (!parsed_valid_hugepagesz) {\n\t\tpr_warn(\"hugepages = %s preceded by \"\n\t\t\t\"an unsupported hugepagesz, ignoring\\n\", s);\n\t\tparsed_valid_hugepagesz = true;\n\t\treturn 1;\n\t}\n\t/*\n\t * !hugetlb_max_hstate means we haven't parsed a hugepagesz= parameter yet,\n\t * so this hugepages= parameter goes to the \"default hstate\".\n\t */\n\telse if (!hugetlb_max_hstate)\n\t\tmhp = &default_hstate_max_huge_pages;\n\telse\n\t\tmhp = &parsed_hstate->max_huge_pages;\n\n\tif (mhp == last_mhp) {\n\t\tpr_warn(\"hugepages= specified twice without interleaving hugepagesz=, ignoring\\n\");\n\t\treturn 1;\n\t}\n\n\tif (sscanf(s, \"%lu\", mhp) <= 0)\n\t\t*mhp = 0;\n\n\t/*\n\t * Global state is always initialized later in hugetlb_init.\n\t * But we need to allocate >= MAX_ORDER hstates here early to still\n\t * use the bootmem allocator.\n\t */\n\tif (hugetlb_max_hstate && parsed_hstate->order >= MAX_ORDER)\n\t\thugetlb_hstate_alloc_pages(parsed_hstate);\n\n\tlast_mhp = mhp;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "hugetlb_add_hstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2811-2836",
    "snippet": "void __init hugetlb_add_hstate(unsigned int order)\n{\n\tstruct hstate *h;\n\tunsigned long i;\n\n\tif (size_to_hstate(PAGE_SIZE << order)) {\n\t\tpr_warn(\"hugepagesz= specified twice, ignoring\\n\");\n\t\treturn;\n\t}\n\tBUG_ON(hugetlb_max_hstate >= HUGE_MAX_HSTATE);\n\tBUG_ON(order == 0);\n\th = &hstates[hugetlb_max_hstate++];\n\th->order = order;\n\th->mask = ~((1ULL << (order + PAGE_SHIFT)) - 1);\n\th->nr_huge_pages = 0;\n\th->free_huge_pages = 0;\n\tfor (i = 0; i < MAX_NUMNODES; ++i)\n\t\tINIT_LIST_HEAD(&h->hugepage_freelists[i]);\n\tINIT_LIST_HEAD(&h->hugepage_activelist);\n\th->next_nid_to_alloc = first_memory_node;\n\th->next_nid_to_free = first_memory_node;\n\tsnprintf(h->name, HSTATE_NAME_LEN, \"hugepages-%lukB\",\n\t\t\t\t\thuge_page_size(h)/1024);\n\n\tparsed_hstate = h;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int hugetlb_max_hstate",
      "struct hstate hstates[HUGE_MAX_HSTATE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "h->name",
            "HSTATE_NAME_LEN",
            "\"hugepages-%lukB\"",
            "huge_page_size(h)/1024"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&h->hugepage_activelist"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&h->hugepage_freelists[i]"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "order == 0"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "hugetlb_max_hstate >= HUGE_MAX_HSTATE"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"hugepagesz= specified twice, ignoring\\n\""
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_to_hstate",
          "args": [
            "PAGE_SIZE << order"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "size_to_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1181-1190",
          "snippet": "struct hstate *size_to_hstate(unsigned long size)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tif (huge_page_size(h) == size)\n\t\t\treturn h;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate *size_to_hstate(unsigned long size)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tif (huge_page_size(h) == size)\n\t\t\treturn h;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint hugetlb_max_hstate;\nstruct hstate hstates[HUGE_MAX_HSTATE];\n\nvoid __init hugetlb_add_hstate(unsigned int order)\n{\n\tstruct hstate *h;\n\tunsigned long i;\n\n\tif (size_to_hstate(PAGE_SIZE << order)) {\n\t\tpr_warn(\"hugepagesz= specified twice, ignoring\\n\");\n\t\treturn;\n\t}\n\tBUG_ON(hugetlb_max_hstate >= HUGE_MAX_HSTATE);\n\tBUG_ON(order == 0);\n\th = &hstates[hugetlb_max_hstate++];\n\th->order = order;\n\th->mask = ~((1ULL << (order + PAGE_SHIFT)) - 1);\n\th->nr_huge_pages = 0;\n\th->free_huge_pages = 0;\n\tfor (i = 0; i < MAX_NUMNODES; ++i)\n\t\tINIT_LIST_HEAD(&h->hugepage_freelists[i]);\n\tINIT_LIST_HEAD(&h->hugepage_activelist);\n\th->next_nid_to_alloc = first_memory_node;\n\th->next_nid_to_free = first_memory_node;\n\tsnprintf(h->name, HSTATE_NAME_LEN, \"hugepages-%lukB\",\n\t\t\t\t\thuge_page_size(h)/1024);\n\n\tparsed_hstate = h;\n}"
  },
  {
    "function_name": "hugetlb_bad_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2806-2809",
    "snippet": "void __init hugetlb_bad_size(void)\n{\n\tparsed_valid_hugepagesz = false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid __init hugetlb_bad_size(void)\n{\n\tparsed_valid_hugepagesz = false;\n}"
  },
  {
    "function_name": "hugetlb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2758-2802",
    "snippet": "static int __init hugetlb_init(void)\n{\n\tint i;\n\n\tif (!hugepages_supported())\n\t\treturn 0;\n\n\tif (!size_to_hstate(default_hstate_size)) {\n\t\tif (default_hstate_size != 0) {\n\t\t\tpr_err(\"HugeTLB: unsupported default_hugepagesz %lu. Reverting to %lu\\n\",\n\t\t\t       default_hstate_size, HPAGE_SIZE);\n\t\t}\n\n\t\tdefault_hstate_size = HPAGE_SIZE;\n\t\tif (!size_to_hstate(default_hstate_size))\n\t\t\thugetlb_add_hstate(HUGETLB_PAGE_ORDER);\n\t}\n\tdefault_hstate_idx = hstate_index(size_to_hstate(default_hstate_size));\n\tif (default_hstate_max_huge_pages) {\n\t\tif (!default_hstate.max_huge_pages)\n\t\t\tdefault_hstate.max_huge_pages = default_hstate_max_huge_pages;\n\t}\n\n\thugetlb_init_hstates();\n\tgather_bootmem_prealloc();\n\treport_hugepages();\n\n\thugetlb_sysfs_init();\n\thugetlb_register_all_nodes();\n\thugetlb_cgroup_file_init();\n\n#ifdef CONFIG_SMP\n\tnum_fault_mutexes = roundup_pow_of_two(8 * num_possible_cpus());\n#else\n\tnum_fault_mutexes = 1;\n#endif\n\thugetlb_fault_mutex_table =\n\t\tkmalloc_array(num_fault_mutexes, sizeof(struct mutex),\n\t\t\t      GFP_KERNEL);\n\tBUG_ON(!hugetlb_fault_mutex_table);\n\n\tfor (i = 0; i < num_fault_mutexes; i++)\n\t\tmutex_init(&hugetlb_fault_mutex_table[i]);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int default_hstate_idx;",
      "static unsigned long __initdata default_hstate_max_huge_pages;",
      "static unsigned long __initdata default_hstate_size;",
      "static int num_fault_mutexes;",
      "struct mutex *hugetlb_fault_mutex_table"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&hugetlb_fault_mutex_table[i]"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!hugetlb_fault_mutex_table"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "num_fault_mutexes",
            "sizeof(struct mutex)",
            "GFP_KERNEL"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "8 * num_possible_cpus()"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_file_init",
          "args": [],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_file_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "397-410",
          "snippet": "void __init hugetlb_cgroup_file_init(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\t/*\n\t\t * Add cgroup control files only if the huge page consists\n\t\t * of more than two normal pages. This is because we use\n\t\t * page[2].private for storing cgroup details.\n\t\t */\n\t\tif (huge_page_order(h) >= HUGETLB_CGROUP_MIN_ORDER)\n\t\t\t__hugetlb_cgroup_file_init(hstate_index(h));\n\t}\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nvoid __init hugetlb_cgroup_file_init(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\t/*\n\t\t * Add cgroup control files only if the huge page consists\n\t\t * of more than two normal pages. This is because we use\n\t\t * page[2].private for storing cgroup details.\n\t\t */\n\t\tif (huge_page_order(h) >= HUGETLB_CGROUP_MIN_ORDER)\n\t\t\t__hugetlb_cgroup_file_init(hstate_index(h));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_register_all_nodes",
          "args": [],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_register_all_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2754-2754",
          "snippet": "static void hugetlb_register_all_nodes(void) { }",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void hugetlb_register_all_nodes(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_sysfs_init",
          "args": [],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_sysfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2597-2612",
          "snippet": "static void __init hugetlb_sysfs_init(void)\n{\n\tstruct hstate *h;\n\tint err;\n\n\thugepages_kobj = kobject_create_and_add(\"hugepages\", mm_kobj);\n\tif (!hugepages_kobj)\n\t\treturn;\n\n\tfor_each_hstate(h) {\n\t\terr = hugetlb_sysfs_add_hstate(h, hugepages_kobj,\n\t\t\t\t\t hstate_kobjs, &hstate_attr_group);\n\t\tif (err)\n\t\t\tpr_err(\"Hugetlb: Unable to add hstate %s\", h->name);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *hugepages_kobj;",
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
            "static const struct attribute_group hstate_attr_group = {\n\t.attrs = hstate_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct kobject *hugepages_kobj;\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic const struct attribute_group hstate_attr_group = {\n\t.attrs = hstate_attrs,\n};\n\nstatic void __init hugetlb_sysfs_init(void)\n{\n\tstruct hstate *h;\n\tint err;\n\n\thugepages_kobj = kobject_create_and_add(\"hugepages\", mm_kobj);\n\tif (!hugepages_kobj)\n\t\treturn;\n\n\tfor_each_hstate(h) {\n\t\terr = hugetlb_sysfs_add_hstate(h, hugepages_kobj,\n\t\t\t\t\t hstate_kobjs, &hstate_attr_group);\n\t\tif (err)\n\t\t\tpr_err(\"Hugetlb: Unable to add hstate %s\", h->name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_hugepages",
          "args": [],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "report_hugepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2201-2212",
          "snippet": "static void __init report_hugepages(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_info(\"HugeTLB registered %s page size, pre-allocated %ld pages\\n\",\n\t\t\tbuf, h->free_huge_pages);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init report_hugepages(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_info(\"HugeTLB registered %s page size, pre-allocated %ld pages\\n\",\n\t\t\tbuf, h->free_huge_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gather_bootmem_prealloc",
          "args": [],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "gather_bootmem_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2137-2161",
          "snippet": "static void __init gather_bootmem_prealloc(void)\n{\n\tstruct huge_bootmem_page *m;\n\n\tlist_for_each_entry(m, &huge_boot_pages, list) {\n\t\tstruct page *page = virt_to_page(m);\n\t\tstruct hstate *h = m->hstate;\n\n\t\tWARN_ON(page_count(page) != 1);\n\t\tprep_compound_huge_page(page, h->order);\n\t\tWARN_ON(PageReserved(page));\n\t\tprep_new_huge_page(h, page, page_to_nid(page));\n\t\tput_page(page); /* free it into the hugepage allocator */\n\n\t\t/*\n\t\t * If we had gigantic hugepages allocated at boot time, we need\n\t\t * to restore the 'stolen' pages to totalram_pages in order to\n\t\t * fix confusing memory reports from free(1) and another\n\t\t * side-effects, like CommitLimit going negative.\n\t\t */\n\t\tif (hstate_is_gigantic(h))\n\t\t\tadjust_managed_page_count(page, 1 << h->order);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__initdata LIST_HEAD(huge_boot_pages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n__initdata LIST_HEAD(huge_boot_pages);\n\nstatic void __init gather_bootmem_prealloc(void)\n{\n\tstruct huge_bootmem_page *m;\n\n\tlist_for_each_entry(m, &huge_boot_pages, list) {\n\t\tstruct page *page = virt_to_page(m);\n\t\tstruct hstate *h = m->hstate;\n\n\t\tWARN_ON(page_count(page) != 1);\n\t\tprep_compound_huge_page(page, h->order);\n\t\tWARN_ON(PageReserved(page));\n\t\tprep_new_huge_page(h, page, page_to_nid(page));\n\t\tput_page(page); /* free it into the hugepage allocator */\n\n\t\t/*\n\t\t * If we had gigantic hugepages allocated at boot time, we need\n\t\t * to restore the 'stolen' pages to totalram_pages in order to\n\t\t * fix confusing memory reports from free(1) and another\n\t\t * side-effects, like CommitLimit going negative.\n\t\t */\n\t\tif (hstate_is_gigantic(h))\n\t\t\tadjust_managed_page_count(page, 1 << h->order);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_init_hstates",
          "args": [],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_init_hstates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2186-2199",
          "snippet": "static void __init hugetlb_init_hstates(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tif (minimum_order > huge_page_order(h))\n\t\t\tminimum_order = huge_page_order(h);\n\n\t\t/* oversize hugepages were init'ed in early boot */\n\t\tif (!hstate_is_gigantic(h))\n\t\t\thugetlb_hstate_alloc_pages(h);\n\t}\n\tVM_BUG_ON(minimum_order == UINT_MAX);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int minimum_order"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned int minimum_order;\n\nstatic void __init hugetlb_init_hstates(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tif (minimum_order > huge_page_order(h))\n\t\t\tminimum_order = huge_page_order(h);\n\n\t\t/* oversize hugepages were init'ed in early boot */\n\t\tif (!hstate_is_gigantic(h))\n\t\t\thugetlb_hstate_alloc_pages(h);\n\t}\n\tVM_BUG_ON(minimum_order == UINT_MAX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_index",
          "args": [
            "size_to_hstate(default_hstate_size)"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_to_hstate",
          "args": [
            "default_hstate_size"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "size_to_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1181-1190",
          "snippet": "struct hstate *size_to_hstate(unsigned long size)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tif (huge_page_size(h) == size)\n\t\t\treturn h;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate *size_to_hstate(unsigned long size)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tif (huge_page_size(h) == size)\n\t\t\treturn h;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_add_hstate",
          "args": [
            "HUGETLB_PAGE_ORDER"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_add_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2811-2836",
          "snippet": "void __init hugetlb_add_hstate(unsigned int order)\n{\n\tstruct hstate *h;\n\tunsigned long i;\n\n\tif (size_to_hstate(PAGE_SIZE << order)) {\n\t\tpr_warn(\"hugepagesz= specified twice, ignoring\\n\");\n\t\treturn;\n\t}\n\tBUG_ON(hugetlb_max_hstate >= HUGE_MAX_HSTATE);\n\tBUG_ON(order == 0);\n\th = &hstates[hugetlb_max_hstate++];\n\th->order = order;\n\th->mask = ~((1ULL << (order + PAGE_SHIFT)) - 1);\n\th->nr_huge_pages = 0;\n\th->free_huge_pages = 0;\n\tfor (i = 0; i < MAX_NUMNODES; ++i)\n\t\tINIT_LIST_HEAD(&h->hugepage_freelists[i]);\n\tINIT_LIST_HEAD(&h->hugepage_activelist);\n\th->next_nid_to_alloc = first_memory_node;\n\th->next_nid_to_free = first_memory_node;\n\tsnprintf(h->name, HSTATE_NAME_LEN, \"hugepages-%lukB\",\n\t\t\t\t\thuge_page_size(h)/1024);\n\n\tparsed_hstate = h;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hugetlb_max_hstate",
            "struct hstate hstates[HUGE_MAX_HSTATE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint hugetlb_max_hstate;\nstruct hstate hstates[HUGE_MAX_HSTATE];\n\nvoid __init hugetlb_add_hstate(unsigned int order)\n{\n\tstruct hstate *h;\n\tunsigned long i;\n\n\tif (size_to_hstate(PAGE_SIZE << order)) {\n\t\tpr_warn(\"hugepagesz= specified twice, ignoring\\n\");\n\t\treturn;\n\t}\n\tBUG_ON(hugetlb_max_hstate >= HUGE_MAX_HSTATE);\n\tBUG_ON(order == 0);\n\th = &hstates[hugetlb_max_hstate++];\n\th->order = order;\n\th->mask = ~((1ULL << (order + PAGE_SHIFT)) - 1);\n\th->nr_huge_pages = 0;\n\th->free_huge_pages = 0;\n\tfor (i = 0; i < MAX_NUMNODES; ++i)\n\t\tINIT_LIST_HEAD(&h->hugepage_freelists[i]);\n\tINIT_LIST_HEAD(&h->hugepage_activelist);\n\th->next_nid_to_alloc = first_memory_node;\n\th->next_nid_to_free = first_memory_node;\n\tsnprintf(h->name, HSTATE_NAME_LEN, \"hugepages-%lukB\",\n\t\t\t\t\thuge_page_size(h)/1024);\n\n\tparsed_hstate = h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"HugeTLB: unsupported default_hugepagesz %lu. Reverting to %lu\\n\"",
            "default_hstate_size",
            "HPAGE_SIZE"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepages_supported",
          "args": [],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nunsigned int default_hstate_idx;\nstatic unsigned long __initdata default_hstate_max_huge_pages;\nstatic unsigned long __initdata default_hstate_size;\nstatic int num_fault_mutexes;\nstruct mutex *hugetlb_fault_mutex_table;\n\nstatic int __init hugetlb_init(void)\n{\n\tint i;\n\n\tif (!hugepages_supported())\n\t\treturn 0;\n\n\tif (!size_to_hstate(default_hstate_size)) {\n\t\tif (default_hstate_size != 0) {\n\t\t\tpr_err(\"HugeTLB: unsupported default_hugepagesz %lu. Reverting to %lu\\n\",\n\t\t\t       default_hstate_size, HPAGE_SIZE);\n\t\t}\n\n\t\tdefault_hstate_size = HPAGE_SIZE;\n\t\tif (!size_to_hstate(default_hstate_size))\n\t\t\thugetlb_add_hstate(HUGETLB_PAGE_ORDER);\n\t}\n\tdefault_hstate_idx = hstate_index(size_to_hstate(default_hstate_size));\n\tif (default_hstate_max_huge_pages) {\n\t\tif (!default_hstate.max_huge_pages)\n\t\t\tdefault_hstate.max_huge_pages = default_hstate_max_huge_pages;\n\t}\n\n\thugetlb_init_hstates();\n\tgather_bootmem_prealloc();\n\treport_hugepages();\n\n\thugetlb_sysfs_init();\n\thugetlb_register_all_nodes();\n\thugetlb_cgroup_file_init();\n\n#ifdef CONFIG_SMP\n\tnum_fault_mutexes = roundup_pow_of_two(8 * num_possible_cpus());\n#else\n\tnum_fault_mutexes = 1;\n#endif\n\thugetlb_fault_mutex_table =\n\t\tkmalloc_array(num_fault_mutexes, sizeof(struct mutex),\n\t\t\t      GFP_KERNEL);\n\tBUG_ON(!hugetlb_fault_mutex_table);\n\n\tfor (i = 0; i < num_fault_mutexes; i++)\n\t\tmutex_init(&hugetlb_fault_mutex_table[i]);\n\treturn 0;\n}"
  },
  {
    "function_name": "hugetlb_register_all_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2754-2754",
    "snippet": "static void hugetlb_register_all_nodes(void) { }",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void hugetlb_register_all_nodes(void) { }"
  },
  {
    "function_name": "kobj_to_node_hstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2746-2752",
    "snippet": "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp)\n{\n\tBUG();\n\tif (nidp)\n\t\t*nidp = -1;\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);\n\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp)\n{\n\tBUG();\n\tif (nidp)\n\t\t*nidp = -1;\n\treturn NULL;\n}"
  },
  {
    "function_name": "hugetlb_register_all_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2727-2743",
    "snippet": "static void __init hugetlb_register_all_nodes(void)\n{\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tstruct node *node = node_devices[nid];\n\t\tif (node->dev.id == nid)\n\t\t\thugetlb_register_node(node);\n\t}\n\n\t/*\n\t * Let the node device driver know we're here so it can\n\t * [un]register hstate attributes on node hotplug.\n\t */\n\tregister_hugetlbfs_with_node(hugetlb_register_node,\n\t\t\t\t     hugetlb_unregister_node);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_hugetlbfs_with_node",
          "args": [
            "hugetlb_register_node",
            "hugetlb_unregister_node"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_register_node",
          "args": [
            "node"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_register_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2695-2720",
          "snippet": "static void hugetlb_register_node(struct node *node)\n{\n\tstruct hstate *h;\n\tstruct node_hstate *nhs = &node_hstates[node->dev.id];\n\tint err;\n\n\tif (nhs->hugepages_kobj)\n\t\treturn;\t\t/* already allocated */\n\n\tnhs->hugepages_kobj = kobject_create_and_add(\"hugepages\",\n\t\t\t\t\t\t\t&node->dev.kobj);\n\tif (!nhs->hugepages_kobj)\n\t\treturn;\n\n\tfor_each_hstate(h) {\n\t\terr = hugetlb_sysfs_add_hstate(h, nhs->hugepages_kobj,\n\t\t\t\t\t\tnhs->hstate_kobjs,\n\t\t\t\t\t\t&per_node_hstate_attr_group);\n\t\tif (err) {\n\t\t\tpr_err(\"Hugetlb: Unable to add hstate %s for node %d\\n\",\n\t\t\t\th->name, node->dev.id);\n\t\t\thugetlb_unregister_node(node);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *hugepages_kobj;",
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct kobject *hugepages_kobj;\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\n\nstatic void hugetlb_register_node(struct node *node)\n{\n\tstruct hstate *h;\n\tstruct node_hstate *nhs = &node_hstates[node->dev.id];\n\tint err;\n\n\tif (nhs->hugepages_kobj)\n\t\treturn;\t\t/* already allocated */\n\n\tnhs->hugepages_kobj = kobject_create_and_add(\"hugepages\",\n\t\t\t\t\t\t\t&node->dev.kobj);\n\tif (!nhs->hugepages_kobj)\n\t\treturn;\n\n\tfor_each_hstate(h) {\n\t\terr = hugetlb_sysfs_add_hstate(h, nhs->hugepages_kobj,\n\t\t\t\t\t\tnhs->hstate_kobjs,\n\t\t\t\t\t\t&per_node_hstate_attr_group);\n\t\tif (err) {\n\t\t\tpr_err(\"Hugetlb: Unable to add hstate %s for node %d\\n\",\n\t\t\t\th->name, node->dev.id);\n\t\t\thugetlb_unregister_node(node);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init hugetlb_register_all_nodes(void)\n{\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tstruct node *node = node_devices[nid];\n\t\tif (node->dev.id == nid)\n\t\t\thugetlb_register_node(node);\n\t}\n\n\t/*\n\t * Let the node device driver know we're here so it can\n\t * [un]register hstate attributes on node hotplug.\n\t */\n\tregister_hugetlbfs_with_node(hugetlb_register_node,\n\t\t\t\t     hugetlb_unregister_node);\n}"
  },
  {
    "function_name": "hugetlb_register_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2695-2720",
    "snippet": "static void hugetlb_register_node(struct node *node)\n{\n\tstruct hstate *h;\n\tstruct node_hstate *nhs = &node_hstates[node->dev.id];\n\tint err;\n\n\tif (nhs->hugepages_kobj)\n\t\treturn;\t\t/* already allocated */\n\n\tnhs->hugepages_kobj = kobject_create_and_add(\"hugepages\",\n\t\t\t\t\t\t\t&node->dev.kobj);\n\tif (!nhs->hugepages_kobj)\n\t\treturn;\n\n\tfor_each_hstate(h) {\n\t\terr = hugetlb_sysfs_add_hstate(h, nhs->hugepages_kobj,\n\t\t\t\t\t\tnhs->hstate_kobjs,\n\t\t\t\t\t\t&per_node_hstate_attr_group);\n\t\tif (err) {\n\t\t\tpr_err(\"Hugetlb: Unable to add hstate %s for node %d\\n\",\n\t\t\t\th->name, node->dev.id);\n\t\t\thugetlb_unregister_node(node);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *hugepages_kobj;",
      "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_unregister_node",
          "args": [
            "node"
          ],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_unregister_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2670-2688",
          "snippet": "static void hugetlb_unregister_node(struct node *node)\n{\n\tstruct hstate *h;\n\tstruct node_hstate *nhs = &node_hstates[node->dev.id];\n\n\tif (!nhs->hugepages_kobj)\n\t\treturn;\t\t/* no hstate attributes */\n\n\tfor_each_hstate(h) {\n\t\tint idx = hstate_index(h);\n\t\tif (nhs->hstate_kobjs[idx]) {\n\t\t\tkobject_put(nhs->hstate_kobjs[idx]);\n\t\t\tnhs->hstate_kobjs[idx] = NULL;\n\t\t}\n\t}\n\n\tkobject_put(nhs->hugepages_kobj);\n\tnhs->hugepages_kobj = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *hugepages_kobj;",
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct kobject *hugepages_kobj;\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\n\nstatic void hugetlb_unregister_node(struct node *node)\n{\n\tstruct hstate *h;\n\tstruct node_hstate *nhs = &node_hstates[node->dev.id];\n\n\tif (!nhs->hugepages_kobj)\n\t\treturn;\t\t/* no hstate attributes */\n\n\tfor_each_hstate(h) {\n\t\tint idx = hstate_index(h);\n\t\tif (nhs->hstate_kobjs[idx]) {\n\t\t\tkobject_put(nhs->hstate_kobjs[idx]);\n\t\t\tnhs->hstate_kobjs[idx] = NULL;\n\t\t}\n\t}\n\n\tkobject_put(nhs->hugepages_kobj);\n\tnhs->hugepages_kobj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Hugetlb: Unable to add hstate %s for node %d\\n\"",
            "h->name",
            "node->dev.id"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_sysfs_add_hstate",
          "args": [
            "h",
            "nhs->hugepages_kobj",
            "nhs->hstate_kobjs",
            "&per_node_hstate_attr_group"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_sysfs_add_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2579-2595",
          "snippet": "static int hugetlb_sysfs_add_hstate(struct hstate *h, struct kobject *parent,\n\t\t\t\t    struct kobject **hstate_kobjs,\n\t\t\t\t    const struct attribute_group *hstate_attr_group)\n{\n\tint retval;\n\tint hi = hstate_index(h);\n\n\thstate_kobjs[hi] = kobject_create_and_add(h->name, parent);\n\tif (!hstate_kobjs[hi])\n\t\treturn -ENOMEM;\n\n\tretval = sysfs_create_group(hstate_kobjs[hi], hstate_attr_group);\n\tif (retval)\n\t\tkobject_put(hstate_kobjs[hi]);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
            "static const struct attribute_group hstate_attr_group = {\n\t.attrs = hstate_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic const struct attribute_group hstate_attr_group = {\n\t.attrs = hstate_attrs,\n};\n\nstatic int hugetlb_sysfs_add_hstate(struct hstate *h, struct kobject *parent,\n\t\t\t\t    struct kobject **hstate_kobjs,\n\t\t\t\t    const struct attribute_group *hstate_attr_group)\n{\n\tint retval;\n\tint hi = hstate_index(h);\n\n\thstate_kobjs[hi] = kobject_create_and_add(h->name, parent);\n\tif (!hstate_kobjs[hi])\n\t\treturn -ENOMEM;\n\n\tretval = sysfs_create_group(hstate_kobjs[hi], hstate_attr_group);\n\tif (retval)\n\t\tkobject_put(hstate_kobjs[hi]);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"hugepages\"",
            "&node->dev.kobj"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct kobject *hugepages_kobj;\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\n\nstatic void hugetlb_register_node(struct node *node)\n{\n\tstruct hstate *h;\n\tstruct node_hstate *nhs = &node_hstates[node->dev.id];\n\tint err;\n\n\tif (nhs->hugepages_kobj)\n\t\treturn;\t\t/* already allocated */\n\n\tnhs->hugepages_kobj = kobject_create_and_add(\"hugepages\",\n\t\t\t\t\t\t\t&node->dev.kobj);\n\tif (!nhs->hugepages_kobj)\n\t\treturn;\n\n\tfor_each_hstate(h) {\n\t\terr = hugetlb_sysfs_add_hstate(h, nhs->hugepages_kobj,\n\t\t\t\t\t\tnhs->hstate_kobjs,\n\t\t\t\t\t\t&per_node_hstate_attr_group);\n\t\tif (err) {\n\t\t\tpr_err(\"Hugetlb: Unable to add hstate %s for node %d\\n\",\n\t\t\t\th->name, node->dev.id);\n\t\t\thugetlb_unregister_node(node);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "hugetlb_unregister_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2670-2688",
    "snippet": "static void hugetlb_unregister_node(struct node *node)\n{\n\tstruct hstate *h;\n\tstruct node_hstate *nhs = &node_hstates[node->dev.id];\n\n\tif (!nhs->hugepages_kobj)\n\t\treturn;\t\t/* no hstate attributes */\n\n\tfor_each_hstate(h) {\n\t\tint idx = hstate_index(h);\n\t\tif (nhs->hstate_kobjs[idx]) {\n\t\t\tkobject_put(nhs->hstate_kobjs[idx]);\n\t\t\tnhs->hstate_kobjs[idx] = NULL;\n\t\t}\n\t}\n\n\tkobject_put(nhs->hugepages_kobj);\n\tnhs->hugepages_kobj = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *hugepages_kobj;",
      "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "nhs->hugepages_kobj"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "nhs->hstate_kobjs[idx]"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_index",
          "args": [
            "h"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct kobject *hugepages_kobj;\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\n\nstatic void hugetlb_unregister_node(struct node *node)\n{\n\tstruct hstate *h;\n\tstruct node_hstate *nhs = &node_hstates[node->dev.id];\n\n\tif (!nhs->hugepages_kobj)\n\t\treturn;\t\t/* no hstate attributes */\n\n\tfor_each_hstate(h) {\n\t\tint idx = hstate_index(h);\n\t\tif (nhs->hstate_kobjs[idx]) {\n\t\t\tkobject_put(nhs->hstate_kobjs[idx]);\n\t\t\tnhs->hstate_kobjs[idx] = NULL;\n\t\t}\n\t}\n\n\tkobject_put(nhs->hugepages_kobj);\n\tnhs->hugepages_kobj = NULL;\n}"
  },
  {
    "function_name": "kobj_to_node_hstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2647-2664",
    "snippet": "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp)\n{\n\tint nid;\n\n\tfor (nid = 0; nid < nr_node_ids; nid++) {\n\t\tstruct node_hstate *nhs = &node_hstates[nid];\n\t\tint i;\n\t\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\t\tif (nhs->hstate_kobjs[i] == kobj) {\n\t\t\t\tif (nidp)\n\t\t\t\t\t*nidp = nid;\n\t\t\t\treturn &hstates[i];\n\t\t\t}\n\t}\n\n\tBUG();\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct hstate hstates[HUGE_MAX_HSTATE];",
      "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
      "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate hstates[HUGE_MAX_HSTATE];\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);\n\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp)\n{\n\tint nid;\n\n\tfor (nid = 0; nid < nr_node_ids; nid++) {\n\t\tstruct node_hstate *nhs = &node_hstates[nid];\n\t\tint i;\n\t\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\t\tif (nhs->hstate_kobjs[i] == kobj) {\n\t\t\t\tif (nidp)\n\t\t\t\t\t*nidp = nid;\n\t\t\t\treturn &hstates[i];\n\t\t\t}\n\t}\n\n\tBUG();\n\treturn NULL;\n}"
  },
  {
    "function_name": "hugetlb_sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2597-2612",
    "snippet": "static void __init hugetlb_sysfs_init(void)\n{\n\tstruct hstate *h;\n\tint err;\n\n\thugepages_kobj = kobject_create_and_add(\"hugepages\", mm_kobj);\n\tif (!hugepages_kobj)\n\t\treturn;\n\n\tfor_each_hstate(h) {\n\t\terr = hugetlb_sysfs_add_hstate(h, hugepages_kobj,\n\t\t\t\t\t hstate_kobjs, &hstate_attr_group);\n\t\tif (err)\n\t\t\tpr_err(\"Hugetlb: Unable to add hstate %s\", h->name);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *hugepages_kobj;",
      "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
      "static const struct attribute_group hstate_attr_group = {\n\t.attrs = hstate_attrs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Hugetlb: Unable to add hstate %s\"",
            "h->name"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_sysfs_add_hstate",
          "args": [
            "h",
            "hugepages_kobj",
            "hstate_kobjs",
            "&hstate_attr_group"
          ],
          "line": 2607
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_sysfs_add_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2579-2595",
          "snippet": "static int hugetlb_sysfs_add_hstate(struct hstate *h, struct kobject *parent,\n\t\t\t\t    struct kobject **hstate_kobjs,\n\t\t\t\t    const struct attribute_group *hstate_attr_group)\n{\n\tint retval;\n\tint hi = hstate_index(h);\n\n\thstate_kobjs[hi] = kobject_create_and_add(h->name, parent);\n\tif (!hstate_kobjs[hi])\n\t\treturn -ENOMEM;\n\n\tretval = sysfs_create_group(hstate_kobjs[hi], hstate_attr_group);\n\tif (retval)\n\t\tkobject_put(hstate_kobjs[hi]);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
            "static const struct attribute_group hstate_attr_group = {\n\t.attrs = hstate_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic const struct attribute_group hstate_attr_group = {\n\t.attrs = hstate_attrs,\n};\n\nstatic int hugetlb_sysfs_add_hstate(struct hstate *h, struct kobject *parent,\n\t\t\t\t    struct kobject **hstate_kobjs,\n\t\t\t\t    const struct attribute_group *hstate_attr_group)\n{\n\tint retval;\n\tint hi = hstate_index(h);\n\n\thstate_kobjs[hi] = kobject_create_and_add(h->name, parent);\n\tif (!hstate_kobjs[hi])\n\t\treturn -ENOMEM;\n\n\tretval = sysfs_create_group(hstate_kobjs[hi], hstate_attr_group);\n\tif (retval)\n\t\tkobject_put(hstate_kobjs[hi]);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"hugepages\"",
            "mm_kobj"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct kobject *hugepages_kobj;\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic const struct attribute_group hstate_attr_group = {\n\t.attrs = hstate_attrs,\n};\n\nstatic void __init hugetlb_sysfs_init(void)\n{\n\tstruct hstate *h;\n\tint err;\n\n\thugepages_kobj = kobject_create_and_add(\"hugepages\", mm_kobj);\n\tif (!hugepages_kobj)\n\t\treturn;\n\n\tfor_each_hstate(h) {\n\t\terr = hugetlb_sysfs_add_hstate(h, hugepages_kobj,\n\t\t\t\t\t hstate_kobjs, &hstate_attr_group);\n\t\tif (err)\n\t\t\tpr_err(\"Hugetlb: Unable to add hstate %s\", h->name);\n\t}\n}"
  },
  {
    "function_name": "hugetlb_sysfs_add_hstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2579-2595",
    "snippet": "static int hugetlb_sysfs_add_hstate(struct hstate *h, struct kobject *parent,\n\t\t\t\t    struct kobject **hstate_kobjs,\n\t\t\t\t    const struct attribute_group *hstate_attr_group)\n{\n\tint retval;\n\tint hi = hstate_index(h);\n\n\thstate_kobjs[hi] = kobject_create_and_add(h->name, parent);\n\tif (!hstate_kobjs[hi])\n\t\treturn -ENOMEM;\n\n\tretval = sysfs_create_group(hstate_kobjs[hi], hstate_attr_group);\n\tif (retval)\n\t\tkobject_put(hstate_kobjs[hi]);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
      "static const struct attribute_group hstate_attr_group = {\n\t.attrs = hstate_attrs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "hstate_kobjs[hi]"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "hstate_kobjs[hi]",
            "hstate_attr_group"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "h->name",
            "parent"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_index",
          "args": [
            "h"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic const struct attribute_group hstate_attr_group = {\n\t.attrs = hstate_attrs,\n};\n\nstatic int hugetlb_sysfs_add_hstate(struct hstate *h, struct kobject *parent,\n\t\t\t\t    struct kobject **hstate_kobjs,\n\t\t\t\t    const struct attribute_group *hstate_attr_group)\n{\n\tint retval;\n\tint hi = hstate_index(h);\n\n\thstate_kobjs[hi] = kobject_create_and_add(h->name, parent);\n\tif (!hstate_kobjs[hi])\n\t\treturn -ENOMEM;\n\n\tretval = sysfs_create_group(hstate_kobjs[hi], hstate_attr_group);\n\tif (retval)\n\t\tkobject_put(hstate_kobjs[hi]);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "surplus_hugepages_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2546-2560",
    "snippet": "static ssize_t surplus_hugepages_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long surplus_huge_pages;\n\tint nid;\n\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tsurplus_huge_pages = h->surplus_huge_pages;\n\telse\n\t\tsurplus_huge_pages = h->surplus_huge_pages_node[nid];\n\n\treturn sprintf(buf, \"%lu\\n\", surplus_huge_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "surplus_huge_pages"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobj_to_hstate",
          "args": [
            "kobj",
            "&nid"
          ],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "kobj_to_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2369-2381",
          "snippet": "static struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hstate hstates[HUGE_MAX_HSTATE];",
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
            "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate hstates[HUGE_MAX_HSTATE];\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);\n\nstatic struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t surplus_hugepages_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long surplus_huge_pages;\n\tint nid;\n\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tsurplus_huge_pages = h->surplus_huge_pages;\n\telse\n\t\tsurplus_huge_pages = h->surplus_huge_pages_node[nid];\n\n\treturn sprintf(buf, \"%lu\\n\", surplus_huge_pages);\n}"
  },
  {
    "function_name": "resv_hugepages_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2538-2543",
    "snippet": "static ssize_t resv_hugepages_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h = kobj_to_hstate(kobj, NULL);\n\treturn sprintf(buf, \"%lu\\n\", h->resv_huge_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "h->resv_huge_pages"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobj_to_hstate",
          "args": [
            "kobj",
            "NULL"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "kobj_to_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2369-2381",
          "snippet": "static struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hstate hstates[HUGE_MAX_HSTATE];",
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
            "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate hstates[HUGE_MAX_HSTATE];\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);\n\nstatic struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t resv_hugepages_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h = kobj_to_hstate(kobj, NULL);\n\treturn sprintf(buf, \"%lu\\n\", h->resv_huge_pages);\n}"
  },
  {
    "function_name": "free_hugepages_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2521-2535",
    "snippet": "static ssize_t free_hugepages_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long free_huge_pages;\n\tint nid;\n\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tfree_huge_pages = h->free_huge_pages;\n\telse\n\t\tfree_huge_pages = h->free_huge_pages_node[nid];\n\n\treturn sprintf(buf, \"%lu\\n\", free_huge_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "free_huge_pages"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobj_to_hstate",
          "args": [
            "kobj",
            "&nid"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "kobj_to_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2369-2381",
          "snippet": "static struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hstate hstates[HUGE_MAX_HSTATE];",
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
            "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate hstates[HUGE_MAX_HSTATE];\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);\n\nstatic struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t free_hugepages_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long free_huge_pages;\n\tint nid;\n\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tfree_huge_pages = h->free_huge_pages;\n\telse\n\t\tfree_huge_pages = h->free_huge_pages_node[nid];\n\n\treturn sprintf(buf, \"%lu\\n\", free_huge_pages);\n}"
  },
  {
    "function_name": "nr_overcommit_hugepages_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2499-2518",
    "snippet": "static ssize_t nr_overcommit_hugepages_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long input;\n\tstruct hstate *h = kobj_to_hstate(kobj, NULL);\n\n\tif (hstate_is_gigantic(h))\n\t\treturn -EINVAL;\n\n\terr = kstrtoul(buf, 10, &input);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock(&hugetlb_lock);\n\th->nr_overcommit_huge_pages = input;\n\tspin_unlock(&hugetlb_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&input"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobj_to_hstate",
          "args": [
            "kobj",
            "NULL"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "kobj_to_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2369-2381",
          "snippet": "static struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hstate hstates[HUGE_MAX_HSTATE];",
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
            "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate hstates[HUGE_MAX_HSTATE];\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);\n\nstatic struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_overcommit_hugepages_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long input;\n\tstruct hstate *h = kobj_to_hstate(kobj, NULL);\n\n\tif (hstate_is_gigantic(h))\n\t\treturn -EINVAL;\n\n\terr = kstrtoul(buf, 10, &input);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock(&hugetlb_lock);\n\th->nr_overcommit_huge_pages = input;\n\tspin_unlock(&hugetlb_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nr_overcommit_hugepages_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2492-2497",
    "snippet": "static ssize_t nr_overcommit_hugepages_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h = kobj_to_hstate(kobj, NULL);\n\treturn sprintf(buf, \"%lu\\n\", h->nr_overcommit_huge_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "h->nr_overcommit_huge_pages"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobj_to_hstate",
          "args": [
            "kobj",
            "NULL"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "kobj_to_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2369-2381",
          "snippet": "static struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hstate hstates[HUGE_MAX_HSTATE];",
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
            "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate hstates[HUGE_MAX_HSTATE];\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);\n\nstatic struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_overcommit_hugepages_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h = kobj_to_hstate(kobj, NULL);\n\treturn sprintf(buf, \"%lu\\n\", h->nr_overcommit_huge_pages);\n}"
  },
  {
    "function_name": "nr_hugepages_mempolicy_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2483-2487",
    "snippet": "static ssize_t nr_hugepages_mempolicy_store(struct kobject *kobj,\n\t       struct kobj_attribute *attr, const char *buf, size_t len)\n{\n\treturn nr_hugepages_store_common(true, kobj, buf, len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_hugepages_store_common",
          "args": [
            "true",
            "kobj",
            "buf",
            "len"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "nr_hugepages_store_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2441-2456",
          "snippet": "static ssize_t nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t struct kobject *kobj, const char *buf,\n\t\t\t\t\t size_t len)\n{\n\tstruct hstate *h;\n\tunsigned long count;\n\tint nid;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &count);\n\tif (err)\n\t\treturn err;\n\n\th = kobj_to_hstate(kobj, &nid);\n\treturn __nr_hugepages_store_common(obey_mempolicy, h, nid, count, len);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t struct kobject *kobj, const char *buf,\n\t\t\t\t\t size_t len)\n{\n\tstruct hstate *h;\n\tunsigned long count;\n\tint nid;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &count);\n\tif (err)\n\t\treturn err;\n\n\th = kobj_to_hstate(kobj, &nid);\n\treturn __nr_hugepages_store_common(obey_mempolicy, h, nid, count, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_hugepages_mempolicy_store(struct kobject *kobj,\n\t       struct kobj_attribute *attr, const char *buf, size_t len)\n{\n\treturn nr_hugepages_store_common(true, kobj, buf, len);\n}"
  },
  {
    "function_name": "nr_hugepages_mempolicy_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2477-2481",
    "snippet": "static ssize_t nr_hugepages_mempolicy_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn nr_hugepages_show_common(kobj, attr, buf);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_hugepages_show_common",
          "args": [
            "kobj",
            "attr",
            "buf"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "nr_hugepages_show_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2383-2397",
          "snippet": "static ssize_t nr_hugepages_show_common(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long nr_huge_pages;\n\tint nid;\n\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tnr_huge_pages = h->nr_huge_pages;\n\telse\n\t\tnr_huge_pages = h->nr_huge_pages_node[nid];\n\n\treturn sprintf(buf, \"%lu\\n\", nr_huge_pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_hugepages_show_common(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long nr_huge_pages;\n\tint nid;\n\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tnr_huge_pages = h->nr_huge_pages;\n\telse\n\t\tnr_huge_pages = h->nr_huge_pages_node[nid];\n\n\treturn sprintf(buf, \"%lu\\n\", nr_huge_pages);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_hugepages_mempolicy_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn nr_hugepages_show_common(kobj, attr, buf);\n}"
  },
  {
    "function_name": "nr_hugepages_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2464-2468",
    "snippet": "static ssize_t nr_hugepages_store(struct kobject *kobj,\n\t       struct kobj_attribute *attr, const char *buf, size_t len)\n{\n\treturn nr_hugepages_store_common(false, kobj, buf, len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_hugepages_store_common",
          "args": [
            "false",
            "kobj",
            "buf",
            "len"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "nr_hugepages_store_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2441-2456",
          "snippet": "static ssize_t nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t struct kobject *kobj, const char *buf,\n\t\t\t\t\t size_t len)\n{\n\tstruct hstate *h;\n\tunsigned long count;\n\tint nid;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &count);\n\tif (err)\n\t\treturn err;\n\n\th = kobj_to_hstate(kobj, &nid);\n\treturn __nr_hugepages_store_common(obey_mempolicy, h, nid, count, len);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t struct kobject *kobj, const char *buf,\n\t\t\t\t\t size_t len)\n{\n\tstruct hstate *h;\n\tunsigned long count;\n\tint nid;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &count);\n\tif (err)\n\t\treturn err;\n\n\th = kobj_to_hstate(kobj, &nid);\n\treturn __nr_hugepages_store_common(obey_mempolicy, h, nid, count, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_hugepages_store(struct kobject *kobj,\n\t       struct kobj_attribute *attr, const char *buf, size_t len)\n{\n\treturn nr_hugepages_store_common(false, kobj, buf, len);\n}"
  },
  {
    "function_name": "nr_hugepages_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2458-2462",
    "snippet": "static ssize_t nr_hugepages_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn nr_hugepages_show_common(kobj, attr, buf);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_hugepages_show_common",
          "args": [
            "kobj",
            "attr",
            "buf"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "nr_hugepages_show_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2383-2397",
          "snippet": "static ssize_t nr_hugepages_show_common(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long nr_huge_pages;\n\tint nid;\n\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tnr_huge_pages = h->nr_huge_pages;\n\telse\n\t\tnr_huge_pages = h->nr_huge_pages_node[nid];\n\n\treturn sprintf(buf, \"%lu\\n\", nr_huge_pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_hugepages_show_common(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long nr_huge_pages;\n\tint nid;\n\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tnr_huge_pages = h->nr_huge_pages;\n\telse\n\t\tnr_huge_pages = h->nr_huge_pages_node[nid];\n\n\treturn sprintf(buf, \"%lu\\n\", nr_huge_pages);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_hugepages_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn nr_hugepages_show_common(kobj, attr, buf);\n}"
  },
  {
    "function_name": "nr_hugepages_store_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2441-2456",
    "snippet": "static ssize_t nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t struct kobject *kobj, const char *buf,\n\t\t\t\t\t size_t len)\n{\n\tstruct hstate *h;\n\tunsigned long count;\n\tint nid;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &count);\n\tif (err)\n\t\treturn err;\n\n\th = kobj_to_hstate(kobj, &nid);\n\treturn __nr_hugepages_store_common(obey_mempolicy, h, nid, count, len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nr_hugepages_store_common",
          "args": [
            "obey_mempolicy",
            "h",
            "nid",
            "count",
            "len"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "__nr_hugepages_store_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2399-2439",
          "snippet": "static ssize_t __nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t   struct hstate *h, int nid,\n\t\t\t\t\t   unsigned long count, size_t len)\n{\n\tint err;\n\tNODEMASK_ALLOC(nodemask_t, nodes_allowed, GFP_KERNEL | __GFP_NORETRY);\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported()) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (nid == NUMA_NO_NODE) {\n\t\t/*\n\t\t * global hstate attribute\n\t\t */\n\t\tif (!(obey_mempolicy &&\n\t\t\t\tinit_nodemask_of_mempolicy(nodes_allowed))) {\n\t\t\tNODEMASK_FREE(nodes_allowed);\n\t\t\tnodes_allowed = &node_states[N_MEMORY];\n\t\t}\n\t} else if (nodes_allowed) {\n\t\t/*\n\t\t * per node hstate attribute: adjust count to global,\n\t\t * but restrict alloc/free to the specified node.\n\t\t */\n\t\tcount += h->nr_huge_pages - h->nr_huge_pages_node[nid];\n\t\tinit_nodemask_of_node(nodes_allowed, nid);\n\t} else\n\t\tnodes_allowed = &node_states[N_MEMORY];\n\n\th->max_huge_pages = set_max_huge_pages(h, count, nodes_allowed);\n\n\tif (nodes_allowed != &node_states[N_MEMORY])\n\t\tNODEMASK_FREE(nodes_allowed);\n\n\treturn len;\nout:\n\tNODEMASK_FREE(nodes_allowed);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t __nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t   struct hstate *h, int nid,\n\t\t\t\t\t   unsigned long count, size_t len)\n{\n\tint err;\n\tNODEMASK_ALLOC(nodemask_t, nodes_allowed, GFP_KERNEL | __GFP_NORETRY);\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported()) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (nid == NUMA_NO_NODE) {\n\t\t/*\n\t\t * global hstate attribute\n\t\t */\n\t\tif (!(obey_mempolicy &&\n\t\t\t\tinit_nodemask_of_mempolicy(nodes_allowed))) {\n\t\t\tNODEMASK_FREE(nodes_allowed);\n\t\t\tnodes_allowed = &node_states[N_MEMORY];\n\t\t}\n\t} else if (nodes_allowed) {\n\t\t/*\n\t\t * per node hstate attribute: adjust count to global,\n\t\t * but restrict alloc/free to the specified node.\n\t\t */\n\t\tcount += h->nr_huge_pages - h->nr_huge_pages_node[nid];\n\t\tinit_nodemask_of_node(nodes_allowed, nid);\n\t} else\n\t\tnodes_allowed = &node_states[N_MEMORY];\n\n\th->max_huge_pages = set_max_huge_pages(h, count, nodes_allowed);\n\n\tif (nodes_allowed != &node_states[N_MEMORY])\n\t\tNODEMASK_FREE(nodes_allowed);\n\n\treturn len;\nout:\n\tNODEMASK_FREE(nodes_allowed);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobj_to_hstate",
          "args": [
            "kobj",
            "&nid"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "kobj_to_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2369-2381",
          "snippet": "static struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hstate hstates[HUGE_MAX_HSTATE];",
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
            "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate hstates[HUGE_MAX_HSTATE];\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);\n\nstatic struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&count"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t struct kobject *kobj, const char *buf,\n\t\t\t\t\t size_t len)\n{\n\tstruct hstate *h;\n\tunsigned long count;\n\tint nid;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &count);\n\tif (err)\n\t\treturn err;\n\n\th = kobj_to_hstate(kobj, &nid);\n\treturn __nr_hugepages_store_common(obey_mempolicy, h, nid, count, len);\n}"
  },
  {
    "function_name": "__nr_hugepages_store_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2399-2439",
    "snippet": "static ssize_t __nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t   struct hstate *h, int nid,\n\t\t\t\t\t   unsigned long count, size_t len)\n{\n\tint err;\n\tNODEMASK_ALLOC(nodemask_t, nodes_allowed, GFP_KERNEL | __GFP_NORETRY);\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported()) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (nid == NUMA_NO_NODE) {\n\t\t/*\n\t\t * global hstate attribute\n\t\t */\n\t\tif (!(obey_mempolicy &&\n\t\t\t\tinit_nodemask_of_mempolicy(nodes_allowed))) {\n\t\t\tNODEMASK_FREE(nodes_allowed);\n\t\t\tnodes_allowed = &node_states[N_MEMORY];\n\t\t}\n\t} else if (nodes_allowed) {\n\t\t/*\n\t\t * per node hstate attribute: adjust count to global,\n\t\t * but restrict alloc/free to the specified node.\n\t\t */\n\t\tcount += h->nr_huge_pages - h->nr_huge_pages_node[nid];\n\t\tinit_nodemask_of_node(nodes_allowed, nid);\n\t} else\n\t\tnodes_allowed = &node_states[N_MEMORY];\n\n\th->max_huge_pages = set_max_huge_pages(h, count, nodes_allowed);\n\n\tif (nodes_allowed != &node_states[N_MEMORY])\n\t\tNODEMASK_FREE(nodes_allowed);\n\n\treturn len;\nout:\n\tNODEMASK_FREE(nodes_allowed);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NODEMASK_FREE",
          "args": [
            "nodes_allowed"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODEMASK_FREE",
          "args": [
            "nodes_allowed"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_max_huge_pages",
          "args": [
            "h",
            "count",
            "nodes_allowed"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "set_max_huge_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2278-2355",
          "snippet": "static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n\tunsigned long min_count, ret;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn h->max_huge_pages;\n\n\t/*\n\t * Increase the pool size\n\t * First take pages out of surplus state.  Then make up the\n\t * remaining difference by allocating fresh huge pages.\n\t *\n\t * We might race with alloc_surplus_huge_page() here and be unable\n\t * to convert a surplus huge page to a normal huge page. That is\n\t * not critical, though, it just means the overall size of the\n\t * pool might be one hugepage larger than it needs to be, but\n\t * within all the constraints specified by the sysctls.\n\t */\n\tspin_lock(&hugetlb_lock);\n\twhile (h->surplus_huge_pages && count > persistent_huge_pages(h)) {\n\t\tif (!adjust_pool_surplus(h, nodes_allowed, -1))\n\t\t\tbreak;\n\t}\n\n\twhile (count > persistent_huge_pages(h)) {\n\t\t/*\n\t\t * If this allocation races such that we no longer need the\n\t\t * page, free_huge_page will handle it by freeing the page\n\t\t * and reducing the surplus.\n\t\t */\n\t\tspin_unlock(&hugetlb_lock);\n\n\t\t/* yield cpu to avoid soft lockup */\n\t\tcond_resched();\n\n\t\tret = alloc_pool_huge_page(h, nodes_allowed);\n\t\tspin_lock(&hugetlb_lock);\n\t\tif (!ret)\n\t\t\tgoto out;\n\n\t\t/* Bail for signals. Probably ctrl-c from user */\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Decrease the pool size\n\t * First return free pages to the buddy allocator (being careful\n\t * to keep enough around to satisfy reservations).  Then place\n\t * pages into surplus state as needed so the pool will shrink\n\t * to the desired size as pages become free.\n\t *\n\t * By placing pages into the surplus state independent of the\n\t * overcommit value, we are allowing the surplus pool size to\n\t * exceed overcommit. There are few sane options here. Since\n\t * alloc_surplus_huge_page() is checking the global counter,\n\t * though, we'll note that we're not allowed to exceed surplus\n\t * and won't grow the pool anywhere else. Not until one of the\n\t * sysctls are changed, or the surplus pages go out of use.\n\t */\n\tmin_count = h->resv_huge_pages + h->nr_huge_pages - h->free_huge_pages;\n\tmin_count = max(count, min_count);\n\ttry_to_free_low(h, min_count, nodes_allowed);\n\twhile (min_count < persistent_huge_pages(h)) {\n\t\tif (!free_pool_huge_page(h, nodes_allowed, 0))\n\t\t\tbreak;\n\t\tcond_resched_lock(&hugetlb_lock);\n\t}\n\twhile (count < persistent_huge_pages(h)) {\n\t\tif (!adjust_pool_surplus(h, nodes_allowed, 1))\n\t\t\tbreak;\n\t}\nout:\n\tret = persistent_huge_pages(h);\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n\tunsigned long min_count, ret;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn h->max_huge_pages;\n\n\t/*\n\t * Increase the pool size\n\t * First take pages out of surplus state.  Then make up the\n\t * remaining difference by allocating fresh huge pages.\n\t *\n\t * We might race with alloc_surplus_huge_page() here and be unable\n\t * to convert a surplus huge page to a normal huge page. That is\n\t * not critical, though, it just means the overall size of the\n\t * pool might be one hugepage larger than it needs to be, but\n\t * within all the constraints specified by the sysctls.\n\t */\n\tspin_lock(&hugetlb_lock);\n\twhile (h->surplus_huge_pages && count > persistent_huge_pages(h)) {\n\t\tif (!adjust_pool_surplus(h, nodes_allowed, -1))\n\t\t\tbreak;\n\t}\n\n\twhile (count > persistent_huge_pages(h)) {\n\t\t/*\n\t\t * If this allocation races such that we no longer need the\n\t\t * page, free_huge_page will handle it by freeing the page\n\t\t * and reducing the surplus.\n\t\t */\n\t\tspin_unlock(&hugetlb_lock);\n\n\t\t/* yield cpu to avoid soft lockup */\n\t\tcond_resched();\n\n\t\tret = alloc_pool_huge_page(h, nodes_allowed);\n\t\tspin_lock(&hugetlb_lock);\n\t\tif (!ret)\n\t\t\tgoto out;\n\n\t\t/* Bail for signals. Probably ctrl-c from user */\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Decrease the pool size\n\t * First return free pages to the buddy allocator (being careful\n\t * to keep enough around to satisfy reservations).  Then place\n\t * pages into surplus state as needed so the pool will shrink\n\t * to the desired size as pages become free.\n\t *\n\t * By placing pages into the surplus state independent of the\n\t * overcommit value, we are allowing the surplus pool size to\n\t * exceed overcommit. There are few sane options here. Since\n\t * alloc_surplus_huge_page() is checking the global counter,\n\t * though, we'll note that we're not allowed to exceed surplus\n\t * and won't grow the pool anywhere else. Not until one of the\n\t * sysctls are changed, or the surplus pages go out of use.\n\t */\n\tmin_count = h->resv_huge_pages + h->nr_huge_pages - h->free_huge_pages;\n\tmin_count = max(count, min_count);\n\ttry_to_free_low(h, min_count, nodes_allowed);\n\twhile (min_count < persistent_huge_pages(h)) {\n\t\tif (!free_pool_huge_page(h, nodes_allowed, 0))\n\t\t\tbreak;\n\t\tcond_resched_lock(&hugetlb_lock);\n\t}\n\twhile (count < persistent_huge_pages(h)) {\n\t\tif (!adjust_pool_surplus(h, nodes_allowed, 1))\n\t\t\tbreak;\n\t}\nout:\n\tret = persistent_huge_pages(h);\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_nodemask_of_node",
          "args": [
            "nodes_allowed",
            "nid"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODEMASK_FREE",
          "args": [
            "nodes_allowed"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_nodemask_of_mempolicy",
          "args": [
            "nodes_allowed"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "init_nodemask_of_mempolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1903-1934",
          "snippet": "bool init_nodemask_of_mempolicy(nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tint nid;\n\n\tif (!(mask && current->mempolicy))\n\t\treturn false;\n\n\ttask_lock(current);\n\tmempolicy = current->mempolicy;\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (mempolicy->flags & MPOL_F_LOCAL)\n\t\t\tnid = numa_node_id();\n\t\telse\n\t\t\tnid = mempolicy->v.preferred_node;\n\t\tinit_nodemask_of_node(mask, nid);\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*mask =  mempolicy->v.nodes;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\ttask_unlock(current);\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool init_nodemask_of_mempolicy(nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tint nid;\n\n\tif (!(mask && current->mempolicy))\n\t\treturn false;\n\n\ttask_lock(current);\n\tmempolicy = current->mempolicy;\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (mempolicy->flags & MPOL_F_LOCAL)\n\t\t\tnid = numa_node_id();\n\t\telse\n\t\t\tnid = mempolicy->v.preferred_node;\n\t\tinit_nodemask_of_node(mask, nid);\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*mask =  mempolicy->v.nodes;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\ttask_unlock(current);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gigantic_page_supported",
          "args": [],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "gigantic_page_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1147-1147",
          "snippet": "static inline bool gigantic_page_supported(void) { return false; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline bool gigantic_page_supported(void) { return false; }"
        }
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODEMASK_ALLOC",
          "args": [
            "nodemask_t",
            "nodes_allowed",
            "GFP_KERNEL | __GFP_NORETRY"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t __nr_hugepages_store_common(bool obey_mempolicy,\n\t\t\t\t\t   struct hstate *h, int nid,\n\t\t\t\t\t   unsigned long count, size_t len)\n{\n\tint err;\n\tNODEMASK_ALLOC(nodemask_t, nodes_allowed, GFP_KERNEL | __GFP_NORETRY);\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported()) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (nid == NUMA_NO_NODE) {\n\t\t/*\n\t\t * global hstate attribute\n\t\t */\n\t\tif (!(obey_mempolicy &&\n\t\t\t\tinit_nodemask_of_mempolicy(nodes_allowed))) {\n\t\t\tNODEMASK_FREE(nodes_allowed);\n\t\t\tnodes_allowed = &node_states[N_MEMORY];\n\t\t}\n\t} else if (nodes_allowed) {\n\t\t/*\n\t\t * per node hstate attribute: adjust count to global,\n\t\t * but restrict alloc/free to the specified node.\n\t\t */\n\t\tcount += h->nr_huge_pages - h->nr_huge_pages_node[nid];\n\t\tinit_nodemask_of_node(nodes_allowed, nid);\n\t} else\n\t\tnodes_allowed = &node_states[N_MEMORY];\n\n\th->max_huge_pages = set_max_huge_pages(h, count, nodes_allowed);\n\n\tif (nodes_allowed != &node_states[N_MEMORY])\n\t\tNODEMASK_FREE(nodes_allowed);\n\n\treturn len;\nout:\n\tNODEMASK_FREE(nodes_allowed);\n\treturn err;\n}"
  },
  {
    "function_name": "nr_hugepages_show_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2383-2397",
    "snippet": "static ssize_t nr_hugepages_show_common(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long nr_huge_pages;\n\tint nid;\n\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tnr_huge_pages = h->nr_huge_pages;\n\telse\n\t\tnr_huge_pages = h->nr_huge_pages_node[nid];\n\n\treturn sprintf(buf, \"%lu\\n\", nr_huge_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "nr_huge_pages"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobj_to_hstate",
          "args": [
            "kobj",
            "&nid"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "kobj_to_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2369-2381",
          "snippet": "static struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hstate hstates[HUGE_MAX_HSTATE];",
            "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
            "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate hstates[HUGE_MAX_HSTATE];\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);\n\nstatic struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic ssize_t nr_hugepages_show_common(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long nr_huge_pages;\n\tint nid;\n\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tnr_huge_pages = h->nr_huge_pages;\n\telse\n\t\tnr_huge_pages = h->nr_huge_pages_node[nid];\n\n\treturn sprintf(buf, \"%lu\\n\", nr_huge_pages);\n}"
  },
  {
    "function_name": "kobj_to_hstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2369-2381",
    "snippet": "static struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct hstate hstates[HUGE_MAX_HSTATE];",
      "static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];",
      "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobj_to_node_hstate",
          "args": [
            "kobj",
            "nidp"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "kobj_to_node_hstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2746-2752",
          "snippet": "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp)\n{\n\tBUG();\n\tif (nidp)\n\t\t*nidp = -1;\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);\n\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp)\n{\n\tBUG();\n\tif (nidp)\n\t\t*nidp = -1;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate hstates[HUGE_MAX_HSTATE];\nstatic struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];\nstatic struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp);\n\nstatic struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\n\treturn kobj_to_node_hstate(kobj, nidp);\n}"
  },
  {
    "function_name": "set_max_huge_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2278-2355",
    "snippet": "static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n\tunsigned long min_count, ret;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn h->max_huge_pages;\n\n\t/*\n\t * Increase the pool size\n\t * First take pages out of surplus state.  Then make up the\n\t * remaining difference by allocating fresh huge pages.\n\t *\n\t * We might race with alloc_surplus_huge_page() here and be unable\n\t * to convert a surplus huge page to a normal huge page. That is\n\t * not critical, though, it just means the overall size of the\n\t * pool might be one hugepage larger than it needs to be, but\n\t * within all the constraints specified by the sysctls.\n\t */\n\tspin_lock(&hugetlb_lock);\n\twhile (h->surplus_huge_pages && count > persistent_huge_pages(h)) {\n\t\tif (!adjust_pool_surplus(h, nodes_allowed, -1))\n\t\t\tbreak;\n\t}\n\n\twhile (count > persistent_huge_pages(h)) {\n\t\t/*\n\t\t * If this allocation races such that we no longer need the\n\t\t * page, free_huge_page will handle it by freeing the page\n\t\t * and reducing the surplus.\n\t\t */\n\t\tspin_unlock(&hugetlb_lock);\n\n\t\t/* yield cpu to avoid soft lockup */\n\t\tcond_resched();\n\n\t\tret = alloc_pool_huge_page(h, nodes_allowed);\n\t\tspin_lock(&hugetlb_lock);\n\t\tif (!ret)\n\t\t\tgoto out;\n\n\t\t/* Bail for signals. Probably ctrl-c from user */\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Decrease the pool size\n\t * First return free pages to the buddy allocator (being careful\n\t * to keep enough around to satisfy reservations).  Then place\n\t * pages into surplus state as needed so the pool will shrink\n\t * to the desired size as pages become free.\n\t *\n\t * By placing pages into the surplus state independent of the\n\t * overcommit value, we are allowing the surplus pool size to\n\t * exceed overcommit. There are few sane options here. Since\n\t * alloc_surplus_huge_page() is checking the global counter,\n\t * though, we'll note that we're not allowed to exceed surplus\n\t * and won't grow the pool anywhere else. Not until one of the\n\t * sysctls are changed, or the surplus pages go out of use.\n\t */\n\tmin_count = h->resv_huge_pages + h->nr_huge_pages - h->free_huge_pages;\n\tmin_count = max(count, min_count);\n\ttry_to_free_low(h, min_count, nodes_allowed);\n\twhile (min_count < persistent_huge_pages(h)) {\n\t\tif (!free_pool_huge_page(h, nodes_allowed, 0))\n\t\t\tbreak;\n\t\tcond_resched_lock(&hugetlb_lock);\n\t}\n\twhile (count < persistent_huge_pages(h)) {\n\t\tif (!adjust_pool_surplus(h, nodes_allowed, 1))\n\t\t\tbreak;\n\t}\nout:\n\tret = persistent_huge_pages(h);\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_huge_pages",
          "args": [
            "h"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_pool_surplus",
          "args": [
            "h",
            "nodes_allowed",
            "1"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_pool_surplus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2250-2275",
          "snippet": "static int adjust_pool_surplus(struct hstate *h, nodemask_t *nodes_allowed,\n\t\t\t\tint delta)\n{\n\tint nr_nodes, node;\n\n\tVM_BUG_ON(delta != -1 && delta != 1);\n\n\tif (delta < 0) {\n\t\tfor_each_node_mask_to_alloc(h, nr_nodes, node, nodes_allowed) {\n\t\t\tif (h->surplus_huge_pages_node[node])\n\t\t\t\tgoto found;\n\t\t}\n\t} else {\n\t\tfor_each_node_mask_to_free(h, nr_nodes, node, nodes_allowed) {\n\t\t\tif (h->surplus_huge_pages_node[node] <\n\t\t\t\t\th->nr_huge_pages_node[node])\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\treturn 0;\n\nfound:\n\th->surplus_huge_pages += delta;\n\th->surplus_huge_pages_node[node] += delta;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int adjust_pool_surplus(struct hstate *h, nodemask_t *nodes_allowed,\n\t\t\t\tint delta)\n{\n\tint nr_nodes, node;\n\n\tVM_BUG_ON(delta != -1 && delta != 1);\n\n\tif (delta < 0) {\n\t\tfor_each_node_mask_to_alloc(h, nr_nodes, node, nodes_allowed) {\n\t\t\tif (h->surplus_huge_pages_node[node])\n\t\t\t\tgoto found;\n\t\t}\n\t} else {\n\t\tfor_each_node_mask_to_free(h, nr_nodes, node, nodes_allowed) {\n\t\t\tif (h->surplus_huge_pages_node[node] <\n\t\t\t\t\th->nr_huge_pages_node[node])\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\treturn 0;\n\nfound:\n\th->surplus_huge_pages += delta;\n\th->surplus_huge_pages_node[node] += delta;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "persistent_huge_pages",
          "args": [
            "h"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pool_huge_page",
          "args": [
            "h",
            "nodes_allowed",
            "0"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "free_pool_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1447-1477",
          "snippet": "static int free_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed,\n\t\t\t\t\t\t\t bool acct_surplus)\n{\n\tint nr_nodes, node;\n\tint ret = 0;\n\n\tfor_each_node_mask_to_free(h, nr_nodes, node, nodes_allowed) {\n\t\t/*\n\t\t * If we're returning unused surplus pages, only examine\n\t\t * nodes with surplus pages.\n\t\t */\n\t\tif ((!acct_surplus || h->surplus_huge_pages_node[node]) &&\n\t\t    !list_empty(&h->hugepage_freelists[node])) {\n\t\t\tstruct page *page =\n\t\t\t\tlist_entry(h->hugepage_freelists[node].next,\n\t\t\t\t\t  struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\th->free_huge_pages--;\n\t\t\th->free_huge_pages_node[node]--;\n\t\t\tif (acct_surplus) {\n\t\t\t\th->surplus_huge_pages--;\n\t\t\t\th->surplus_huge_pages_node[node]--;\n\t\t\t}\n\t\t\tupdate_and_free_page(h, page);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int free_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed,\n\t\t\t\t\t\t\t bool acct_surplus)\n{\n\tint nr_nodes, node;\n\tint ret = 0;\n\n\tfor_each_node_mask_to_free(h, nr_nodes, node, nodes_allowed) {\n\t\t/*\n\t\t * If we're returning unused surplus pages, only examine\n\t\t * nodes with surplus pages.\n\t\t */\n\t\tif ((!acct_surplus || h->surplus_huge_pages_node[node]) &&\n\t\t    !list_empty(&h->hugepage_freelists[node])) {\n\t\t\tstruct page *page =\n\t\t\t\tlist_entry(h->hugepage_freelists[node].next,\n\t\t\t\t\t  struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\th->free_huge_pages--;\n\t\t\th->free_huge_pages_node[node]--;\n\t\t\tif (acct_surplus) {\n\t\t\t\th->surplus_huge_pages--;\n\t\t\t\th->surplus_huge_pages_node[node]--;\n\t\t\t}\n\t\t\tupdate_and_free_page(h, page);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "persistent_huge_pages",
          "args": [
            "h"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_free_low",
          "args": [
            "h",
            "min_count",
            "nodes_allowed"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2239-2242",
          "snippet": "static inline void try_to_free_low(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void try_to_free_low(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "count",
            "min_count"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pool_huge_page",
          "args": [
            "h",
            "nodes_allowed"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pool_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1421-1439",
          "snippet": "static int alloc_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed)\n{\n\tstruct page *page;\n\tint nr_nodes, node;\n\tgfp_t gfp_mask = htlb_alloc_mask(h) | __GFP_THISNODE;\n\n\tfor_each_node_mask_to_alloc(h, nr_nodes, node, nodes_allowed) {\n\t\tpage = alloc_fresh_huge_page(h, gfp_mask, node, nodes_allowed);\n\t\tif (page)\n\t\t\tbreak;\n\t}\n\n\tif (!page)\n\t\treturn 0;\n\n\tput_page(page); /* free it into the hugepage allocator */\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int alloc_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed)\n{\n\tstruct page *page;\n\tint nr_nodes, node;\n\tgfp_t gfp_mask = htlb_alloc_mask(h) | __GFP_THISNODE;\n\n\tfor_each_node_mask_to_alloc(h, nr_nodes, node, nodes_allowed) {\n\t\tpage = alloc_fresh_huge_page(h, gfp_mask, node, nodes_allowed);\n\t\tif (page)\n\t\t\tbreak;\n\t}\n\n\tif (!page)\n\t\treturn 0;\n\n\tput_page(page); /* free it into the hugepage allocator */\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_huge_pages",
          "args": [
            "h"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_huge_pages",
          "args": [
            "h"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gigantic_page_supported",
          "args": [],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "gigantic_page_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1147-1147",
          "snippet": "static inline bool gigantic_page_supported(void) { return false; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline bool gigantic_page_supported(void) { return false; }"
        }
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n\tunsigned long min_count, ret;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn h->max_huge_pages;\n\n\t/*\n\t * Increase the pool size\n\t * First take pages out of surplus state.  Then make up the\n\t * remaining difference by allocating fresh huge pages.\n\t *\n\t * We might race with alloc_surplus_huge_page() here and be unable\n\t * to convert a surplus huge page to a normal huge page. That is\n\t * not critical, though, it just means the overall size of the\n\t * pool might be one hugepage larger than it needs to be, but\n\t * within all the constraints specified by the sysctls.\n\t */\n\tspin_lock(&hugetlb_lock);\n\twhile (h->surplus_huge_pages && count > persistent_huge_pages(h)) {\n\t\tif (!adjust_pool_surplus(h, nodes_allowed, -1))\n\t\t\tbreak;\n\t}\n\n\twhile (count > persistent_huge_pages(h)) {\n\t\t/*\n\t\t * If this allocation races such that we no longer need the\n\t\t * page, free_huge_page will handle it by freeing the page\n\t\t * and reducing the surplus.\n\t\t */\n\t\tspin_unlock(&hugetlb_lock);\n\n\t\t/* yield cpu to avoid soft lockup */\n\t\tcond_resched();\n\n\t\tret = alloc_pool_huge_page(h, nodes_allowed);\n\t\tspin_lock(&hugetlb_lock);\n\t\tif (!ret)\n\t\t\tgoto out;\n\n\t\t/* Bail for signals. Probably ctrl-c from user */\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Decrease the pool size\n\t * First return free pages to the buddy allocator (being careful\n\t * to keep enough around to satisfy reservations).  Then place\n\t * pages into surplus state as needed so the pool will shrink\n\t * to the desired size as pages become free.\n\t *\n\t * By placing pages into the surplus state independent of the\n\t * overcommit value, we are allowing the surplus pool size to\n\t * exceed overcommit. There are few sane options here. Since\n\t * alloc_surplus_huge_page() is checking the global counter,\n\t * though, we'll note that we're not allowed to exceed surplus\n\t * and won't grow the pool anywhere else. Not until one of the\n\t * sysctls are changed, or the surplus pages go out of use.\n\t */\n\tmin_count = h->resv_huge_pages + h->nr_huge_pages - h->free_huge_pages;\n\tmin_count = max(count, min_count);\n\ttry_to_free_low(h, min_count, nodes_allowed);\n\twhile (min_count < persistent_huge_pages(h)) {\n\t\tif (!free_pool_huge_page(h, nodes_allowed, 0))\n\t\t\tbreak;\n\t\tcond_resched_lock(&hugetlb_lock);\n\t}\n\twhile (count < persistent_huge_pages(h)) {\n\t\tif (!adjust_pool_surplus(h, nodes_allowed, 1))\n\t\t\tbreak;\n\t}\nout:\n\tret = persistent_huge_pages(h);\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "adjust_pool_surplus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2250-2275",
    "snippet": "static int adjust_pool_surplus(struct hstate *h, nodemask_t *nodes_allowed,\n\t\t\t\tint delta)\n{\n\tint nr_nodes, node;\n\n\tVM_BUG_ON(delta != -1 && delta != 1);\n\n\tif (delta < 0) {\n\t\tfor_each_node_mask_to_alloc(h, nr_nodes, node, nodes_allowed) {\n\t\t\tif (h->surplus_huge_pages_node[node])\n\t\t\t\tgoto found;\n\t\t}\n\t} else {\n\t\tfor_each_node_mask_to_free(h, nr_nodes, node, nodes_allowed) {\n\t\t\tif (h->surplus_huge_pages_node[node] <\n\t\t\t\t\th->nr_huge_pages_node[node])\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\treturn 0;\n\nfound:\n\th->surplus_huge_pages += delta;\n\th->surplus_huge_pages_node[node] += delta;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int hugetlb_acct_memory(struct hstate *h, long delta);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_node_mask_to_free",
          "args": [
            "h",
            "nr_nodes",
            "node",
            "nodes_allowed"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_mask_to_alloc",
          "args": [
            "h",
            "nr_nodes",
            "node",
            "nodes_allowed"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "delta != -1 && delta != 1"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int adjust_pool_surplus(struct hstate *h, nodemask_t *nodes_allowed,\n\t\t\t\tint delta)\n{\n\tint nr_nodes, node;\n\n\tVM_BUG_ON(delta != -1 && delta != 1);\n\n\tif (delta < 0) {\n\t\tfor_each_node_mask_to_alloc(h, nr_nodes, node, nodes_allowed) {\n\t\t\tif (h->surplus_huge_pages_node[node])\n\t\t\t\tgoto found;\n\t\t}\n\t} else {\n\t\tfor_each_node_mask_to_free(h, nr_nodes, node, nodes_allowed) {\n\t\t\tif (h->surplus_huge_pages_node[node] <\n\t\t\t\t\th->nr_huge_pages_node[node])\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\treturn 0;\n\nfound:\n\th->surplus_huge_pages += delta;\n\th->surplus_huge_pages_node[node] += delta;\n\treturn 1;\n}"
  },
  {
    "function_name": "try_to_free_low",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2239-2242",
    "snippet": "static inline void try_to_free_low(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void try_to_free_low(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n}"
  },
  {
    "function_name": "try_to_free_low",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2215-2237",
    "snippet": "static void try_to_free_low(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn;\n\n\tfor_each_node_mask(i, *nodes_allowed) {\n\t\tstruct page *page, *next;\n\t\tstruct list_head *freel = &h->hugepage_freelists[i];\n\t\tlist_for_each_entry_safe(page, next, freel, lru) {\n\t\t\tif (count >= h->nr_huge_pages)\n\t\t\t\treturn;\n\t\t\tif (PageHighMem(page))\n\t\t\t\tcontinue;\n\t\t\tlist_del(&page->lru);\n\t\t\tupdate_and_free_page(h, page);\n\t\t\th->free_huge_pages--;\n\t\t\th->free_huge_pages_node[page_to_nid(page)]--;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_and_free_page",
          "args": [
            "h",
            "page"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "update_and_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1155-1179",
          "snippet": "static void update_and_free_page(struct hstate *h, struct page *page)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn;\n\n\th->nr_huge_pages--;\n\th->nr_huge_pages_node[page_to_nid(page)]--;\n\tfor (i = 0; i < pages_per_huge_page(h); i++) {\n\t\tpage[i].flags &= ~(1 << PG_locked | 1 << PG_error |\n\t\t\t\t1 << PG_referenced | 1 << PG_dirty |\n\t\t\t\t1 << PG_active | 1 << PG_private |\n\t\t\t\t1 << PG_writeback);\n\t}\n\tVM_BUG_ON_PAGE(hugetlb_cgroup_from_page(page), page);\n\tset_compound_page_dtor(page, NULL_COMPOUND_DTOR);\n\tset_page_refcounted(page);\n\tif (hstate_is_gigantic(h)) {\n\t\tdestroy_compound_gigantic_page(page, huge_page_order(h));\n\t\tfree_gigantic_page(page, huge_page_order(h));\n\t} else {\n\t\t__free_pages(page, huge_page_order(h));\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void update_and_free_page(struct hstate *h, struct page *page)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn;\n\n\th->nr_huge_pages--;\n\th->nr_huge_pages_node[page_to_nid(page)]--;\n\tfor (i = 0; i < pages_per_huge_page(h); i++) {\n\t\tpage[i].flags &= ~(1 << PG_locked | 1 << PG_error |\n\t\t\t\t1 << PG_referenced | 1 << PG_dirty |\n\t\t\t\t1 << PG_active | 1 << PG_private |\n\t\t\t\t1 << PG_writeback);\n\t}\n\tVM_BUG_ON_PAGE(hugetlb_cgroup_from_page(page), page);\n\tset_compound_page_dtor(page, NULL_COMPOUND_DTOR);\n\tset_page_refcounted(page);\n\tif (hstate_is_gigantic(h)) {\n\t\tdestroy_compound_gigantic_page(page, huge_page_order(h));\n\t\tfree_gigantic_page(page, huge_page_order(h));\n\t} else {\n\t\t__free_pages(page, huge_page_order(h));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "next",
            "freel",
            "lru"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_mask",
          "args": [
            "i",
            "*nodes_allowed"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void try_to_free_low(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn;\n\n\tfor_each_node_mask(i, *nodes_allowed) {\n\t\tstruct page *page, *next;\n\t\tstruct list_head *freel = &h->hugepage_freelists[i];\n\t\tlist_for_each_entry_safe(page, next, freel, lru) {\n\t\t\tif (count >= h->nr_huge_pages)\n\t\t\t\treturn;\n\t\t\tif (PageHighMem(page))\n\t\t\t\tcontinue;\n\t\t\tlist_del(&page->lru);\n\t\t\tupdate_and_free_page(h, page);\n\t\t\th->free_huge_pages--;\n\t\t\th->free_huge_pages_node[page_to_nid(page)]--;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "report_hugepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2201-2212",
    "snippet": "static void __init report_hugepages(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_info(\"HugeTLB registered %s page size, pre-allocated %ld pages\\n\",\n\t\t\tbuf, h->free_huge_pages);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"HugeTLB registered %s page size, pre-allocated %ld pages\\n\"",
            "buf",
            "h->free_huge_pages"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_get_size",
          "args": [
            "huge_page_size(h)",
            "1",
            "STRING_UNITS_2",
            "buf",
            "32"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init report_hugepages(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_info(\"HugeTLB registered %s page size, pre-allocated %ld pages\\n\",\n\t\t\tbuf, h->free_huge_pages);\n\t}\n}"
  },
  {
    "function_name": "hugetlb_init_hstates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2186-2199",
    "snippet": "static void __init hugetlb_init_hstates(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tif (minimum_order > huge_page_order(h))\n\t\t\tminimum_order = huge_page_order(h);\n\n\t\t/* oversize hugepages were init'ed in early boot */\n\t\tif (!hstate_is_gigantic(h))\n\t\t\thugetlb_hstate_alloc_pages(h);\n\t}\n\tVM_BUG_ON(minimum_order == UINT_MAX);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int minimum_order"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "minimum_order == UINT_MAX"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_hstate_alloc_pages",
          "args": [
            "h"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_hstate_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2163-2184",
          "snippet": "static void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned int minimum_order;\n\nstatic void __init hugetlb_init_hstates(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tif (minimum_order > huge_page_order(h))\n\t\t\tminimum_order = huge_page_order(h);\n\n\t\t/* oversize hugepages were init'ed in early boot */\n\t\tif (!hstate_is_gigantic(h))\n\t\t\thugetlb_hstate_alloc_pages(h);\n\t}\n\tVM_BUG_ON(minimum_order == UINT_MAX);\n}"
  },
  {
    "function_name": "hugetlb_hstate_alloc_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2163-2184",
    "snippet": "static void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\"",
            "h->max_huge_pages",
            "buf",
            "i"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_get_size",
          "args": [
            "huge_page_size(h)",
            "1",
            "STRING_UNITS_2",
            "buf",
            "32"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pool_huge_page",
          "args": [
            "h",
            "&node_states[N_MEMORY]"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pool_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1421-1439",
          "snippet": "static int alloc_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed)\n{\n\tstruct page *page;\n\tint nr_nodes, node;\n\tgfp_t gfp_mask = htlb_alloc_mask(h) | __GFP_THISNODE;\n\n\tfor_each_node_mask_to_alloc(h, nr_nodes, node, nodes_allowed) {\n\t\tpage = alloc_fresh_huge_page(h, gfp_mask, node, nodes_allowed);\n\t\tif (page)\n\t\t\tbreak;\n\t}\n\n\tif (!page)\n\t\treturn 0;\n\n\tput_page(page); /* free it into the hugepage allocator */\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int alloc_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed)\n{\n\tstruct page *page;\n\tint nr_nodes, node;\n\tgfp_t gfp_mask = htlb_alloc_mask(h) | __GFP_THISNODE;\n\n\tfor_each_node_mask_to_alloc(h, nr_nodes, node, nodes_allowed) {\n\t\tpage = alloc_fresh_huge_page(h, gfp_mask, node, nodes_allowed);\n\t\tif (page)\n\t\t\tbreak;\n\t}\n\n\tif (!page)\n\t\treturn 0;\n\n\tput_page(page); /* free it into the hugepage allocator */\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_bootmem_huge_page",
          "args": [
            "h"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_bootmem_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2095-2125",
          "snippet": "int __alloc_bootmem_huge_page(struct hstate *h)\n{\n\tstruct huge_bootmem_page *m;\n\tint nr_nodes, node;\n\n\tfor_each_node_mask_to_alloc(h, nr_nodes, node, &node_states[N_MEMORY]) {\n\t\tvoid *addr;\n\n\t\taddr = memblock_alloc_try_nid_raw(\n\t\t\t\thuge_page_size(h), huge_page_size(h),\n\t\t\t\t0, MEMBLOCK_ALLOC_ACCESSIBLE, node);\n\t\tif (addr) {\n\t\t\t/*\n\t\t\t * Use the beginning of the huge page to store the\n\t\t\t * huge_bootmem_page struct (until gather_bootmem\n\t\t\t * puts them into the mem_map).\n\t\t\t */\n\t\t\tm = addr;\n\t\t\tgoto found;\n\t\t}\n\t}\n\treturn 0;\n\nfound:\n\tBUG_ON(!IS_ALIGNED(virt_to_phys(m), huge_page_size(h)));\n\t/* Put them into a private list first because mem_map is not up yet */\n\tINIT_LIST_HEAD(&m->list);\n\tlist_add(&m->list, &huge_boot_pages);\n\tm->hstate = h;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__initdata LIST_HEAD(huge_boot_pages);",
            "int alloc_bootmem_huge_page(struct hstate *h)\n\t__attribute__ ((weak, alias(\"__alloc_bootmem_huge_page\")));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n__initdata LIST_HEAD(huge_boot_pages);\nint alloc_bootmem_huge_page(struct hstate *h)\n\t__attribute__ ((weak, alias(\"__alloc_bootmem_huge_page\")));\n\nint __alloc_bootmem_huge_page(struct hstate *h)\n{\n\tstruct huge_bootmem_page *m;\n\tint nr_nodes, node;\n\n\tfor_each_node_mask_to_alloc(h, nr_nodes, node, &node_states[N_MEMORY]) {\n\t\tvoid *addr;\n\n\t\taddr = memblock_alloc_try_nid_raw(\n\t\t\t\thuge_page_size(h), huge_page_size(h),\n\t\t\t\t0, MEMBLOCK_ALLOC_ACCESSIBLE, node);\n\t\tif (addr) {\n\t\t\t/*\n\t\t\t * Use the beginning of the huge page to store the\n\t\t\t * huge_bootmem_page struct (until gather_bootmem\n\t\t\t * puts them into the mem_map).\n\t\t\t */\n\t\t\tm = addr;\n\t\t\tgoto found;\n\t\t}\n\t}\n\treturn 0;\n\nfound:\n\tBUG_ON(!IS_ALIGNED(virt_to_phys(m), huge_page_size(h)));\n\t/* Put them into a private list first because mem_map is not up yet */\n\tINIT_LIST_HEAD(&m->list);\n\tlist_add(&m->list, &huge_boot_pages);\n\tm->hstate = h;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}"
  },
  {
    "function_name": "gather_bootmem_prealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2137-2161",
    "snippet": "static void __init gather_bootmem_prealloc(void)\n{\n\tstruct huge_bootmem_page *m;\n\n\tlist_for_each_entry(m, &huge_boot_pages, list) {\n\t\tstruct page *page = virt_to_page(m);\n\t\tstruct hstate *h = m->hstate;\n\n\t\tWARN_ON(page_count(page) != 1);\n\t\tprep_compound_huge_page(page, h->order);\n\t\tWARN_ON(PageReserved(page));\n\t\tprep_new_huge_page(h, page, page_to_nid(page));\n\t\tput_page(page); /* free it into the hugepage allocator */\n\n\t\t/*\n\t\t * If we had gigantic hugepages allocated at boot time, we need\n\t\t * to restore the 'stolen' pages to totalram_pages in order to\n\t\t * fix confusing memory reports from free(1) and another\n\t\t * side-effects, like CommitLimit going negative.\n\t\t */\n\t\tif (hstate_is_gigantic(h))\n\t\t\tadjust_managed_page_count(page, 1 << h->order);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata LIST_HEAD(huge_boot_pages);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_managed_page_count",
          "args": [
            "page",
            "1 << h->order"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prep_new_huge_page",
          "args": [
            "h",
            "page",
            "page_to_nid(page)"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "prep_new_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1290-1299",
          "snippet": "static void prep_new_huge_page(struct hstate *h, struct page *page, int nid)\n{\n\tINIT_LIST_HEAD(&page->lru);\n\tset_compound_page_dtor(page, HUGETLB_PAGE_DTOR);\n\tspin_lock(&hugetlb_lock);\n\tset_hugetlb_cgroup(page, NULL);\n\th->nr_huge_pages++;\n\th->nr_huge_pages_node[nid]++;\n\tspin_unlock(&hugetlb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void prep_new_huge_page(struct hstate *h, struct page *page, int nid)\n{\n\tINIT_LIST_HEAD(&page->lru);\n\tset_compound_page_dtor(page, HUGETLB_PAGE_DTOR);\n\tspin_lock(&hugetlb_lock);\n\tset_hugetlb_cgroup(page, NULL);\n\th->nr_huge_pages++;\n\th->nr_huge_pages_node[nid]++;\n\tspin_unlock(&hugetlb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageReserved(page)"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "page"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prep_compound_huge_page",
          "args": [
            "page",
            "h->order"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "prep_compound_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2127-2134",
          "snippet": "static void __init prep_compound_huge_page(struct page *page,\n\t\tunsigned int order)\n{\n\tif (unlikely(order > (MAX_ORDER - 1)))\n\t\tprep_compound_gigantic_page(page, order);\n\telse\n\t\tprep_compound_page(page, order);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init prep_compound_huge_page(struct page *page,\n\t\tunsigned int order)\n{\n\tif (unlikely(order > (MAX_ORDER - 1)))\n\t\tprep_compound_gigantic_page(page, order);\n\telse\n\t\tprep_compound_page(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page_count(page) != 1"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "m"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "m",
            "&huge_boot_pages",
            "list"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n__initdata LIST_HEAD(huge_boot_pages);\n\nstatic void __init gather_bootmem_prealloc(void)\n{\n\tstruct huge_bootmem_page *m;\n\n\tlist_for_each_entry(m, &huge_boot_pages, list) {\n\t\tstruct page *page = virt_to_page(m);\n\t\tstruct hstate *h = m->hstate;\n\n\t\tWARN_ON(page_count(page) != 1);\n\t\tprep_compound_huge_page(page, h->order);\n\t\tWARN_ON(PageReserved(page));\n\t\tprep_new_huge_page(h, page, page_to_nid(page));\n\t\tput_page(page); /* free it into the hugepage allocator */\n\n\t\t/*\n\t\t * If we had gigantic hugepages allocated at boot time, we need\n\t\t * to restore the 'stolen' pages to totalram_pages in order to\n\t\t * fix confusing memory reports from free(1) and another\n\t\t * side-effects, like CommitLimit going negative.\n\t\t */\n\t\tif (hstate_is_gigantic(h))\n\t\t\tadjust_managed_page_count(page, 1 << h->order);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "prep_compound_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2127-2134",
    "snippet": "static void __init prep_compound_huge_page(struct page *page,\n\t\tunsigned int order)\n{\n\tif (unlikely(order > (MAX_ORDER - 1)))\n\t\tprep_compound_gigantic_page(page, order);\n\telse\n\t\tprep_compound_page(page, order);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prep_compound_page",
          "args": [
            "page",
            "order"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "prep_compound_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "576-591",
          "snippet": "void prep_compound_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\n\tset_compound_page_dtor(page, COMPOUND_PAGE_DTOR);\n\tset_compound_order(page, order);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++) {\n\t\tstruct page *p = page + i;\n\t\tset_page_count(p, 0);\n\t\tp->mapping = TAIL_MAPPING;\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid prep_compound_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\n\tset_compound_page_dtor(page, COMPOUND_PAGE_DTOR);\n\tset_compound_order(page, order);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++) {\n\t\tstruct page *p = page + i;\n\t\tset_page_count(p, 0);\n\t\tp->mapping = TAIL_MAPPING;\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prep_compound_gigantic_page",
          "args": [
            "page",
            "order"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "prep_compound_gigantic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1301-1329",
          "snippet": "static void prep_compound_gigantic_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\tstruct page *p = page + 1;\n\n\t/* we rely on prep_new_huge_page to set the destructor */\n\tset_compound_order(page, order);\n\t__ClearPageReserved(page);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++, p = mem_map_next(p, page, i)) {\n\t\t/*\n\t\t * For gigantic hugepages allocated through bootmem at\n\t\t * boot, it's safer to be consistent with the not-gigantic\n\t\t * hugepages and clear the PG_reserved bit from all tail pages\n\t\t * too.  Otherwse drivers using get_user_pages() to access tail\n\t\t * pages may get the reference counting wrong if they see\n\t\t * PG_reserved set on a tail page (despite the head page not\n\t\t * having PG_reserved set).  Enforcing this consistency between\n\t\t * head and tail pages allows drivers to optimize away a check\n\t\t * on the head page when they need know if put_page() is needed\n\t\t * after get_user_pages().\n\t\t */\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void prep_compound_gigantic_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\tstruct page *p = page + 1;\n\n\t/* we rely on prep_new_huge_page to set the destructor */\n\tset_compound_order(page, order);\n\t__ClearPageReserved(page);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++, p = mem_map_next(p, page, i)) {\n\t\t/*\n\t\t * For gigantic hugepages allocated through bootmem at\n\t\t * boot, it's safer to be consistent with the not-gigantic\n\t\t * hugepages and clear the PG_reserved bit from all tail pages\n\t\t * too.  Otherwse drivers using get_user_pages() to access tail\n\t\t * pages may get the reference counting wrong if they see\n\t\t * PG_reserved set on a tail page (despite the head page not\n\t\t * having PG_reserved set).  Enforcing this consistency between\n\t\t * head and tail pages allows drivers to optimize away a check\n\t\t * on the head page when they need know if put_page() is needed\n\t\t * after get_user_pages().\n\t\t */\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "order > (MAX_ORDER - 1)"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init prep_compound_huge_page(struct page *page,\n\t\tunsigned int order)\n{\n\tif (unlikely(order > (MAX_ORDER - 1)))\n\t\tprep_compound_gigantic_page(page, order);\n\telse\n\t\tprep_compound_page(page, order);\n}"
  },
  {
    "function_name": "__alloc_bootmem_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "2095-2125",
    "snippet": "int __alloc_bootmem_huge_page(struct hstate *h)\n{\n\tstruct huge_bootmem_page *m;\n\tint nr_nodes, node;\n\n\tfor_each_node_mask_to_alloc(h, nr_nodes, node, &node_states[N_MEMORY]) {\n\t\tvoid *addr;\n\n\t\taddr = memblock_alloc_try_nid_raw(\n\t\t\t\thuge_page_size(h), huge_page_size(h),\n\t\t\t\t0, MEMBLOCK_ALLOC_ACCESSIBLE, node);\n\t\tif (addr) {\n\t\t\t/*\n\t\t\t * Use the beginning of the huge page to store the\n\t\t\t * huge_bootmem_page struct (until gather_bootmem\n\t\t\t * puts them into the mem_map).\n\t\t\t */\n\t\t\tm = addr;\n\t\t\tgoto found;\n\t\t}\n\t}\n\treturn 0;\n\nfound:\n\tBUG_ON(!IS_ALIGNED(virt_to_phys(m), huge_page_size(h)));\n\t/* Put them into a private list first because mem_map is not up yet */\n\tINIT_LIST_HEAD(&m->list);\n\tlist_add(&m->list, &huge_boot_pages);\n\tm->hstate = h;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata LIST_HEAD(huge_boot_pages);",
      "int alloc_bootmem_huge_page(struct hstate *h)\n\t__attribute__ ((weak, alias(\"__alloc_bootmem_huge_page\")));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&m->list",
            "&huge_boot_pages"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&m->list"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!IS_ALIGNED(virt_to_phys(m), huge_page_size(h))"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "virt_to_phys(m)",
            "huge_page_size(h)"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_phys",
          "args": [
            "m"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_try_nid_raw",
          "args": [
            "huge_page_size(h)",
            "huge_page_size(h)",
            "0",
            "MEMBLOCK_ALLOC_ACCESSIBLE",
            "node"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_try_nid_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1445-1462",
          "snippet": "void * __init memblock_alloc_try_nid_raw(\n\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr && size > 0)\n\t\tpage_init_poison(ptr, size);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid * __init memblock_alloc_try_nid_raw(\n\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr && size > 0)\n\t\tpage_init_poison(ptr, size);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_mask_to_alloc",
          "args": [
            "h",
            "nr_nodes",
            "node",
            "&node_states[N_MEMORY]"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n__initdata LIST_HEAD(huge_boot_pages);\nint alloc_bootmem_huge_page(struct hstate *h)\n\t__attribute__ ((weak, alias(\"__alloc_bootmem_huge_page\")));\n\nint __alloc_bootmem_huge_page(struct hstate *h)\n{\n\tstruct huge_bootmem_page *m;\n\tint nr_nodes, node;\n\n\tfor_each_node_mask_to_alloc(h, nr_nodes, node, &node_states[N_MEMORY]) {\n\t\tvoid *addr;\n\n\t\taddr = memblock_alloc_try_nid_raw(\n\t\t\t\thuge_page_size(h), huge_page_size(h),\n\t\t\t\t0, MEMBLOCK_ALLOC_ACCESSIBLE, node);\n\t\tif (addr) {\n\t\t\t/*\n\t\t\t * Use the beginning of the huge page to store the\n\t\t\t * huge_bootmem_page struct (until gather_bootmem\n\t\t\t * puts them into the mem_map).\n\t\t\t */\n\t\t\tm = addr;\n\t\t\tgoto found;\n\t\t}\n\t}\n\treturn 0;\n\nfound:\n\tBUG_ON(!IS_ALIGNED(virt_to_phys(m), huge_page_size(h)));\n\t/* Put them into a private list first because mem_map is not up yet */\n\tINIT_LIST_HEAD(&m->list);\n\tlist_add(&m->list, &huge_boot_pages);\n\tm->hstate = h;\n\treturn 1;\n}"
  },
  {
    "function_name": "alloc_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1990-2091",
    "snippet": "struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong map_chg, map_commit;\n\tlong gbl_chg;\n\tint ret, idx;\n\tstruct hugetlb_cgroup *h_cg;\n\n\tidx = hstate_index(h);\n\t/*\n\t * Examine the region/reserve map to determine if the process\n\t * has a reservation for the page to be allocated.  A return\n\t * code of zero indicates a reservation exists (no change).\n\t */\n\tmap_chg = gbl_chg = vma_needs_reservation(h, vma, addr);\n\tif (map_chg < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Processes that did not create the mapping will have no\n\t * reserves as indicated by the region/reserve map. Check\n\t * that the allocation will not exceed the subpool limit.\n\t * Allocations for MAP_NORESERVE mappings also need to be\n\t * checked against any subpool limit.\n\t */\n\tif (map_chg || avoid_reserve) {\n\t\tgbl_chg = hugepage_subpool_get_pages(spool, 1);\n\t\tif (gbl_chg < 0) {\n\t\t\tvma_end_reservation(h, vma, addr);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\n\t\t/*\n\t\t * Even though there was no reservation in the region/reserve\n\t\t * map, there could be reservations associated with the\n\t\t * subpool that can be used.  This would be indicated if the\n\t\t * return value of hugepage_subpool_get_pages() is zero.\n\t\t * However, if avoid_reserve is specified we still avoid even\n\t\t * the subpool reservations.\n\t\t */\n\t\tif (avoid_reserve)\n\t\t\tgbl_chg = 1;\n\t}\n\n\tret = hugetlb_cgroup_charge_cgroup(idx, pages_per_huge_page(h), &h_cg);\n\tif (ret)\n\t\tgoto out_subpool_put;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * glb_chg is passed to indicate whether or not a page must be taken\n\t * from the global free pool (global change).  gbl_chg == 0 indicates\n\t * a reservation exists for the allocation.\n\t */\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve, gbl_chg);\n\tif (!page) {\n\t\tspin_unlock(&hugetlb_lock);\n\t\tpage = alloc_buddy_huge_page_with_mpol(h, vma, addr);\n\t\tif (!page)\n\t\t\tgoto out_uncharge_cgroup;\n\t\tif (!avoid_reserve && vma_has_reserves(vma, gbl_chg)) {\n\t\t\tSetPagePrivate(page);\n\t\t\th->resv_huge_pages--;\n\t\t}\n\t\tspin_lock(&hugetlb_lock);\n\t\tlist_move(&page->lru, &h->hugepage_activelist);\n\t\t/* Fall through */\n\t}\n\thugetlb_cgroup_commit_charge(idx, pages_per_huge_page(h), h_cg, page);\n\tspin_unlock(&hugetlb_lock);\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tmap_commit = vma_commit_reservation(h, vma, addr);\n\tif (unlikely(map_chg > map_commit)) {\n\t\t/*\n\t\t * The page was added to the reservation map between\n\t\t * vma_needs_reservation and vma_commit_reservation.\n\t\t * This indicates a race with hugetlb_reserve_pages.\n\t\t * Adjust for the subpool count incremented above AND\n\t\t * in hugetlb_reserve_pages for the same page.  Also,\n\t\t * the reservation count added in hugetlb_reserve_pages\n\t\t * no longer applies.\n\t\t */\n\t\tlong rsv_adjust;\n\n\t\trsv_adjust = hugepage_subpool_put_pages(spool, 1);\n\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t}\n\treturn page;\n\nout_uncharge_cgroup:\n\thugetlb_cgroup_uncharge_cgroup(idx, pages_per_huge_page(h), h_cg);\nout_subpool_put:\n\tif (map_chg || avoid_reserve)\n\t\thugepage_subpool_put_pages(spool, 1);\n\tvma_end_reservation(h, vma, addr);\n\treturn ERR_PTR(-ENOSPC);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_end_reservation",
          "args": [
            "h",
            "vma",
            "addr"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "vma_end_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1934-1938",
          "snippet": "static void vma_end_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\t(void)__vma_reservation_common(h, vma, addr, VMA_END_RESV);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void vma_end_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\t(void)__vma_reservation_common(h, vma, addr, VMA_END_RESV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugepage_subpool_put_pages",
          "args": [
            "spool",
            "1"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_subpool_put_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "176-208",
          "snippet": "static long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_uncharge_cgroup",
          "args": [
            "idx",
            "pages_per_huge_page(h)",
            "h_cg"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_uncharge_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "244-255",
          "snippet": "void hugetlb_cgroup_uncharge_cgroup(int idx, unsigned long nr_pages,\n\t\t\t\t    struct hugetlb_cgroup *h_cg)\n{\n\tif (hugetlb_cgroup_disabled() || !h_cg)\n\t\treturn;\n\n\tif (huge_page_order(&hstates[idx]) < HUGETLB_CGROUP_MIN_ORDER)\n\t\treturn;\n\n\tpage_counter_uncharge(&h_cg->hugepage[idx], nr_pages);\n\treturn;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nvoid hugetlb_cgroup_uncharge_cgroup(int idx, unsigned long nr_pages,\n\t\t\t\t    struct hugetlb_cgroup *h_cg)\n{\n\tif (hugetlb_cgroup_disabled() || !h_cg)\n\t\treturn;\n\n\tif (huge_page_order(&hstates[idx]) < HUGETLB_CGROUP_MIN_ORDER)\n\t\treturn;\n\n\tpage_counter_uncharge(&h_cg->hugepage[idx], nr_pages);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_acct_memory",
          "args": [
            "h",
            "-rsv_adjust"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_acct_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3052-3091",
          "snippet": "static int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_chg > map_commit"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_commit_reservation",
          "args": [
            "h",
            "vma",
            "addr"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "vma_commit_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1928-1932",
          "snippet": "static long vma_commit_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_COMMIT_RESV);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long vma_commit_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_COMMIT_RESV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "(unsigned long)spool"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_commit_charge",
          "args": [
            "idx",
            "pages_per_huge_page(h)",
            "h_cg",
            "page"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "214-223",
          "snippet": "void hugetlb_cgroup_commit_charge(int idx, unsigned long nr_pages,\n\t\t\t\t  struct hugetlb_cgroup *h_cg,\n\t\t\t\t  struct page *page)\n{\n\tif (hugetlb_cgroup_disabled() || !h_cg)\n\t\treturn;\n\n\tset_hugetlb_cgroup(page, h_cg);\n\treturn;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nvoid hugetlb_cgroup_commit_charge(int idx, unsigned long nr_pages,\n\t\t\t\t  struct hugetlb_cgroup *h_cg,\n\t\t\t\t  struct page *page)\n{\n\tif (hugetlb_cgroup_disabled() || !h_cg)\n\t\treturn;\n\n\tset_hugetlb_cgroup(page, h_cg);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&page->lru",
            "&h->hugepage_activelist"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_has_reserves",
          "args": [
            "vma",
            "gbl_chg"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "vma_has_reserves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "793-853",
          "snippet": "static bool vma_has_reserves(struct vm_area_struct *vma, long chg)\n{\n\tif (vma->vm_flags & VM_NORESERVE) {\n\t\t/*\n\t\t * This address is already reserved by other process(chg == 0),\n\t\t * so, we should decrement reserved count. Without decrementing,\n\t\t * reserve count remains after releasing inode, because this\n\t\t * allocated page will go into page cache and is regarded as\n\t\t * coming from reserved pool in releasing step.  Currently, we\n\t\t * don't have any other solution to deal with this situation\n\t\t * properly, so add work-around here.\n\t\t */\n\t\tif (vma->vm_flags & VM_MAYSHARE && chg == 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/* Shared mappings always use reserves */\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\t/*\n\t\t * We know VM_NORESERVE is not set.  Therefore, there SHOULD\n\t\t * be a region map for all pages.  The only situation where\n\t\t * there is no region map is if a hole was punched via\n\t\t * fallocate.  In this case, there really are no reverves to\n\t\t * use.  This situation is indicated if chg != 0.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Only the process that called mmap() has reserves for\n\t * private mappings.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\t/*\n\t\t * Like the shared case above, a hole punch or truncate\n\t\t * could have been performed on the private mapping.\n\t\t * Examine the value of chg to determine if reserves\n\t\t * actually exist or were previously consumed.\n\t\t * Very Subtle - The value of chg comes from a previous\n\t\t * call to vma_needs_reserves().  The reserve map for\n\t\t * private mappings has different (opposite) semantics\n\t\t * than that of shared mappings.  vma_needs_reserves()\n\t\t * has already taken this difference in semantics into\n\t\t * account.  Therefore, the meaning of chg is the same\n\t\t * as in the shared case above.  Code could easily be\n\t\t * combined, but keeping it separate draws attention to\n\t\t * subtle differences.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_OWNER    (1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic bool vma_has_reserves(struct vm_area_struct *vma, long chg)\n{\n\tif (vma->vm_flags & VM_NORESERVE) {\n\t\t/*\n\t\t * This address is already reserved by other process(chg == 0),\n\t\t * so, we should decrement reserved count. Without decrementing,\n\t\t * reserve count remains after releasing inode, because this\n\t\t * allocated page will go into page cache and is regarded as\n\t\t * coming from reserved pool in releasing step.  Currently, we\n\t\t * don't have any other solution to deal with this situation\n\t\t * properly, so add work-around here.\n\t\t */\n\t\tif (vma->vm_flags & VM_MAYSHARE && chg == 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/* Shared mappings always use reserves */\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\t/*\n\t\t * We know VM_NORESERVE is not set.  Therefore, there SHOULD\n\t\t * be a region map for all pages.  The only situation where\n\t\t * there is no region map is if a hole was punched via\n\t\t * fallocate.  In this case, there really are no reverves to\n\t\t * use.  This situation is indicated if chg != 0.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Only the process that called mmap() has reserves for\n\t * private mappings.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\t/*\n\t\t * Like the shared case above, a hole punch or truncate\n\t\t * could have been performed on the private mapping.\n\t\t * Examine the value of chg to determine if reserves\n\t\t * actually exist or were previously consumed.\n\t\t * Very Subtle - The value of chg comes from a previous\n\t\t * call to vma_needs_reserves().  The reserve map for\n\t\t * private mappings has different (opposite) semantics\n\t\t * than that of shared mappings.  vma_needs_reserves()\n\t\t * has already taken this difference in semantics into\n\t\t * account.  Therefore, the meaning of chg is the same\n\t\t * as in the shared case above.  Code could easily be\n\t\t * combined, but keeping it separate draws attention to\n\t\t * subtle differences.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_buddy_huge_page_with_mpol",
          "args": [
            "h",
            "vma",
            "addr"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_buddy_huge_page_with_mpol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1612-1627",
          "snippet": "static\nstruct page *alloc_buddy_huge_page_with_mpol(struct hstate *h,\n\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct page *page;\n\tstruct mempolicy *mpol;\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\tint nid;\n\tnodemask_t *nodemask;\n\n\tnid = huge_node(vma, addr, gfp_mask, &mpol, &nodemask);\n\tpage = alloc_surplus_huge_page(h, gfp_mask, nid, nodemask);\n\tmpol_cond_put(mpol);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic\nstruct page *alloc_buddy_huge_page_with_mpol(struct hstate *h,\n\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct page *page;\n\tstruct mempolicy *mpol;\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\tint nid;\n\tnodemask_t *nodemask;\n\n\tnid = huge_node(vma, addr, gfp_mask, &mpol, &nodemask);\n\tpage = alloc_surplus_huge_page(h, gfp_mask, nid, nodemask);\n\tmpol_cond_put(mpol);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_huge_page_vma",
          "args": [
            "h",
            "vma",
            "addr",
            "avoid_reserve",
            "gbl_chg"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_huge_page_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "928-965",
          "snippet": "static struct page *dequeue_huge_page_vma(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long address, int avoid_reserve,\n\t\t\t\tlong chg)\n{\n\tstruct page *page;\n\tstruct mempolicy *mpol;\n\tgfp_t gfp_mask;\n\tnodemask_t *nodemask;\n\tint nid;\n\n\t/*\n\t * A child process with MAP_PRIVATE mappings created by their parent\n\t * have no page reserves. This check ensures that reservations are\n\t * not \"stolen\". The child may still get SIGKILLed\n\t */\n\tif (!vma_has_reserves(vma, chg) &&\n\t\t\th->free_huge_pages - h->resv_huge_pages == 0)\n\t\tgoto err;\n\n\t/* If reserves cannot be used, ensure enough pages are in the pool */\n\tif (avoid_reserve && h->free_huge_pages - h->resv_huge_pages == 0)\n\t\tgoto err;\n\n\tgfp_mask = htlb_alloc_mask(h);\n\tnid = huge_node(vma, address, gfp_mask, &mpol, &nodemask);\n\tpage = dequeue_huge_page_nodemask(h, gfp_mask, nid, nodemask);\n\tif (page && !avoid_reserve && vma_has_reserves(vma, chg)) {\n\t\tSetPagePrivate(page);\n\t\th->resv_huge_pages--;\n\t}\n\n\tmpol_cond_put(mpol);\n\treturn page;\n\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *dequeue_huge_page_vma(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long address, int avoid_reserve,\n\t\t\t\tlong chg)\n{\n\tstruct page *page;\n\tstruct mempolicy *mpol;\n\tgfp_t gfp_mask;\n\tnodemask_t *nodemask;\n\tint nid;\n\n\t/*\n\t * A child process with MAP_PRIVATE mappings created by their parent\n\t * have no page reserves. This check ensures that reservations are\n\t * not \"stolen\". The child may still get SIGKILLed\n\t */\n\tif (!vma_has_reserves(vma, chg) &&\n\t\t\th->free_huge_pages - h->resv_huge_pages == 0)\n\t\tgoto err;\n\n\t/* If reserves cannot be used, ensure enough pages are in the pool */\n\tif (avoid_reserve && h->free_huge_pages - h->resv_huge_pages == 0)\n\t\tgoto err;\n\n\tgfp_mask = htlb_alloc_mask(h);\n\tnid = huge_node(vma, address, gfp_mask, &mpol, &nodemask);\n\tpage = dequeue_huge_page_nodemask(h, gfp_mask, nid, nodemask);\n\tif (page && !avoid_reserve && vma_has_reserves(vma, chg)) {\n\t\tSetPagePrivate(page);\n\t\th->resv_huge_pages--;\n\t}\n\n\tmpol_cond_put(mpol);\n\treturn page;\n\nerr:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_charge_cgroup",
          "args": [
            "idx",
            "pages_per_huge_page(h)",
            "&h_cg"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_charge_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "181-211",
          "snippet": "int hugetlb_cgroup_charge_cgroup(int idx, unsigned long nr_pages,\n\t\t\t\t struct hugetlb_cgroup **ptr)\n{\n\tint ret = 0;\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *h_cg = NULL;\n\n\tif (hugetlb_cgroup_disabled())\n\t\tgoto done;\n\t/*\n\t * We don't charge any cgroup if the compound page have less\n\t * than 3 pages.\n\t */\n\tif (huge_page_order(&hstates[idx]) < HUGETLB_CGROUP_MIN_ORDER)\n\t\tgoto done;\nagain:\n\trcu_read_lock();\n\th_cg = hugetlb_cgroup_from_task(current);\n\tif (!css_tryget_online(&h_cg->css)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tif (!page_counter_try_charge(&h_cg->hugepage[idx], nr_pages, &counter))\n\t\tret = -ENOMEM;\n\tcss_put(&h_cg->css);\ndone:\n\t*ptr = h_cg;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nint hugetlb_cgroup_charge_cgroup(int idx, unsigned long nr_pages,\n\t\t\t\t struct hugetlb_cgroup **ptr)\n{\n\tint ret = 0;\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *h_cg = NULL;\n\n\tif (hugetlb_cgroup_disabled())\n\t\tgoto done;\n\t/*\n\t * We don't charge any cgroup if the compound page have less\n\t * than 3 pages.\n\t */\n\tif (huge_page_order(&hstates[idx]) < HUGETLB_CGROUP_MIN_ORDER)\n\t\tgoto done;\nagain:\n\trcu_read_lock();\n\th_cg = hugetlb_cgroup_from_task(current);\n\tif (!css_tryget_online(&h_cg->css)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tif (!page_counter_try_charge(&h_cg->hugepage[idx], nr_pages, &counter))\n\t\tret = -ENOMEM;\n\tcss_put(&h_cg->css);\ndone:\n\t*ptr = h_cg;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_subpool_get_pages",
          "args": [
            "spool",
            "1"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_subpool_get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "131-168",
          "snippet": "static long hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n\t\t\t\t      long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn ret;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1) {\t\t/* maximum size accounting */\n\t\tif ((spool->used_hpages + delta) <= spool->max_hpages)\n\t\t\tspool->used_hpages += delta;\n\t\telse {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_ret;\n\t\t}\n\t}\n\n\t/* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->rsv_hpages) {\n\t\tif (delta > spool->rsv_hpages) {\n\t\t\t/*\n\t\t\t * Asking for more reserves than those already taken on\n\t\t\t * behalf of subpool.  Return difference.\n\t\t\t */\n\t\t\tret = delta - spool->rsv_hpages;\n\t\t\tspool->rsv_hpages = 0;\n\t\t} else {\n\t\t\tret = 0;\t/* reserves already accounted for */\n\t\t\tspool->rsv_hpages -= delta;\n\t\t}\n\t}\n\nunlock_ret:\n\tspin_unlock(&spool->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic long hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n\t\t\t\t      long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn ret;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1) {\t\t/* maximum size accounting */\n\t\tif ((spool->used_hpages + delta) <= spool->max_hpages)\n\t\t\tspool->used_hpages += delta;\n\t\telse {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_ret;\n\t\t}\n\t}\n\n\t/* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->rsv_hpages) {\n\t\tif (delta > spool->rsv_hpages) {\n\t\t\t/*\n\t\t\t * Asking for more reserves than those already taken on\n\t\t\t * behalf of subpool.  Return difference.\n\t\t\t */\n\t\t\tret = delta - spool->rsv_hpages;\n\t\t\tspool->rsv_hpages = 0;\n\t\t} else {\n\t\t\tret = 0;\t/* reserves already accounted for */\n\t\t\tspool->rsv_hpages -= delta;\n\t\t}\n\t}\n\nunlock_ret:\n\tspin_unlock(&spool->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_needs_reservation",
          "args": [
            "h",
            "vma",
            "addr"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "vma_needs_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1922-1926",
          "snippet": "static long vma_needs_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_NEEDS_RESV);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long vma_needs_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_NEEDS_RESV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_index",
          "args": [
            "h"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subpool_vma",
          "args": [
            "vma"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "subpool_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "215-218",
          "snippet": "static inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)\n{\n\treturn subpool_inode(file_inode(vma->vm_file));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)\n{\n\treturn subpool_inode(file_inode(vma->vm_file));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong map_chg, map_commit;\n\tlong gbl_chg;\n\tint ret, idx;\n\tstruct hugetlb_cgroup *h_cg;\n\n\tidx = hstate_index(h);\n\t/*\n\t * Examine the region/reserve map to determine if the process\n\t * has a reservation for the page to be allocated.  A return\n\t * code of zero indicates a reservation exists (no change).\n\t */\n\tmap_chg = gbl_chg = vma_needs_reservation(h, vma, addr);\n\tif (map_chg < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Processes that did not create the mapping will have no\n\t * reserves as indicated by the region/reserve map. Check\n\t * that the allocation will not exceed the subpool limit.\n\t * Allocations for MAP_NORESERVE mappings also need to be\n\t * checked against any subpool limit.\n\t */\n\tif (map_chg || avoid_reserve) {\n\t\tgbl_chg = hugepage_subpool_get_pages(spool, 1);\n\t\tif (gbl_chg < 0) {\n\t\t\tvma_end_reservation(h, vma, addr);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\n\t\t/*\n\t\t * Even though there was no reservation in the region/reserve\n\t\t * map, there could be reservations associated with the\n\t\t * subpool that can be used.  This would be indicated if the\n\t\t * return value of hugepage_subpool_get_pages() is zero.\n\t\t * However, if avoid_reserve is specified we still avoid even\n\t\t * the subpool reservations.\n\t\t */\n\t\tif (avoid_reserve)\n\t\t\tgbl_chg = 1;\n\t}\n\n\tret = hugetlb_cgroup_charge_cgroup(idx, pages_per_huge_page(h), &h_cg);\n\tif (ret)\n\t\tgoto out_subpool_put;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * glb_chg is passed to indicate whether or not a page must be taken\n\t * from the global free pool (global change).  gbl_chg == 0 indicates\n\t * a reservation exists for the allocation.\n\t */\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve, gbl_chg);\n\tif (!page) {\n\t\tspin_unlock(&hugetlb_lock);\n\t\tpage = alloc_buddy_huge_page_with_mpol(h, vma, addr);\n\t\tif (!page)\n\t\t\tgoto out_uncharge_cgroup;\n\t\tif (!avoid_reserve && vma_has_reserves(vma, gbl_chg)) {\n\t\t\tSetPagePrivate(page);\n\t\t\th->resv_huge_pages--;\n\t\t}\n\t\tspin_lock(&hugetlb_lock);\n\t\tlist_move(&page->lru, &h->hugepage_activelist);\n\t\t/* Fall through */\n\t}\n\thugetlb_cgroup_commit_charge(idx, pages_per_huge_page(h), h_cg, page);\n\tspin_unlock(&hugetlb_lock);\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tmap_commit = vma_commit_reservation(h, vma, addr);\n\tif (unlikely(map_chg > map_commit)) {\n\t\t/*\n\t\t * The page was added to the reservation map between\n\t\t * vma_needs_reservation and vma_commit_reservation.\n\t\t * This indicates a race with hugetlb_reserve_pages.\n\t\t * Adjust for the subpool count incremented above AND\n\t\t * in hugetlb_reserve_pages for the same page.  Also,\n\t\t * the reservation count added in hugetlb_reserve_pages\n\t\t * no longer applies.\n\t\t */\n\t\tlong rsv_adjust;\n\n\t\trsv_adjust = hugepage_subpool_put_pages(spool, 1);\n\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t}\n\treturn page;\n\nout_uncharge_cgroup:\n\thugetlb_cgroup_uncharge_cgroup(idx, pages_per_huge_page(h), h_cg);\nout_subpool_put:\n\tif (map_chg || avoid_reserve)\n\t\thugepage_subpool_put_pages(spool, 1);\n\tvma_end_reservation(h, vma, addr);\n\treturn ERR_PTR(-ENOSPC);\n}"
  },
  {
    "function_name": "restore_reserve_on_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1957-1988",
    "snippet": "static void restore_reserve_on_error(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address,\n\t\t\tstruct page *page)\n{\n\tif (unlikely(PagePrivate(page))) {\n\t\tlong rc = vma_needs_reservation(h, vma, address);\n\n\t\tif (unlikely(rc < 0)) {\n\t\t\t/*\n\t\t\t * Rare out of memory condition in reserve map\n\t\t\t * manipulation.  Clear PagePrivate so that\n\t\t\t * global reserve count will not be incremented\n\t\t\t * by free_huge_page.  This will make it appear\n\t\t\t * as though the reservation for this page was\n\t\t\t * consumed.  This may prevent the task from\n\t\t\t * faulting in the page at a later time.  This\n\t\t\t * is better than inconsistent global huge page\n\t\t\t * accounting of reserve counts.\n\t\t\t */\n\t\t\tClearPagePrivate(page);\n\t\t} else if (rc) {\n\t\t\trc = vma_add_reservation(h, vma, address);\n\t\t\tif (unlikely(rc < 0))\n\t\t\t\t/*\n\t\t\t\t * See above comment about rare out of\n\t\t\t\t * memory condition.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t} else\n\t\t\tvma_end_reservation(h, vma, address);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_end_reservation",
          "args": [
            "h",
            "vma",
            "address"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "vma_end_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1934-1938",
          "snippet": "static void vma_end_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\t(void)__vma_reservation_common(h, vma, addr, VMA_END_RESV);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void vma_end_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\t(void)__vma_reservation_common(h, vma, addr, VMA_END_RESV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc < 0"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_add_reservation",
          "args": [
            "h",
            "vma",
            "address"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "vma_add_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1940-1944",
          "snippet": "static long vma_add_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_ADD_RESV);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long vma_add_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_ADD_RESV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc < 0"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_needs_reservation",
          "args": [
            "h",
            "vma",
            "address"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "vma_needs_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1922-1926",
          "snippet": "static long vma_needs_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_NEEDS_RESV);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long vma_needs_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_NEEDS_RESV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PagePrivate(page)"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void restore_reserve_on_error(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address,\n\t\t\tstruct page *page)\n{\n\tif (unlikely(PagePrivate(page))) {\n\t\tlong rc = vma_needs_reservation(h, vma, address);\n\n\t\tif (unlikely(rc < 0)) {\n\t\t\t/*\n\t\t\t * Rare out of memory condition in reserve map\n\t\t\t * manipulation.  Clear PagePrivate so that\n\t\t\t * global reserve count will not be incremented\n\t\t\t * by free_huge_page.  This will make it appear\n\t\t\t * as though the reservation for this page was\n\t\t\t * consumed.  This may prevent the task from\n\t\t\t * faulting in the page at a later time.  This\n\t\t\t * is better than inconsistent global huge page\n\t\t\t * accounting of reserve counts.\n\t\t\t */\n\t\t\tClearPagePrivate(page);\n\t\t} else if (rc) {\n\t\t\trc = vma_add_reservation(h, vma, address);\n\t\t\tif (unlikely(rc < 0))\n\t\t\t\t/*\n\t\t\t\t * See above comment about rare out of\n\t\t\t\t * memory condition.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t} else\n\t\t\tvma_end_reservation(h, vma, address);\n\t}\n}"
  },
  {
    "function_name": "vma_add_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1940-1944",
    "snippet": "static long vma_add_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_ADD_RESV);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vma_reservation_common",
          "args": [
            "h",
            "vma",
            "addr",
            "VMA_ADD_RESV"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_reservation_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1861-1920",
          "snippet": "static long __vma_reservation_common(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tenum vma_resv_mode mode)\n{\n\tstruct resv_map *resv;\n\tpgoff_t idx;\n\tlong ret;\n\n\tresv = vma_resv_map(vma);\n\tif (!resv)\n\t\treturn 1;\n\n\tidx = vma_hugecache_offset(h, vma, addr);\n\tswitch (mode) {\n\tcase VMA_NEEDS_RESV:\n\t\tret = region_chg(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_COMMIT_RESV:\n\t\tret = region_add(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_END_RESV:\n\t\tregion_abort(resv, idx, idx + 1);\n\t\tret = 0;\n\t\tbreak;\n\tcase VMA_ADD_RESV:\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tret = region_add(resv, idx, idx + 1);\n\t\telse {\n\t\t\tregion_abort(resv, idx, idx + 1);\n\t\t\tret = region_del(resv, idx, idx + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn ret;\n\telse if (is_vma_resv_set(vma, HPAGE_RESV_OWNER) && ret >= 0) {\n\t\t/*\n\t\t * In most cases, reserves always exist for private mappings.\n\t\t * However, a file associated with mapping could have been\n\t\t * hole punched or truncated after reserves were consumed.\n\t\t * As subsequent fault on such a range will not use reserves.\n\t\t * Subtle - The reserve map for private mappings has the\n\t\t * opposite meaning than that of shared mappings.  If NO\n\t\t * entry is in the reserve map, it means a reservation exists.\n\t\t * If an entry exists in the reserve map, it means the\n\t\t * reservation has already been consumed.  As a result, the\n\t\t * return value of this routine is the opposite of the\n\t\t * value returned from reserve map manipulation routines above.\n\t\t */\n\t\tif (ret)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_OWNER    (1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic long __vma_reservation_common(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tenum vma_resv_mode mode)\n{\n\tstruct resv_map *resv;\n\tpgoff_t idx;\n\tlong ret;\n\n\tresv = vma_resv_map(vma);\n\tif (!resv)\n\t\treturn 1;\n\n\tidx = vma_hugecache_offset(h, vma, addr);\n\tswitch (mode) {\n\tcase VMA_NEEDS_RESV:\n\t\tret = region_chg(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_COMMIT_RESV:\n\t\tret = region_add(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_END_RESV:\n\t\tregion_abort(resv, idx, idx + 1);\n\t\tret = 0;\n\t\tbreak;\n\tcase VMA_ADD_RESV:\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tret = region_add(resv, idx, idx + 1);\n\t\telse {\n\t\t\tregion_abort(resv, idx, idx + 1);\n\t\t\tret = region_del(resv, idx, idx + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn ret;\n\telse if (is_vma_resv_set(vma, HPAGE_RESV_OWNER) && ret >= 0) {\n\t\t/*\n\t\t * In most cases, reserves always exist for private mappings.\n\t\t * However, a file associated with mapping could have been\n\t\t * hole punched or truncated after reserves were consumed.\n\t\t * As subsequent fault on such a range will not use reserves.\n\t\t * Subtle - The reserve map for private mappings has the\n\t\t * opposite meaning than that of shared mappings.  If NO\n\t\t * entry is in the reserve map, it means a reservation exists.\n\t\t * If an entry exists in the reserve map, it means the\n\t\t * reservation has already been consumed.  As a result, the\n\t\t * return value of this routine is the opposite of the\n\t\t * value returned from reserve map manipulation routines above.\n\t\t */\n\t\tif (ret)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t\treturn ret < 0 ? ret : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long vma_add_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_ADD_RESV);\n}"
  },
  {
    "function_name": "vma_end_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1934-1938",
    "snippet": "static void vma_end_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\t(void)__vma_reservation_common(h, vma, addr, VMA_END_RESV);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vma_reservation_common",
          "args": [
            "h",
            "vma",
            "addr",
            "VMA_END_RESV"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_reservation_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1861-1920",
          "snippet": "static long __vma_reservation_common(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tenum vma_resv_mode mode)\n{\n\tstruct resv_map *resv;\n\tpgoff_t idx;\n\tlong ret;\n\n\tresv = vma_resv_map(vma);\n\tif (!resv)\n\t\treturn 1;\n\n\tidx = vma_hugecache_offset(h, vma, addr);\n\tswitch (mode) {\n\tcase VMA_NEEDS_RESV:\n\t\tret = region_chg(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_COMMIT_RESV:\n\t\tret = region_add(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_END_RESV:\n\t\tregion_abort(resv, idx, idx + 1);\n\t\tret = 0;\n\t\tbreak;\n\tcase VMA_ADD_RESV:\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tret = region_add(resv, idx, idx + 1);\n\t\telse {\n\t\t\tregion_abort(resv, idx, idx + 1);\n\t\t\tret = region_del(resv, idx, idx + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn ret;\n\telse if (is_vma_resv_set(vma, HPAGE_RESV_OWNER) && ret >= 0) {\n\t\t/*\n\t\t * In most cases, reserves always exist for private mappings.\n\t\t * However, a file associated with mapping could have been\n\t\t * hole punched or truncated after reserves were consumed.\n\t\t * As subsequent fault on such a range will not use reserves.\n\t\t * Subtle - The reserve map for private mappings has the\n\t\t * opposite meaning than that of shared mappings.  If NO\n\t\t * entry is in the reserve map, it means a reservation exists.\n\t\t * If an entry exists in the reserve map, it means the\n\t\t * reservation has already been consumed.  As a result, the\n\t\t * return value of this routine is the opposite of the\n\t\t * value returned from reserve map manipulation routines above.\n\t\t */\n\t\tif (ret)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_OWNER    (1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic long __vma_reservation_common(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tenum vma_resv_mode mode)\n{\n\tstruct resv_map *resv;\n\tpgoff_t idx;\n\tlong ret;\n\n\tresv = vma_resv_map(vma);\n\tif (!resv)\n\t\treturn 1;\n\n\tidx = vma_hugecache_offset(h, vma, addr);\n\tswitch (mode) {\n\tcase VMA_NEEDS_RESV:\n\t\tret = region_chg(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_COMMIT_RESV:\n\t\tret = region_add(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_END_RESV:\n\t\tregion_abort(resv, idx, idx + 1);\n\t\tret = 0;\n\t\tbreak;\n\tcase VMA_ADD_RESV:\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tret = region_add(resv, idx, idx + 1);\n\t\telse {\n\t\t\tregion_abort(resv, idx, idx + 1);\n\t\t\tret = region_del(resv, idx, idx + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn ret;\n\telse if (is_vma_resv_set(vma, HPAGE_RESV_OWNER) && ret >= 0) {\n\t\t/*\n\t\t * In most cases, reserves always exist for private mappings.\n\t\t * However, a file associated with mapping could have been\n\t\t * hole punched or truncated after reserves were consumed.\n\t\t * As subsequent fault on such a range will not use reserves.\n\t\t * Subtle - The reserve map for private mappings has the\n\t\t * opposite meaning than that of shared mappings.  If NO\n\t\t * entry is in the reserve map, it means a reservation exists.\n\t\t * If an entry exists in the reserve map, it means the\n\t\t * reservation has already been consumed.  As a result, the\n\t\t * return value of this routine is the opposite of the\n\t\t * value returned from reserve map manipulation routines above.\n\t\t */\n\t\tif (ret)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t\treturn ret < 0 ? ret : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void vma_end_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\t(void)__vma_reservation_common(h, vma, addr, VMA_END_RESV);\n}"
  },
  {
    "function_name": "vma_commit_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1928-1932",
    "snippet": "static long vma_commit_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_COMMIT_RESV);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vma_reservation_common",
          "args": [
            "h",
            "vma",
            "addr",
            "VMA_COMMIT_RESV"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_reservation_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1861-1920",
          "snippet": "static long __vma_reservation_common(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tenum vma_resv_mode mode)\n{\n\tstruct resv_map *resv;\n\tpgoff_t idx;\n\tlong ret;\n\n\tresv = vma_resv_map(vma);\n\tif (!resv)\n\t\treturn 1;\n\n\tidx = vma_hugecache_offset(h, vma, addr);\n\tswitch (mode) {\n\tcase VMA_NEEDS_RESV:\n\t\tret = region_chg(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_COMMIT_RESV:\n\t\tret = region_add(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_END_RESV:\n\t\tregion_abort(resv, idx, idx + 1);\n\t\tret = 0;\n\t\tbreak;\n\tcase VMA_ADD_RESV:\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tret = region_add(resv, idx, idx + 1);\n\t\telse {\n\t\t\tregion_abort(resv, idx, idx + 1);\n\t\t\tret = region_del(resv, idx, idx + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn ret;\n\telse if (is_vma_resv_set(vma, HPAGE_RESV_OWNER) && ret >= 0) {\n\t\t/*\n\t\t * In most cases, reserves always exist for private mappings.\n\t\t * However, a file associated with mapping could have been\n\t\t * hole punched or truncated after reserves were consumed.\n\t\t * As subsequent fault on such a range will not use reserves.\n\t\t * Subtle - The reserve map for private mappings has the\n\t\t * opposite meaning than that of shared mappings.  If NO\n\t\t * entry is in the reserve map, it means a reservation exists.\n\t\t * If an entry exists in the reserve map, it means the\n\t\t * reservation has already been consumed.  As a result, the\n\t\t * return value of this routine is the opposite of the\n\t\t * value returned from reserve map manipulation routines above.\n\t\t */\n\t\tif (ret)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_OWNER    (1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic long __vma_reservation_common(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tenum vma_resv_mode mode)\n{\n\tstruct resv_map *resv;\n\tpgoff_t idx;\n\tlong ret;\n\n\tresv = vma_resv_map(vma);\n\tif (!resv)\n\t\treturn 1;\n\n\tidx = vma_hugecache_offset(h, vma, addr);\n\tswitch (mode) {\n\tcase VMA_NEEDS_RESV:\n\t\tret = region_chg(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_COMMIT_RESV:\n\t\tret = region_add(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_END_RESV:\n\t\tregion_abort(resv, idx, idx + 1);\n\t\tret = 0;\n\t\tbreak;\n\tcase VMA_ADD_RESV:\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tret = region_add(resv, idx, idx + 1);\n\t\telse {\n\t\t\tregion_abort(resv, idx, idx + 1);\n\t\t\tret = region_del(resv, idx, idx + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn ret;\n\telse if (is_vma_resv_set(vma, HPAGE_RESV_OWNER) && ret >= 0) {\n\t\t/*\n\t\t * In most cases, reserves always exist for private mappings.\n\t\t * However, a file associated with mapping could have been\n\t\t * hole punched or truncated after reserves were consumed.\n\t\t * As subsequent fault on such a range will not use reserves.\n\t\t * Subtle - The reserve map for private mappings has the\n\t\t * opposite meaning than that of shared mappings.  If NO\n\t\t * entry is in the reserve map, it means a reservation exists.\n\t\t * If an entry exists in the reserve map, it means the\n\t\t * reservation has already been consumed.  As a result, the\n\t\t * return value of this routine is the opposite of the\n\t\t * value returned from reserve map manipulation routines above.\n\t\t */\n\t\tif (ret)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t\treturn ret < 0 ? ret : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long vma_commit_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_COMMIT_RESV);\n}"
  },
  {
    "function_name": "vma_needs_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1922-1926",
    "snippet": "static long vma_needs_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_NEEDS_RESV);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vma_reservation_common",
          "args": [
            "h",
            "vma",
            "addr",
            "VMA_NEEDS_RESV"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_reservation_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1861-1920",
          "snippet": "static long __vma_reservation_common(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tenum vma_resv_mode mode)\n{\n\tstruct resv_map *resv;\n\tpgoff_t idx;\n\tlong ret;\n\n\tresv = vma_resv_map(vma);\n\tif (!resv)\n\t\treturn 1;\n\n\tidx = vma_hugecache_offset(h, vma, addr);\n\tswitch (mode) {\n\tcase VMA_NEEDS_RESV:\n\t\tret = region_chg(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_COMMIT_RESV:\n\t\tret = region_add(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_END_RESV:\n\t\tregion_abort(resv, idx, idx + 1);\n\t\tret = 0;\n\t\tbreak;\n\tcase VMA_ADD_RESV:\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tret = region_add(resv, idx, idx + 1);\n\t\telse {\n\t\t\tregion_abort(resv, idx, idx + 1);\n\t\t\tret = region_del(resv, idx, idx + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn ret;\n\telse if (is_vma_resv_set(vma, HPAGE_RESV_OWNER) && ret >= 0) {\n\t\t/*\n\t\t * In most cases, reserves always exist for private mappings.\n\t\t * However, a file associated with mapping could have been\n\t\t * hole punched or truncated after reserves were consumed.\n\t\t * As subsequent fault on such a range will not use reserves.\n\t\t * Subtle - The reserve map for private mappings has the\n\t\t * opposite meaning than that of shared mappings.  If NO\n\t\t * entry is in the reserve map, it means a reservation exists.\n\t\t * If an entry exists in the reserve map, it means the\n\t\t * reservation has already been consumed.  As a result, the\n\t\t * return value of this routine is the opposite of the\n\t\t * value returned from reserve map manipulation routines above.\n\t\t */\n\t\tif (ret)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_OWNER    (1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic long __vma_reservation_common(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tenum vma_resv_mode mode)\n{\n\tstruct resv_map *resv;\n\tpgoff_t idx;\n\tlong ret;\n\n\tresv = vma_resv_map(vma);\n\tif (!resv)\n\t\treturn 1;\n\n\tidx = vma_hugecache_offset(h, vma, addr);\n\tswitch (mode) {\n\tcase VMA_NEEDS_RESV:\n\t\tret = region_chg(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_COMMIT_RESV:\n\t\tret = region_add(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_END_RESV:\n\t\tregion_abort(resv, idx, idx + 1);\n\t\tret = 0;\n\t\tbreak;\n\tcase VMA_ADD_RESV:\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tret = region_add(resv, idx, idx + 1);\n\t\telse {\n\t\t\tregion_abort(resv, idx, idx + 1);\n\t\t\tret = region_del(resv, idx, idx + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn ret;\n\telse if (is_vma_resv_set(vma, HPAGE_RESV_OWNER) && ret >= 0) {\n\t\t/*\n\t\t * In most cases, reserves always exist for private mappings.\n\t\t * However, a file associated with mapping could have been\n\t\t * hole punched or truncated after reserves were consumed.\n\t\t * As subsequent fault on such a range will not use reserves.\n\t\t * Subtle - The reserve map for private mappings has the\n\t\t * opposite meaning than that of shared mappings.  If NO\n\t\t * entry is in the reserve map, it means a reservation exists.\n\t\t * If an entry exists in the reserve map, it means the\n\t\t * reservation has already been consumed.  As a result, the\n\t\t * return value of this routine is the opposite of the\n\t\t * value returned from reserve map manipulation routines above.\n\t\t */\n\t\tif (ret)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t\treturn ret < 0 ? ret : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long vma_needs_reservation(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\treturn __vma_reservation_common(h, vma, addr, VMA_NEEDS_RESV);\n}"
  },
  {
    "function_name": "__vma_reservation_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1861-1920",
    "snippet": "static long __vma_reservation_common(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tenum vma_resv_mode mode)\n{\n\tstruct resv_map *resv;\n\tpgoff_t idx;\n\tlong ret;\n\n\tresv = vma_resv_map(vma);\n\tif (!resv)\n\t\treturn 1;\n\n\tidx = vma_hugecache_offset(h, vma, addr);\n\tswitch (mode) {\n\tcase VMA_NEEDS_RESV:\n\t\tret = region_chg(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_COMMIT_RESV:\n\t\tret = region_add(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_END_RESV:\n\t\tregion_abort(resv, idx, idx + 1);\n\t\tret = 0;\n\t\tbreak;\n\tcase VMA_ADD_RESV:\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tret = region_add(resv, idx, idx + 1);\n\t\telse {\n\t\t\tregion_abort(resv, idx, idx + 1);\n\t\t\tret = region_del(resv, idx, idx + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn ret;\n\telse if (is_vma_resv_set(vma, HPAGE_RESV_OWNER) && ret >= 0) {\n\t\t/*\n\t\t * In most cases, reserves always exist for private mappings.\n\t\t * However, a file associated with mapping could have been\n\t\t * hole punched or truncated after reserves were consumed.\n\t\t * As subsequent fault on such a range will not use reserves.\n\t\t * Subtle - The reserve map for private mappings has the\n\t\t * opposite meaning than that of shared mappings.  If NO\n\t\t * entry is in the reserve map, it means a reservation exists.\n\t\t * If an entry exists in the reserve map, it means the\n\t\t * reservation has already been consumed.  As a result, the\n\t\t * return value of this routine is the opposite of the\n\t\t * value returned from reserve map manipulation routines above.\n\t\t */\n\t\tif (ret)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define HPAGE_RESV_OWNER    (1UL << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_vma_resv_set",
          "args": [
            "vma",
            "HPAGE_RESV_OWNER"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "is_vma_resv_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "777-782",
          "snippet": "static int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "region_del",
          "args": [
            "resv",
            "idx",
            "idx + 1"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "region_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "482-561",
          "snippet": "static long region_del(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *trg;\n\tstruct file_region *nrg = NULL;\n\tlong del = 0;\n\nretry:\n\tspin_lock(&resv->lock);\n\tlist_for_each_entry_safe(rg, trg, head, link) {\n\t\t/*\n\t\t * Skip regions before the range to be deleted.  file_region\n\t\t * ranges are normally of the form [from, to).  However, there\n\t\t * may be a \"placeholder\" entry in the map which is of the form\n\t\t * (from, to) with from == to.  Check for placeholder entries\n\t\t * at the beginning of the range to be deleted.\n\t\t */\n\t\tif (rg->to <= f && (rg->to != rg->from || rg->to != f))\n\t\t\tcontinue;\n\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tif (f > rg->from && t < rg->to) { /* Must split region */\n\t\t\t/*\n\t\t\t * Check for an entry in the cache before dropping\n\t\t\t * lock and attempting allocation.\n\t\t\t */\n\t\t\tif (!nrg &&\n\t\t\t    resv->region_cache_count > resv->adds_in_progress) {\n\t\t\t\tnrg = list_first_entry(&resv->region_cache,\n\t\t\t\t\t\t\tstruct file_region,\n\t\t\t\t\t\t\tlink);\n\t\t\t\tlist_del(&nrg->link);\n\t\t\t\tresv->region_cache_count--;\n\t\t\t}\n\n\t\t\tif (!nrg) {\n\t\t\t\tspin_unlock(&resv->lock);\n\t\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\t\tif (!nrg)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tdel += t - f;\n\n\t\t\t/* New entry for end of split region */\n\t\t\tnrg->from = t;\n\t\t\tnrg->to = rg->to;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\n\t\t\t/* Original entry is trimmed */\n\t\t\trg->to = f;\n\n\t\t\tlist_add(&nrg->link, &rg->link);\n\t\t\tnrg = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (f <= rg->from && t >= rg->to) { /* Remove entire region */\n\t\t\tdel += rg->to - rg->from;\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (f <= rg->from) {\t/* Trim beginning of region */\n\t\t\tdel += t - rg->from;\n\t\t\trg->from = t;\n\t\t} else {\t\t/* Trim end of region */\n\t\t\tdel += rg->to - f;\n\t\t\trg->to = f;\n\t\t}\n\t}\n\n\tspin_unlock(&resv->lock);\n\tkfree(nrg);\n\treturn del;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_del(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *trg;\n\tstruct file_region *nrg = NULL;\n\tlong del = 0;\n\nretry:\n\tspin_lock(&resv->lock);\n\tlist_for_each_entry_safe(rg, trg, head, link) {\n\t\t/*\n\t\t * Skip regions before the range to be deleted.  file_region\n\t\t * ranges are normally of the form [from, to).  However, there\n\t\t * may be a \"placeholder\" entry in the map which is of the form\n\t\t * (from, to) with from == to.  Check for placeholder entries\n\t\t * at the beginning of the range to be deleted.\n\t\t */\n\t\tif (rg->to <= f && (rg->to != rg->from || rg->to != f))\n\t\t\tcontinue;\n\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tif (f > rg->from && t < rg->to) { /* Must split region */\n\t\t\t/*\n\t\t\t * Check for an entry in the cache before dropping\n\t\t\t * lock and attempting allocation.\n\t\t\t */\n\t\t\tif (!nrg &&\n\t\t\t    resv->region_cache_count > resv->adds_in_progress) {\n\t\t\t\tnrg = list_first_entry(&resv->region_cache,\n\t\t\t\t\t\t\tstruct file_region,\n\t\t\t\t\t\t\tlink);\n\t\t\t\tlist_del(&nrg->link);\n\t\t\t\tresv->region_cache_count--;\n\t\t\t}\n\n\t\t\tif (!nrg) {\n\t\t\t\tspin_unlock(&resv->lock);\n\t\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\t\tif (!nrg)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tdel += t - f;\n\n\t\t\t/* New entry for end of split region */\n\t\t\tnrg->from = t;\n\t\t\tnrg->to = rg->to;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\n\t\t\t/* Original entry is trimmed */\n\t\t\trg->to = f;\n\n\t\t\tlist_add(&nrg->link, &rg->link);\n\t\t\tnrg = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (f <= rg->from && t >= rg->to) { /* Remove entire region */\n\t\t\tdel += rg->to - rg->from;\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (f <= rg->from) {\t/* Trim beginning of region */\n\t\t\tdel += t - rg->from;\n\t\t\trg->from = t;\n\t\t} else {\t\t/* Trim end of region */\n\t\t\tdel += rg->to - f;\n\t\t\trg->to = f;\n\t\t}\n\t}\n\n\tspin_unlock(&resv->lock);\n\tkfree(nrg);\n\treturn del;\n}"
        }
      },
      {
        "call_info": {
          "callee": "region_abort",
          "args": [
            "resv",
            "idx",
            "idx + 1"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "region_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "460-466",
          "snippet": "static void region_abort(struct resv_map *resv, long f, long t)\n{\n\tspin_lock(&resv->lock);\n\tVM_BUG_ON(!resv->region_cache_count);\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void region_abort(struct resv_map *resv, long f, long t)\n{\n\tspin_lock(&resv->lock);\n\tVM_BUG_ON(!resv->region_cache_count);\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "region_add",
          "args": [
            "resv",
            "idx",
            "idx + 1"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "region_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "259-331",
          "snippet": "static long region_add(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg, *trg;\n\tlong add = 0;\n\n\tspin_lock(&resv->lock);\n\t/* Locate the region we are either in or before. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/*\n\t * If no region exists which can be expanded to include the\n\t * specified range, the list must have been modified by an\n\t * interleving call to region_del().  Pull a region descriptor\n\t * from the cache and use it for this range.\n\t */\n\tif (&rg->link == head || t < rg->from) {\n\t\tVM_BUG_ON(resv->region_cache_count <= 0);\n\n\t\tresv->region_cache_count--;\n\t\tnrg = list_first_entry(&resv->region_cache, struct file_region,\n\t\t\t\t\tlink);\n\t\tlist_del(&nrg->link);\n\n\t\tnrg->from = f;\n\t\tnrg->to = t;\n\t\tlist_add(&nrg->link, rg->link.prev);\n\n\t\tadd += t - f;\n\t\tgoto out_locked;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tnrg = rg;\n\tlist_for_each_entry_safe(rg, trg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tbreak;\n\n\t\t/* If this area reaches higher then extend our area to\n\t\t * include it completely.  If this is not the first area\n\t\t * which we intend to reuse, free it. */\n\t\tif (rg->to > t)\n\t\t\tt = rg->to;\n\t\tif (rg != nrg) {\n\t\t\t/* Decrement return value by the deleted range.\n\t\t\t * Another range will span this area so that by\n\t\t\t * end of routine add will be >= zero\n\t\t\t */\n\t\t\tadd -= (rg->to - rg->from);\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t}\n\t}\n\n\tadd += (nrg->from - f);\t\t/* Added to beginning of region */\n\tnrg->from = f;\n\tadd += t - nrg->to;\t\t/* Added to end of region */\n\tnrg->to = t;\n\nout_locked:\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n\tVM_BUG_ON(add < 0);\n\treturn add;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_add(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg, *trg;\n\tlong add = 0;\n\n\tspin_lock(&resv->lock);\n\t/* Locate the region we are either in or before. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/*\n\t * If no region exists which can be expanded to include the\n\t * specified range, the list must have been modified by an\n\t * interleving call to region_del().  Pull a region descriptor\n\t * from the cache and use it for this range.\n\t */\n\tif (&rg->link == head || t < rg->from) {\n\t\tVM_BUG_ON(resv->region_cache_count <= 0);\n\n\t\tresv->region_cache_count--;\n\t\tnrg = list_first_entry(&resv->region_cache, struct file_region,\n\t\t\t\t\tlink);\n\t\tlist_del(&nrg->link);\n\n\t\tnrg->from = f;\n\t\tnrg->to = t;\n\t\tlist_add(&nrg->link, rg->link.prev);\n\n\t\tadd += t - f;\n\t\tgoto out_locked;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tnrg = rg;\n\tlist_for_each_entry_safe(rg, trg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tbreak;\n\n\t\t/* If this area reaches higher then extend our area to\n\t\t * include it completely.  If this is not the first area\n\t\t * which we intend to reuse, free it. */\n\t\tif (rg->to > t)\n\t\t\tt = rg->to;\n\t\tif (rg != nrg) {\n\t\t\t/* Decrement return value by the deleted range.\n\t\t\t * Another range will span this area so that by\n\t\t\t * end of routine add will be >= zero\n\t\t\t */\n\t\t\tadd -= (rg->to - rg->from);\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t}\n\t}\n\n\tadd += (nrg->from - f);\t\t/* Added to beginning of region */\n\tnrg->from = f;\n\tadd += t - nrg->to;\t\t/* Added to end of region */\n\tnrg->to = t;\n\nout_locked:\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n\tVM_BUG_ON(add < 0);\n\treturn add;\n}"
        }
      },
      {
        "call_info": {
          "callee": "region_chg",
          "args": [
            "resv",
            "idx",
            "idx + 1"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "region_chg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "355-447",
          "snippet": "static long region_chg(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg = NULL;\n\tlong chg = 0;\n\nretry:\n\tspin_lock(&resv->lock);\nretry_locked:\n\tresv->adds_in_progress++;\n\n\t/*\n\t * Check for sufficient descriptors in the cache to accommodate\n\t * the number of in progress add operations.\n\t */\n\tif (resv->adds_in_progress > resv->region_cache_count) {\n\t\tstruct file_region *trg;\n\n\t\tVM_BUG_ON(resv->adds_in_progress - resv->region_cache_count > 1);\n\t\t/* Must drop lock to allocate a new descriptor. */\n\t\tresv->adds_in_progress--;\n\t\tspin_unlock(&resv->lock);\n\n\t\ttrg = kmalloc(sizeof(*trg), GFP_KERNEL);\n\t\tif (!trg) {\n\t\t\tkfree(nrg);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tspin_lock(&resv->lock);\n\t\tlist_add(&trg->link, &resv->region_cache);\n\t\tresv->region_cache_count++;\n\t\tgoto retry_locked;\n\t}\n\n\t/* Locate the region we are before or in. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/* If we are below the current region then a new region is required.\n\t * Subtle, allocate a new region at the position but make it zero\n\t * size such that we can guarantee to record the reservation. */\n\tif (&rg->link == head || t < rg->from) {\n\t\tif (!nrg) {\n\t\t\tresv->adds_in_progress--;\n\t\t\tspin_unlock(&resv->lock);\n\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\tif (!nrg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnrg->from = f;\n\t\t\tnrg->to   = f;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tlist_add(&nrg->link, rg->link.prev);\n\t\tchg = t - f;\n\t\tgoto out_nrg;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\tchg = t - f;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tlist_for_each_entry(rg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tgoto out;\n\n\t\t/* We overlap with this area, if it extends further than\n\t\t * us then we must extend ourselves.  Account for its\n\t\t * existing reservation. */\n\t\tif (rg->to > t) {\n\t\t\tchg += rg->to - t;\n\t\t\tt = rg->to;\n\t\t}\n\t\tchg -= rg->to - rg->from;\n\t}\n\nout:\n\tspin_unlock(&resv->lock);\n\t/*  We already know we raced and no longer need the new region */\n\tkfree(nrg);\n\treturn chg;\nout_nrg:\n\tspin_unlock(&resv->lock);\n\treturn chg;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_chg(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg = NULL;\n\tlong chg = 0;\n\nretry:\n\tspin_lock(&resv->lock);\nretry_locked:\n\tresv->adds_in_progress++;\n\n\t/*\n\t * Check for sufficient descriptors in the cache to accommodate\n\t * the number of in progress add operations.\n\t */\n\tif (resv->adds_in_progress > resv->region_cache_count) {\n\t\tstruct file_region *trg;\n\n\t\tVM_BUG_ON(resv->adds_in_progress - resv->region_cache_count > 1);\n\t\t/* Must drop lock to allocate a new descriptor. */\n\t\tresv->adds_in_progress--;\n\t\tspin_unlock(&resv->lock);\n\n\t\ttrg = kmalloc(sizeof(*trg), GFP_KERNEL);\n\t\tif (!trg) {\n\t\t\tkfree(nrg);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tspin_lock(&resv->lock);\n\t\tlist_add(&trg->link, &resv->region_cache);\n\t\tresv->region_cache_count++;\n\t\tgoto retry_locked;\n\t}\n\n\t/* Locate the region we are before or in. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/* If we are below the current region then a new region is required.\n\t * Subtle, allocate a new region at the position but make it zero\n\t * size such that we can guarantee to record the reservation. */\n\tif (&rg->link == head || t < rg->from) {\n\t\tif (!nrg) {\n\t\t\tresv->adds_in_progress--;\n\t\t\tspin_unlock(&resv->lock);\n\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\tif (!nrg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnrg->from = f;\n\t\t\tnrg->to   = f;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tlist_add(&nrg->link, rg->link.prev);\n\t\tchg = t - f;\n\t\tgoto out_nrg;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\tchg = t - f;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tlist_for_each_entry(rg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tgoto out;\n\n\t\t/* We overlap with this area, if it extends further than\n\t\t * us then we must extend ourselves.  Account for its\n\t\t * existing reservation. */\n\t\tif (rg->to > t) {\n\t\t\tchg += rg->to - t;\n\t\t\tt = rg->to;\n\t\t}\n\t\tchg -= rg->to - rg->from;\n\t}\n\nout:\n\tspin_unlock(&resv->lock);\n\t/*  We already know we raced and no longer need the new region */\n\tkfree(nrg);\n\treturn chg;\nout_nrg:\n\tspin_unlock(&resv->lock);\n\treturn chg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_hugecache_offset",
          "args": [
            "h",
            "vma",
            "addr"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "vma_hugecache_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "620-625",
          "snippet": "static pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_resv_map",
          "args": [
            "vma"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "vma_resv_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "745-758",
          "snippet": "static struct resv_map *vma_resv_map(struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\t\tstruct inode *inode = mapping->host;\n\n\t\treturn inode_resv_map(inode);\n\n\t} else {\n\t\treturn (struct resv_map *)(get_vma_private_data(vma) &\n\t\t\t\t\t\t\t~HPAGE_RESV_MASK);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)\n\nstatic struct resv_map *vma_resv_map(struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\t\tstruct inode *inode = mapping->host;\n\n\t\treturn inode_resv_map(inode);\n\n\t} else {\n\t\treturn (struct resv_map *)(get_vma_private_data(vma) &\n\t\t\t\t\t\t\t~HPAGE_RESV_MASK);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic long __vma_reservation_common(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tenum vma_resv_mode mode)\n{\n\tstruct resv_map *resv;\n\tpgoff_t idx;\n\tlong ret;\n\n\tresv = vma_resv_map(vma);\n\tif (!resv)\n\t\treturn 1;\n\n\tidx = vma_hugecache_offset(h, vma, addr);\n\tswitch (mode) {\n\tcase VMA_NEEDS_RESV:\n\t\tret = region_chg(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_COMMIT_RESV:\n\t\tret = region_add(resv, idx, idx + 1);\n\t\tbreak;\n\tcase VMA_END_RESV:\n\t\tregion_abort(resv, idx, idx + 1);\n\t\tret = 0;\n\t\tbreak;\n\tcase VMA_ADD_RESV:\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tret = region_add(resv, idx, idx + 1);\n\t\telse {\n\t\t\tregion_abort(resv, idx, idx + 1);\n\t\t\tret = region_del(resv, idx, idx + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn ret;\n\telse if (is_vma_resv_set(vma, HPAGE_RESV_OWNER) && ret >= 0) {\n\t\t/*\n\t\t * In most cases, reserves always exist for private mappings.\n\t\t * However, a file associated with mapping could have been\n\t\t * hole punched or truncated after reserves were consumed.\n\t\t * As subsequent fault on such a range will not use reserves.\n\t\t * Subtle - The reserve map for private mappings has the\n\t\t * opposite meaning than that of shared mappings.  If NO\n\t\t * entry is in the reserve map, it means a reservation exists.\n\t\t * If an entry exists in the reserve map, it means the\n\t\t * reservation has already been consumed.  As a result, the\n\t\t * return value of this routine is the opposite of the\n\t\t * value returned from reserve map manipulation routines above.\n\t\t */\n\t\tif (ret)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t\treturn ret < 0 ? ret : 0;\n}"
  },
  {
    "function_name": "return_unused_surplus_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1790-1828",
    "snippet": "static void return_unused_surplus_pages(struct hstate *h,\n\t\t\t\t\tunsigned long unused_resv_pages)\n{\n\tunsigned long nr_pages;\n\n\t/* Cannot return gigantic pages currently */\n\tif (hstate_is_gigantic(h))\n\t\tgoto out;\n\n\t/*\n\t * Part (or even all) of the reservation could have been backed\n\t * by pre-allocated pages. Only free surplus pages.\n\t */\n\tnr_pages = min(unused_resv_pages, h->surplus_huge_pages);\n\n\t/*\n\t * We want to release as many surplus pages as possible, spread\n\t * evenly across all nodes with memory. Iterate across these nodes\n\t * until we can no longer free unreserved surplus pages. This occurs\n\t * when the nodes with surplus pages have no free pages.\n\t * free_pool_huge_page() will balance the the freed pages across the\n\t * on-line nodes with memory and will handle the hstate accounting.\n\t *\n\t * Note that we decrement resv_huge_pages as we free the pages.  If\n\t * we drop the lock, resv_huge_pages will still be sufficiently large\n\t * to cover subsequent pages we may free.\n\t */\n\twhile (nr_pages--) {\n\t\th->resv_huge_pages--;\n\t\tunused_resv_pages--;\n\t\tif (!free_pool_huge_page(h, &node_states[N_MEMORY], 1))\n\t\t\tgoto out;\n\t\tcond_resched_lock(&hugetlb_lock);\n\t}\n\nout:\n\t/* Fully uncommit the reservation */\n\th->resv_huge_pages -= unused_resv_pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pool_huge_page",
          "args": [
            "h",
            "&node_states[N_MEMORY]",
            "1"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "free_pool_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1447-1477",
          "snippet": "static int free_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed,\n\t\t\t\t\t\t\t bool acct_surplus)\n{\n\tint nr_nodes, node;\n\tint ret = 0;\n\n\tfor_each_node_mask_to_free(h, nr_nodes, node, nodes_allowed) {\n\t\t/*\n\t\t * If we're returning unused surplus pages, only examine\n\t\t * nodes with surplus pages.\n\t\t */\n\t\tif ((!acct_surplus || h->surplus_huge_pages_node[node]) &&\n\t\t    !list_empty(&h->hugepage_freelists[node])) {\n\t\t\tstruct page *page =\n\t\t\t\tlist_entry(h->hugepage_freelists[node].next,\n\t\t\t\t\t  struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\th->free_huge_pages--;\n\t\t\th->free_huge_pages_node[node]--;\n\t\t\tif (acct_surplus) {\n\t\t\t\th->surplus_huge_pages--;\n\t\t\t\th->surplus_huge_pages_node[node]--;\n\t\t\t}\n\t\t\tupdate_and_free_page(h, page);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int free_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed,\n\t\t\t\t\t\t\t bool acct_surplus)\n{\n\tint nr_nodes, node;\n\tint ret = 0;\n\n\tfor_each_node_mask_to_free(h, nr_nodes, node, nodes_allowed) {\n\t\t/*\n\t\t * If we're returning unused surplus pages, only examine\n\t\t * nodes with surplus pages.\n\t\t */\n\t\tif ((!acct_surplus || h->surplus_huge_pages_node[node]) &&\n\t\t    !list_empty(&h->hugepage_freelists[node])) {\n\t\t\tstruct page *page =\n\t\t\t\tlist_entry(h->hugepage_freelists[node].next,\n\t\t\t\t\t  struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\th->free_huge_pages--;\n\t\t\th->free_huge_pages_node[node]--;\n\t\t\tif (acct_surplus) {\n\t\t\t\th->surplus_huge_pages--;\n\t\t\t\th->surplus_huge_pages_node[node]--;\n\t\t\t}\n\t\t\tupdate_and_free_page(h, page);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "unused_resv_pages",
            "h->surplus_huge_pages"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_report_node_meminfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3003-3015",
          "snippet": "int hugetlb_report_node_meminfo(int nid, char *buf)\n{\n\tstruct hstate *h = &default_hstate;\n\tif (!hugepages_supported())\n\t\treturn 0;\n\treturn sprintf(buf,\n\t\t\"Node %d HugePages_Total: %5u\\n\"\n\t\t\"Node %d HugePages_Free:  %5u\\n\"\n\t\t\"Node %d HugePages_Surp:  %5u\\n\",\n\t\tnid, h->nr_huge_pages_node[nid],\n\t\tnid, h->free_huge_pages_node[nid],\n\t\tnid, h->surplus_huge_pages_node[nid]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint hugetlb_report_node_meminfo(int nid, char *buf)\n{\n\tstruct hstate *h = &default_hstate;\n\tif (!hugepages_supported())\n\t\treturn 0;\n\treturn sprintf(buf,\n\t\t\"Node %d HugePages_Total: %5u\\n\"\n\t\t\"Node %d HugePages_Free:  %5u\\n\"\n\t\t\"Node %d HugePages_Surp:  %5u\\n\",\n\t\tnid, h->nr_huge_pages_node[nid],\n\t\tnid, h->free_huge_pages_node[nid],\n\t\tnid, h->surplus_huge_pages_node[nid]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void return_unused_surplus_pages(struct hstate *h,\n\t\t\t\t\tunsigned long unused_resv_pages)\n{\n\tunsigned long nr_pages;\n\n\t/* Cannot return gigantic pages currently */\n\tif (hstate_is_gigantic(h))\n\t\tgoto out;\n\n\t/*\n\t * Part (or even all) of the reservation could have been backed\n\t * by pre-allocated pages. Only free surplus pages.\n\t */\n\tnr_pages = min(unused_resv_pages, h->surplus_huge_pages);\n\n\t/*\n\t * We want to release as many surplus pages as possible, spread\n\t * evenly across all nodes with memory. Iterate across these nodes\n\t * until we can no longer free unreserved surplus pages. This occurs\n\t * when the nodes with surplus pages have no free pages.\n\t * free_pool_huge_page() will balance the the freed pages across the\n\t * on-line nodes with memory and will handle the hstate accounting.\n\t *\n\t * Note that we decrement resv_huge_pages as we free the pages.  If\n\t * we drop the lock, resv_huge_pages will still be sufficiently large\n\t * to cover subsequent pages we may free.\n\t */\n\twhile (nr_pages--) {\n\t\th->resv_huge_pages--;\n\t\tunused_resv_pages--;\n\t\tif (!free_pool_huge_page(h, &node_states[N_MEMORY], 1))\n\t\t\tgoto out;\n\t\tcond_resched_lock(&hugetlb_lock);\n\t}\n\nout:\n\t/* Fully uncommit the reservation */\n\th->resv_huge_pages -= unused_resv_pages;\n}"
  },
  {
    "function_name": "gather_surplus_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1692-1774",
    "snippet": "static int gather_surplus_pages(struct hstate *h, int delta)\n{\n\tstruct list_head surplus_list;\n\tstruct page *page, *tmp;\n\tint ret, i;\n\tint needed, allocated;\n\tbool alloc_ok = true;\n\n\tneeded = (h->resv_huge_pages + delta) - h->free_huge_pages;\n\tif (needed <= 0) {\n\t\th->resv_huge_pages += delta;\n\t\treturn 0;\n\t}\n\n\tallocated = 0;\n\tINIT_LIST_HEAD(&surplus_list);\n\n\tret = -ENOMEM;\nretry:\n\tspin_unlock(&hugetlb_lock);\n\tfor (i = 0; i < needed; i++) {\n\t\tpage = alloc_surplus_huge_page(h, htlb_alloc_mask(h),\n\t\t\t\tNUMA_NO_NODE, NULL);\n\t\tif (!page) {\n\t\t\talloc_ok = false;\n\t\t\tbreak;\n\t\t}\n\t\tlist_add(&page->lru, &surplus_list);\n\t\tcond_resched();\n\t}\n\tallocated += i;\n\n\t/*\n\t * After retaking hugetlb_lock, we need to recalculate 'needed'\n\t * because either resv_huge_pages or free_huge_pages may have changed.\n\t */\n\tspin_lock(&hugetlb_lock);\n\tneeded = (h->resv_huge_pages + delta) -\n\t\t\t(h->free_huge_pages + allocated);\n\tif (needed > 0) {\n\t\tif (alloc_ok)\n\t\t\tgoto retry;\n\t\t/*\n\t\t * We were not able to allocate enough pages to\n\t\t * satisfy the entire reservation so we free what\n\t\t * we've allocated so far.\n\t\t */\n\t\tgoto free;\n\t}\n\t/*\n\t * The surplus_list now contains _at_least_ the number of extra pages\n\t * needed to accommodate the reservation.  Add the appropriate number\n\t * of pages to the hugetlb pool and free the extras back to the buddy\n\t * allocator.  Commit the entire reservation here to prevent another\n\t * process from stealing the pages as they are added to the pool but\n\t * before they are reserved.\n\t */\n\tneeded += allocated;\n\th->resv_huge_pages += delta;\n\tret = 0;\n\n\t/* Free the needed pages to the hugetlb pool */\n\tlist_for_each_entry_safe(page, tmp, &surplus_list, lru) {\n\t\tif ((--needed) < 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * This page is now managed by the hugetlb allocator and has\n\t\t * no users -- drop the buddy allocator's reference.\n\t\t */\n\t\tput_page_testzero(page);\n\t\tVM_BUG_ON_PAGE(page_count(page), page);\n\t\tenqueue_huge_page(h, page);\n\t}\nfree:\n\tspin_unlock(&hugetlb_lock);\n\n\t/* Free unnecessary surplus pages to the buddy allocator */\n\tlist_for_each_entry_safe(page, tmp, &surplus_list, lru)\n\t\tput_page(page);\n\tspin_lock(&hugetlb_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int hugetlb_acct_memory(struct hstate *h, long delta);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "tmp",
            "&surplus_list",
            "lru"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enqueue_huge_page",
          "args": [
            "h",
            "page"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "855-861",
          "snippet": "static void enqueue_huge_page(struct hstate *h, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tlist_move(&page->lru, &h->hugepage_freelists[nid]);\n\th->free_huge_pages++;\n\th->free_huge_pages_node[nid]++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void enqueue_huge_page(struct hstate *h, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tlist_move(&page->lru, &h->hugepage_freelists[nid]);\n\th->free_huge_pages++;\n\th->free_huge_pages_node[nid]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_count(page)",
            "page"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page_testzero",
          "args": [
            "page"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "tmp",
            "&surplus_list",
            "lru"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&surplus_list"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_surplus_huge_page",
          "args": [
            "h",
            "htlb_alloc_mask(h)",
            "NUMA_NO_NODE",
            "NULL"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_surplus_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1548-1586",
          "snippet": "static struct page *alloc_surplus_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page = NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages)\n\t\tgoto out_unlock;\n\tspin_unlock(&hugetlb_lock);\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * We could have raced with the pool size change.\n\t * Double check that and simply deallocate the new page\n\t * if we would end up overcommiting the surpluses. Abuse\n\t * temporary page to workaround the nasty free_huge_page\n\t * codeflow\n\t */\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages) {\n\t\tSetPageHugeTemporary(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t} else {\n\t\th->surplus_huge_pages++;\n\t\th->surplus_huge_pages_node[page_to_nid(page)]++;\n\t}\n\nout_unlock:\n\tspin_unlock(&hugetlb_lock);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_surplus_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page = NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages)\n\t\tgoto out_unlock;\n\tspin_unlock(&hugetlb_lock);\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * We could have raced with the pool size change.\n\t * Double check that and simply deallocate the new page\n\t * if we would end up overcommiting the surpluses. Abuse\n\t * temporary page to workaround the nasty free_huge_page\n\t * codeflow\n\t */\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages) {\n\t\tSetPageHugeTemporary(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t} else {\n\t\th->surplus_huge_pages++;\n\t\th->surplus_huge_pages_node[page_to_nid(page)]++;\n\t}\n\nout_unlock:\n\tspin_unlock(&hugetlb_lock);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htlb_alloc_mask",
          "args": [
            "h"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "htlb_alloc_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "920-926",
          "snippet": "static inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&surplus_list"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int gather_surplus_pages(struct hstate *h, int delta)\n{\n\tstruct list_head surplus_list;\n\tstruct page *page, *tmp;\n\tint ret, i;\n\tint needed, allocated;\n\tbool alloc_ok = true;\n\n\tneeded = (h->resv_huge_pages + delta) - h->free_huge_pages;\n\tif (needed <= 0) {\n\t\th->resv_huge_pages += delta;\n\t\treturn 0;\n\t}\n\n\tallocated = 0;\n\tINIT_LIST_HEAD(&surplus_list);\n\n\tret = -ENOMEM;\nretry:\n\tspin_unlock(&hugetlb_lock);\n\tfor (i = 0; i < needed; i++) {\n\t\tpage = alloc_surplus_huge_page(h, htlb_alloc_mask(h),\n\t\t\t\tNUMA_NO_NODE, NULL);\n\t\tif (!page) {\n\t\t\talloc_ok = false;\n\t\t\tbreak;\n\t\t}\n\t\tlist_add(&page->lru, &surplus_list);\n\t\tcond_resched();\n\t}\n\tallocated += i;\n\n\t/*\n\t * After retaking hugetlb_lock, we need to recalculate 'needed'\n\t * because either resv_huge_pages or free_huge_pages may have changed.\n\t */\n\tspin_lock(&hugetlb_lock);\n\tneeded = (h->resv_huge_pages + delta) -\n\t\t\t(h->free_huge_pages + allocated);\n\tif (needed > 0) {\n\t\tif (alloc_ok)\n\t\t\tgoto retry;\n\t\t/*\n\t\t * We were not able to allocate enough pages to\n\t\t * satisfy the entire reservation so we free what\n\t\t * we've allocated so far.\n\t\t */\n\t\tgoto free;\n\t}\n\t/*\n\t * The surplus_list now contains _at_least_ the number of extra pages\n\t * needed to accommodate the reservation.  Add the appropriate number\n\t * of pages to the hugetlb pool and free the extras back to the buddy\n\t * allocator.  Commit the entire reservation here to prevent another\n\t * process from stealing the pages as they are added to the pool but\n\t * before they are reserved.\n\t */\n\tneeded += allocated;\n\th->resv_huge_pages += delta;\n\tret = 0;\n\n\t/* Free the needed pages to the hugetlb pool */\n\tlist_for_each_entry_safe(page, tmp, &surplus_list, lru) {\n\t\tif ((--needed) < 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * This page is now managed by the hugetlb allocator and has\n\t\t * no users -- drop the buddy allocator's reference.\n\t\t */\n\t\tput_page_testzero(page);\n\t\tVM_BUG_ON_PAGE(page_count(page), page);\n\t\tenqueue_huge_page(h, page);\n\t}\nfree:\n\tspin_unlock(&hugetlb_lock);\n\n\t/* Free unnecessary surplus pages to the buddy allocator */\n\tlist_for_each_entry_safe(page, tmp, &surplus_list, lru)\n\t\tput_page(page);\n\tspin_lock(&hugetlb_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "alloc_huge_page_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1671-1686",
    "snippet": "struct page *alloc_huge_page_vma(struct hstate *h, struct vm_area_struct *vma,\n\t\tunsigned long address)\n{\n\tstruct mempolicy *mpol;\n\tnodemask_t *nodemask;\n\tstruct page *page;\n\tgfp_t gfp_mask;\n\tint node;\n\n\tgfp_mask = htlb_alloc_mask(h);\n\tnode = huge_node(vma, address, gfp_mask, &mpol, &nodemask);\n\tpage = alloc_huge_page_nodemask(h, node, nodemask);\n\tmpol_cond_put(mpol);\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_cond_put",
          "args": [
            "mpol"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_huge_page_nodemask",
          "args": [
            "h",
            "node",
            "nodemask"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_huge_page_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1650-1668",
          "snippet": "struct page *alloc_huge_page_nodemask(struct hstate *h, int preferred_nid,\n\t\tnodemask_t *nmask)\n{\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0) {\n\t\tstruct page *page;\n\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, preferred_nid, nmask);\n\t\tif (page) {\n\t\t\tspin_unlock(&hugetlb_lock);\n\t\t\treturn page;\n\t\t}\n\t}\n\tspin_unlock(&hugetlb_lock);\n\n\treturn alloc_migrate_huge_page(h, gfp_mask, preferred_nid, nmask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page *alloc_huge_page_nodemask(struct hstate *h, int preferred_nid,\n\t\tnodemask_t *nmask)\n{\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0) {\n\t\tstruct page *page;\n\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, preferred_nid, nmask);\n\t\tif (page) {\n\t\t\tspin_unlock(&hugetlb_lock);\n\t\t\treturn page;\n\t\t}\n\t}\n\tspin_unlock(&hugetlb_lock);\n\n\treturn alloc_migrate_huge_page(h, gfp_mask, preferred_nid, nmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_node",
          "args": [
            "vma",
            "address",
            "gfp_mask",
            "&mpol",
            "&nodemask"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "huge_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1868-1885",
          "snippet": "int huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nint huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htlb_alloc_mask",
          "args": [
            "h"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "htlb_alloc_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "920-926",
          "snippet": "static inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page *alloc_huge_page_vma(struct hstate *h, struct vm_area_struct *vma,\n\t\tunsigned long address)\n{\n\tstruct mempolicy *mpol;\n\tnodemask_t *nodemask;\n\tstruct page *page;\n\tgfp_t gfp_mask;\n\tint node;\n\n\tgfp_mask = htlb_alloc_mask(h);\n\tnode = huge_node(vma, address, gfp_mask, &mpol, &nodemask);\n\tpage = alloc_huge_page_nodemask(h, node, nodemask);\n\tmpol_cond_put(mpol);\n\n\treturn page;\n}"
  },
  {
    "function_name": "alloc_huge_page_nodemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1650-1668",
    "snippet": "struct page *alloc_huge_page_nodemask(struct hstate *h, int preferred_nid,\n\t\tnodemask_t *nmask)\n{\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0) {\n\t\tstruct page *page;\n\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, preferred_nid, nmask);\n\t\tif (page) {\n\t\t\tspin_unlock(&hugetlb_lock);\n\t\t\treturn page;\n\t\t}\n\t}\n\tspin_unlock(&hugetlb_lock);\n\n\treturn alloc_migrate_huge_page(h, gfp_mask, preferred_nid, nmask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_migrate_huge_page",
          "args": [
            "h",
            "gfp_mask",
            "preferred_nid",
            "nmask"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_migrate_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1588-1607",
          "snippet": "static struct page *alloc_migrate_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\t/*\n\t * We do not account these pages as surplus because they are only\n\t * temporary and will be released properly on the last reference\n\t */\n\tSetPageHugeTemporary(page);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_migrate_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\t/*\n\t * We do not account these pages as surplus because they are only\n\t * temporary and will be released properly on the last reference\n\t */\n\tSetPageHugeTemporary(page);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_huge_page_nodemask",
          "args": [
            "h",
            "gfp_mask",
            "preferred_nid",
            "nmask"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_huge_page_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "883-917",
          "snippet": "static struct page *dequeue_huge_page_nodemask(struct hstate *h, gfp_t gfp_mask, int nid,\n\t\tnodemask_t *nmask)\n{\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zonelist;\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tint node = -1;\n\n\tzonelist = node_zonelist(nid, gfp_mask);\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, gfp_zone(gfp_mask), nmask) {\n\t\tstruct page *page;\n\n\t\tif (!cpuset_zone_allowed(zone, gfp_mask))\n\t\t\tcontinue;\n\t\t/*\n\t\t * no need to ask again on the same node. Pool is node rather than\n\t\t * zone aware\n\t\t */\n\t\tif (zone_to_nid(zone) == node)\n\t\t\tcontinue;\n\t\tnode = zone_to_nid(zone);\n\n\t\tpage = dequeue_huge_page_node_exact(h, node);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *dequeue_huge_page_nodemask(struct hstate *h, gfp_t gfp_mask, int nid,\n\t\tnodemask_t *nmask)\n{\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zonelist;\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tint node = -1;\n\n\tzonelist = node_zonelist(nid, gfp_mask);\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, gfp_zone(gfp_mask), nmask) {\n\t\tstruct page *page;\n\n\t\tif (!cpuset_zone_allowed(zone, gfp_mask))\n\t\t\tcontinue;\n\t\t/*\n\t\t * no need to ask again on the same node. Pool is node rather than\n\t\t * zone aware\n\t\t */\n\t\tif (zone_to_nid(zone) == node)\n\t\t\tcontinue;\n\t\tnode = zone_to_nid(zone);\n\n\t\tpage = dequeue_huge_page_node_exact(h, node);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htlb_alloc_mask",
          "args": [
            "h"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "htlb_alloc_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "920-926",
          "snippet": "static inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page *alloc_huge_page_nodemask(struct hstate *h, int preferred_nid,\n\t\tnodemask_t *nmask)\n{\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0) {\n\t\tstruct page *page;\n\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, preferred_nid, nmask);\n\t\tif (page) {\n\t\t\tspin_unlock(&hugetlb_lock);\n\t\t\treturn page;\n\t\t}\n\t}\n\tspin_unlock(&hugetlb_lock);\n\n\treturn alloc_migrate_huge_page(h, gfp_mask, preferred_nid, nmask);\n}"
  },
  {
    "function_name": "alloc_huge_page_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1630-1647",
    "snippet": "struct page *alloc_huge_page_node(struct hstate *h, int nid)\n{\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\tstruct page *page = NULL;\n\n\tif (nid != NUMA_NO_NODE)\n\t\tgfp_mask |= __GFP_THISNODE;\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0)\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, nid, NULL);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page)\n\t\tpage = alloc_migrate_huge_page(h, gfp_mask, nid, NULL);\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_migrate_huge_page",
          "args": [
            "h",
            "gfp_mask",
            "nid",
            "NULL"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_migrate_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1588-1607",
          "snippet": "static struct page *alloc_migrate_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\t/*\n\t * We do not account these pages as surplus because they are only\n\t * temporary and will be released properly on the last reference\n\t */\n\tSetPageHugeTemporary(page);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_migrate_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\t/*\n\t * We do not account these pages as surplus because they are only\n\t * temporary and will be released properly on the last reference\n\t */\n\tSetPageHugeTemporary(page);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_huge_page_nodemask",
          "args": [
            "h",
            "gfp_mask",
            "nid",
            "NULL"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_huge_page_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "883-917",
          "snippet": "static struct page *dequeue_huge_page_nodemask(struct hstate *h, gfp_t gfp_mask, int nid,\n\t\tnodemask_t *nmask)\n{\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zonelist;\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tint node = -1;\n\n\tzonelist = node_zonelist(nid, gfp_mask);\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, gfp_zone(gfp_mask), nmask) {\n\t\tstruct page *page;\n\n\t\tif (!cpuset_zone_allowed(zone, gfp_mask))\n\t\t\tcontinue;\n\t\t/*\n\t\t * no need to ask again on the same node. Pool is node rather than\n\t\t * zone aware\n\t\t */\n\t\tif (zone_to_nid(zone) == node)\n\t\t\tcontinue;\n\t\tnode = zone_to_nid(zone);\n\n\t\tpage = dequeue_huge_page_node_exact(h, node);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *dequeue_huge_page_nodemask(struct hstate *h, gfp_t gfp_mask, int nid,\n\t\tnodemask_t *nmask)\n{\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zonelist;\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tint node = -1;\n\n\tzonelist = node_zonelist(nid, gfp_mask);\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, gfp_zone(gfp_mask), nmask) {\n\t\tstruct page *page;\n\n\t\tif (!cpuset_zone_allowed(zone, gfp_mask))\n\t\t\tcontinue;\n\t\t/*\n\t\t * no need to ask again on the same node. Pool is node rather than\n\t\t * zone aware\n\t\t */\n\t\tif (zone_to_nid(zone) == node)\n\t\t\tcontinue;\n\t\tnode = zone_to_nid(zone);\n\n\t\tpage = dequeue_huge_page_node_exact(h, node);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htlb_alloc_mask",
          "args": [
            "h"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "htlb_alloc_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "920-926",
          "snippet": "static inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page *alloc_huge_page_node(struct hstate *h, int nid)\n{\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\tstruct page *page = NULL;\n\n\tif (nid != NUMA_NO_NODE)\n\t\tgfp_mask |= __GFP_THISNODE;\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0)\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, nid, NULL);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page)\n\t\tpage = alloc_migrate_huge_page(h, gfp_mask, nid, NULL);\n\n\treturn page;\n}"
  },
  {
    "function_name": "alloc_buddy_huge_page_with_mpol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1612-1627",
    "snippet": "static\nstruct page *alloc_buddy_huge_page_with_mpol(struct hstate *h,\n\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct page *page;\n\tstruct mempolicy *mpol;\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\tint nid;\n\tnodemask_t *nodemask;\n\n\tnid = huge_node(vma, addr, gfp_mask, &mpol, &nodemask);\n\tpage = alloc_surplus_huge_page(h, gfp_mask, nid, nodemask);\n\tmpol_cond_put(mpol);\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_cond_put",
          "args": [
            "mpol"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_surplus_huge_page",
          "args": [
            "h",
            "gfp_mask",
            "nid",
            "nodemask"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_surplus_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1548-1586",
          "snippet": "static struct page *alloc_surplus_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page = NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages)\n\t\tgoto out_unlock;\n\tspin_unlock(&hugetlb_lock);\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * We could have raced with the pool size change.\n\t * Double check that and simply deallocate the new page\n\t * if we would end up overcommiting the surpluses. Abuse\n\t * temporary page to workaround the nasty free_huge_page\n\t * codeflow\n\t */\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages) {\n\t\tSetPageHugeTemporary(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t} else {\n\t\th->surplus_huge_pages++;\n\t\th->surplus_huge_pages_node[page_to_nid(page)]++;\n\t}\n\nout_unlock:\n\tspin_unlock(&hugetlb_lock);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_surplus_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page = NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages)\n\t\tgoto out_unlock;\n\tspin_unlock(&hugetlb_lock);\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * We could have raced with the pool size change.\n\t * Double check that and simply deallocate the new page\n\t * if we would end up overcommiting the surpluses. Abuse\n\t * temporary page to workaround the nasty free_huge_page\n\t * codeflow\n\t */\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages) {\n\t\tSetPageHugeTemporary(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t} else {\n\t\th->surplus_huge_pages++;\n\t\th->surplus_huge_pages_node[page_to_nid(page)]++;\n\t}\n\nout_unlock:\n\tspin_unlock(&hugetlb_lock);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_node",
          "args": [
            "vma",
            "addr",
            "gfp_mask",
            "&mpol",
            "&nodemask"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "huge_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1868-1885",
          "snippet": "int huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nint huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htlb_alloc_mask",
          "args": [
            "h"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "htlb_alloc_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "920-926",
          "snippet": "static inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic\nstruct page *alloc_buddy_huge_page_with_mpol(struct hstate *h,\n\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct page *page;\n\tstruct mempolicy *mpol;\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\tint nid;\n\tnodemask_t *nodemask;\n\n\tnid = huge_node(vma, addr, gfp_mask, &mpol, &nodemask);\n\tpage = alloc_surplus_huge_page(h, gfp_mask, nid, nodemask);\n\tmpol_cond_put(mpol);\n\n\treturn page;\n}"
  },
  {
    "function_name": "alloc_migrate_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1588-1607",
    "snippet": "static struct page *alloc_migrate_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\t/*\n\t * We do not account these pages as surplus because they are only\n\t * temporary and will be released properly on the last reference\n\t */\n\tSetPageHugeTemporary(page);\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageHugeTemporary",
          "args": [
            "page"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "SetPageHugeTemporary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1229-1232",
          "snippet": "static inline void SetPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = (void *)-1U;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void SetPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = (void *)-1U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_fresh_huge_page",
          "args": [
            "h",
            "gfp_mask",
            "nid",
            "nmask"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fresh_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1397-1415",
          "snippet": "static struct page *alloc_fresh_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\tpage = alloc_gigantic_page(h, gfp_mask, nid, nmask);\n\telse\n\t\tpage = alloc_buddy_huge_page(h, gfp_mask,\n\t\t\t\tnid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\tprep_compound_gigantic_page(page, huge_page_order(h));\n\tprep_new_huge_page(h, page, page_to_nid(page));\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_fresh_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\tpage = alloc_gigantic_page(h, gfp_mask, nid, nmask);\n\telse\n\t\tpage = alloc_buddy_huge_page(h, gfp_mask,\n\t\t\t\tnid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\tprep_compound_gigantic_page(page, huge_page_order(h));\n\tprep_new_huge_page(h, page, page_to_nid(page));\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_migrate_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\t/*\n\t * We do not account these pages as surplus because they are only\n\t * temporary and will be released properly on the last reference\n\t */\n\tSetPageHugeTemporary(page);\n\n\treturn page;\n}"
  },
  {
    "function_name": "alloc_surplus_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1548-1586",
    "snippet": "static struct page *alloc_surplus_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page = NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages)\n\t\tgoto out_unlock;\n\tspin_unlock(&hugetlb_lock);\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * We could have raced with the pool size change.\n\t * Double check that and simply deallocate the new page\n\t * if we would end up overcommiting the surpluses. Abuse\n\t * temporary page to workaround the nasty free_huge_page\n\t * codeflow\n\t */\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages) {\n\t\tSetPageHugeTemporary(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t} else {\n\t\th->surplus_huge_pages++;\n\t\th->surplus_huge_pages_node[page_to_nid(page)]++;\n\t}\n\nout_unlock:\n\tspin_unlock(&hugetlb_lock);\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageHugeTemporary",
          "args": [
            "page"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "SetPageHugeTemporary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1229-1232",
          "snippet": "static inline void SetPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = (void *)-1U;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void SetPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = (void *)-1U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_fresh_huge_page",
          "args": [
            "h",
            "gfp_mask",
            "nid",
            "nmask"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fresh_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1397-1415",
          "snippet": "static struct page *alloc_fresh_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\tpage = alloc_gigantic_page(h, gfp_mask, nid, nmask);\n\telse\n\t\tpage = alloc_buddy_huge_page(h, gfp_mask,\n\t\t\t\tnid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\tprep_compound_gigantic_page(page, huge_page_order(h));\n\tprep_new_huge_page(h, page, page_to_nid(page));\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_fresh_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\tpage = alloc_gigantic_page(h, gfp_mask, nid, nmask);\n\telse\n\t\tpage = alloc_buddy_huge_page(h, gfp_mask,\n\t\t\t\tnid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\tprep_compound_gigantic_page(page, huge_page_order(h));\n\tprep_new_huge_page(h, page, page_to_nid(page));\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_surplus_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nmask)\n{\n\tstruct page *page = NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages)\n\t\tgoto out_unlock;\n\tspin_unlock(&hugetlb_lock);\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * We could have raced with the pool size change.\n\t * Double check that and simply deallocate the new page\n\t * if we would end up overcommiting the surpluses. Abuse\n\t * temporary page to workaround the nasty free_huge_page\n\t * codeflow\n\t */\n\tif (h->surplus_huge_pages >= h->nr_overcommit_huge_pages) {\n\t\tSetPageHugeTemporary(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t} else {\n\t\th->surplus_huge_pages++;\n\t\th->surplus_huge_pages_node[page_to_nid(page)]++;\n\t}\n\nout_unlock:\n\tspin_unlock(&hugetlb_lock);\n\n\treturn page;\n}"
  },
  {
    "function_name": "dissolve_free_huge_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1524-1543",
    "snippet": "int dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tint rc = 0;\n\n\tif (!hugepages_supported())\n\t\treturn rc;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += 1 << minimum_order) {\n\t\tpage = pfn_to_page(pfn);\n\t\tif (PageHuge(page) && !page_count(page)) {\n\t\t\trc = dissolve_free_huge_page(page);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int minimum_order"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dissolve_free_huge_page",
          "args": [
            "page"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "dissolve_free_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1485-1514",
          "snippet": "int dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "PageHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1336-1343",
          "snippet": "int PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepages_supported",
          "args": [],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned int minimum_order;\n\nint dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tint rc = 0;\n\n\tif (!hugepages_supported())\n\t\treturn rc;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += 1 << minimum_order) {\n\t\tpage = pfn_to_page(pfn);\n\t\tif (PageHuge(page) && !page_count(page)) {\n\t\t\trc = dissolve_free_huge_page(page);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "dissolve_free_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1485-1514",
    "snippet": "int dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_and_free_page",
          "args": [
            "h",
            "head"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "update_and_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1155-1179",
          "snippet": "static void update_and_free_page(struct hstate *h, struct page *page)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn;\n\n\th->nr_huge_pages--;\n\th->nr_huge_pages_node[page_to_nid(page)]--;\n\tfor (i = 0; i < pages_per_huge_page(h); i++) {\n\t\tpage[i].flags &= ~(1 << PG_locked | 1 << PG_error |\n\t\t\t\t1 << PG_referenced | 1 << PG_dirty |\n\t\t\t\t1 << PG_active | 1 << PG_private |\n\t\t\t\t1 << PG_writeback);\n\t}\n\tVM_BUG_ON_PAGE(hugetlb_cgroup_from_page(page), page);\n\tset_compound_page_dtor(page, NULL_COMPOUND_DTOR);\n\tset_page_refcounted(page);\n\tif (hstate_is_gigantic(h)) {\n\t\tdestroy_compound_gigantic_page(page, huge_page_order(h));\n\t\tfree_gigantic_page(page, huge_page_order(h));\n\t} else {\n\t\t__free_pages(page, huge_page_order(h));\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void update_and_free_page(struct hstate *h, struct page *page)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn;\n\n\th->nr_huge_pages--;\n\th->nr_huge_pages_node[page_to_nid(page)]--;\n\tfor (i = 0; i < pages_per_huge_page(h); i++) {\n\t\tpage[i].flags &= ~(1 << PG_locked | 1 << PG_error |\n\t\t\t\t1 << PG_referenced | 1 << PG_dirty |\n\t\t\t\t1 << PG_active | 1 << PG_private |\n\t\t\t\t1 << PG_writeback);\n\t}\n\tVM_BUG_ON_PAGE(hugetlb_cgroup_from_page(page), page);\n\tset_compound_page_dtor(page, NULL_COMPOUND_DTOR);\n\tset_page_refcounted(page);\n\tif (hstate_is_gigantic(h)) {\n\t\tdestroy_compound_gigantic_page(page, huge_page_order(h));\n\t\tfree_gigantic_page(page, huge_page_order(h));\n\t} else {\n\t\t__free_pages(page, huge_page_order(h));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&head->lru"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageHWPoison",
          "args": [
            "head"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageHWPoison",
          "args": [
            "page"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "head"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "head"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "head"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "PageHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1336-1343",
          "snippet": "int PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}"
  },
  {
    "function_name": "free_pool_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1447-1477",
    "snippet": "static int free_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed,\n\t\t\t\t\t\t\t bool acct_surplus)\n{\n\tint nr_nodes, node;\n\tint ret = 0;\n\n\tfor_each_node_mask_to_free(h, nr_nodes, node, nodes_allowed) {\n\t\t/*\n\t\t * If we're returning unused surplus pages, only examine\n\t\t * nodes with surplus pages.\n\t\t */\n\t\tif ((!acct_surplus || h->surplus_huge_pages_node[node]) &&\n\t\t    !list_empty(&h->hugepage_freelists[node])) {\n\t\t\tstruct page *page =\n\t\t\t\tlist_entry(h->hugepage_freelists[node].next,\n\t\t\t\t\t  struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\th->free_huge_pages--;\n\t\t\th->free_huge_pages_node[node]--;\n\t\t\tif (acct_surplus) {\n\t\t\t\th->surplus_huge_pages--;\n\t\t\t\th->surplus_huge_pages_node[node]--;\n\t\t\t}\n\t\t\tupdate_and_free_page(h, page);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_and_free_page",
          "args": [
            "h",
            "page"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "update_and_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1155-1179",
          "snippet": "static void update_and_free_page(struct hstate *h, struct page *page)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn;\n\n\th->nr_huge_pages--;\n\th->nr_huge_pages_node[page_to_nid(page)]--;\n\tfor (i = 0; i < pages_per_huge_page(h); i++) {\n\t\tpage[i].flags &= ~(1 << PG_locked | 1 << PG_error |\n\t\t\t\t1 << PG_referenced | 1 << PG_dirty |\n\t\t\t\t1 << PG_active | 1 << PG_private |\n\t\t\t\t1 << PG_writeback);\n\t}\n\tVM_BUG_ON_PAGE(hugetlb_cgroup_from_page(page), page);\n\tset_compound_page_dtor(page, NULL_COMPOUND_DTOR);\n\tset_page_refcounted(page);\n\tif (hstate_is_gigantic(h)) {\n\t\tdestroy_compound_gigantic_page(page, huge_page_order(h));\n\t\tfree_gigantic_page(page, huge_page_order(h));\n\t} else {\n\t\t__free_pages(page, huge_page_order(h));\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void update_and_free_page(struct hstate *h, struct page *page)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn;\n\n\th->nr_huge_pages--;\n\th->nr_huge_pages_node[page_to_nid(page)]--;\n\tfor (i = 0; i < pages_per_huge_page(h); i++) {\n\t\tpage[i].flags &= ~(1 << PG_locked | 1 << PG_error |\n\t\t\t\t1 << PG_referenced | 1 << PG_dirty |\n\t\t\t\t1 << PG_active | 1 << PG_private |\n\t\t\t\t1 << PG_writeback);\n\t}\n\tVM_BUG_ON_PAGE(hugetlb_cgroup_from_page(page), page);\n\tset_compound_page_dtor(page, NULL_COMPOUND_DTOR);\n\tset_page_refcounted(page);\n\tif (hstate_is_gigantic(h)) {\n\t\tdestroy_compound_gigantic_page(page, huge_page_order(h));\n\t\tfree_gigantic_page(page, huge_page_order(h));\n\t} else {\n\t\t__free_pages(page, huge_page_order(h));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "h->hugepage_freelists[node].next",
            "structpage",
            "lru"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&h->hugepage_freelists[node]"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_node_mask_to_free",
          "args": [
            "h",
            "nr_nodes",
            "node",
            "nodes_allowed"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int free_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed,\n\t\t\t\t\t\t\t bool acct_surplus)\n{\n\tint nr_nodes, node;\n\tint ret = 0;\n\n\tfor_each_node_mask_to_free(h, nr_nodes, node, nodes_allowed) {\n\t\t/*\n\t\t * If we're returning unused surplus pages, only examine\n\t\t * nodes with surplus pages.\n\t\t */\n\t\tif ((!acct_surplus || h->surplus_huge_pages_node[node]) &&\n\t\t    !list_empty(&h->hugepage_freelists[node])) {\n\t\t\tstruct page *page =\n\t\t\t\tlist_entry(h->hugepage_freelists[node].next,\n\t\t\t\t\t  struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\th->free_huge_pages--;\n\t\t\th->free_huge_pages_node[node]--;\n\t\t\tif (acct_surplus) {\n\t\t\t\th->surplus_huge_pages--;\n\t\t\t\th->surplus_huge_pages_node[node]--;\n\t\t\t}\n\t\t\tupdate_and_free_page(h, page);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "alloc_pool_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1421-1439",
    "snippet": "static int alloc_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed)\n{\n\tstruct page *page;\n\tint nr_nodes, node;\n\tgfp_t gfp_mask = htlb_alloc_mask(h) | __GFP_THISNODE;\n\n\tfor_each_node_mask_to_alloc(h, nr_nodes, node, nodes_allowed) {\n\t\tpage = alloc_fresh_huge_page(h, gfp_mask, node, nodes_allowed);\n\t\tif (page)\n\t\t\tbreak;\n\t}\n\n\tif (!page)\n\t\treturn 0;\n\n\tput_page(page); /* free it into the hugepage allocator */\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_fresh_huge_page",
          "args": [
            "h",
            "gfp_mask",
            "node",
            "nodes_allowed"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fresh_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1397-1415",
          "snippet": "static struct page *alloc_fresh_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\tpage = alloc_gigantic_page(h, gfp_mask, nid, nmask);\n\telse\n\t\tpage = alloc_buddy_huge_page(h, gfp_mask,\n\t\t\t\tnid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\tprep_compound_gigantic_page(page, huge_page_order(h));\n\tprep_new_huge_page(h, page, page_to_nid(page));\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_fresh_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\tpage = alloc_gigantic_page(h, gfp_mask, nid, nmask);\n\telse\n\t\tpage = alloc_buddy_huge_page(h, gfp_mask,\n\t\t\t\tnid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\tprep_compound_gigantic_page(page, huge_page_order(h));\n\tprep_new_huge_page(h, page, page_to_nid(page));\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_node_mask_to_alloc",
          "args": [
            "h",
            "nr_nodes",
            "node",
            "nodes_allowed"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htlb_alloc_mask",
          "args": [
            "h"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "htlb_alloc_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "920-926",
          "snippet": "static inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int alloc_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed)\n{\n\tstruct page *page;\n\tint nr_nodes, node;\n\tgfp_t gfp_mask = htlb_alloc_mask(h) | __GFP_THISNODE;\n\n\tfor_each_node_mask_to_alloc(h, nr_nodes, node, nodes_allowed) {\n\t\tpage = alloc_fresh_huge_page(h, gfp_mask, node, nodes_allowed);\n\t\tif (page)\n\t\t\tbreak;\n\t}\n\n\tif (!page)\n\t\treturn 0;\n\n\tput_page(page); /* free it into the hugepage allocator */\n\n\treturn 1;\n}"
  },
  {
    "function_name": "alloc_fresh_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1397-1415",
    "snippet": "static struct page *alloc_fresh_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\tpage = alloc_gigantic_page(h, gfp_mask, nid, nmask);\n\telse\n\t\tpage = alloc_buddy_huge_page(h, gfp_mask,\n\t\t\t\tnid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\tprep_compound_gigantic_page(page, huge_page_order(h));\n\tprep_new_huge_page(h, page, page_to_nid(page));\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prep_new_huge_page",
          "args": [
            "h",
            "page",
            "page_to_nid(page)"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "prep_new_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1290-1299",
          "snippet": "static void prep_new_huge_page(struct hstate *h, struct page *page, int nid)\n{\n\tINIT_LIST_HEAD(&page->lru);\n\tset_compound_page_dtor(page, HUGETLB_PAGE_DTOR);\n\tspin_lock(&hugetlb_lock);\n\tset_hugetlb_cgroup(page, NULL);\n\th->nr_huge_pages++;\n\th->nr_huge_pages_node[nid]++;\n\tspin_unlock(&hugetlb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void prep_new_huge_page(struct hstate *h, struct page *page, int nid)\n{\n\tINIT_LIST_HEAD(&page->lru);\n\tset_compound_page_dtor(page, HUGETLB_PAGE_DTOR);\n\tspin_lock(&hugetlb_lock);\n\tset_hugetlb_cgroup(page, NULL);\n\th->nr_huge_pages++;\n\th->nr_huge_pages_node[nid]++;\n\tspin_unlock(&hugetlb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "prep_compound_gigantic_page",
          "args": [
            "page",
            "huge_page_order(h)"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "prep_compound_gigantic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1301-1329",
          "snippet": "static void prep_compound_gigantic_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\tstruct page *p = page + 1;\n\n\t/* we rely on prep_new_huge_page to set the destructor */\n\tset_compound_order(page, order);\n\t__ClearPageReserved(page);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++, p = mem_map_next(p, page, i)) {\n\t\t/*\n\t\t * For gigantic hugepages allocated through bootmem at\n\t\t * boot, it's safer to be consistent with the not-gigantic\n\t\t * hugepages and clear the PG_reserved bit from all tail pages\n\t\t * too.  Otherwse drivers using get_user_pages() to access tail\n\t\t * pages may get the reference counting wrong if they see\n\t\t * PG_reserved set on a tail page (despite the head page not\n\t\t * having PG_reserved set).  Enforcing this consistency between\n\t\t * head and tail pages allows drivers to optimize away a check\n\t\t * on the head page when they need know if put_page() is needed\n\t\t * after get_user_pages().\n\t\t */\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void prep_compound_gigantic_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\tstruct page *p = page + 1;\n\n\t/* we rely on prep_new_huge_page to set the destructor */\n\tset_compound_order(page, order);\n\t__ClearPageReserved(page);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++, p = mem_map_next(p, page, i)) {\n\t\t/*\n\t\t * For gigantic hugepages allocated through bootmem at\n\t\t * boot, it's safer to be consistent with the not-gigantic\n\t\t * hugepages and clear the PG_reserved bit from all tail pages\n\t\t * too.  Otherwse drivers using get_user_pages() to access tail\n\t\t * pages may get the reference counting wrong if they see\n\t\t * PG_reserved set on a tail page (despite the head page not\n\t\t * having PG_reserved set).  Enforcing this consistency between\n\t\t * head and tail pages allows drivers to optimize away a check\n\t\t * on the head page when they need know if put_page() is needed\n\t\t * after get_user_pages().\n\t\t */\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_buddy_huge_page",
          "args": [
            "h",
            "gfp_mask",
            "nid",
            "nmask"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_buddy_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1375-1391",
          "snippet": "static struct page *alloc_buddy_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tint order = huge_page_order(h);\n\tstruct page *page;\n\n\tgfp_mask |= __GFP_COMP|__GFP_RETRY_MAYFAIL|__GFP_NOWARN;\n\tif (nid == NUMA_NO_NODE)\n\t\tnid = numa_mem_id();\n\tpage = __alloc_pages_nodemask(gfp_mask, order, nid, nmask);\n\tif (page)\n\t\t__count_vm_event(HTLB_BUDDY_PGALLOC);\n\telse\n\t\t__count_vm_event(HTLB_BUDDY_PGALLOC_FAIL);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_buddy_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tint order = huge_page_order(h);\n\tstruct page *page;\n\n\tgfp_mask |= __GFP_COMP|__GFP_RETRY_MAYFAIL|__GFP_NOWARN;\n\tif (nid == NUMA_NO_NODE)\n\t\tnid = numa_mem_id();\n\tpage = __alloc_pages_nodemask(gfp_mask, order, nid, nmask);\n\tif (page)\n\t\t__count_vm_event(HTLB_BUDDY_PGALLOC);\n\telse\n\t\t__count_vm_event(HTLB_BUDDY_PGALLOC_FAIL);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_gigantic_page",
          "args": [
            "h",
            "gfp_mask",
            "nid",
            "nmask"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_gigantic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1148-1149",
          "snippet": "static struct page *alloc_gigantic_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nodemask) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_gigantic_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nodemask) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_fresh_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\tpage = alloc_gigantic_page(h, gfp_mask, nid, nmask);\n\telse\n\t\tpage = alloc_buddy_huge_page(h, gfp_mask,\n\t\t\t\tnid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\tprep_compound_gigantic_page(page, huge_page_order(h));\n\tprep_new_huge_page(h, page, page_to_nid(page));\n\n\treturn page;\n}"
  },
  {
    "function_name": "alloc_buddy_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1375-1391",
    "snippet": "static struct page *alloc_buddy_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tint order = huge_page_order(h);\n\tstruct page *page;\n\n\tgfp_mask |= __GFP_COMP|__GFP_RETRY_MAYFAIL|__GFP_NOWARN;\n\tif (nid == NUMA_NO_NODE)\n\t\tnid = numa_mem_id();\n\tpage = __alloc_pages_nodemask(gfp_mask, order, nid, nmask);\n\tif (page)\n\t\t__count_vm_event(HTLB_BUDDY_PGALLOC);\n\telse\n\t\t__count_vm_event(HTLB_BUDDY_PGALLOC_FAIL);\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__count_vm_event",
          "args": [
            "HTLB_BUDDY_PGALLOC_FAIL"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_event",
          "args": [
            "HTLB_BUDDY_PGALLOC"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_pages_nodemask",
          "args": [
            "gfp_mask",
            "order",
            "nid",
            "nmask"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_pages_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4347-4405",
          "snippet": "struct page *\n__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; /* The gfp_t that was actually used for allocation */\n\tstruct alloc_context ac = { };\n\n\t/*\n\t * There are several places where we assume that the order value is sane\n\t * so bail out early if the request is out of bound.\n\t */\n\tif (unlikely(order >= MAX_ORDER)) {\n\t\tWARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));\n\t\treturn NULL;\n\t}\n\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\n\tfinalise_ac(gfp_mask, &ac);\n\n\t/* First allocation attempt */\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\n\t/*\n\t * Apply scoped allocation constraints. This is mainly about GFP_NOFS\n\t * resp. GFP_NOIO which has to be inherited for all allocation requests\n\t * from a particular context which has been marked by\n\t * memalloc_no{fs,io}_{save,restore}.\n\t */\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\n\t/*\n\t * Restore the original nodemask if it was potentially replaced with\n\t * &cpuset_current_mems_allowed to optimize the fast-path attempt.\n\t */\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\n\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "gfp_t gfp_allowed_mask",
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\ngfp_t gfp_allowed_mask;\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstruct page *\n__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; /* The gfp_t that was actually used for allocation */\n\tstruct alloc_context ac = { };\n\n\t/*\n\t * There are several places where we assume that the order value is sane\n\t * so bail out early if the request is out of bound.\n\t */\n\tif (unlikely(order >= MAX_ORDER)) {\n\t\tWARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));\n\t\treturn NULL;\n\t}\n\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\n\tfinalise_ac(gfp_mask, &ac);\n\n\t/* First allocation attempt */\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\n\t/*\n\t * Apply scoped allocation constraints. This is mainly about GFP_NOFS\n\t * resp. GFP_NOIO which has to be inherited for all allocation requests\n\t * from a particular context which has been marked by\n\t * memalloc_no{fs,io}_{save,restore}.\n\t */\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\n\t/*\n\t * Restore the original nodemask if it was potentially replaced with\n\t * &cpuset_current_mems_allowed to optimize the fast-path attempt.\n\t */\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\n\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_buddy_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tint order = huge_page_order(h);\n\tstruct page *page;\n\n\tgfp_mask |= __GFP_COMP|__GFP_RETRY_MAYFAIL|__GFP_NOWARN;\n\tif (nid == NUMA_NO_NODE)\n\t\tnid = numa_mem_id();\n\tpage = __alloc_pages_nodemask(gfp_mask, order, nid, nmask);\n\tif (page)\n\t\t__count_vm_event(HTLB_BUDDY_PGALLOC);\n\telse\n\t\t__count_vm_event(HTLB_BUDDY_PGALLOC_FAIL);\n\n\treturn page;\n}"
  },
  {
    "function_name": "__basepage_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1358-1373",
    "snippet": "pgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page_head"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page_head"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page_head"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "__basepage_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1358-1373",
          "snippet": "pgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page_head"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "PageHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1336-1343",
          "snippet": "int PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}"
  },
  {
    "function_name": "PageHeadHuge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1350-1356",
    "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_compound_page_dtor",
          "args": [
            "page_head"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page_head"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
  },
  {
    "function_name": "PageHuge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1336-1343",
    "snippet": "int PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}"
  },
  {
    "function_name": "prep_compound_gigantic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1301-1329",
    "snippet": "static void prep_compound_gigantic_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\tstruct page *p = page + 1;\n\n\t/* we rely on prep_new_huge_page to set the destructor */\n\tset_compound_order(page, order);\n\t__ClearPageReserved(page);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++, p = mem_map_next(p, page, i)) {\n\t\t/*\n\t\t * For gigantic hugepages allocated through bootmem at\n\t\t * boot, it's safer to be consistent with the not-gigantic\n\t\t * hugepages and clear the PG_reserved bit from all tail pages\n\t\t * too.  Otherwse drivers using get_user_pages() to access tail\n\t\t * pages may get the reference counting wrong if they see\n\t\t * PG_reserved set on a tail page (despite the head page not\n\t\t * having PG_reserved set).  Enforcing this consistency between\n\t\t * head and tail pages allows drivers to optimize away a check\n\t\t * on the head page when they need know if put_page() is needed\n\t\t * after get_user_pages().\n\t\t */\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "compound_mapcount_ptr(page)",
            "-1"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_compound_head",
          "args": [
            "p",
            "page"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_count",
          "args": [
            "p",
            "0"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageReserved",
          "args": [
            "p"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_map_next",
          "args": [
            "p",
            "page",
            "i"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "mem_map_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "380-390",
          "snippet": "static inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__SetPageHead",
          "args": [
            "page"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageReserved",
          "args": [
            "page"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_compound_order",
          "args": [
            "page",
            "order"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void prep_compound_gigantic_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\tstruct page *p = page + 1;\n\n\t/* we rely on prep_new_huge_page to set the destructor */\n\tset_compound_order(page, order);\n\t__ClearPageReserved(page);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++, p = mem_map_next(p, page, i)) {\n\t\t/*\n\t\t * For gigantic hugepages allocated through bootmem at\n\t\t * boot, it's safer to be consistent with the not-gigantic\n\t\t * hugepages and clear the PG_reserved bit from all tail pages\n\t\t * too.  Otherwse drivers using get_user_pages() to access tail\n\t\t * pages may get the reference counting wrong if they see\n\t\t * PG_reserved set on a tail page (despite the head page not\n\t\t * having PG_reserved set).  Enforcing this consistency between\n\t\t * head and tail pages allows drivers to optimize away a check\n\t\t * on the head page when they need know if put_page() is needed\n\t\t * after get_user_pages().\n\t\t */\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}"
  },
  {
    "function_name": "prep_new_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1290-1299",
    "snippet": "static void prep_new_huge_page(struct hstate *h, struct page *page, int nid)\n{\n\tINIT_LIST_HEAD(&page->lru);\n\tset_compound_page_dtor(page, HUGETLB_PAGE_DTOR);\n\tspin_lock(&hugetlb_lock);\n\tset_hugetlb_cgroup(page, NULL);\n\th->nr_huge_pages++;\n\th->nr_huge_pages_node[nid]++;\n\tspin_unlock(&hugetlb_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_hugetlb_cgroup",
          "args": [
            "page",
            "NULL"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_compound_page_dtor",
          "args": [
            "page",
            "HUGETLB_PAGE_DTOR"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&page->lru"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void prep_new_huge_page(struct hstate *h, struct page *page, int nid)\n{\n\tINIT_LIST_HEAD(&page->lru);\n\tset_compound_page_dtor(page, HUGETLB_PAGE_DTOR);\n\tspin_lock(&hugetlb_lock);\n\tset_hugetlb_cgroup(page, NULL);\n\th->nr_huge_pages++;\n\th->nr_huge_pages_node[nid]++;\n\tspin_unlock(&hugetlb_lock);\n}"
  },
  {
    "function_name": "free_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1239-1288",
    "snippet": "void free_huge_page(struct page *page)\n{\n\t/*\n\t * Can't pass hstate in here because it is called from the\n\t * compound page destructor.\n\t */\n\tstruct hstate *h = page_hstate(page);\n\tint nid = page_to_nid(page);\n\tstruct hugepage_subpool *spool =\n\t\t(struct hugepage_subpool *)page_private(page);\n\tbool restore_reserve;\n\n\tset_page_private(page, 0);\n\tpage->mapping = NULL;\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\tVM_BUG_ON_PAGE(page_mapcount(page), page);\n\trestore_reserve = PagePrivate(page);\n\tClearPagePrivate(page);\n\n\t/*\n\t * A return code of zero implies that the subpool will be under its\n\t * minimum size if the reservation is not restored after page is free.\n\t * Therefore, force restore_reserve operation.\n\t */\n\tif (hugepage_subpool_put_pages(spool, 1) == 0)\n\t\trestore_reserve = true;\n\n\tspin_lock(&hugetlb_lock);\n\tclear_page_huge_active(page);\n\thugetlb_cgroup_uncharge_page(hstate_index(h),\n\t\t\t\t     pages_per_huge_page(h), page);\n\tif (restore_reserve)\n\t\th->resv_huge_pages++;\n\n\tif (PageHugeTemporary(page)) {\n\t\tlist_del(&page->lru);\n\t\tClearPageHugeTemporary(page);\n\t\tupdate_and_free_page(h, page);\n\t} else if (h->surplus_huge_pages_node[nid]) {\n\t\t/* remove the page from active list */\n\t\tlist_del(&page->lru);\n\t\tupdate_and_free_page(h, page);\n\t\th->surplus_huge_pages--;\n\t\th->surplus_huge_pages_node[nid]--;\n\t} else {\n\t\tarch_clear_hugepage_flags(page);\n\t\tenqueue_huge_page(h, page);\n\t}\n\tspin_unlock(&hugetlb_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enqueue_huge_page",
          "args": [
            "h",
            "page"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "855-861",
          "snippet": "static void enqueue_huge_page(struct hstate *h, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tlist_move(&page->lru, &h->hugepage_freelists[nid]);\n\th->free_huge_pages++;\n\th->free_huge_pages_node[nid]++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void enqueue_huge_page(struct hstate *h, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tlist_move(&page->lru, &h->hugepage_freelists[nid]);\n\th->free_huge_pages++;\n\th->free_huge_pages_node[nid]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_clear_hugepage_flags",
          "args": [
            "page"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_and_free_page",
          "args": [
            "h",
            "page"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "update_and_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1155-1179",
          "snippet": "static void update_and_free_page(struct hstate *h, struct page *page)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn;\n\n\th->nr_huge_pages--;\n\th->nr_huge_pages_node[page_to_nid(page)]--;\n\tfor (i = 0; i < pages_per_huge_page(h); i++) {\n\t\tpage[i].flags &= ~(1 << PG_locked | 1 << PG_error |\n\t\t\t\t1 << PG_referenced | 1 << PG_dirty |\n\t\t\t\t1 << PG_active | 1 << PG_private |\n\t\t\t\t1 << PG_writeback);\n\t}\n\tVM_BUG_ON_PAGE(hugetlb_cgroup_from_page(page), page);\n\tset_compound_page_dtor(page, NULL_COMPOUND_DTOR);\n\tset_page_refcounted(page);\n\tif (hstate_is_gigantic(h)) {\n\t\tdestroy_compound_gigantic_page(page, huge_page_order(h));\n\t\tfree_gigantic_page(page, huge_page_order(h));\n\t} else {\n\t\t__free_pages(page, huge_page_order(h));\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void update_and_free_page(struct hstate *h, struct page *page)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn;\n\n\th->nr_huge_pages--;\n\th->nr_huge_pages_node[page_to_nid(page)]--;\n\tfor (i = 0; i < pages_per_huge_page(h); i++) {\n\t\tpage[i].flags &= ~(1 << PG_locked | 1 << PG_error |\n\t\t\t\t1 << PG_referenced | 1 << PG_dirty |\n\t\t\t\t1 << PG_active | 1 << PG_private |\n\t\t\t\t1 << PG_writeback);\n\t}\n\tVM_BUG_ON_PAGE(hugetlb_cgroup_from_page(page), page);\n\tset_compound_page_dtor(page, NULL_COMPOUND_DTOR);\n\tset_page_refcounted(page);\n\tif (hstate_is_gigantic(h)) {\n\t\tdestroy_compound_gigantic_page(page, huge_page_order(h));\n\t\tfree_gigantic_page(page, huge_page_order(h));\n\t} else {\n\t\t__free_pages(page, huge_page_order(h));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageHugeTemporary",
          "args": [
            "page"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "ClearPageHugeTemporary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1234-1237",
          "snippet": "static inline void ClearPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void ClearPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_uncharge_page",
          "args": [
            "hstate_index(h)",
            "pages_per_huge_page(h)",
            "page"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_uncharge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "228-242",
          "snippet": "void hugetlb_cgroup_uncharge_page(int idx, unsigned long nr_pages,\n\t\t\t\t  struct page *page)\n{\n\tstruct hugetlb_cgroup *h_cg;\n\n\tif (hugetlb_cgroup_disabled())\n\t\treturn;\n\tlockdep_assert_held(&hugetlb_lock);\n\th_cg = hugetlb_cgroup_from_page(page);\n\tif (unlikely(!h_cg))\n\t\treturn;\n\tset_hugetlb_cgroup(page, NULL);\n\tpage_counter_uncharge(&h_cg->hugepage[idx], nr_pages);\n\treturn;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nvoid hugetlb_cgroup_uncharge_page(int idx, unsigned long nr_pages,\n\t\t\t\t  struct page *page)\n{\n\tstruct hugetlb_cgroup *h_cg;\n\n\tif (hugetlb_cgroup_disabled())\n\t\treturn;\n\tlockdep_assert_held(&hugetlb_lock);\n\th_cg = hugetlb_cgroup_from_page(page);\n\tif (unlikely(!h_cg))\n\t\treturn;\n\tset_hugetlb_cgroup(page, NULL);\n\tpage_counter_uncharge(&h_cg->hugepage[idx], nr_pages);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_index",
          "args": [
            "h"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_huge_active",
          "args": [
            "page"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_huge_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1211-1215",
          "snippet": "static void clear_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tClearPagePrivate(&page[1]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void clear_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tClearPagePrivate(&page[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_subpool_put_pages",
          "args": [
            "spool",
            "1"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_subpool_put_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "176-208",
          "snippet": "static long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_mapcount(page)",
            "page"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_count(page)",
            "page"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "page"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid free_huge_page(struct page *page)\n{\n\t/*\n\t * Can't pass hstate in here because it is called from the\n\t * compound page destructor.\n\t */\n\tstruct hstate *h = page_hstate(page);\n\tint nid = page_to_nid(page);\n\tstruct hugepage_subpool *spool =\n\t\t(struct hugepage_subpool *)page_private(page);\n\tbool restore_reserve;\n\n\tset_page_private(page, 0);\n\tpage->mapping = NULL;\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\tVM_BUG_ON_PAGE(page_mapcount(page), page);\n\trestore_reserve = PagePrivate(page);\n\tClearPagePrivate(page);\n\n\t/*\n\t * A return code of zero implies that the subpool will be under its\n\t * minimum size if the reservation is not restored after page is free.\n\t * Therefore, force restore_reserve operation.\n\t */\n\tif (hugepage_subpool_put_pages(spool, 1) == 0)\n\t\trestore_reserve = true;\n\n\tspin_lock(&hugetlb_lock);\n\tclear_page_huge_active(page);\n\thugetlb_cgroup_uncharge_page(hstate_index(h),\n\t\t\t\t     pages_per_huge_page(h), page);\n\tif (restore_reserve)\n\t\th->resv_huge_pages++;\n\n\tif (PageHugeTemporary(page)) {\n\t\tlist_del(&page->lru);\n\t\tClearPageHugeTemporary(page);\n\t\tupdate_and_free_page(h, page);\n\t} else if (h->surplus_huge_pages_node[nid]) {\n\t\t/* remove the page from active list */\n\t\tlist_del(&page->lru);\n\t\tupdate_and_free_page(h, page);\n\t\th->surplus_huge_pages--;\n\t\th->surplus_huge_pages_node[nid]--;\n\t} else {\n\t\tarch_clear_hugepage_flags(page);\n\t\tenqueue_huge_page(h, page);\n\t}\n\tspin_unlock(&hugetlb_lock);\n}"
  },
  {
    "function_name": "ClearPageHugeTemporary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1234-1237",
    "snippet": "static inline void ClearPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void ClearPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = NULL;\n}"
  },
  {
    "function_name": "SetPageHugeTemporary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1229-1232",
    "snippet": "static inline void SetPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = (void *)-1U;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void SetPageHugeTemporary(struct page *page)\n{\n\tpage[2].mapping = (void *)-1U;\n}"
  },
  {
    "function_name": "PageHugeTemporary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1221-1227",
    "snippet": "static inline bool PageHugeTemporary(struct page *page)\n{\n\tif (!PageHuge(page))\n\t\treturn false;\n\n\treturn (unsigned long)page[2].mapping == -1U;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "PageHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1336-1343",
          "snippet": "int PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline bool PageHugeTemporary(struct page *page)\n{\n\tif (!PageHuge(page))\n\t\treturn false;\n\n\treturn (unsigned long)page[2].mapping == -1U;\n}"
  },
  {
    "function_name": "clear_page_huge_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1211-1215",
    "snippet": "static void clear_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tClearPagePrivate(&page[1]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "&page[1]"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHeadHuge(page)",
            "page"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHeadHuge",
          "args": [
            "page"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void clear_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tClearPagePrivate(&page[1]);\n}"
  },
  {
    "function_name": "set_page_huge_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1205-1209",
    "snippet": "static void set_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tSetPagePrivate(&page[1]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "&page[1]"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHeadHuge(page)",
            "page"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHeadHuge",
          "args": [
            "page"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tSetPagePrivate(&page[1]);\n}"
  },
  {
    "function_name": "page_huge_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1198-1202",
    "snippet": "bool page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHuge(page), page);\n\treturn PageHead(page) && PagePrivate(&page[1]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "&page[1]"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHuge(page)",
            "page"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "PageHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1336-1343",
          "snippet": "int PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nbool page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHuge(page), page);\n\treturn PageHead(page) && PagePrivate(&page[1]);\n}"
  },
  {
    "function_name": "size_to_hstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1181-1190",
    "snippet": "struct hstate *size_to_hstate(unsigned long size)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tif (huge_page_size(h) == size)\n\t\t\treturn h;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hstate *size_to_hstate(unsigned long size)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tif (huge_page_size(h) == size)\n\t\t\treturn h;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "update_and_free_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1155-1179",
    "snippet": "static void update_and_free_page(struct hstate *h, struct page *page)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn;\n\n\th->nr_huge_pages--;\n\th->nr_huge_pages_node[page_to_nid(page)]--;\n\tfor (i = 0; i < pages_per_huge_page(h); i++) {\n\t\tpage[i].flags &= ~(1 << PG_locked | 1 << PG_error |\n\t\t\t\t1 << PG_referenced | 1 << PG_dirty |\n\t\t\t\t1 << PG_active | 1 << PG_private |\n\t\t\t\t1 << PG_writeback);\n\t}\n\tVM_BUG_ON_PAGE(hugetlb_cgroup_from_page(page), page);\n\tset_compound_page_dtor(page, NULL_COMPOUND_DTOR);\n\tset_page_refcounted(page);\n\tif (hstate_is_gigantic(h)) {\n\t\tdestroy_compound_gigantic_page(page, huge_page_order(h));\n\t\tfree_gigantic_page(page, huge_page_order(h));\n\t} else {\n\t\t__free_pages(page, huge_page_order(h));\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "huge_page_order(h)"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_gigantic_page",
          "args": [
            "page",
            "huge_page_order(h)"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "free_gigantic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1150-1150",
          "snippet": "static inline void free_gigantic_page(struct page *page, unsigned int order) { }",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void free_gigantic_page(struct page *page, unsigned int order) { }"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_compound_gigantic_page",
          "args": [
            "page",
            "huge_page_order(h)"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_compound_gigantic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1151-1152",
          "snippet": "static inline void destroy_compound_gigantic_page(struct page *page,\n\t\t\t\t\t\tunsigned int order) { }",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void destroy_compound_gigantic_page(struct page *page,\n\t\t\t\t\t\tunsigned int order) { }"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_refcounted",
          "args": [
            "page"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_refcounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "74-79",
          "snippet": "static inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_compound_page_dtor",
          "args": [
            "page",
            "NULL_COMPOUND_DTOR"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "hugetlb_cgroup_from_page(page)",
            "page"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_page",
          "args": [
            "page"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "gigantic_page_supported",
          "args": [],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "gigantic_page_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1147-1147",
          "snippet": "static inline bool gigantic_page_supported(void) { return false; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline bool gigantic_page_supported(void) { return false; }"
        }
      },
      {
        "call_info": {
          "callee": "hstate_is_gigantic",
          "args": [
            "h"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void update_and_free_page(struct hstate *h, struct page *page)\n{\n\tint i;\n\n\tif (hstate_is_gigantic(h) && !gigantic_page_supported())\n\t\treturn;\n\n\th->nr_huge_pages--;\n\th->nr_huge_pages_node[page_to_nid(page)]--;\n\tfor (i = 0; i < pages_per_huge_page(h); i++) {\n\t\tpage[i].flags &= ~(1 << PG_locked | 1 << PG_error |\n\t\t\t\t1 << PG_referenced | 1 << PG_dirty |\n\t\t\t\t1 << PG_active | 1 << PG_private |\n\t\t\t\t1 << PG_writeback);\n\t}\n\tVM_BUG_ON_PAGE(hugetlb_cgroup_from_page(page), page);\n\tset_compound_page_dtor(page, NULL_COMPOUND_DTOR);\n\tset_page_refcounted(page);\n\tif (hstate_is_gigantic(h)) {\n\t\tdestroy_compound_gigantic_page(page, huge_page_order(h));\n\t\tfree_gigantic_page(page, huge_page_order(h));\n\t} else {\n\t\t__free_pages(page, huge_page_order(h));\n\t}\n}"
  },
  {
    "function_name": "destroy_compound_gigantic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1151-1152",
    "snippet": "static inline void destroy_compound_gigantic_page(struct page *page,\n\t\t\t\t\t\tunsigned int order) { }",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void destroy_compound_gigantic_page(struct page *page,\n\t\t\t\t\t\tunsigned int order) { }"
  },
  {
    "function_name": "free_gigantic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1150-1150",
    "snippet": "static inline void free_gigantic_page(struct page *page, unsigned int order) { }",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void free_gigantic_page(struct page *page, unsigned int order) { }"
  },
  {
    "function_name": "alloc_gigantic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1148-1149",
    "snippet": "static struct page *alloc_gigantic_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nodemask) { return NULL; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_gigantic_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nodemask) { return NULL; }"
  },
  {
    "function_name": "gigantic_page_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1147-1147",
    "snippet": "static inline bool gigantic_page_supported(void) { return false; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline bool gigantic_page_supported(void) { return false; }"
  },
  {
    "function_name": "alloc_gigantic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1104-1141",
    "snippet": "static struct page *alloc_gigantic_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nodemask)\n{\n\tunsigned int order = huge_page_order(h);\n\tunsigned long nr_pages = 1 << order;\n\tunsigned long ret, pfn, flags;\n\tstruct zonelist *zonelist;\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\n\tzonelist = node_zonelist(nid, gfp_mask);\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, gfp_zone(gfp_mask), nodemask) {\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\n\t\tpfn = ALIGN(zone->zone_start_pfn, nr_pages);\n\t\twhile (zone_spans_last_pfn(zone, pfn, nr_pages)) {\n\t\t\tif (pfn_range_valid_gigantic(zone, pfn, nr_pages)) {\n\t\t\t\t/*\n\t\t\t\t * We release the zone lock here because\n\t\t\t\t * alloc_contig_range() will also lock the zone\n\t\t\t\t * at some point. If there's an allocation\n\t\t\t\t * spinning on this lock, it may win the race\n\t\t\t\t * and cause alloc_contig_range() to fail...\n\t\t\t\t */\n\t\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\t\t\tret = __alloc_gigantic_page(pfn, nr_pages, gfp_mask);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn pfn_to_page(pfn);\n\t\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\t\t}\n\t\t\tpfn += nr_pages;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_gigantic_page",
          "args": [
            "pfn",
            "nr_pages",
            "gfp_mask"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_gigantic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1061-1067",
          "snippet": "static int __alloc_gigantic_page(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages, gfp_t gfp_mask)\n{\n\tunsigned long end_pfn = start_pfn + nr_pages;\n\treturn alloc_contig_range(start_pfn, end_pfn, MIGRATE_MOVABLE,\n\t\t\t\t  gfp_mask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int __alloc_gigantic_page(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages, gfp_t gfp_mask)\n{\n\tunsigned long end_pfn = start_pfn + nr_pages;\n\treturn alloc_contig_range(start_pfn, end_pfn, MIGRATE_MOVABLE,\n\t\t\t\t  gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_range_valid_gigantic",
          "args": [
            "zone",
            "pfn",
            "nr_pages"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "pfn_range_valid_gigantic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1069-1095",
          "snippet": "static bool pfn_range_valid_gigantic(struct zone *z,\n\t\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tunsigned long i, end_pfn = start_pfn + nr_pages;\n\tstruct page *page;\n\n\tfor (i = start_pfn; i < end_pfn; i++) {\n\t\tif (!pfn_valid(i))\n\t\t\treturn false;\n\n\t\tpage = pfn_to_page(i);\n\n\t\tif (page_zone(page) != z)\n\t\t\treturn false;\n\n\t\tif (PageReserved(page))\n\t\t\treturn false;\n\n\t\tif (page_count(page) > 0)\n\t\t\treturn false;\n\n\t\tif (PageHuge(page))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic bool pfn_range_valid_gigantic(struct zone *z,\n\t\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tunsigned long i, end_pfn = start_pfn + nr_pages;\n\tstruct page *page;\n\n\tfor (i = start_pfn; i < end_pfn; i++) {\n\t\tif (!pfn_valid(i))\n\t\t\treturn false;\n\n\t\tpage = pfn_to_page(i);\n\n\t\tif (page_zone(page) != z)\n\t\t\treturn false;\n\n\t\tif (PageReserved(page))\n\t\t\treturn false;\n\n\t\tif (page_count(page) > 0)\n\t\t\treturn false;\n\n\t\tif (PageHuge(page))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_spans_last_pfn",
          "args": [
            "zone",
            "pfn",
            "nr_pages"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "zone_spans_last_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1097-1102",
          "snippet": "static bool zone_spans_last_pfn(const struct zone *zone,\n\t\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tunsigned long last_pfn = start_pfn + nr_pages - 1;\n\treturn zone_spans_pfn(zone, last_pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic bool zone_spans_last_pfn(const struct zone *zone,\n\t\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tunsigned long last_pfn = start_pfn + nr_pages - 1;\n\treturn zone_spans_pfn(zone, last_pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "zone->zone_start_pfn",
            "nr_pages"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "zonelist",
            "gfp_zone(gfp_mask)",
            "nodemask"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "gfp_mask"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_zonelist",
          "args": [
            "nid",
            "gfp_mask"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *alloc_gigantic_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nodemask)\n{\n\tunsigned int order = huge_page_order(h);\n\tunsigned long nr_pages = 1 << order;\n\tunsigned long ret, pfn, flags;\n\tstruct zonelist *zonelist;\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\n\tzonelist = node_zonelist(nid, gfp_mask);\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, gfp_zone(gfp_mask), nodemask) {\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\n\t\tpfn = ALIGN(zone->zone_start_pfn, nr_pages);\n\t\twhile (zone_spans_last_pfn(zone, pfn, nr_pages)) {\n\t\t\tif (pfn_range_valid_gigantic(zone, pfn, nr_pages)) {\n\t\t\t\t/*\n\t\t\t\t * We release the zone lock here because\n\t\t\t\t * alloc_contig_range() will also lock the zone\n\t\t\t\t * at some point. If there's an allocation\n\t\t\t\t * spinning on this lock, it may win the race\n\t\t\t\t * and cause alloc_contig_range() to fail...\n\t\t\t\t */\n\t\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\t\t\tret = __alloc_gigantic_page(pfn, nr_pages, gfp_mask);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn pfn_to_page(pfn);\n\t\t\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\t\t}\n\t\t\tpfn += nr_pages;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "zone_spans_last_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1097-1102",
    "snippet": "static bool zone_spans_last_pfn(const struct zone *zone,\n\t\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tunsigned long last_pfn = start_pfn + nr_pages - 1;\n\treturn zone_spans_pfn(zone, last_pfn);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_spans_pfn",
          "args": [
            "zone",
            "last_pfn"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic bool zone_spans_last_pfn(const struct zone *zone,\n\t\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tunsigned long last_pfn = start_pfn + nr_pages - 1;\n\treturn zone_spans_pfn(zone, last_pfn);\n}"
  },
  {
    "function_name": "pfn_range_valid_gigantic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1069-1095",
    "snippet": "static bool pfn_range_valid_gigantic(struct zone *z,\n\t\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tunsigned long i, end_pfn = start_pfn + nr_pages;\n\tstruct page *page;\n\n\tfor (i = start_pfn; i < end_pfn; i++) {\n\t\tif (!pfn_valid(i))\n\t\t\treturn false;\n\n\t\tpage = pfn_to_page(i);\n\n\t\tif (page_zone(page) != z)\n\t\t\treturn false;\n\n\t\tif (PageReserved(page))\n\t\t\treturn false;\n\n\t\tif (page_count(page) > 0)\n\t\t\treturn false;\n\n\t\tif (PageHuge(page))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "PageHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1336-1343",
          "snippet": "int PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHuge(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\treturn page[1].compound_dtor == HUGETLB_PAGE_DTOR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "page"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "i"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "i"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic bool pfn_range_valid_gigantic(struct zone *z,\n\t\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tunsigned long i, end_pfn = start_pfn + nr_pages;\n\tstruct page *page;\n\n\tfor (i = start_pfn; i < end_pfn; i++) {\n\t\tif (!pfn_valid(i))\n\t\t\treturn false;\n\n\t\tpage = pfn_to_page(i);\n\n\t\tif (page_zone(page) != z)\n\t\t\treturn false;\n\n\t\tif (PageReserved(page))\n\t\t\treturn false;\n\n\t\tif (page_count(page) > 0)\n\t\t\treturn false;\n\n\t\tif (PageHuge(page))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "__alloc_gigantic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1061-1067",
    "snippet": "static int __alloc_gigantic_page(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages, gfp_t gfp_mask)\n{\n\tunsigned long end_pfn = start_pfn + nr_pages;\n\treturn alloc_contig_range(start_pfn, end_pfn, MIGRATE_MOVABLE,\n\t\t\t\t  gfp_mask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_contig_range",
          "args": [
            "start_pfn",
            "end_pfn",
            "MIGRATE_MOVABLE",
            "gfp_mask"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int __alloc_gigantic_page(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages, gfp_t gfp_mask)\n{\n\tunsigned long end_pfn = start_pfn + nr_pages;\n\treturn alloc_contig_range(start_pfn, end_pfn, MIGRATE_MOVABLE,\n\t\t\t\t  gfp_mask);\n}"
  },
  {
    "function_name": "free_gigantic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1056-1059",
    "snippet": "static void free_gigantic_page(struct page *page, unsigned int order)\n{\n\tfree_contig_range(page_to_pfn(page), 1 << order);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_contig_range",
          "args": [
            "page_to_pfn(page)",
            "1 << order"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void free_gigantic_page(struct page *page, unsigned int order)\n{\n\tfree_contig_range(page_to_pfn(page), 1 << order);\n}"
  },
  {
    "function_name": "destroy_compound_gigantic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1039-1054",
    "snippet": "static void destroy_compound_gigantic_page(struct page *page,\n\t\t\t\t\tunsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\tstruct page *p = page + 1;\n\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\tfor (i = 1; i < nr_pages; i++, p = mem_map_next(p, page, i)) {\n\t\tclear_compound_head(p);\n\t\tset_page_refcounted(p);\n\t}\n\n\tset_compound_order(page, 0);\n\t__ClearPageHead(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ClearPageHead",
          "args": [
            "page"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_compound_order",
          "args": [
            "page",
            "0"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_refcounted",
          "args": [
            "p"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_refcounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "74-79",
          "snippet": "static inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_compound_head",
          "args": [
            "p"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_map_next",
          "args": [
            "p",
            "page",
            "i"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "mem_map_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "380-390",
          "snippet": "static inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "compound_mapcount_ptr(page)",
            "0"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void destroy_compound_gigantic_page(struct page *page,\n\t\t\t\t\tunsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\tstruct page *p = page + 1;\n\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\tfor (i = 1; i < nr_pages; i++, p = mem_map_next(p, page, i)) {\n\t\tclear_compound_head(p);\n\t\tset_page_refcounted(p);\n\t}\n\n\tset_compound_order(page, 0);\n\t__ClearPageHead(page);\n}"
  },
  {
    "function_name": "hstate_next_node_to_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "1014-1024",
    "snippet": "static int hstate_next_node_to_free(struct hstate *h, nodemask_t *nodes_allowed)\n{\n\tint nid;\n\n\tVM_BUG_ON(!nodes_allowed);\n\n\tnid = get_valid_node_allowed(h->next_nid_to_free, nodes_allowed);\n\th->next_nid_to_free = next_node_allowed(nid, nodes_allowed);\n\n\treturn nid;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_node_allowed",
          "args": [
            "nid",
            "nodes_allowed"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "next_node_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "974-980",
          "snippet": "static int next_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tnid = next_node_in(nid, *nodes_allowed);\n\tVM_BUG_ON(nid >= MAX_NUMNODES);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int next_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tnid = next_node_in(nid, *nodes_allowed);\n\tVM_BUG_ON(nid >= MAX_NUMNODES);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_valid_node_allowed",
          "args": [
            "h->next_nid_to_free",
            "nodes_allowed"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_node_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "982-987",
          "snippet": "static int get_valid_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tif (!node_isset(nid, *nodes_allowed))\n\t\tnid = next_node_allowed(nid, nodes_allowed);\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int get_valid_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tif (!node_isset(nid, *nodes_allowed))\n\t\tnid = next_node_allowed(nid, nodes_allowed);\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!nodes_allowed"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hstate_next_node_to_free(struct hstate *h, nodemask_t *nodes_allowed)\n{\n\tint nid;\n\n\tVM_BUG_ON(!nodes_allowed);\n\n\tnid = get_valid_node_allowed(h->next_nid_to_free, nodes_allowed);\n\th->next_nid_to_free = next_node_allowed(nid, nodes_allowed);\n\n\treturn nid;\n}"
  },
  {
    "function_name": "hstate_next_node_to_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "995-1006",
    "snippet": "static int hstate_next_node_to_alloc(struct hstate *h,\n\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n\tint nid;\n\n\tVM_BUG_ON(!nodes_allowed);\n\n\tnid = get_valid_node_allowed(h->next_nid_to_alloc, nodes_allowed);\n\th->next_nid_to_alloc = next_node_allowed(nid, nodes_allowed);\n\n\treturn nid;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_node_allowed",
          "args": [
            "nid",
            "nodes_allowed"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "next_node_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "974-980",
          "snippet": "static int next_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tnid = next_node_in(nid, *nodes_allowed);\n\tVM_BUG_ON(nid >= MAX_NUMNODES);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int next_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tnid = next_node_in(nid, *nodes_allowed);\n\tVM_BUG_ON(nid >= MAX_NUMNODES);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_valid_node_allowed",
          "args": [
            "h->next_nid_to_alloc",
            "nodes_allowed"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_node_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "982-987",
          "snippet": "static int get_valid_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tif (!node_isset(nid, *nodes_allowed))\n\t\tnid = next_node_allowed(nid, nodes_allowed);\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int get_valid_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tif (!node_isset(nid, *nodes_allowed))\n\t\tnid = next_node_allowed(nid, nodes_allowed);\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!nodes_allowed"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hstate_next_node_to_alloc(struct hstate *h,\n\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n\tint nid;\n\n\tVM_BUG_ON(!nodes_allowed);\n\n\tnid = get_valid_node_allowed(h->next_nid_to_alloc, nodes_allowed);\n\th->next_nid_to_alloc = next_node_allowed(nid, nodes_allowed);\n\n\treturn nid;\n}"
  },
  {
    "function_name": "get_valid_node_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "982-987",
    "snippet": "static int get_valid_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tif (!node_isset(nid, *nodes_allowed))\n\t\tnid = next_node_allowed(nid, nodes_allowed);\n\treturn nid;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_node_allowed",
          "args": [
            "nid",
            "nodes_allowed"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "next_node_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "974-980",
          "snippet": "static int next_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tnid = next_node_in(nid, *nodes_allowed);\n\tVM_BUG_ON(nid >= MAX_NUMNODES);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int next_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tnid = next_node_in(nid, *nodes_allowed);\n\tVM_BUG_ON(nid >= MAX_NUMNODES);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "nid",
            "*nodes_allowed"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int get_valid_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tif (!node_isset(nid, *nodes_allowed))\n\t\tnid = next_node_allowed(nid, nodes_allowed);\n\treturn nid;\n}"
  },
  {
    "function_name": "next_node_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "974-980",
    "snippet": "static int next_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tnid = next_node_in(nid, *nodes_allowed);\n\tVM_BUG_ON(nid >= MAX_NUMNODES);\n\n\treturn nid;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "nid >= MAX_NUMNODES"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_node_in",
          "args": [
            "nid",
            "*nodes_allowed"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int next_node_allowed(int nid, nodemask_t *nodes_allowed)\n{\n\tnid = next_node_in(nid, *nodes_allowed);\n\tVM_BUG_ON(nid >= MAX_NUMNODES);\n\n\treturn nid;\n}"
  },
  {
    "function_name": "dequeue_huge_page_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "928-965",
    "snippet": "static struct page *dequeue_huge_page_vma(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long address, int avoid_reserve,\n\t\t\t\tlong chg)\n{\n\tstruct page *page;\n\tstruct mempolicy *mpol;\n\tgfp_t gfp_mask;\n\tnodemask_t *nodemask;\n\tint nid;\n\n\t/*\n\t * A child process with MAP_PRIVATE mappings created by their parent\n\t * have no page reserves. This check ensures that reservations are\n\t * not \"stolen\". The child may still get SIGKILLed\n\t */\n\tif (!vma_has_reserves(vma, chg) &&\n\t\t\th->free_huge_pages - h->resv_huge_pages == 0)\n\t\tgoto err;\n\n\t/* If reserves cannot be used, ensure enough pages are in the pool */\n\tif (avoid_reserve && h->free_huge_pages - h->resv_huge_pages == 0)\n\t\tgoto err;\n\n\tgfp_mask = htlb_alloc_mask(h);\n\tnid = huge_node(vma, address, gfp_mask, &mpol, &nodemask);\n\tpage = dequeue_huge_page_nodemask(h, gfp_mask, nid, nodemask);\n\tif (page && !avoid_reserve && vma_has_reserves(vma, chg)) {\n\t\tSetPagePrivate(page);\n\t\th->resv_huge_pages--;\n\t}\n\n\tmpol_cond_put(mpol);\n\treturn page;\n\nerr:\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_cond_put",
          "args": [
            "mpol"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_has_reserves",
          "args": [
            "vma",
            "chg"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "vma_has_reserves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "793-853",
          "snippet": "static bool vma_has_reserves(struct vm_area_struct *vma, long chg)\n{\n\tif (vma->vm_flags & VM_NORESERVE) {\n\t\t/*\n\t\t * This address is already reserved by other process(chg == 0),\n\t\t * so, we should decrement reserved count. Without decrementing,\n\t\t * reserve count remains after releasing inode, because this\n\t\t * allocated page will go into page cache and is regarded as\n\t\t * coming from reserved pool in releasing step.  Currently, we\n\t\t * don't have any other solution to deal with this situation\n\t\t * properly, so add work-around here.\n\t\t */\n\t\tif (vma->vm_flags & VM_MAYSHARE && chg == 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/* Shared mappings always use reserves */\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\t/*\n\t\t * We know VM_NORESERVE is not set.  Therefore, there SHOULD\n\t\t * be a region map for all pages.  The only situation where\n\t\t * there is no region map is if a hole was punched via\n\t\t * fallocate.  In this case, there really are no reverves to\n\t\t * use.  This situation is indicated if chg != 0.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Only the process that called mmap() has reserves for\n\t * private mappings.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\t/*\n\t\t * Like the shared case above, a hole punch or truncate\n\t\t * could have been performed on the private mapping.\n\t\t * Examine the value of chg to determine if reserves\n\t\t * actually exist or were previously consumed.\n\t\t * Very Subtle - The value of chg comes from a previous\n\t\t * call to vma_needs_reserves().  The reserve map for\n\t\t * private mappings has different (opposite) semantics\n\t\t * than that of shared mappings.  vma_needs_reserves()\n\t\t * has already taken this difference in semantics into\n\t\t * account.  Therefore, the meaning of chg is the same\n\t\t * as in the shared case above.  Code could easily be\n\t\t * combined, but keeping it separate draws attention to\n\t\t * subtle differences.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [
            "#define HPAGE_RESV_OWNER    (1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic bool vma_has_reserves(struct vm_area_struct *vma, long chg)\n{\n\tif (vma->vm_flags & VM_NORESERVE) {\n\t\t/*\n\t\t * This address is already reserved by other process(chg == 0),\n\t\t * so, we should decrement reserved count. Without decrementing,\n\t\t * reserve count remains after releasing inode, because this\n\t\t * allocated page will go into page cache and is regarded as\n\t\t * coming from reserved pool in releasing step.  Currently, we\n\t\t * don't have any other solution to deal with this situation\n\t\t * properly, so add work-around here.\n\t\t */\n\t\tif (vma->vm_flags & VM_MAYSHARE && chg == 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/* Shared mappings always use reserves */\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\t/*\n\t\t * We know VM_NORESERVE is not set.  Therefore, there SHOULD\n\t\t * be a region map for all pages.  The only situation where\n\t\t * there is no region map is if a hole was punched via\n\t\t * fallocate.  In this case, there really are no reverves to\n\t\t * use.  This situation is indicated if chg != 0.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Only the process that called mmap() has reserves for\n\t * private mappings.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\t/*\n\t\t * Like the shared case above, a hole punch or truncate\n\t\t * could have been performed on the private mapping.\n\t\t * Examine the value of chg to determine if reserves\n\t\t * actually exist or were previously consumed.\n\t\t * Very Subtle - The value of chg comes from a previous\n\t\t * call to vma_needs_reserves().  The reserve map for\n\t\t * private mappings has different (opposite) semantics\n\t\t * than that of shared mappings.  vma_needs_reserves()\n\t\t * has already taken this difference in semantics into\n\t\t * account.  Therefore, the meaning of chg is the same\n\t\t * as in the shared case above.  Code could easily be\n\t\t * combined, but keeping it separate draws attention to\n\t\t * subtle differences.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_huge_page_nodemask",
          "args": [
            "h",
            "gfp_mask",
            "nid",
            "nodemask"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_huge_page_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "883-917",
          "snippet": "static struct page *dequeue_huge_page_nodemask(struct hstate *h, gfp_t gfp_mask, int nid,\n\t\tnodemask_t *nmask)\n{\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zonelist;\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tint node = -1;\n\n\tzonelist = node_zonelist(nid, gfp_mask);\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, gfp_zone(gfp_mask), nmask) {\n\t\tstruct page *page;\n\n\t\tif (!cpuset_zone_allowed(zone, gfp_mask))\n\t\t\tcontinue;\n\t\t/*\n\t\t * no need to ask again on the same node. Pool is node rather than\n\t\t * zone aware\n\t\t */\n\t\tif (zone_to_nid(zone) == node)\n\t\t\tcontinue;\n\t\tnode = zone_to_nid(zone);\n\n\t\tpage = dequeue_huge_page_node_exact(h, node);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *dequeue_huge_page_nodemask(struct hstate *h, gfp_t gfp_mask, int nid,\n\t\tnodemask_t *nmask)\n{\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zonelist;\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tint node = -1;\n\n\tzonelist = node_zonelist(nid, gfp_mask);\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, gfp_zone(gfp_mask), nmask) {\n\t\tstruct page *page;\n\n\t\tif (!cpuset_zone_allowed(zone, gfp_mask))\n\t\t\tcontinue;\n\t\t/*\n\t\t * no need to ask again on the same node. Pool is node rather than\n\t\t * zone aware\n\t\t */\n\t\tif (zone_to_nid(zone) == node)\n\t\t\tcontinue;\n\t\tnode = zone_to_nid(zone);\n\n\t\tpage = dequeue_huge_page_node_exact(h, node);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_node",
          "args": [
            "vma",
            "address",
            "gfp_mask",
            "&mpol",
            "&nodemask"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "huge_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1868-1885",
          "snippet": "int huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nint huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htlb_alloc_mask",
          "args": [
            "h"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "htlb_alloc_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "920-926",
          "snippet": "static inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *dequeue_huge_page_vma(struct hstate *h,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long address, int avoid_reserve,\n\t\t\t\tlong chg)\n{\n\tstruct page *page;\n\tstruct mempolicy *mpol;\n\tgfp_t gfp_mask;\n\tnodemask_t *nodemask;\n\tint nid;\n\n\t/*\n\t * A child process with MAP_PRIVATE mappings created by their parent\n\t * have no page reserves. This check ensures that reservations are\n\t * not \"stolen\". The child may still get SIGKILLed\n\t */\n\tif (!vma_has_reserves(vma, chg) &&\n\t\t\th->free_huge_pages - h->resv_huge_pages == 0)\n\t\tgoto err;\n\n\t/* If reserves cannot be used, ensure enough pages are in the pool */\n\tif (avoid_reserve && h->free_huge_pages - h->resv_huge_pages == 0)\n\t\tgoto err;\n\n\tgfp_mask = htlb_alloc_mask(h);\n\tnid = huge_node(vma, address, gfp_mask, &mpol, &nodemask);\n\tpage = dequeue_huge_page_nodemask(h, gfp_mask, nid, nodemask);\n\tif (page && !avoid_reserve && vma_has_reserves(vma, chg)) {\n\t\tSetPagePrivate(page);\n\t\th->resv_huge_pages--;\n\t}\n\n\tmpol_cond_put(mpol);\n\treturn page;\n\nerr:\n\treturn NULL;\n}"
  },
  {
    "function_name": "htlb_alloc_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "920-926",
    "snippet": "static inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugepage_migration_supported",
          "args": [
            "h"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}"
  },
  {
    "function_name": "dequeue_huge_page_nodemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "883-917",
    "snippet": "static struct page *dequeue_huge_page_nodemask(struct hstate *h, gfp_t gfp_mask, int nid,\n\t\tnodemask_t *nmask)\n{\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zonelist;\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tint node = -1;\n\n\tzonelist = node_zonelist(nid, gfp_mask);\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, gfp_zone(gfp_mask), nmask) {\n\t\tstruct page *page;\n\n\t\tif (!cpuset_zone_allowed(zone, gfp_mask))\n\t\t\tcontinue;\n\t\t/*\n\t\t * no need to ask again on the same node. Pool is node rather than\n\t\t * zone aware\n\t\t */\n\t\tif (zone_to_nid(zone) == node)\n\t\t\tcontinue;\n\t\tnode = zone_to_nid(zone);\n\n\t\tpage = dequeue_huge_page_node_exact(h, node);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "read_mems_allowed_retry(cpuset_mems_cookie)"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mems_allowed_retry",
          "args": [
            "cpuset_mems_cookie"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_huge_page_node_exact",
          "args": [
            "h",
            "node"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_huge_page_node_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "863-881",
          "snippet": "static struct page *dequeue_huge_page_node_exact(struct hstate *h, int nid)\n{\n\tstruct page *page;\n\n\tlist_for_each_entry(page, &h->hugepage_freelists[nid], lru)\n\t\tif (!PageHWPoison(page))\n\t\t\tbreak;\n\t/*\n\t * if 'non-isolated free hugepage' not found on the list,\n\t * the allocation fails.\n\t */\n\tif (&h->hugepage_freelists[nid] == &page->lru)\n\t\treturn NULL;\n\tlist_move(&page->lru, &h->hugepage_activelist);\n\tset_page_refcounted(page);\n\th->free_huge_pages--;\n\th->free_huge_pages_node[nid]--;\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *dequeue_huge_page_node_exact(struct hstate *h, int nid)\n{\n\tstruct page *page;\n\n\tlist_for_each_entry(page, &h->hugepage_freelists[nid], lru)\n\t\tif (!PageHWPoison(page))\n\t\t\tbreak;\n\t/*\n\t * if 'non-isolated free hugepage' not found on the list,\n\t * the allocation fails.\n\t */\n\tif (&h->hugepage_freelists[nid] == &page->lru)\n\t\treturn NULL;\n\tlist_move(&page->lru, &h->hugepage_activelist);\n\tset_page_refcounted(page);\n\th->free_huge_pages--;\n\th->free_huge_pages_node[nid]--;\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_zone_allowed",
          "args": [
            "zone",
            "gfp_mask"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "zonelist",
            "gfp_zone(gfp_mask)",
            "nmask"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "gfp_mask"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mems_allowed_begin",
          "args": [],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_zonelist",
          "args": [
            "nid",
            "gfp_mask"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *dequeue_huge_page_nodemask(struct hstate *h, gfp_t gfp_mask, int nid,\n\t\tnodemask_t *nmask)\n{\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zonelist;\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tint node = -1;\n\n\tzonelist = node_zonelist(nid, gfp_mask);\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, gfp_zone(gfp_mask), nmask) {\n\t\tstruct page *page;\n\n\t\tif (!cpuset_zone_allowed(zone, gfp_mask))\n\t\t\tcontinue;\n\t\t/*\n\t\t * no need to ask again on the same node. Pool is node rather than\n\t\t * zone aware\n\t\t */\n\t\tif (zone_to_nid(zone) == node)\n\t\t\tcontinue;\n\t\tnode = zone_to_nid(zone);\n\n\t\tpage = dequeue_huge_page_node_exact(h, node);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "dequeue_huge_page_node_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "863-881",
    "snippet": "static struct page *dequeue_huge_page_node_exact(struct hstate *h, int nid)\n{\n\tstruct page *page;\n\n\tlist_for_each_entry(page, &h->hugepage_freelists[nid], lru)\n\t\tif (!PageHWPoison(page))\n\t\t\tbreak;\n\t/*\n\t * if 'non-isolated free hugepage' not found on the list,\n\t * the allocation fails.\n\t */\n\tif (&h->hugepage_freelists[nid] == &page->lru)\n\t\treturn NULL;\n\tlist_move(&page->lru, &h->hugepage_activelist);\n\tset_page_refcounted(page);\n\th->free_huge_pages--;\n\th->free_huge_pages_node[nid]--;\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_refcounted",
          "args": [
            "page"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_refcounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "74-79",
          "snippet": "static inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&page->lru",
            "&h->hugepage_activelist"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&h->hugepage_freelists[nid]",
            "lru"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic struct page *dequeue_huge_page_node_exact(struct hstate *h, int nid)\n{\n\tstruct page *page;\n\n\tlist_for_each_entry(page, &h->hugepage_freelists[nid], lru)\n\t\tif (!PageHWPoison(page))\n\t\t\tbreak;\n\t/*\n\t * if 'non-isolated free hugepage' not found on the list,\n\t * the allocation fails.\n\t */\n\tif (&h->hugepage_freelists[nid] == &page->lru)\n\t\treturn NULL;\n\tlist_move(&page->lru, &h->hugepage_activelist);\n\tset_page_refcounted(page);\n\th->free_huge_pages--;\n\th->free_huge_pages_node[nid]--;\n\treturn page;\n}"
  },
  {
    "function_name": "enqueue_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "855-861",
    "snippet": "static void enqueue_huge_page(struct hstate *h, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tlist_move(&page->lru, &h->hugepage_freelists[nid]);\n\th->free_huge_pages++;\n\th->free_huge_pages_node[nid]++;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&page->lru",
            "&h->hugepage_freelists[nid]"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void enqueue_huge_page(struct hstate *h, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tlist_move(&page->lru, &h->hugepage_freelists[nid]);\n\th->free_huge_pages++;\n\th->free_huge_pages_node[nid]++;\n}"
  },
  {
    "function_name": "vma_has_reserves",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "793-853",
    "snippet": "static bool vma_has_reserves(struct vm_area_struct *vma, long chg)\n{\n\tif (vma->vm_flags & VM_NORESERVE) {\n\t\t/*\n\t\t * This address is already reserved by other process(chg == 0),\n\t\t * so, we should decrement reserved count. Without decrementing,\n\t\t * reserve count remains after releasing inode, because this\n\t\t * allocated page will go into page cache and is regarded as\n\t\t * coming from reserved pool in releasing step.  Currently, we\n\t\t * don't have any other solution to deal with this situation\n\t\t * properly, so add work-around here.\n\t\t */\n\t\tif (vma->vm_flags & VM_MAYSHARE && chg == 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/* Shared mappings always use reserves */\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\t/*\n\t\t * We know VM_NORESERVE is not set.  Therefore, there SHOULD\n\t\t * be a region map for all pages.  The only situation where\n\t\t * there is no region map is if a hole was punched via\n\t\t * fallocate.  In this case, there really are no reverves to\n\t\t * use.  This situation is indicated if chg != 0.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Only the process that called mmap() has reserves for\n\t * private mappings.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\t/*\n\t\t * Like the shared case above, a hole punch or truncate\n\t\t * could have been performed on the private mapping.\n\t\t * Examine the value of chg to determine if reserves\n\t\t * actually exist or were previously consumed.\n\t\t * Very Subtle - The value of chg comes from a previous\n\t\t * call to vma_needs_reserves().  The reserve map for\n\t\t * private mappings has different (opposite) semantics\n\t\t * than that of shared mappings.  vma_needs_reserves()\n\t\t * has already taken this difference in semantics into\n\t\t * account.  Therefore, the meaning of chg is the same\n\t\t * as in the shared case above.  Code could easily be\n\t\t * combined, but keeping it separate draws attention to\n\t\t * subtle differences.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define HPAGE_RESV_OWNER    (1UL << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_vma_resv_set",
          "args": [
            "vma",
            "HPAGE_RESV_OWNER"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "is_vma_resv_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "777-782",
          "snippet": "static int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_OWNER    (1UL << 0)\n\nstatic bool vma_has_reserves(struct vm_area_struct *vma, long chg)\n{\n\tif (vma->vm_flags & VM_NORESERVE) {\n\t\t/*\n\t\t * This address is already reserved by other process(chg == 0),\n\t\t * so, we should decrement reserved count. Without decrementing,\n\t\t * reserve count remains after releasing inode, because this\n\t\t * allocated page will go into page cache and is regarded as\n\t\t * coming from reserved pool in releasing step.  Currently, we\n\t\t * don't have any other solution to deal with this situation\n\t\t * properly, so add work-around here.\n\t\t */\n\t\tif (vma->vm_flags & VM_MAYSHARE && chg == 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/* Shared mappings always use reserves */\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\t/*\n\t\t * We know VM_NORESERVE is not set.  Therefore, there SHOULD\n\t\t * be a region map for all pages.  The only situation where\n\t\t * there is no region map is if a hole was punched via\n\t\t * fallocate.  In this case, there really are no reverves to\n\t\t * use.  This situation is indicated if chg != 0.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Only the process that called mmap() has reserves for\n\t * private mappings.\n\t */\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\t/*\n\t\t * Like the shared case above, a hole punch or truncate\n\t\t * could have been performed on the private mapping.\n\t\t * Examine the value of chg to determine if reserves\n\t\t * actually exist or were previously consumed.\n\t\t * Very Subtle - The value of chg comes from a previous\n\t\t * call to vma_needs_reserves().  The reserve map for\n\t\t * private mappings has different (opposite) semantics\n\t\t * than that of shared mappings.  vma_needs_reserves()\n\t\t * has already taken this difference in semantics into\n\t\t * account.  Therefore, the meaning of chg is the same\n\t\t * as in the shared case above.  Code could easily be\n\t\t * combined, but keeping it separate draws attention to\n\t\t * subtle differences.\n\t\t */\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "reset_vma_resv_huge_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "785-790",
    "snippet": "void reset_vma_resv_huge_pages(struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\tvma->vm_private_data = (void *)0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "!is_vm_hugetlb_page(vma)",
            "vma"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid reset_vma_resv_huge_pages(struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\tvma->vm_private_data = (void *)0;\n}"
  },
  {
    "function_name": "is_vma_resv_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "777-782",
    "snippet": "static int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_vma_private_data",
          "args": [
            "vma"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "get_vma_private_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "685-688",
          "snippet": "static unsigned long get_vma_private_data(struct vm_area_struct *vma)\n{\n\treturn (unsigned long)vma->vm_private_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned long get_vma_private_data(struct vm_area_struct *vma)\n{\n\treturn (unsigned long)vma->vm_private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "!is_vm_hugetlb_page(vma)",
            "vma"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}"
  },
  {
    "function_name": "set_vma_resv_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "769-775",
    "snippet": "static void set_vma_resv_flags(struct vm_area_struct *vma, unsigned long flags)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, get_vma_private_data(vma) | flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_vma_private_data",
          "args": [
            "vma",
            "get_vma_private_data(vma) | flags"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "set_vma_private_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "690-694",
          "snippet": "static void set_vma_private_data(struct vm_area_struct *vma,\n\t\t\t\t\t\t\tunsigned long value)\n{\n\tvma->vm_private_data = (void *)value;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_vma_private_data(struct vm_area_struct *vma,\n\t\t\t\t\t\t\tunsigned long value)\n{\n\tvma->vm_private_data = (void *)value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vma_private_data",
          "args": [
            "vma"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "get_vma_private_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "685-688",
          "snippet": "static unsigned long get_vma_private_data(struct vm_area_struct *vma)\n{\n\treturn (unsigned long)vma->vm_private_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned long get_vma_private_data(struct vm_area_struct *vma)\n{\n\treturn (unsigned long)vma->vm_private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "vma->vm_flags & VM_MAYSHARE",
            "vma"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "!is_vm_hugetlb_page(vma)",
            "vma"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_vma_resv_flags(struct vm_area_struct *vma, unsigned long flags)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, get_vma_private_data(vma) | flags);\n}"
  },
  {
    "function_name": "set_vma_resv_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "760-767",
    "snippet": "static void set_vma_resv_map(struct vm_area_struct *vma, struct resv_map *map)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, (get_vma_private_data(vma) &\n\t\t\t\tHPAGE_RESV_MASK) | (unsigned long)map);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_vma_private_data",
          "args": [
            "vma",
            "(get_vma_private_data(vma) &\n\t\t\t\tHPAGE_RESV_MASK) | (unsigned long)map"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "set_vma_private_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "690-694",
          "snippet": "static void set_vma_private_data(struct vm_area_struct *vma,\n\t\t\t\t\t\t\tunsigned long value)\n{\n\tvma->vm_private_data = (void *)value;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_vma_private_data(struct vm_area_struct *vma,\n\t\t\t\t\t\t\tunsigned long value)\n{\n\tvma->vm_private_data = (void *)value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vma_private_data",
          "args": [
            "vma"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "get_vma_private_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "685-688",
          "snippet": "static unsigned long get_vma_private_data(struct vm_area_struct *vma)\n{\n\treturn (unsigned long)vma->vm_private_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned long get_vma_private_data(struct vm_area_struct *vma)\n{\n\treturn (unsigned long)vma->vm_private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "vma->vm_flags & VM_MAYSHARE",
            "vma"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "!is_vm_hugetlb_page(vma)",
            "vma"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)\n\nstatic void set_vma_resv_map(struct vm_area_struct *vma, struct resv_map *map)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, (get_vma_private_data(vma) &\n\t\t\t\tHPAGE_RESV_MASK) | (unsigned long)map);\n}"
  },
  {
    "function_name": "vma_resv_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "745-758",
    "snippet": "static struct resv_map *vma_resv_map(struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\t\tstruct inode *inode = mapping->host;\n\n\t\treturn inode_resv_map(inode);\n\n\t} else {\n\t\treturn (struct resv_map *)(get_vma_private_data(vma) &\n\t\t\t\t\t\t\t~HPAGE_RESV_MASK);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_vma_private_data",
          "args": [
            "vma"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "get_vma_private_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "685-688",
          "snippet": "static unsigned long get_vma_private_data(struct vm_area_struct *vma)\n{\n\treturn (unsigned long)vma->vm_private_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned long get_vma_private_data(struct vm_area_struct *vma)\n{\n\treturn (unsigned long)vma->vm_private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_resv_map",
          "args": [
            "inode"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "inode_resv_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "740-743",
          "snippet": "static inline struct resv_map *inode_resv_map(struct inode *inode)\n{\n\treturn inode->i_mapping->private_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct resv_map *inode_resv_map(struct inode *inode)\n{\n\treturn inode->i_mapping->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "!is_vm_hugetlb_page(vma)",
            "vma"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)\n\nstatic struct resv_map *vma_resv_map(struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\t\tstruct inode *inode = mapping->host;\n\n\t\treturn inode_resv_map(inode);\n\n\t} else {\n\t\treturn (struct resv_map *)(get_vma_private_data(vma) &\n\t\t\t\t\t\t\t~HPAGE_RESV_MASK);\n\t}\n}"
  },
  {
    "function_name": "inode_resv_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "740-743",
    "snippet": "static inline struct resv_map *inode_resv_map(struct inode *inode)\n{\n\treturn inode->i_mapping->private_data;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct resv_map *inode_resv_map(struct inode *inode)\n{\n\treturn inode->i_mapping->private_data;\n}"
  },
  {
    "function_name": "resv_map_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "720-738",
    "snippet": "void resv_map_release(struct kref *ref)\n{\n\tstruct resv_map *resv_map = container_of(ref, struct resv_map, refs);\n\tstruct list_head *head = &resv_map->region_cache;\n\tstruct file_region *rg, *trg;\n\n\t/* Clear out any active regions before we release the map. */\n\tregion_del(resv_map, 0, LONG_MAX);\n\n\t/* ... and any entries left in the cache */\n\tlist_for_each_entry_safe(rg, trg, head, link) {\n\t\tlist_del(&rg->link);\n\t\tkfree(rg);\n\t}\n\n\tVM_BUG_ON(resv_map->adds_in_progress);\n\n\tkfree(resv_map);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "resv_map"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "resv_map->adds_in_progress"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rg->link"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rg",
            "trg",
            "head",
            "link"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "region_del",
          "args": [
            "resv_map",
            "0",
            "LONG_MAX"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "region_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "482-561",
          "snippet": "static long region_del(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *trg;\n\tstruct file_region *nrg = NULL;\n\tlong del = 0;\n\nretry:\n\tspin_lock(&resv->lock);\n\tlist_for_each_entry_safe(rg, trg, head, link) {\n\t\t/*\n\t\t * Skip regions before the range to be deleted.  file_region\n\t\t * ranges are normally of the form [from, to).  However, there\n\t\t * may be a \"placeholder\" entry in the map which is of the form\n\t\t * (from, to) with from == to.  Check for placeholder entries\n\t\t * at the beginning of the range to be deleted.\n\t\t */\n\t\tif (rg->to <= f && (rg->to != rg->from || rg->to != f))\n\t\t\tcontinue;\n\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tif (f > rg->from && t < rg->to) { /* Must split region */\n\t\t\t/*\n\t\t\t * Check for an entry in the cache before dropping\n\t\t\t * lock and attempting allocation.\n\t\t\t */\n\t\t\tif (!nrg &&\n\t\t\t    resv->region_cache_count > resv->adds_in_progress) {\n\t\t\t\tnrg = list_first_entry(&resv->region_cache,\n\t\t\t\t\t\t\tstruct file_region,\n\t\t\t\t\t\t\tlink);\n\t\t\t\tlist_del(&nrg->link);\n\t\t\t\tresv->region_cache_count--;\n\t\t\t}\n\n\t\t\tif (!nrg) {\n\t\t\t\tspin_unlock(&resv->lock);\n\t\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\t\tif (!nrg)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tdel += t - f;\n\n\t\t\t/* New entry for end of split region */\n\t\t\tnrg->from = t;\n\t\t\tnrg->to = rg->to;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\n\t\t\t/* Original entry is trimmed */\n\t\t\trg->to = f;\n\n\t\t\tlist_add(&nrg->link, &rg->link);\n\t\t\tnrg = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (f <= rg->from && t >= rg->to) { /* Remove entire region */\n\t\t\tdel += rg->to - rg->from;\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (f <= rg->from) {\t/* Trim beginning of region */\n\t\t\tdel += t - rg->from;\n\t\t\trg->from = t;\n\t\t} else {\t\t/* Trim end of region */\n\t\t\tdel += rg->to - f;\n\t\t\trg->to = f;\n\t\t}\n\t}\n\n\tspin_unlock(&resv->lock);\n\tkfree(nrg);\n\treturn del;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_del(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *trg;\n\tstruct file_region *nrg = NULL;\n\tlong del = 0;\n\nretry:\n\tspin_lock(&resv->lock);\n\tlist_for_each_entry_safe(rg, trg, head, link) {\n\t\t/*\n\t\t * Skip regions before the range to be deleted.  file_region\n\t\t * ranges are normally of the form [from, to).  However, there\n\t\t * may be a \"placeholder\" entry in the map which is of the form\n\t\t * (from, to) with from == to.  Check for placeholder entries\n\t\t * at the beginning of the range to be deleted.\n\t\t */\n\t\tif (rg->to <= f && (rg->to != rg->from || rg->to != f))\n\t\t\tcontinue;\n\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tif (f > rg->from && t < rg->to) { /* Must split region */\n\t\t\t/*\n\t\t\t * Check for an entry in the cache before dropping\n\t\t\t * lock and attempting allocation.\n\t\t\t */\n\t\t\tif (!nrg &&\n\t\t\t    resv->region_cache_count > resv->adds_in_progress) {\n\t\t\t\tnrg = list_first_entry(&resv->region_cache,\n\t\t\t\t\t\t\tstruct file_region,\n\t\t\t\t\t\t\tlink);\n\t\t\t\tlist_del(&nrg->link);\n\t\t\t\tresv->region_cache_count--;\n\t\t\t}\n\n\t\t\tif (!nrg) {\n\t\t\t\tspin_unlock(&resv->lock);\n\t\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\t\tif (!nrg)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tdel += t - f;\n\n\t\t\t/* New entry for end of split region */\n\t\t\tnrg->from = t;\n\t\t\tnrg->to = rg->to;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\n\t\t\t/* Original entry is trimmed */\n\t\t\trg->to = f;\n\n\t\t\tlist_add(&nrg->link, &rg->link);\n\t\t\tnrg = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (f <= rg->from && t >= rg->to) { /* Remove entire region */\n\t\t\tdel += rg->to - rg->from;\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (f <= rg->from) {\t/* Trim beginning of region */\n\t\t\tdel += t - rg->from;\n\t\t\trg->from = t;\n\t\t} else {\t\t/* Trim end of region */\n\t\t\tdel += rg->to - f;\n\t\t\trg->to = f;\n\t\t}\n\t}\n\n\tspin_unlock(&resv->lock);\n\tkfree(nrg);\n\treturn del;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structresv_map",
            "refs"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid resv_map_release(struct kref *ref)\n{\n\tstruct resv_map *resv_map = container_of(ref, struct resv_map, refs);\n\tstruct list_head *head = &resv_map->region_cache;\n\tstruct file_region *rg, *trg;\n\n\t/* Clear out any active regions before we release the map. */\n\tregion_del(resv_map, 0, LONG_MAX);\n\n\t/* ... and any entries left in the cache */\n\tlist_for_each_entry_safe(rg, trg, head, link) {\n\t\tlist_del(&rg->link);\n\t\tkfree(rg);\n\t}\n\n\tVM_BUG_ON(resv_map->adds_in_progress);\n\n\tkfree(resv_map);\n}"
  },
  {
    "function_name": "resv_map_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "696-718",
    "snippet": "struct resv_map *resv_map_alloc(void)\n{\n\tstruct resv_map *resv_map = kmalloc(sizeof(*resv_map), GFP_KERNEL);\n\tstruct file_region *rg = kmalloc(sizeof(*rg), GFP_KERNEL);\n\n\tif (!resv_map || !rg) {\n\t\tkfree(resv_map);\n\t\tkfree(rg);\n\t\treturn NULL;\n\t}\n\n\tkref_init(&resv_map->refs);\n\tspin_lock_init(&resv_map->lock);\n\tINIT_LIST_HEAD(&resv_map->regions);\n\n\tresv_map->adds_in_progress = 0;\n\n\tINIT_LIST_HEAD(&resv_map->region_cache);\n\tlist_add(&rg->link, &resv_map->region_cache);\n\tresv_map->region_cache_count = 1;\n\n\treturn resv_map;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&rg->link",
            "&resv_map->region_cache"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&resv_map->region_cache"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&resv_map->regions"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&resv_map->lock"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&resv_map->refs"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rg"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*rg)",
            "GFP_KERNEL"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct resv_map *resv_map_alloc(void)\n{\n\tstruct resv_map *resv_map = kmalloc(sizeof(*resv_map), GFP_KERNEL);\n\tstruct file_region *rg = kmalloc(sizeof(*rg), GFP_KERNEL);\n\n\tif (!resv_map || !rg) {\n\t\tkfree(resv_map);\n\t\tkfree(rg);\n\t\treturn NULL;\n\t}\n\n\tkref_init(&resv_map->refs);\n\tspin_lock_init(&resv_map->lock);\n\tINIT_LIST_HEAD(&resv_map->regions);\n\n\tresv_map->adds_in_progress = 0;\n\n\tINIT_LIST_HEAD(&resv_map->region_cache);\n\tlist_add(&rg->link, &resv_map->region_cache);\n\tresv_map->region_cache_count = 1;\n\n\treturn resv_map;\n}"
  },
  {
    "function_name": "set_vma_private_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "690-694",
    "snippet": "static void set_vma_private_data(struct vm_area_struct *vma,\n\t\t\t\t\t\t\tunsigned long value)\n{\n\tvma->vm_private_data = (void *)value;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void set_vma_private_data(struct vm_area_struct *vma,\n\t\t\t\t\t\t\tunsigned long value)\n{\n\tvma->vm_private_data = (void *)value;\n}"
  },
  {
    "function_name": "get_vma_private_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "685-688",
    "snippet": "static unsigned long get_vma_private_data(struct vm_area_struct *vma)\n{\n\treturn (unsigned long)vma->vm_private_data;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned long get_vma_private_data(struct vm_area_struct *vma)\n{\n\treturn (unsigned long)vma->vm_private_data;\n}"
  },
  {
    "function_name": "vma_mmu_pagesize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "652-655",
    "snippet": "__weak unsigned long vma_mmu_pagesize(struct vm_area_struct *vma)\n{\n\treturn vma_kernel_pagesize(vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_kernel_pagesize",
          "args": [
            "vma"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "vma_kernel_pagesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "638-643",
          "snippet": "unsigned long vma_kernel_pagesize(struct vm_area_struct *vma)\n{\n\tif (vma->vm_ops && vma->vm_ops->pagesize)\n\t\treturn vma->vm_ops->pagesize(vma);\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nunsigned long vma_kernel_pagesize(struct vm_area_struct *vma)\n{\n\tif (vma->vm_ops && vma->vm_ops->pagesize)\n\t\treturn vma->vm_ops->pagesize(vma);\n\treturn PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n__weak unsigned long vma_mmu_pagesize(struct vm_area_struct *vma)\n{\n\treturn vma_kernel_pagesize(vma);\n}"
  },
  {
    "function_name": "vma_kernel_pagesize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "638-643",
    "snippet": "unsigned long vma_kernel_pagesize(struct vm_area_struct *vma)\n{\n\tif (vma->vm_ops && vma->vm_ops->pagesize)\n\t\treturn vma->vm_ops->pagesize(vma);\n\treturn PAGE_SIZE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma->vm_ops->pagesize",
          "args": [
            "vma"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nunsigned long vma_kernel_pagesize(struct vm_area_struct *vma)\n{\n\tif (vma->vm_ops && vma->vm_ops->pagesize)\n\t\treturn vma->vm_ops->pagesize(vma);\n\treturn PAGE_SIZE;\n}"
  },
  {
    "function_name": "linear_hugepage_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "627-631",
    "snippet": "pgoff_t linear_hugepage_index(struct vm_area_struct *vma,\n\t\t\t\t     unsigned long address)\n{\n\treturn vma_hugecache_offset(hstate_vma(vma), vma, address);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_hugecache_offset",
          "args": [
            "hstate_vma(vma)",
            "vma",
            "address"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "vma_hugecache_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "620-625",
          "snippet": "static pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npgoff_t linear_hugepage_index(struct vm_area_struct *vma,\n\t\t\t\t     unsigned long address)\n{\n\treturn vma_hugecache_offset(hstate_vma(vma), vma, address);\n}"
  },
  {
    "function_name": "vma_hugecache_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "620-625",
    "snippet": "static pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic pgoff_t vma_hugecache_offset(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn ((address - vma->vm_start) >> huge_page_shift(h)) +\n\t\t\t(vma->vm_pgoff >> huge_page_order(h));\n}"
  },
  {
    "function_name": "region_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "589-614",
    "snippet": "static long region_count(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg;\n\tlong chg = 0;\n\n\tspin_lock(&resv->lock);\n\t/* Locate each segment we overlap with, and count that overlap. */\n\tlist_for_each_entry(rg, head, link) {\n\t\tlong seg_from;\n\t\tlong seg_to;\n\n\t\tif (rg->to <= f)\n\t\t\tcontinue;\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tseg_from = max(rg->from, f);\n\t\tseg_to = min(rg->to, t);\n\n\t\tchg += seg_to - seg_from;\n\t}\n\tspin_unlock(&resv->lock);\n\n\treturn chg;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv->lock"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "rg->to",
            "t"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_report_node_meminfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3003-3015",
          "snippet": "int hugetlb_report_node_meminfo(int nid, char *buf)\n{\n\tstruct hstate *h = &default_hstate;\n\tif (!hugepages_supported())\n\t\treturn 0;\n\treturn sprintf(buf,\n\t\t\"Node %d HugePages_Total: %5u\\n\"\n\t\t\"Node %d HugePages_Free:  %5u\\n\"\n\t\t\"Node %d HugePages_Surp:  %5u\\n\",\n\t\tnid, h->nr_huge_pages_node[nid],\n\t\tnid, h->free_huge_pages_node[nid],\n\t\tnid, h->surplus_huge_pages_node[nid]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint hugetlb_report_node_meminfo(int nid, char *buf)\n{\n\tstruct hstate *h = &default_hstate;\n\tif (!hugepages_supported())\n\t\treturn 0;\n\treturn sprintf(buf,\n\t\t\"Node %d HugePages_Total: %5u\\n\"\n\t\t\"Node %d HugePages_Free:  %5u\\n\"\n\t\t\"Node %d HugePages_Surp:  %5u\\n\",\n\t\tnid, h->nr_huge_pages_node[nid],\n\t\tnid, h->free_huge_pages_node[nid],\n\t\tnid, h->surplus_huge_pages_node[nid]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "rg->from",
            "f"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "rg",
            "head",
            "link"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&resv->lock"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_count(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg;\n\tlong chg = 0;\n\n\tspin_lock(&resv->lock);\n\t/* Locate each segment we overlap with, and count that overlap. */\n\tlist_for_each_entry(rg, head, link) {\n\t\tlong seg_from;\n\t\tlong seg_to;\n\n\t\tif (rg->to <= f)\n\t\t\tcontinue;\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tseg_from = max(rg->from, f);\n\t\tseg_to = min(rg->to, t);\n\n\t\tchg += seg_to - seg_from;\n\t}\n\tspin_unlock(&resv->lock);\n\n\treturn chg;\n}"
  },
  {
    "function_name": "hugetlb_fix_reserve_counts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "572-583",
    "snippet": "void hugetlb_fix_reserve_counts(struct inode *inode)\n{\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tlong rsv_adjust;\n\n\trsv_adjust = hugepage_subpool_get_pages(spool, 1);\n\tif (rsv_adjust) {\n\t\tstruct hstate *h = hstate_inode(inode);\n\n\t\thugetlb_acct_memory(h, 1);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_acct_memory",
          "args": [
            "h",
            "1"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_acct_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3052-3091",
          "snippet": "static int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_inode",
          "args": [
            "inode"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_subpool_get_pages",
          "args": [
            "spool",
            "1"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_subpool_get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "131-168",
          "snippet": "static long hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n\t\t\t\t      long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn ret;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1) {\t\t/* maximum size accounting */\n\t\tif ((spool->used_hpages + delta) <= spool->max_hpages)\n\t\t\tspool->used_hpages += delta;\n\t\telse {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_ret;\n\t\t}\n\t}\n\n\t/* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->rsv_hpages) {\n\t\tif (delta > spool->rsv_hpages) {\n\t\t\t/*\n\t\t\t * Asking for more reserves than those already taken on\n\t\t\t * behalf of subpool.  Return difference.\n\t\t\t */\n\t\t\tret = delta - spool->rsv_hpages;\n\t\t\tspool->rsv_hpages = 0;\n\t\t} else {\n\t\t\tret = 0;\t/* reserves already accounted for */\n\t\t\tspool->rsv_hpages -= delta;\n\t\t}\n\t}\n\nunlock_ret:\n\tspin_unlock(&spool->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic long hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n\t\t\t\t      long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn ret;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1) {\t\t/* maximum size accounting */\n\t\tif ((spool->used_hpages + delta) <= spool->max_hpages)\n\t\t\tspool->used_hpages += delta;\n\t\telse {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_ret;\n\t\t}\n\t}\n\n\t/* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->rsv_hpages) {\n\t\tif (delta > spool->rsv_hpages) {\n\t\t\t/*\n\t\t\t * Asking for more reserves than those already taken on\n\t\t\t * behalf of subpool.  Return difference.\n\t\t\t */\n\t\t\tret = delta - spool->rsv_hpages;\n\t\t\tspool->rsv_hpages = 0;\n\t\t} else {\n\t\t\tret = 0;\t/* reserves already accounted for */\n\t\t\tspool->rsv_hpages -= delta;\n\t\t}\n\t}\n\nunlock_ret:\n\tspin_unlock(&spool->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "subpool_inode",
          "args": [
            "inode"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "subpool_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "210-213",
          "snippet": "static inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n{\n\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n{\n\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid hugetlb_fix_reserve_counts(struct inode *inode)\n{\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tlong rsv_adjust;\n\n\trsv_adjust = hugepage_subpool_get_pages(spool, 1);\n\tif (rsv_adjust) {\n\t\tstruct hstate *h = hstate_inode(inode);\n\n\t\thugetlb_acct_memory(h, 1);\n\t}\n}"
  },
  {
    "function_name": "region_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "482-561",
    "snippet": "static long region_del(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *trg;\n\tstruct file_region *nrg = NULL;\n\tlong del = 0;\n\nretry:\n\tspin_lock(&resv->lock);\n\tlist_for_each_entry_safe(rg, trg, head, link) {\n\t\t/*\n\t\t * Skip regions before the range to be deleted.  file_region\n\t\t * ranges are normally of the form [from, to).  However, there\n\t\t * may be a \"placeholder\" entry in the map which is of the form\n\t\t * (from, to) with from == to.  Check for placeholder entries\n\t\t * at the beginning of the range to be deleted.\n\t\t */\n\t\tif (rg->to <= f && (rg->to != rg->from || rg->to != f))\n\t\t\tcontinue;\n\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tif (f > rg->from && t < rg->to) { /* Must split region */\n\t\t\t/*\n\t\t\t * Check for an entry in the cache before dropping\n\t\t\t * lock and attempting allocation.\n\t\t\t */\n\t\t\tif (!nrg &&\n\t\t\t    resv->region_cache_count > resv->adds_in_progress) {\n\t\t\t\tnrg = list_first_entry(&resv->region_cache,\n\t\t\t\t\t\t\tstruct file_region,\n\t\t\t\t\t\t\tlink);\n\t\t\t\tlist_del(&nrg->link);\n\t\t\t\tresv->region_cache_count--;\n\t\t\t}\n\n\t\t\tif (!nrg) {\n\t\t\t\tspin_unlock(&resv->lock);\n\t\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\t\tif (!nrg)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tdel += t - f;\n\n\t\t\t/* New entry for end of split region */\n\t\t\tnrg->from = t;\n\t\t\tnrg->to = rg->to;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\n\t\t\t/* Original entry is trimmed */\n\t\t\trg->to = f;\n\n\t\t\tlist_add(&nrg->link, &rg->link);\n\t\t\tnrg = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (f <= rg->from && t >= rg->to) { /* Remove entire region */\n\t\t\tdel += rg->to - rg->from;\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (f <= rg->from) {\t/* Trim beginning of region */\n\t\t\tdel += t - rg->from;\n\t\t\trg->from = t;\n\t\t} else {\t\t/* Trim end of region */\n\t\t\tdel += rg->to - f;\n\t\t\trg->to = f;\n\t\t}\n\t}\n\n\tspin_unlock(&resv->lock);\n\tkfree(nrg);\n\treturn del;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nrg"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv->lock"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rg->link"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&nrg->link",
            "&rg->link"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nrg->link"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*nrg)",
            "GFP_KERNEL"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv->lock"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&nrg->link"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&resv->region_cache",
            "structfile_region",
            "link"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rg",
            "trg",
            "head",
            "link"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&resv->lock"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_del(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *trg;\n\tstruct file_region *nrg = NULL;\n\tlong del = 0;\n\nretry:\n\tspin_lock(&resv->lock);\n\tlist_for_each_entry_safe(rg, trg, head, link) {\n\t\t/*\n\t\t * Skip regions before the range to be deleted.  file_region\n\t\t * ranges are normally of the form [from, to).  However, there\n\t\t * may be a \"placeholder\" entry in the map which is of the form\n\t\t * (from, to) with from == to.  Check for placeholder entries\n\t\t * at the beginning of the range to be deleted.\n\t\t */\n\t\tif (rg->to <= f && (rg->to != rg->from || rg->to != f))\n\t\t\tcontinue;\n\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\n\t\tif (f > rg->from && t < rg->to) { /* Must split region */\n\t\t\t/*\n\t\t\t * Check for an entry in the cache before dropping\n\t\t\t * lock and attempting allocation.\n\t\t\t */\n\t\t\tif (!nrg &&\n\t\t\t    resv->region_cache_count > resv->adds_in_progress) {\n\t\t\t\tnrg = list_first_entry(&resv->region_cache,\n\t\t\t\t\t\t\tstruct file_region,\n\t\t\t\t\t\t\tlink);\n\t\t\t\tlist_del(&nrg->link);\n\t\t\t\tresv->region_cache_count--;\n\t\t\t}\n\n\t\t\tif (!nrg) {\n\t\t\t\tspin_unlock(&resv->lock);\n\t\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\t\tif (!nrg)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tdel += t - f;\n\n\t\t\t/* New entry for end of split region */\n\t\t\tnrg->from = t;\n\t\t\tnrg->to = rg->to;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\n\t\t\t/* Original entry is trimmed */\n\t\t\trg->to = f;\n\n\t\t\tlist_add(&nrg->link, &rg->link);\n\t\t\tnrg = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (f <= rg->from && t >= rg->to) { /* Remove entire region */\n\t\t\tdel += rg->to - rg->from;\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (f <= rg->from) {\t/* Trim beginning of region */\n\t\t\tdel += t - rg->from;\n\t\t\trg->from = t;\n\t\t} else {\t\t/* Trim end of region */\n\t\t\tdel += rg->to - f;\n\t\t\trg->to = f;\n\t\t}\n\t}\n\n\tspin_unlock(&resv->lock);\n\tkfree(nrg);\n\treturn del;\n}"
  },
  {
    "function_name": "region_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "460-466",
    "snippet": "static void region_abort(struct resv_map *resv, long f, long t)\n{\n\tspin_lock(&resv->lock);\n\tVM_BUG_ON(!resv->region_cache_count);\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv->lock"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!resv->region_cache_count"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&resv->lock"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void region_abort(struct resv_map *resv, long f, long t)\n{\n\tspin_lock(&resv->lock);\n\tVM_BUG_ON(!resv->region_cache_count);\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n}"
  },
  {
    "function_name": "region_chg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "355-447",
    "snippet": "static long region_chg(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg = NULL;\n\tlong chg = 0;\n\nretry:\n\tspin_lock(&resv->lock);\nretry_locked:\n\tresv->adds_in_progress++;\n\n\t/*\n\t * Check for sufficient descriptors in the cache to accommodate\n\t * the number of in progress add operations.\n\t */\n\tif (resv->adds_in_progress > resv->region_cache_count) {\n\t\tstruct file_region *trg;\n\n\t\tVM_BUG_ON(resv->adds_in_progress - resv->region_cache_count > 1);\n\t\t/* Must drop lock to allocate a new descriptor. */\n\t\tresv->adds_in_progress--;\n\t\tspin_unlock(&resv->lock);\n\n\t\ttrg = kmalloc(sizeof(*trg), GFP_KERNEL);\n\t\tif (!trg) {\n\t\t\tkfree(nrg);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tspin_lock(&resv->lock);\n\t\tlist_add(&trg->link, &resv->region_cache);\n\t\tresv->region_cache_count++;\n\t\tgoto retry_locked;\n\t}\n\n\t/* Locate the region we are before or in. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/* If we are below the current region then a new region is required.\n\t * Subtle, allocate a new region at the position but make it zero\n\t * size such that we can guarantee to record the reservation. */\n\tif (&rg->link == head || t < rg->from) {\n\t\tif (!nrg) {\n\t\t\tresv->adds_in_progress--;\n\t\t\tspin_unlock(&resv->lock);\n\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\tif (!nrg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnrg->from = f;\n\t\t\tnrg->to   = f;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tlist_add(&nrg->link, rg->link.prev);\n\t\tchg = t - f;\n\t\tgoto out_nrg;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\tchg = t - f;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tlist_for_each_entry(rg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tgoto out;\n\n\t\t/* We overlap with this area, if it extends further than\n\t\t * us then we must extend ourselves.  Account for its\n\t\t * existing reservation. */\n\t\tif (rg->to > t) {\n\t\t\tchg += rg->to - t;\n\t\t\tt = rg->to;\n\t\t}\n\t\tchg -= rg->to - rg->from;\n\t}\n\nout:\n\tspin_unlock(&resv->lock);\n\t/*  We already know we raced and no longer need the new region */\n\tkfree(nrg);\n\treturn chg;\nout_nrg:\n\tspin_unlock(&resv->lock);\n\treturn chg;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv->lock"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nrg"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv->lock"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "rg",
            "rg->link.prev",
            "link"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&nrg->link",
            "rg->link.prev"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nrg->link"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*nrg)",
            "GFP_KERNEL"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv->lock"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "rg",
            "head",
            "link"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&trg->link",
            "&resv->region_cache"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&resv->lock"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv->lock"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "resv->adds_in_progress - resv->region_cache_count > 1"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&resv->lock"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_chg(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg = NULL;\n\tlong chg = 0;\n\nretry:\n\tspin_lock(&resv->lock);\nretry_locked:\n\tresv->adds_in_progress++;\n\n\t/*\n\t * Check for sufficient descriptors in the cache to accommodate\n\t * the number of in progress add operations.\n\t */\n\tif (resv->adds_in_progress > resv->region_cache_count) {\n\t\tstruct file_region *trg;\n\n\t\tVM_BUG_ON(resv->adds_in_progress - resv->region_cache_count > 1);\n\t\t/* Must drop lock to allocate a new descriptor. */\n\t\tresv->adds_in_progress--;\n\t\tspin_unlock(&resv->lock);\n\n\t\ttrg = kmalloc(sizeof(*trg), GFP_KERNEL);\n\t\tif (!trg) {\n\t\t\tkfree(nrg);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tspin_lock(&resv->lock);\n\t\tlist_add(&trg->link, &resv->region_cache);\n\t\tresv->region_cache_count++;\n\t\tgoto retry_locked;\n\t}\n\n\t/* Locate the region we are before or in. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/* If we are below the current region then a new region is required.\n\t * Subtle, allocate a new region at the position but make it zero\n\t * size such that we can guarantee to record the reservation. */\n\tif (&rg->link == head || t < rg->from) {\n\t\tif (!nrg) {\n\t\t\tresv->adds_in_progress--;\n\t\t\tspin_unlock(&resv->lock);\n\t\t\tnrg = kmalloc(sizeof(*nrg), GFP_KERNEL);\n\t\t\tif (!nrg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnrg->from = f;\n\t\t\tnrg->to   = f;\n\t\t\tINIT_LIST_HEAD(&nrg->link);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tlist_add(&nrg->link, rg->link.prev);\n\t\tchg = t - f;\n\t\tgoto out_nrg;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\tchg = t - f;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tlist_for_each_entry(rg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tgoto out;\n\n\t\t/* We overlap with this area, if it extends further than\n\t\t * us then we must extend ourselves.  Account for its\n\t\t * existing reservation. */\n\t\tif (rg->to > t) {\n\t\t\tchg += rg->to - t;\n\t\t\tt = rg->to;\n\t\t}\n\t\tchg -= rg->to - rg->from;\n\t}\n\nout:\n\tspin_unlock(&resv->lock);\n\t/*  We already know we raced and no longer need the new region */\n\tkfree(nrg);\n\treturn chg;\nout_nrg:\n\tspin_unlock(&resv->lock);\n\treturn chg;\n}"
  },
  {
    "function_name": "region_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "259-331",
    "snippet": "static long region_add(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg, *trg;\n\tlong add = 0;\n\n\tspin_lock(&resv->lock);\n\t/* Locate the region we are either in or before. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/*\n\t * If no region exists which can be expanded to include the\n\t * specified range, the list must have been modified by an\n\t * interleving call to region_del().  Pull a region descriptor\n\t * from the cache and use it for this range.\n\t */\n\tif (&rg->link == head || t < rg->from) {\n\t\tVM_BUG_ON(resv->region_cache_count <= 0);\n\n\t\tresv->region_cache_count--;\n\t\tnrg = list_first_entry(&resv->region_cache, struct file_region,\n\t\t\t\t\tlink);\n\t\tlist_del(&nrg->link);\n\n\t\tnrg->from = f;\n\t\tnrg->to = t;\n\t\tlist_add(&nrg->link, rg->link.prev);\n\n\t\tadd += t - f;\n\t\tgoto out_locked;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tnrg = rg;\n\tlist_for_each_entry_safe(rg, trg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tbreak;\n\n\t\t/* If this area reaches higher then extend our area to\n\t\t * include it completely.  If this is not the first area\n\t\t * which we intend to reuse, free it. */\n\t\tif (rg->to > t)\n\t\t\tt = rg->to;\n\t\tif (rg != nrg) {\n\t\t\t/* Decrement return value by the deleted range.\n\t\t\t * Another range will span this area so that by\n\t\t\t * end of routine add will be >= zero\n\t\t\t */\n\t\t\tadd -= (rg->to - rg->from);\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t}\n\t}\n\n\tadd += (nrg->from - f);\t\t/* Added to beginning of region */\n\tnrg->from = f;\n\tadd += t - nrg->to;\t\t/* Added to end of region */\n\tnrg->to = t;\n\nout_locked:\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n\tVM_BUG_ON(add < 0);\n\treturn add;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "add < 0"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv->lock"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rg"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rg->link"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rg",
            "trg",
            "rg->link.prev",
            "link"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&nrg->link",
            "rg->link.prev"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&nrg->link"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&resv->region_cache",
            "structfile_region",
            "link"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "resv->region_cache_count <= 0"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "rg",
            "head",
            "link"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&resv->lock"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic long region_add(struct resv_map *resv, long f, long t)\n{\n\tstruct list_head *head = &resv->regions;\n\tstruct file_region *rg, *nrg, *trg;\n\tlong add = 0;\n\n\tspin_lock(&resv->lock);\n\t/* Locate the region we are either in or before. */\n\tlist_for_each_entry(rg, head, link)\n\t\tif (f <= rg->to)\n\t\t\tbreak;\n\n\t/*\n\t * If no region exists which can be expanded to include the\n\t * specified range, the list must have been modified by an\n\t * interleving call to region_del().  Pull a region descriptor\n\t * from the cache and use it for this range.\n\t */\n\tif (&rg->link == head || t < rg->from) {\n\t\tVM_BUG_ON(resv->region_cache_count <= 0);\n\n\t\tresv->region_cache_count--;\n\t\tnrg = list_first_entry(&resv->region_cache, struct file_region,\n\t\t\t\t\tlink);\n\t\tlist_del(&nrg->link);\n\n\t\tnrg->from = f;\n\t\tnrg->to = t;\n\t\tlist_add(&nrg->link, rg->link.prev);\n\n\t\tadd += t - f;\n\t\tgoto out_locked;\n\t}\n\n\t/* Round our left edge to the current segment if it encloses us. */\n\tif (f > rg->from)\n\t\tf = rg->from;\n\n\t/* Check for and consume any regions we now overlap with. */\n\tnrg = rg;\n\tlist_for_each_entry_safe(rg, trg, rg->link.prev, link) {\n\t\tif (&rg->link == head)\n\t\t\tbreak;\n\t\tif (rg->from > t)\n\t\t\tbreak;\n\n\t\t/* If this area reaches higher then extend our area to\n\t\t * include it completely.  If this is not the first area\n\t\t * which we intend to reuse, free it. */\n\t\tif (rg->to > t)\n\t\t\tt = rg->to;\n\t\tif (rg != nrg) {\n\t\t\t/* Decrement return value by the deleted range.\n\t\t\t * Another range will span this area so that by\n\t\t\t * end of routine add will be >= zero\n\t\t\t */\n\t\t\tadd -= (rg->to - rg->from);\n\t\t\tlist_del(&rg->link);\n\t\t\tkfree(rg);\n\t\t}\n\t}\n\n\tadd += (nrg->from - f);\t\t/* Added to beginning of region */\n\tnrg->from = f;\n\tadd += t - nrg->to;\t\t/* Added to end of region */\n\tnrg->to = t;\n\nout_locked:\n\tresv->adds_in_progress--;\n\tspin_unlock(&resv->lock);\n\tVM_BUG_ON(add < 0);\n\treturn add;\n}"
  },
  {
    "function_name": "subpool_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "215-218",
    "snippet": "static inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)\n{\n\treturn subpool_inode(file_inode(vma->vm_file));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "subpool_inode",
          "args": [
            "file_inode(vma->vm_file)"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "subpool_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "210-213",
          "snippet": "static inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n{\n\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n{\n\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)\n{\n\treturn subpool_inode(file_inode(vma->vm_file));\n}"
  },
  {
    "function_name": "subpool_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "210-213",
    "snippet": "static inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n{\n\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HUGETLBFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n{\n\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n}"
  },
  {
    "function_name": "hugepage_subpool_put_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "176-208",
    "snippet": "static long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int hugetlb_acct_memory(struct hstate *h, long delta);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_or_release_subpool",
          "args": [
            "spool"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_or_release_subpool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "74-89",
          "snippet": "static inline void unlock_or_release_subpool(struct hugepage_subpool *spool)\n{\n\tbool free = (spool->count == 0) && (spool->used_hpages == 0);\n\n\tspin_unlock(&spool->lock);\n\n\t/* If no pages are used, and no other handles to the subpool\n\t * remain, give up any reservations mased on minimum size and\n\t * free the subpool */\n\tif (free) {\n\t\tif (spool->min_hpages != -1)\n\t\t\thugetlb_acct_memory(spool->hstate,\n\t\t\t\t\t\t-spool->min_hpages);\n\t\tkfree(spool);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void unlock_or_release_subpool(struct hugepage_subpool *spool)\n{\n\tbool free = (spool->count == 0) && (spool->used_hpages == 0);\n\n\tspin_unlock(&spool->lock);\n\n\t/* If no pages are used, and no other handles to the subpool\n\t * remain, give up any reservations mased on minimum size and\n\t * free the subpool */\n\tif (free) {\n\t\tif (spool->min_hpages != -1)\n\t\t\thugetlb_acct_memory(spool->hstate,\n\t\t\t\t\t\t-spool->min_hpages);\n\t\tkfree(spool);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&spool->lock"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic long hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn delta;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1)\t\t/* maximum size accounting */\n\t\tspool->used_hpages -= delta;\n\n\t /* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {\n\t\tif (spool->rsv_hpages + delta <= spool->min_hpages)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = spool->rsv_hpages + delta - spool->min_hpages;\n\n\t\tspool->rsv_hpages += delta;\n\t\tif (spool->rsv_hpages > spool->min_hpages)\n\t\t\tspool->rsv_hpages = spool->min_hpages;\n\t}\n\n\t/*\n\t * If hugetlbfs_put_super couldn't free spool due to an outstanding\n\t * quota reference, free it now.\n\t */\n\tunlock_or_release_subpool(spool);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hugepage_subpool_get_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "131-168",
    "snippet": "static long hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n\t\t\t\t      long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn ret;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1) {\t\t/* maximum size accounting */\n\t\tif ((spool->used_hpages + delta) <= spool->max_hpages)\n\t\t\tspool->used_hpages += delta;\n\t\telse {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_ret;\n\t\t}\n\t}\n\n\t/* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->rsv_hpages) {\n\t\tif (delta > spool->rsv_hpages) {\n\t\t\t/*\n\t\t\t * Asking for more reserves than those already taken on\n\t\t\t * behalf of subpool.  Return difference.\n\t\t\t */\n\t\t\tret = delta - spool->rsv_hpages;\n\t\t\tspool->rsv_hpages = 0;\n\t\t} else {\n\t\t\tret = 0;\t/* reserves already accounted for */\n\t\t\tspool->rsv_hpages -= delta;\n\t\t}\n\t}\n\nunlock_ret:\n\tspin_unlock(&spool->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int hugetlb_acct_memory(struct hstate *h, long delta);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&spool->lock"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&spool->lock"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic long hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n\t\t\t\t      long delta)\n{\n\tlong ret = delta;\n\n\tif (!spool)\n\t\treturn ret;\n\n\tspin_lock(&spool->lock);\n\n\tif (spool->max_hpages != -1) {\t\t/* maximum size accounting */\n\t\tif ((spool->used_hpages + delta) <= spool->max_hpages)\n\t\t\tspool->used_hpages += delta;\n\t\telse {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_ret;\n\t\t}\n\t}\n\n\t/* minimum size accounting */\n\tif (spool->min_hpages != -1 && spool->rsv_hpages) {\n\t\tif (delta > spool->rsv_hpages) {\n\t\t\t/*\n\t\t\t * Asking for more reserves than those already taken on\n\t\t\t * behalf of subpool.  Return difference.\n\t\t\t */\n\t\t\tret = delta - spool->rsv_hpages;\n\t\t\tspool->rsv_hpages = 0;\n\t\t} else {\n\t\t\tret = 0;\t/* reserves already accounted for */\n\t\t\tspool->rsv_hpages -= delta;\n\t\t}\n\t}\n\nunlock_ret:\n\tspin_unlock(&spool->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "hugepage_put_subpool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "115-121",
    "snippet": "void hugepage_put_subpool(struct hugepage_subpool *spool)\n{\n\tspin_lock(&spool->lock);\n\tBUG_ON(!spool->count);\n\tspool->count--;\n\tunlock_or_release_subpool(spool);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_or_release_subpool",
          "args": [
            "spool"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_or_release_subpool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "74-89",
          "snippet": "static inline void unlock_or_release_subpool(struct hugepage_subpool *spool)\n{\n\tbool free = (spool->count == 0) && (spool->used_hpages == 0);\n\n\tspin_unlock(&spool->lock);\n\n\t/* If no pages are used, and no other handles to the subpool\n\t * remain, give up any reservations mased on minimum size and\n\t * free the subpool */\n\tif (free) {\n\t\tif (spool->min_hpages != -1)\n\t\t\thugetlb_acct_memory(spool->hstate,\n\t\t\t\t\t\t-spool->min_hpages);\n\t\tkfree(spool);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void unlock_or_release_subpool(struct hugepage_subpool *spool)\n{\n\tbool free = (spool->count == 0) && (spool->used_hpages == 0);\n\n\tspin_unlock(&spool->lock);\n\n\t/* If no pages are used, and no other handles to the subpool\n\t * remain, give up any reservations mased on minimum size and\n\t * free the subpool */\n\tif (free) {\n\t\tif (spool->min_hpages != -1)\n\t\t\thugetlb_acct_memory(spool->hstate,\n\t\t\t\t\t\t-spool->min_hpages);\n\t\tkfree(spool);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!spool->count"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&spool->lock"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid hugepage_put_subpool(struct hugepage_subpool *spool)\n{\n\tspin_lock(&spool->lock);\n\tBUG_ON(!spool->count);\n\tspool->count--;\n\tunlock_or_release_subpool(spool);\n}"
  },
  {
    "function_name": "hugepage_new_subpool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "91-113",
    "snippet": "struct hugepage_subpool *hugepage_new_subpool(struct hstate *h, long max_hpages,\n\t\t\t\t\t\tlong min_hpages)\n{\n\tstruct hugepage_subpool *spool;\n\n\tspool = kzalloc(sizeof(*spool), GFP_KERNEL);\n\tif (!spool)\n\t\treturn NULL;\n\n\tspin_lock_init(&spool->lock);\n\tspool->count = 1;\n\tspool->max_hpages = max_hpages;\n\tspool->hstate = h;\n\tspool->min_hpages = min_hpages;\n\n\tif (min_hpages != -1 && hugetlb_acct_memory(h, min_hpages)) {\n\t\tkfree(spool);\n\t\treturn NULL;\n\t}\n\tspool->rsv_hpages = min_hpages;\n\n\treturn spool;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "spool"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_acct_memory",
          "args": [
            "h",
            "min_hpages"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_acct_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3052-3091",
          "snippet": "static int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&spool->lock"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*spool)",
            "GFP_KERNEL"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct hugepage_subpool *hugepage_new_subpool(struct hstate *h, long max_hpages,\n\t\t\t\t\t\tlong min_hpages)\n{\n\tstruct hugepage_subpool *spool;\n\n\tspool = kzalloc(sizeof(*spool), GFP_KERNEL);\n\tif (!spool)\n\t\treturn NULL;\n\n\tspin_lock_init(&spool->lock);\n\tspool->count = 1;\n\tspool->max_hpages = max_hpages;\n\tspool->hstate = h;\n\tspool->min_hpages = min_hpages;\n\n\tif (min_hpages != -1 && hugetlb_acct_memory(h, min_hpages)) {\n\t\tkfree(spool);\n\t\treturn NULL;\n\t}\n\tspool->rsv_hpages = min_hpages;\n\n\treturn spool;\n}"
  },
  {
    "function_name": "unlock_or_release_subpool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
    "lines": "74-89",
    "snippet": "static inline void unlock_or_release_subpool(struct hugepage_subpool *spool)\n{\n\tbool free = (spool->count == 0) && (spool->used_hpages == 0);\n\n\tspin_unlock(&spool->lock);\n\n\t/* If no pages are used, and no other handles to the subpool\n\t * remain, give up any reservations mased on minimum size and\n\t * free the subpool */\n\tif (free) {\n\t\tif (spool->min_hpages != -1)\n\t\t\thugetlb_acct_memory(spool->hstate,\n\t\t\t\t\t\t-spool->min_hpages);\n\t\tkfree(spool);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/page_owner.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/node.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/io.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/jhash.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/rmap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/compiler.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "spool"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_acct_memory",
          "args": [
            "spool->hstate",
            "-spool->min_hpages"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_acct_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3052-3091",
          "snippet": "static int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hugetlb_acct_memory(struct hstate *h, long delta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta);\n\nstatic int hugetlb_acct_memory(struct hstate *h, long delta)\n{\n\tint ret = -ENOMEM;\n\n\tspin_lock(&hugetlb_lock);\n\t/*\n\t * When cpuset is configured, it breaks the strict hugetlb page\n\t * reservation as the accounting is done on a global variable. Such\n\t * reservation is completely rubbish in the presence of cpuset because\n\t * the reservation is not checked against page availability for the\n\t * current cpuset. Application can still potentially OOM'ed by kernel\n\t * with lack of free htlb page in cpuset that the task is in.\n\t * Attempt to enforce strict accounting with cpuset is almost\n\t * impossible (or too ugly) because cpuset is too fluid that\n\t * task or memory node can be dynamically moved between cpusets.\n\t *\n\t * The change of semantics for shared hugetlb mapping with cpuset is\n\t * undesirable. However, in order to preserve some of the semantics,\n\t * we fall back to check against current free page availability as\n\t * a best attempt and hopefully to minimize the impact of changing\n\t * semantics that cpuset has.\n\t */\n\tif (delta > 0) {\n\t\tif (gather_surplus_pages(h, delta) < 0)\n\t\t\tgoto out;\n\n\t\tif (delta > cpuset_mems_nr(h->free_huge_pages_node)) {\n\t\t\treturn_unused_surplus_pages(h, delta);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (delta < 0)\n\t\treturn_unused_surplus_pages(h, (unsigned long) -delta);\n\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&spool->lock"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic inline void unlock_or_release_subpool(struct hugepage_subpool *spool)\n{\n\tbool free = (spool->count == 0) && (spool->used_hpages == 0);\n\n\tspin_unlock(&spool->lock);\n\n\t/* If no pages are used, and no other handles to the subpool\n\t * remain, give up any reservations mased on minimum size and\n\t * free the subpool */\n\tif (free) {\n\t\tif (spool->min_hpages != -1)\n\t\t\thugetlb_acct_memory(spool->hstate,\n\t\t\t\t\t\t-spool->min_hpages);\n\t\tkfree(spool);\n\t}\n}"
  }
]