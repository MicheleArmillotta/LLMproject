[
  {
    "function_name": "percpu_enable_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "2785-2789",
    "snippet": "static int __init percpu_enable_async(void)\n{\n\tpcpu_async_enabled = true;\n\treturn 0;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool pcpu_async_enabled"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic bool pcpu_async_enabled;\n\nstatic int __init percpu_enable_async(void)\n{\n\tpcpu_async_enabled = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "pcpu_nr_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "2775-2778",
    "snippet": "unsigned long pcpu_nr_pages(void)\n{\n\treturn pcpu_nr_populated * pcpu_nr_units;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pcpu_nr_units",
      "static unsigned long pcpu_nr_populated;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_nr_units;\nstatic unsigned long pcpu_nr_populated;\n\nunsigned long pcpu_nr_pages(void)\n{\n\treturn pcpu_nr_populated * pcpu_nr_units;\n}"
  },
  {
    "function_name": "setup_per_cpu_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "2733-2760",
    "snippet": "void __init setup_per_cpu_areas(void)\n{\n\tconst size_t unit_size =\n\t\troundup_pow_of_two(max_t(size_t, PCPU_MIN_UNIT_SIZE,\n\t\t\t\t\t PERCPU_DYNAMIC_RESERVE));\n\tstruct pcpu_alloc_info *ai;\n\tvoid *fc;\n\n\tai = pcpu_alloc_alloc_info(1, 1);\n\tfc = memblock_alloc_from_nopanic(unit_size,\n\t\t\t\t\t      PAGE_SIZE,\n\t\t\t\t\t      __pa(MAX_DMA_ADDRESS));\n\tif (!ai || !fc)\n\t\tpanic(\"Failed to allocate memory for percpu areas.\");\n\t/* kmemleak tracks the percpu allocations separately */\n\tkmemleak_free(fc);\n\n\tai->dyn_size = unit_size;\n\tai->unit_size = unit_size;\n\tai->atom_size = unit_size;\n\tai->alloc_size = unit_size;\n\tai->groups[0].nr_units = 1;\n\tai->groups[0].cpu_map[0] = 0;\n\n\tif (pcpu_setup_first_chunk(ai, fc) < 0)\n\t\tpanic(\"Failed to initialize percpu areas.\");\n\tpcpu_free_alloc_info(ai);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_free_alloc_info",
          "args": [
            "ai"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_free_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1914-1917",
          "snippet": "void __init pcpu_free_alloc_info(struct pcpu_alloc_info *ai)\n{\n\tmemblock_free_early(__pa(ai), ai->__ai_size);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nvoid __init pcpu_free_alloc_info(struct pcpu_alloc_info *ai)\n{\n\tmemblock_free_early(__pa(ai), ai->__ai_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Failed to initialize percpu areas.\""
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_setup_first_chunk",
          "args": [
            "ai",
            "fc"
          ],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_setup_first_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "2033-2201",
          "snippet": "int __init pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai,\n\t\t\t\t  void *base_addr)\n{\n\tsize_t size_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tsize_t static_size, dyn_size;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long *group_offsets;\n\tsize_t *group_sizes;\n\tunsigned long *unit_off;\n\tunsigned int cpu;\n\tint *unit_map;\n\tint group, unit, i;\n\tint map_size;\n\tunsigned long tmp_addr;\n\n#define PCPU_SETUP_BUG_ON(cond)\tdo {\t\t\t\t\t\\\n\tif (unlikely(cond)) {\t\t\t\t\t\t\\\n\t\tpr_emerg(\"failed to initialize, %s\\n\", #cond);\t\t\\\n\t\tpr_emerg(\"cpu_possible_mask=%*pb\\n\",\t\t\t\\\n\t\t\t cpumask_pr_args(cpu_possible_mask));\t\t\\\n\t\tpcpu_dump_alloc_info(KERN_EMERG, ai);\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\t/* sanity checks */\n\tPCPU_SETUP_BUG_ON(ai->nr_groups <= 0);\n#ifdef CONFIG_SMP\n\tPCPU_SETUP_BUG_ON(!ai->static_size);\n\tPCPU_SETUP_BUG_ON(offset_in_page(__per_cpu_start));\n#endif\n\tPCPU_SETUP_BUG_ON(!base_addr);\n\tPCPU_SETUP_BUG_ON(offset_in_page(base_addr));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < size_sum);\n\tPCPU_SETUP_BUG_ON(offset_in_page(ai->unit_size));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < PCPU_MIN_UNIT_SIZE);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->unit_size, PCPU_BITMAP_BLOCK_SIZE));\n\tPCPU_SETUP_BUG_ON(ai->dyn_size < PERCPU_DYNAMIC_EARLY_SIZE);\n\tPCPU_SETUP_BUG_ON(!ai->dyn_size);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->reserved_size, PCPU_MIN_ALLOC_SIZE));\n\tPCPU_SETUP_BUG_ON(!(IS_ALIGNED(PCPU_BITMAP_BLOCK_SIZE, PAGE_SIZE) ||\n\t\t\t    IS_ALIGNED(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE)));\n\tPCPU_SETUP_BUG_ON(pcpu_verify_alloc_info(ai) < 0);\n\n\t/* process group information and build config tables accordingly */\n\tgroup_offsets = memblock_alloc(ai->nr_groups * sizeof(group_offsets[0]),\n\t\t\t\t       SMP_CACHE_BYTES);\n\tgroup_sizes = memblock_alloc(ai->nr_groups * sizeof(group_sizes[0]),\n\t\t\t\t     SMP_CACHE_BYTES);\n\tunit_map = memblock_alloc(nr_cpu_ids * sizeof(unit_map[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\tunit_off = memblock_alloc(nr_cpu_ids * sizeof(unit_off[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tunit_map[cpu] = UINT_MAX;\n\n\tpcpu_low_unit_cpu = NR_CPUS;\n\tpcpu_high_unit_cpu = NR_CPUS;\n\n\tfor (group = 0, unit = 0; group < ai->nr_groups; group++, unit += i) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\n\t\tgroup_offsets[group] = gi->base_offset;\n\t\tgroup_sizes[group] = gi->nr_units * ai->unit_size;\n\n\t\tfor (i = 0; i < gi->nr_units; i++) {\n\t\t\tcpu = gi->cpu_map[i];\n\t\t\tif (cpu == NR_CPUS)\n\t\t\t\tcontinue;\n\n\t\t\tPCPU_SETUP_BUG_ON(cpu >= nr_cpu_ids);\n\t\t\tPCPU_SETUP_BUG_ON(!cpu_possible(cpu));\n\t\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] != UINT_MAX);\n\n\t\t\tunit_map[cpu] = unit + i;\n\t\t\tunit_off[cpu] = gi->base_offset + i * ai->unit_size;\n\n\t\t\t/* determine low/high unit_cpu */\n\t\t\tif (pcpu_low_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] < unit_off[pcpu_low_unit_cpu])\n\t\t\t\tpcpu_low_unit_cpu = cpu;\n\t\t\tif (pcpu_high_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] > unit_off[pcpu_high_unit_cpu])\n\t\t\t\tpcpu_high_unit_cpu = cpu;\n\t\t}\n\t}\n\tpcpu_nr_units = unit;\n\n\tfor_each_possible_cpu(cpu)\n\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] == UINT_MAX);\n\n\t/* we're done parsing the input, undefine BUG macro and dump config */\n#undef PCPU_SETUP_BUG_ON\n\tpcpu_dump_alloc_info(KERN_DEBUG, ai);\n\n\tpcpu_nr_groups = ai->nr_groups;\n\tpcpu_group_offsets = group_offsets;\n\tpcpu_group_sizes = group_sizes;\n\tpcpu_unit_map = unit_map;\n\tpcpu_unit_offsets = unit_off;\n\n\t/* determine basic parameters */\n\tpcpu_unit_pages = ai->unit_size >> PAGE_SHIFT;\n\tpcpu_unit_size = pcpu_unit_pages << PAGE_SHIFT;\n\tpcpu_atom_size = ai->atom_size;\n\tpcpu_chunk_struct_size = sizeof(struct pcpu_chunk) +\n\t\tBITS_TO_LONGS(pcpu_unit_pages) * sizeof(unsigned long);\n\n\tpcpu_stats_save_ai(ai);\n\n\t/*\n\t * Allocate chunk slots.  The additional last slot is for\n\t * empty chunks.\n\t */\n\tpcpu_nr_slots = __pcpu_size_to_slot(pcpu_unit_size) + 2;\n\tpcpu_slot = memblock_alloc(pcpu_nr_slots * sizeof(pcpu_slot[0]),\n\t\t\t\t   SMP_CACHE_BYTES);\n\tfor (i = 0; i < pcpu_nr_slots; i++)\n\t\tINIT_LIST_HEAD(&pcpu_slot[i]);\n\n\t/*\n\t * The end of the static region needs to be aligned with the\n\t * minimum allocation size as this offsets the reserved and\n\t * dynamic region.  The first chunk ends page aligned by\n\t * expanding the dynamic region, therefore the dynamic region\n\t * can be shrunk to compensate while still staying above the\n\t * configured sizes.\n\t */\n\tstatic_size = ALIGN(ai->static_size, PCPU_MIN_ALLOC_SIZE);\n\tdyn_size = ai->dyn_size - (static_size - ai->static_size);\n\n\t/*\n\t * Initialize first chunk.\n\t * If the reserved_size is non-zero, this initializes the reserved\n\t * chunk.  If the reserved_size is zero, the reserved chunk is NULL\n\t * and the dynamic region is initialized here.  The first chunk,\n\t * pcpu_first_chunk, will always point to the chunk that serves\n\t * the dynamic region.\n\t */\n\ttmp_addr = (unsigned long)base_addr + static_size;\n\tmap_size = ai->reserved_size ?: dyn_size;\n\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\n\t/* init dynamic chunk if necessary */\n\tif (ai->reserved_size) {\n\t\tpcpu_reserved_chunk = chunk;\n\n\t\ttmp_addr = (unsigned long)base_addr + static_size +\n\t\t\t   ai->reserved_size;\n\t\tmap_size = dyn_size;\n\t\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\t}\n\n\t/* link the first chunk in */\n\tpcpu_first_chunk = chunk;\n\tpcpu_nr_empty_pop_pages = pcpu_first_chunk->nr_empty_pop_pages;\n\tpcpu_chunk_relocate(pcpu_first_chunk, -1);\n\n\t/* include all regions of the first chunk */\n\tpcpu_nr_populated += PFN_DOWN(size_sum);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(base_addr);\n\n\t/* we're done */\n\tpcpu_base_addr = base_addr;\n\treturn 0;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_pages",
            "static int pcpu_unit_size",
            "static int pcpu_nr_units",
            "static int pcpu_atom_size",
            "int pcpu_nr_slots",
            "static size_t pcpu_chunk_struct_size",
            "static unsigned int pcpu_low_unit_cpu",
            "static unsigned int pcpu_high_unit_cpu",
            "void *pcpu_base_addr",
            "static const int *pcpu_unit_map",
            "const unsigned long *pcpu_unit_offsets",
            "static int pcpu_nr_groups",
            "static const unsigned long *pcpu_group_offsets",
            "static const size_t *pcpu_group_sizes",
            "struct pcpu_chunk *pcpu_first_chunk",
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "int pcpu_nr_empty_pop_pages;",
            "static unsigned long pcpu_nr_populated;",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic int pcpu_unit_size;\nstatic int pcpu_nr_units;\nstatic int pcpu_atom_size;\nint pcpu_nr_slots;\nstatic size_t pcpu_chunk_struct_size;\nstatic unsigned int pcpu_low_unit_cpu;\nstatic unsigned int pcpu_high_unit_cpu;\nvoid *pcpu_base_addr;\nstatic const int *pcpu_unit_map;\nconst unsigned long *pcpu_unit_offsets;\nstatic int pcpu_nr_groups;\nstatic const unsigned long *pcpu_group_offsets;\nstatic const size_t *pcpu_group_sizes;\nstruct pcpu_chunk *pcpu_first_chunk;\nstruct pcpu_chunk *pcpu_reserved_chunk;\nint pcpu_nr_empty_pop_pages;\nstatic unsigned long pcpu_nr_populated;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nint __init pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai,\n\t\t\t\t  void *base_addr)\n{\n\tsize_t size_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tsize_t static_size, dyn_size;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long *group_offsets;\n\tsize_t *group_sizes;\n\tunsigned long *unit_off;\n\tunsigned int cpu;\n\tint *unit_map;\n\tint group, unit, i;\n\tint map_size;\n\tunsigned long tmp_addr;\n\n#define PCPU_SETUP_BUG_ON(cond)\tdo {\t\t\t\t\t\\\n\tif (unlikely(cond)) {\t\t\t\t\t\t\\\n\t\tpr_emerg(\"failed to initialize, %s\\n\", #cond);\t\t\\\n\t\tpr_emerg(\"cpu_possible_mask=%*pb\\n\",\t\t\t\\\n\t\t\t cpumask_pr_args(cpu_possible_mask));\t\t\\\n\t\tpcpu_dump_alloc_info(KERN_EMERG, ai);\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\t/* sanity checks */\n\tPCPU_SETUP_BUG_ON(ai->nr_groups <= 0);\n#ifdef CONFIG_SMP\n\tPCPU_SETUP_BUG_ON(!ai->static_size);\n\tPCPU_SETUP_BUG_ON(offset_in_page(__per_cpu_start));\n#endif\n\tPCPU_SETUP_BUG_ON(!base_addr);\n\tPCPU_SETUP_BUG_ON(offset_in_page(base_addr));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < size_sum);\n\tPCPU_SETUP_BUG_ON(offset_in_page(ai->unit_size));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < PCPU_MIN_UNIT_SIZE);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->unit_size, PCPU_BITMAP_BLOCK_SIZE));\n\tPCPU_SETUP_BUG_ON(ai->dyn_size < PERCPU_DYNAMIC_EARLY_SIZE);\n\tPCPU_SETUP_BUG_ON(!ai->dyn_size);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->reserved_size, PCPU_MIN_ALLOC_SIZE));\n\tPCPU_SETUP_BUG_ON(!(IS_ALIGNED(PCPU_BITMAP_BLOCK_SIZE, PAGE_SIZE) ||\n\t\t\t    IS_ALIGNED(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE)));\n\tPCPU_SETUP_BUG_ON(pcpu_verify_alloc_info(ai) < 0);\n\n\t/* process group information and build config tables accordingly */\n\tgroup_offsets = memblock_alloc(ai->nr_groups * sizeof(group_offsets[0]),\n\t\t\t\t       SMP_CACHE_BYTES);\n\tgroup_sizes = memblock_alloc(ai->nr_groups * sizeof(group_sizes[0]),\n\t\t\t\t     SMP_CACHE_BYTES);\n\tunit_map = memblock_alloc(nr_cpu_ids * sizeof(unit_map[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\tunit_off = memblock_alloc(nr_cpu_ids * sizeof(unit_off[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tunit_map[cpu] = UINT_MAX;\n\n\tpcpu_low_unit_cpu = NR_CPUS;\n\tpcpu_high_unit_cpu = NR_CPUS;\n\n\tfor (group = 0, unit = 0; group < ai->nr_groups; group++, unit += i) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\n\t\tgroup_offsets[group] = gi->base_offset;\n\t\tgroup_sizes[group] = gi->nr_units * ai->unit_size;\n\n\t\tfor (i = 0; i < gi->nr_units; i++) {\n\t\t\tcpu = gi->cpu_map[i];\n\t\t\tif (cpu == NR_CPUS)\n\t\t\t\tcontinue;\n\n\t\t\tPCPU_SETUP_BUG_ON(cpu >= nr_cpu_ids);\n\t\t\tPCPU_SETUP_BUG_ON(!cpu_possible(cpu));\n\t\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] != UINT_MAX);\n\n\t\t\tunit_map[cpu] = unit + i;\n\t\t\tunit_off[cpu] = gi->base_offset + i * ai->unit_size;\n\n\t\t\t/* determine low/high unit_cpu */\n\t\t\tif (pcpu_low_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] < unit_off[pcpu_low_unit_cpu])\n\t\t\t\tpcpu_low_unit_cpu = cpu;\n\t\t\tif (pcpu_high_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] > unit_off[pcpu_high_unit_cpu])\n\t\t\t\tpcpu_high_unit_cpu = cpu;\n\t\t}\n\t}\n\tpcpu_nr_units = unit;\n\n\tfor_each_possible_cpu(cpu)\n\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] == UINT_MAX);\n\n\t/* we're done parsing the input, undefine BUG macro and dump config */\n#undef PCPU_SETUP_BUG_ON\n\tpcpu_dump_alloc_info(KERN_DEBUG, ai);\n\n\tpcpu_nr_groups = ai->nr_groups;\n\tpcpu_group_offsets = group_offsets;\n\tpcpu_group_sizes = group_sizes;\n\tpcpu_unit_map = unit_map;\n\tpcpu_unit_offsets = unit_off;\n\n\t/* determine basic parameters */\n\tpcpu_unit_pages = ai->unit_size >> PAGE_SHIFT;\n\tpcpu_unit_size = pcpu_unit_pages << PAGE_SHIFT;\n\tpcpu_atom_size = ai->atom_size;\n\tpcpu_chunk_struct_size = sizeof(struct pcpu_chunk) +\n\t\tBITS_TO_LONGS(pcpu_unit_pages) * sizeof(unsigned long);\n\n\tpcpu_stats_save_ai(ai);\n\n\t/*\n\t * Allocate chunk slots.  The additional last slot is for\n\t * empty chunks.\n\t */\n\tpcpu_nr_slots = __pcpu_size_to_slot(pcpu_unit_size) + 2;\n\tpcpu_slot = memblock_alloc(pcpu_nr_slots * sizeof(pcpu_slot[0]),\n\t\t\t\t   SMP_CACHE_BYTES);\n\tfor (i = 0; i < pcpu_nr_slots; i++)\n\t\tINIT_LIST_HEAD(&pcpu_slot[i]);\n\n\t/*\n\t * The end of the static region needs to be aligned with the\n\t * minimum allocation size as this offsets the reserved and\n\t * dynamic region.  The first chunk ends page aligned by\n\t * expanding the dynamic region, therefore the dynamic region\n\t * can be shrunk to compensate while still staying above the\n\t * configured sizes.\n\t */\n\tstatic_size = ALIGN(ai->static_size, PCPU_MIN_ALLOC_SIZE);\n\tdyn_size = ai->dyn_size - (static_size - ai->static_size);\n\n\t/*\n\t * Initialize first chunk.\n\t * If the reserved_size is non-zero, this initializes the reserved\n\t * chunk.  If the reserved_size is zero, the reserved chunk is NULL\n\t * and the dynamic region is initialized here.  The first chunk,\n\t * pcpu_first_chunk, will always point to the chunk that serves\n\t * the dynamic region.\n\t */\n\ttmp_addr = (unsigned long)base_addr + static_size;\n\tmap_size = ai->reserved_size ?: dyn_size;\n\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\n\t/* init dynamic chunk if necessary */\n\tif (ai->reserved_size) {\n\t\tpcpu_reserved_chunk = chunk;\n\n\t\ttmp_addr = (unsigned long)base_addr + static_size +\n\t\t\t   ai->reserved_size;\n\t\tmap_size = dyn_size;\n\t\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\t}\n\n\t/* link the first chunk in */\n\tpcpu_first_chunk = chunk;\n\tpcpu_nr_empty_pop_pages = pcpu_first_chunk->nr_empty_pop_pages;\n\tpcpu_chunk_relocate(pcpu_first_chunk, -1);\n\n\t/* include all regions of the first chunk */\n\tpcpu_nr_populated += PFN_DOWN(size_sum);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(base_addr);\n\n\t/* we're done */\n\tpcpu_base_addr = base_addr;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_free",
          "args": [
            "fc"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1082-1094",
          "snippet": "void __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_free_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Failed to allocate memory for percpu areas.\""
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_from_nopanic",
          "args": [
            "unit_size",
            "PAGE_SIZE",
            "__pa(MAX_DMA_ADDRESS)"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "MAX_DMA_ADDRESS"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_alloc_alloc_info",
          "args": [
            "1",
            "1"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_alloc_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1879-1906",
          "snippet": "struct pcpu_alloc_info * __init pcpu_alloc_alloc_info(int nr_groups,\n\t\t\t\t\t\t      int nr_units)\n{\n\tstruct pcpu_alloc_info *ai;\n\tsize_t base_size, ai_size;\n\tvoid *ptr;\n\tint unit;\n\n\tbase_size = ALIGN(sizeof(*ai) + nr_groups * sizeof(ai->groups[0]),\n\t\t\t  __alignof__(ai->groups[0].cpu_map[0]));\n\tai_size = base_size + nr_units * sizeof(ai->groups[0].cpu_map[0]);\n\n\tptr = memblock_alloc_nopanic(PFN_ALIGN(ai_size), PAGE_SIZE);\n\tif (!ptr)\n\t\treturn NULL;\n\tai = ptr;\n\tptr += base_size;\n\n\tai->groups[0].cpu_map = ptr;\n\n\tfor (unit = 0; unit < nr_units; unit++)\n\t\tai->groups[0].cpu_map[unit] = NR_CPUS;\n\n\tai->nr_groups = nr_groups;\n\tai->__ai_size = PFN_ALIGN(ai_size);\n\n\treturn ai;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nstruct pcpu_alloc_info * __init pcpu_alloc_alloc_info(int nr_groups,\n\t\t\t\t\t\t      int nr_units)\n{\n\tstruct pcpu_alloc_info *ai;\n\tsize_t base_size, ai_size;\n\tvoid *ptr;\n\tint unit;\n\n\tbase_size = ALIGN(sizeof(*ai) + nr_groups * sizeof(ai->groups[0]),\n\t\t\t  __alignof__(ai->groups[0].cpu_map[0]));\n\tai_size = base_size + nr_units * sizeof(ai->groups[0].cpu_map[0]);\n\n\tptr = memblock_alloc_nopanic(PFN_ALIGN(ai_size), PAGE_SIZE);\n\tif (!ptr)\n\t\treturn NULL;\n\tai = ptr;\n\tptr += base_size;\n\n\tai->groups[0].cpu_map = ptr;\n\n\tfor (unit = 0; unit < nr_units; unit++)\n\t\tai->groups[0].cpu_map[unit] = NR_CPUS;\n\n\tai->nr_groups = nr_groups;\n\tai->__ai_size = PFN_ALIGN(ai_size);\n\n\treturn ai;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "max_t(size_t, PCPU_MIN_UNIT_SIZE,\n\t\t\t\t\t PERCPU_DYNAMIC_RESERVE)"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "PCPU_MIN_UNIT_SIZE",
            "PERCPU_DYNAMIC_RESERVE"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nvoid __init setup_per_cpu_areas(void)\n{\n\tconst size_t unit_size =\n\t\troundup_pow_of_two(max_t(size_t, PCPU_MIN_UNIT_SIZE,\n\t\t\t\t\t PERCPU_DYNAMIC_RESERVE));\n\tstruct pcpu_alloc_info *ai;\n\tvoid *fc;\n\n\tai = pcpu_alloc_alloc_info(1, 1);\n\tfc = memblock_alloc_from_nopanic(unit_size,\n\t\t\t\t\t      PAGE_SIZE,\n\t\t\t\t\t      __pa(MAX_DMA_ADDRESS));\n\tif (!ai || !fc)\n\t\tpanic(\"Failed to allocate memory for percpu areas.\");\n\t/* kmemleak tracks the percpu allocations separately */\n\tkmemleak_free(fc);\n\n\tai->dyn_size = unit_size;\n\tai->unit_size = unit_size;\n\tai->atom_size = unit_size;\n\tai->alloc_size = unit_size;\n\tai->groups[0].nr_units = 1;\n\tai->groups[0].cpu_map[0] = 0;\n\n\tif (pcpu_setup_first_chunk(ai, fc) < 0)\n\t\tpanic(\"Failed to initialize percpu areas.\");\n\tpcpu_free_alloc_info(ai);\n}"
  },
  {
    "function_name": "setup_per_cpu_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "2702-2721",
    "snippet": "void __init setup_per_cpu_areas(void)\n{\n\tunsigned long delta;\n\tunsigned int cpu;\n\tint rc;\n\n\t/*\n\t * Always reserve area for module percpu variables.  That's\n\t * what the legacy allocator did.\n\t */\n\trc = pcpu_embed_first_chunk(PERCPU_MODULE_RESERVE,\n\t\t\t\t    PERCPU_DYNAMIC_RESERVE, PAGE_SIZE, NULL,\n\t\t\t\t    pcpu_dfl_fc_alloc, pcpu_dfl_fc_free);\n\tif (rc < 0)\n\t\tpanic(\"Failed to initialize percpu areas.\");\n\n\tdelta = (unsigned long)pcpu_base_addr - (unsigned long)__per_cpu_start;\n\tfor_each_possible_cpu(cpu)\n\t\t__per_cpu_offset[cpu] = delta + pcpu_unit_offsets[cpu];\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *pcpu_base_addr",
      "const unsigned long *pcpu_unit_offsets"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Failed to initialize percpu areas.\""
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_embed_first_chunk",
          "args": [
            "PERCPU_MODULE_RESERVE",
            "PERCPU_DYNAMIC_RESERVE",
            "PAGE_SIZE",
            "NULL",
            "pcpu_dfl_fc_alloc",
            "pcpu_dfl_fc_free"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_embed_first_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "2442-2551",
          "snippet": "int __init pcpu_embed_first_chunk(size_t reserved_size, size_t dyn_size,\n\t\t\t\t  size_t atom_size,\n\t\t\t\t  pcpu_fc_cpu_distance_fn_t cpu_distance_fn,\n\t\t\t\t  pcpu_fc_alloc_fn_t alloc_fn,\n\t\t\t\t  pcpu_fc_free_fn_t free_fn)\n{\n\tvoid *base = (void *)ULONG_MAX;\n\tvoid **areas = NULL;\n\tstruct pcpu_alloc_info *ai;\n\tsize_t size_sum, areas_size;\n\tunsigned long max_distance;\n\tint group, i, highest_group, rc;\n\n\tai = pcpu_build_alloc_info(reserved_size, dyn_size, atom_size,\n\t\t\t\t   cpu_distance_fn);\n\tif (IS_ERR(ai))\n\t\treturn PTR_ERR(ai);\n\n\tsize_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tareas_size = PFN_ALIGN(ai->nr_groups * sizeof(void *));\n\n\tareas = memblock_alloc_nopanic(areas_size, SMP_CACHE_BYTES);\n\tif (!areas) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* allocate, copy and determine base address & max_distance */\n\thighest_group = 0;\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\t\tunsigned int cpu = NR_CPUS;\n\t\tvoid *ptr;\n\n\t\tfor (i = 0; i < gi->nr_units && cpu == NR_CPUS; i++)\n\t\t\tcpu = gi->cpu_map[i];\n\t\tBUG_ON(cpu == NR_CPUS);\n\n\t\t/* allocate space for the whole group */\n\t\tptr = alloc_fn(cpu, gi->nr_units * ai->unit_size, atom_size);\n\t\tif (!ptr) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_free_areas;\n\t\t}\n\t\t/* kmemleak tracks the percpu allocations separately */\n\t\tkmemleak_free(ptr);\n\t\tareas[group] = ptr;\n\n\t\tbase = min(ptr, base);\n\t\tif (ptr > areas[highest_group])\n\t\t\thighest_group = group;\n\t}\n\tmax_distance = areas[highest_group] - base;\n\tmax_distance += ai->unit_size * ai->groups[highest_group].nr_units;\n\n\t/* warn if maximum distance is further than 75% of vmalloc space */\n\tif (max_distance > VMALLOC_TOTAL * 3 / 4) {\n\t\tpr_warn(\"max_distance=0x%lx too large for vmalloc space 0x%lx\\n\",\n\t\t\t\tmax_distance, VMALLOC_TOTAL);\n#ifdef CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK\n\t\t/* and fail if we have fallback */\n\t\trc = -EINVAL;\n\t\tgoto out_free_areas;\n#endif\n\t}\n\n\t/*\n\t * Copy data and free unused parts.  This should happen after all\n\t * allocations are complete; otherwise, we may end up with\n\t * overlapping groups.\n\t */\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\t\tvoid *ptr = areas[group];\n\n\t\tfor (i = 0; i < gi->nr_units; i++, ptr += ai->unit_size) {\n\t\t\tif (gi->cpu_map[i] == NR_CPUS) {\n\t\t\t\t/* unused unit, free whole */\n\t\t\t\tfree_fn(ptr, ai->unit_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* copy and return the unused part */\n\t\t\tmemcpy(ptr, __per_cpu_load, ai->static_size);\n\t\t\tfree_fn(ptr + size_sum, ai->unit_size - size_sum);\n\t\t}\n\t}\n\n\t/* base address is now known, determine group base offsets */\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tai->groups[group].base_offset = areas[group] - base;\n\t}\n\n\tpr_info(\"Embedded %zu pages/cpu @%p s%zu r%zu d%zu u%zu\\n\",\n\t\tPFN_DOWN(size_sum), base, ai->static_size, ai->reserved_size,\n\t\tai->dyn_size, ai->unit_size);\n\n\trc = pcpu_setup_first_chunk(ai, base);\n\tgoto out_free;\n\nout_free_areas:\n\tfor (group = 0; group < ai->nr_groups; group++)\n\t\tif (areas[group])\n\t\t\tfree_fn(areas[group],\n\t\t\t\tai->groups[group].nr_units * ai->unit_size);\nout_free:\n\tpcpu_free_alloc_info(ai);\n\tif (areas)\n\t\tmemblock_free_early(__pa(areas), areas_size);\n\treturn rc;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nint __init pcpu_embed_first_chunk(size_t reserved_size, size_t dyn_size,\n\t\t\t\t  size_t atom_size,\n\t\t\t\t  pcpu_fc_cpu_distance_fn_t cpu_distance_fn,\n\t\t\t\t  pcpu_fc_alloc_fn_t alloc_fn,\n\t\t\t\t  pcpu_fc_free_fn_t free_fn)\n{\n\tvoid *base = (void *)ULONG_MAX;\n\tvoid **areas = NULL;\n\tstruct pcpu_alloc_info *ai;\n\tsize_t size_sum, areas_size;\n\tunsigned long max_distance;\n\tint group, i, highest_group, rc;\n\n\tai = pcpu_build_alloc_info(reserved_size, dyn_size, atom_size,\n\t\t\t\t   cpu_distance_fn);\n\tif (IS_ERR(ai))\n\t\treturn PTR_ERR(ai);\n\n\tsize_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tareas_size = PFN_ALIGN(ai->nr_groups * sizeof(void *));\n\n\tareas = memblock_alloc_nopanic(areas_size, SMP_CACHE_BYTES);\n\tif (!areas) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* allocate, copy and determine base address & max_distance */\n\thighest_group = 0;\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\t\tunsigned int cpu = NR_CPUS;\n\t\tvoid *ptr;\n\n\t\tfor (i = 0; i < gi->nr_units && cpu == NR_CPUS; i++)\n\t\t\tcpu = gi->cpu_map[i];\n\t\tBUG_ON(cpu == NR_CPUS);\n\n\t\t/* allocate space for the whole group */\n\t\tptr = alloc_fn(cpu, gi->nr_units * ai->unit_size, atom_size);\n\t\tif (!ptr) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_free_areas;\n\t\t}\n\t\t/* kmemleak tracks the percpu allocations separately */\n\t\tkmemleak_free(ptr);\n\t\tareas[group] = ptr;\n\n\t\tbase = min(ptr, base);\n\t\tif (ptr > areas[highest_group])\n\t\t\thighest_group = group;\n\t}\n\tmax_distance = areas[highest_group] - base;\n\tmax_distance += ai->unit_size * ai->groups[highest_group].nr_units;\n\n\t/* warn if maximum distance is further than 75% of vmalloc space */\n\tif (max_distance > VMALLOC_TOTAL * 3 / 4) {\n\t\tpr_warn(\"max_distance=0x%lx too large for vmalloc space 0x%lx\\n\",\n\t\t\t\tmax_distance, VMALLOC_TOTAL);\n#ifdef CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK\n\t\t/* and fail if we have fallback */\n\t\trc = -EINVAL;\n\t\tgoto out_free_areas;\n#endif\n\t}\n\n\t/*\n\t * Copy data and free unused parts.  This should happen after all\n\t * allocations are complete; otherwise, we may end up with\n\t * overlapping groups.\n\t */\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\t\tvoid *ptr = areas[group];\n\n\t\tfor (i = 0; i < gi->nr_units; i++, ptr += ai->unit_size) {\n\t\t\tif (gi->cpu_map[i] == NR_CPUS) {\n\t\t\t\t/* unused unit, free whole */\n\t\t\t\tfree_fn(ptr, ai->unit_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* copy and return the unused part */\n\t\t\tmemcpy(ptr, __per_cpu_load, ai->static_size);\n\t\t\tfree_fn(ptr + size_sum, ai->unit_size - size_sum);\n\t\t}\n\t}\n\n\t/* base address is now known, determine group base offsets */\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tai->groups[group].base_offset = areas[group] - base;\n\t}\n\n\tpr_info(\"Embedded %zu pages/cpu @%p s%zu r%zu d%zu u%zu\\n\",\n\t\tPFN_DOWN(size_sum), base, ai->static_size, ai->reserved_size,\n\t\tai->dyn_size, ai->unit_size);\n\n\trc = pcpu_setup_first_chunk(ai, base);\n\tgoto out_free;\n\nout_free_areas:\n\tfor (group = 0; group < ai->nr_groups; group++)\n\t\tif (areas[group])\n\t\t\tfree_fn(areas[group],\n\t\t\t\tai->groups[group].nr_units * ai->unit_size);\nout_free:\n\tpcpu_free_alloc_info(ai);\n\tif (areas)\n\t\tmemblock_free_early(__pa(areas), areas_size);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nvoid *pcpu_base_addr;\nconst unsigned long *pcpu_unit_offsets;\n\nvoid __init setup_per_cpu_areas(void)\n{\n\tunsigned long delta;\n\tunsigned int cpu;\n\tint rc;\n\n\t/*\n\t * Always reserve area for module percpu variables.  That's\n\t * what the legacy allocator did.\n\t */\n\trc = pcpu_embed_first_chunk(PERCPU_MODULE_RESERVE,\n\t\t\t\t    PERCPU_DYNAMIC_RESERVE, PAGE_SIZE, NULL,\n\t\t\t\t    pcpu_dfl_fc_alloc, pcpu_dfl_fc_free);\n\tif (rc < 0)\n\t\tpanic(\"Failed to initialize percpu areas.\");\n\n\tdelta = (unsigned long)pcpu_base_addr - (unsigned long)__per_cpu_start;\n\tfor_each_possible_cpu(cpu)\n\t\t__per_cpu_offset[cpu] = delta + pcpu_unit_offsets[cpu];\n}"
  },
  {
    "function_name": "pcpu_dfl_fc_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "2697-2700",
    "snippet": "static void __init pcpu_dfl_fc_free(void *ptr, size_t size)\n{\n\tmemblock_free_early(__pa(ptr), size);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_free_early",
          "args": [
            "__pa(ptr)",
            "size"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "__memblock_free_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1547-1555",
          "snippet": "void __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "ptr"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void __init pcpu_dfl_fc_free(void *ptr, size_t size)\n{\n\tmemblock_free_early(__pa(ptr), size);\n}"
  },
  {
    "function_name": "pcpu_dfl_fc_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "2690-2695",
    "snippet": "static void * __init pcpu_dfl_fc_alloc(unsigned int cpu, size_t size,\n\t\t\t\t       size_t align)\n{\n\treturn  memblock_alloc_from_nopanic(\n\t\t\tsize, align, __pa(MAX_DMA_ADDRESS));\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_from_nopanic",
          "args": [
            "size",
            "align",
            "__pa(MAX_DMA_ADDRESS)"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "MAX_DMA_ADDRESS"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void * __init pcpu_dfl_fc_alloc(unsigned int cpu, size_t size,\n\t\t\t\t       size_t align)\n{\n\treturn  memblock_alloc_from_nopanic(\n\t\t\tsize, align, __pa(MAX_DMA_ADDRESS));\n}"
  },
  {
    "function_name": "pcpu_page_first_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "2571-2671",
    "snippet": "int __init pcpu_page_first_chunk(size_t reserved_size,\n\t\t\t\t pcpu_fc_alloc_fn_t alloc_fn,\n\t\t\t\t pcpu_fc_free_fn_t free_fn,\n\t\t\t\t pcpu_fc_populate_pte_fn_t populate_pte_fn)\n{\n\tstatic struct vm_struct vm;\n\tstruct pcpu_alloc_info *ai;\n\tchar psize_str[16];\n\tint unit_pages;\n\tsize_t pages_size;\n\tstruct page **pages;\n\tint unit, i, j, rc;\n\tint upa;\n\tint nr_g0_units;\n\n\tsnprintf(psize_str, sizeof(psize_str), \"%luK\", PAGE_SIZE >> 10);\n\n\tai = pcpu_build_alloc_info(reserved_size, 0, PAGE_SIZE, NULL);\n\tif (IS_ERR(ai))\n\t\treturn PTR_ERR(ai);\n\tBUG_ON(ai->nr_groups != 1);\n\tupa = ai->alloc_size/ai->unit_size;\n\tnr_g0_units = roundup(num_possible_cpus(), upa);\n\tif (WARN_ON(ai->groups[0].nr_units != nr_g0_units)) {\n\t\tpcpu_free_alloc_info(ai);\n\t\treturn -EINVAL;\n\t}\n\n\tunit_pages = ai->unit_size >> PAGE_SHIFT;\n\n\t/* unaligned allocations can't be freed, round up to page size */\n\tpages_size = PFN_ALIGN(unit_pages * num_possible_cpus() *\n\t\t\t       sizeof(pages[0]));\n\tpages = memblock_alloc(pages_size, SMP_CACHE_BYTES);\n\n\t/* allocate pages */\n\tj = 0;\n\tfor (unit = 0; unit < num_possible_cpus(); unit++) {\n\t\tunsigned int cpu = ai->groups[0].cpu_map[unit];\n\t\tfor (i = 0; i < unit_pages; i++) {\n\t\t\tvoid *ptr;\n\n\t\t\tptr = alloc_fn(cpu, PAGE_SIZE, PAGE_SIZE);\n\t\t\tif (!ptr) {\n\t\t\t\tpr_warn(\"failed to allocate %s page for cpu%u\\n\",\n\t\t\t\t\t\tpsize_str, cpu);\n\t\t\t\tgoto enomem;\n\t\t\t}\n\t\t\t/* kmemleak tracks the percpu allocations separately */\n\t\t\tkmemleak_free(ptr);\n\t\t\tpages[j++] = virt_to_page(ptr);\n\t\t}\n\t}\n\n\t/* allocate vm area, map the pages and copy static data */\n\tvm.flags = VM_ALLOC;\n\tvm.size = num_possible_cpus() * ai->unit_size;\n\tvm_area_register_early(&vm, PAGE_SIZE);\n\n\tfor (unit = 0; unit < num_possible_cpus(); unit++) {\n\t\tunsigned long unit_addr =\n\t\t\t(unsigned long)vm.addr + unit * ai->unit_size;\n\n\t\tfor (i = 0; i < unit_pages; i++)\n\t\t\tpopulate_pte_fn(unit_addr + (i << PAGE_SHIFT));\n\n\t\t/* pte already populated, the following shouldn't fail */\n\t\trc = __pcpu_map_pages(unit_addr, &pages[unit * unit_pages],\n\t\t\t\t      unit_pages);\n\t\tif (rc < 0)\n\t\t\tpanic(\"failed to map percpu area, err=%d\\n\", rc);\n\n\t\t/*\n\t\t * FIXME: Archs with virtual cache should flush local\n\t\t * cache for the linear mapping here - something\n\t\t * equivalent to flush_cache_vmap() on the local cpu.\n\t\t * flush_cache_vmap() can't be used as most supporting\n\t\t * data structures are not set up yet.\n\t\t */\n\n\t\t/* copy static data */\n\t\tmemcpy((void *)unit_addr, __per_cpu_load, ai->static_size);\n\t}\n\n\t/* we're ready, commit */\n\tpr_info(\"%d %s pages/cpu @%p s%zu r%zu d%zu\\n\",\n\t\tunit_pages, psize_str, vm.addr, ai->static_size,\n\t\tai->reserved_size, ai->dyn_size);\n\n\trc = pcpu_setup_first_chunk(ai, vm.addr);\n\tgoto out_free_ar;\n\nenomem:\n\twhile (--j >= 0)\n\t\tfree_fn(page_address(pages[j]), PAGE_SIZE);\n\trc = -ENOMEM;\nout_free_ar:\n\tmemblock_free_early(__pa(pages), pages_size);\n\tpcpu_free_alloc_info(ai);\n\treturn rc;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct page *pcpu_addr_to_page(void *addr);",
      "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_free_alloc_info",
          "args": [
            "ai"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_free_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1914-1917",
          "snippet": "void __init pcpu_free_alloc_info(struct pcpu_alloc_info *ai)\n{\n\tmemblock_free_early(__pa(ai), ai->__ai_size);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nvoid __init pcpu_free_alloc_info(struct pcpu_alloc_info *ai)\n{\n\tmemblock_free_early(__pa(ai), ai->__ai_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_free_early",
          "args": [
            "__pa(pages)",
            "pages_size"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "__memblock_free_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1547-1555",
          "snippet": "void __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "pages"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_fn",
          "args": [
            "page_address(pages[j])",
            "PAGE_SIZE"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pages[j]"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_setup_first_chunk",
          "args": [
            "ai",
            "vm.addr"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_setup_first_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "2033-2201",
          "snippet": "int __init pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai,\n\t\t\t\t  void *base_addr)\n{\n\tsize_t size_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tsize_t static_size, dyn_size;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long *group_offsets;\n\tsize_t *group_sizes;\n\tunsigned long *unit_off;\n\tunsigned int cpu;\n\tint *unit_map;\n\tint group, unit, i;\n\tint map_size;\n\tunsigned long tmp_addr;\n\n#define PCPU_SETUP_BUG_ON(cond)\tdo {\t\t\t\t\t\\\n\tif (unlikely(cond)) {\t\t\t\t\t\t\\\n\t\tpr_emerg(\"failed to initialize, %s\\n\", #cond);\t\t\\\n\t\tpr_emerg(\"cpu_possible_mask=%*pb\\n\",\t\t\t\\\n\t\t\t cpumask_pr_args(cpu_possible_mask));\t\t\\\n\t\tpcpu_dump_alloc_info(KERN_EMERG, ai);\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\t/* sanity checks */\n\tPCPU_SETUP_BUG_ON(ai->nr_groups <= 0);\n#ifdef CONFIG_SMP\n\tPCPU_SETUP_BUG_ON(!ai->static_size);\n\tPCPU_SETUP_BUG_ON(offset_in_page(__per_cpu_start));\n#endif\n\tPCPU_SETUP_BUG_ON(!base_addr);\n\tPCPU_SETUP_BUG_ON(offset_in_page(base_addr));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < size_sum);\n\tPCPU_SETUP_BUG_ON(offset_in_page(ai->unit_size));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < PCPU_MIN_UNIT_SIZE);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->unit_size, PCPU_BITMAP_BLOCK_SIZE));\n\tPCPU_SETUP_BUG_ON(ai->dyn_size < PERCPU_DYNAMIC_EARLY_SIZE);\n\tPCPU_SETUP_BUG_ON(!ai->dyn_size);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->reserved_size, PCPU_MIN_ALLOC_SIZE));\n\tPCPU_SETUP_BUG_ON(!(IS_ALIGNED(PCPU_BITMAP_BLOCK_SIZE, PAGE_SIZE) ||\n\t\t\t    IS_ALIGNED(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE)));\n\tPCPU_SETUP_BUG_ON(pcpu_verify_alloc_info(ai) < 0);\n\n\t/* process group information and build config tables accordingly */\n\tgroup_offsets = memblock_alloc(ai->nr_groups * sizeof(group_offsets[0]),\n\t\t\t\t       SMP_CACHE_BYTES);\n\tgroup_sizes = memblock_alloc(ai->nr_groups * sizeof(group_sizes[0]),\n\t\t\t\t     SMP_CACHE_BYTES);\n\tunit_map = memblock_alloc(nr_cpu_ids * sizeof(unit_map[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\tunit_off = memblock_alloc(nr_cpu_ids * sizeof(unit_off[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tunit_map[cpu] = UINT_MAX;\n\n\tpcpu_low_unit_cpu = NR_CPUS;\n\tpcpu_high_unit_cpu = NR_CPUS;\n\n\tfor (group = 0, unit = 0; group < ai->nr_groups; group++, unit += i) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\n\t\tgroup_offsets[group] = gi->base_offset;\n\t\tgroup_sizes[group] = gi->nr_units * ai->unit_size;\n\n\t\tfor (i = 0; i < gi->nr_units; i++) {\n\t\t\tcpu = gi->cpu_map[i];\n\t\t\tif (cpu == NR_CPUS)\n\t\t\t\tcontinue;\n\n\t\t\tPCPU_SETUP_BUG_ON(cpu >= nr_cpu_ids);\n\t\t\tPCPU_SETUP_BUG_ON(!cpu_possible(cpu));\n\t\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] != UINT_MAX);\n\n\t\t\tunit_map[cpu] = unit + i;\n\t\t\tunit_off[cpu] = gi->base_offset + i * ai->unit_size;\n\n\t\t\t/* determine low/high unit_cpu */\n\t\t\tif (pcpu_low_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] < unit_off[pcpu_low_unit_cpu])\n\t\t\t\tpcpu_low_unit_cpu = cpu;\n\t\t\tif (pcpu_high_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] > unit_off[pcpu_high_unit_cpu])\n\t\t\t\tpcpu_high_unit_cpu = cpu;\n\t\t}\n\t}\n\tpcpu_nr_units = unit;\n\n\tfor_each_possible_cpu(cpu)\n\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] == UINT_MAX);\n\n\t/* we're done parsing the input, undefine BUG macro and dump config */\n#undef PCPU_SETUP_BUG_ON\n\tpcpu_dump_alloc_info(KERN_DEBUG, ai);\n\n\tpcpu_nr_groups = ai->nr_groups;\n\tpcpu_group_offsets = group_offsets;\n\tpcpu_group_sizes = group_sizes;\n\tpcpu_unit_map = unit_map;\n\tpcpu_unit_offsets = unit_off;\n\n\t/* determine basic parameters */\n\tpcpu_unit_pages = ai->unit_size >> PAGE_SHIFT;\n\tpcpu_unit_size = pcpu_unit_pages << PAGE_SHIFT;\n\tpcpu_atom_size = ai->atom_size;\n\tpcpu_chunk_struct_size = sizeof(struct pcpu_chunk) +\n\t\tBITS_TO_LONGS(pcpu_unit_pages) * sizeof(unsigned long);\n\n\tpcpu_stats_save_ai(ai);\n\n\t/*\n\t * Allocate chunk slots.  The additional last slot is for\n\t * empty chunks.\n\t */\n\tpcpu_nr_slots = __pcpu_size_to_slot(pcpu_unit_size) + 2;\n\tpcpu_slot = memblock_alloc(pcpu_nr_slots * sizeof(pcpu_slot[0]),\n\t\t\t\t   SMP_CACHE_BYTES);\n\tfor (i = 0; i < pcpu_nr_slots; i++)\n\t\tINIT_LIST_HEAD(&pcpu_slot[i]);\n\n\t/*\n\t * The end of the static region needs to be aligned with the\n\t * minimum allocation size as this offsets the reserved and\n\t * dynamic region.  The first chunk ends page aligned by\n\t * expanding the dynamic region, therefore the dynamic region\n\t * can be shrunk to compensate while still staying above the\n\t * configured sizes.\n\t */\n\tstatic_size = ALIGN(ai->static_size, PCPU_MIN_ALLOC_SIZE);\n\tdyn_size = ai->dyn_size - (static_size - ai->static_size);\n\n\t/*\n\t * Initialize first chunk.\n\t * If the reserved_size is non-zero, this initializes the reserved\n\t * chunk.  If the reserved_size is zero, the reserved chunk is NULL\n\t * and the dynamic region is initialized here.  The first chunk,\n\t * pcpu_first_chunk, will always point to the chunk that serves\n\t * the dynamic region.\n\t */\n\ttmp_addr = (unsigned long)base_addr + static_size;\n\tmap_size = ai->reserved_size ?: dyn_size;\n\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\n\t/* init dynamic chunk if necessary */\n\tif (ai->reserved_size) {\n\t\tpcpu_reserved_chunk = chunk;\n\n\t\ttmp_addr = (unsigned long)base_addr + static_size +\n\t\t\t   ai->reserved_size;\n\t\tmap_size = dyn_size;\n\t\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\t}\n\n\t/* link the first chunk in */\n\tpcpu_first_chunk = chunk;\n\tpcpu_nr_empty_pop_pages = pcpu_first_chunk->nr_empty_pop_pages;\n\tpcpu_chunk_relocate(pcpu_first_chunk, -1);\n\n\t/* include all regions of the first chunk */\n\tpcpu_nr_populated += PFN_DOWN(size_sum);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(base_addr);\n\n\t/* we're done */\n\tpcpu_base_addr = base_addr;\n\treturn 0;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_pages",
            "static int pcpu_unit_size",
            "static int pcpu_nr_units",
            "static int pcpu_atom_size",
            "int pcpu_nr_slots",
            "static size_t pcpu_chunk_struct_size",
            "static unsigned int pcpu_low_unit_cpu",
            "static unsigned int pcpu_high_unit_cpu",
            "void *pcpu_base_addr",
            "static const int *pcpu_unit_map",
            "const unsigned long *pcpu_unit_offsets",
            "static int pcpu_nr_groups",
            "static const unsigned long *pcpu_group_offsets",
            "static const size_t *pcpu_group_sizes",
            "struct pcpu_chunk *pcpu_first_chunk",
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "int pcpu_nr_empty_pop_pages;",
            "static unsigned long pcpu_nr_populated;",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic int pcpu_unit_size;\nstatic int pcpu_nr_units;\nstatic int pcpu_atom_size;\nint pcpu_nr_slots;\nstatic size_t pcpu_chunk_struct_size;\nstatic unsigned int pcpu_low_unit_cpu;\nstatic unsigned int pcpu_high_unit_cpu;\nvoid *pcpu_base_addr;\nstatic const int *pcpu_unit_map;\nconst unsigned long *pcpu_unit_offsets;\nstatic int pcpu_nr_groups;\nstatic const unsigned long *pcpu_group_offsets;\nstatic const size_t *pcpu_group_sizes;\nstruct pcpu_chunk *pcpu_first_chunk;\nstruct pcpu_chunk *pcpu_reserved_chunk;\nint pcpu_nr_empty_pop_pages;\nstatic unsigned long pcpu_nr_populated;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nint __init pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai,\n\t\t\t\t  void *base_addr)\n{\n\tsize_t size_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tsize_t static_size, dyn_size;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long *group_offsets;\n\tsize_t *group_sizes;\n\tunsigned long *unit_off;\n\tunsigned int cpu;\n\tint *unit_map;\n\tint group, unit, i;\n\tint map_size;\n\tunsigned long tmp_addr;\n\n#define PCPU_SETUP_BUG_ON(cond)\tdo {\t\t\t\t\t\\\n\tif (unlikely(cond)) {\t\t\t\t\t\t\\\n\t\tpr_emerg(\"failed to initialize, %s\\n\", #cond);\t\t\\\n\t\tpr_emerg(\"cpu_possible_mask=%*pb\\n\",\t\t\t\\\n\t\t\t cpumask_pr_args(cpu_possible_mask));\t\t\\\n\t\tpcpu_dump_alloc_info(KERN_EMERG, ai);\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\t/* sanity checks */\n\tPCPU_SETUP_BUG_ON(ai->nr_groups <= 0);\n#ifdef CONFIG_SMP\n\tPCPU_SETUP_BUG_ON(!ai->static_size);\n\tPCPU_SETUP_BUG_ON(offset_in_page(__per_cpu_start));\n#endif\n\tPCPU_SETUP_BUG_ON(!base_addr);\n\tPCPU_SETUP_BUG_ON(offset_in_page(base_addr));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < size_sum);\n\tPCPU_SETUP_BUG_ON(offset_in_page(ai->unit_size));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < PCPU_MIN_UNIT_SIZE);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->unit_size, PCPU_BITMAP_BLOCK_SIZE));\n\tPCPU_SETUP_BUG_ON(ai->dyn_size < PERCPU_DYNAMIC_EARLY_SIZE);\n\tPCPU_SETUP_BUG_ON(!ai->dyn_size);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->reserved_size, PCPU_MIN_ALLOC_SIZE));\n\tPCPU_SETUP_BUG_ON(!(IS_ALIGNED(PCPU_BITMAP_BLOCK_SIZE, PAGE_SIZE) ||\n\t\t\t    IS_ALIGNED(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE)));\n\tPCPU_SETUP_BUG_ON(pcpu_verify_alloc_info(ai) < 0);\n\n\t/* process group information and build config tables accordingly */\n\tgroup_offsets = memblock_alloc(ai->nr_groups * sizeof(group_offsets[0]),\n\t\t\t\t       SMP_CACHE_BYTES);\n\tgroup_sizes = memblock_alloc(ai->nr_groups * sizeof(group_sizes[0]),\n\t\t\t\t     SMP_CACHE_BYTES);\n\tunit_map = memblock_alloc(nr_cpu_ids * sizeof(unit_map[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\tunit_off = memblock_alloc(nr_cpu_ids * sizeof(unit_off[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tunit_map[cpu] = UINT_MAX;\n\n\tpcpu_low_unit_cpu = NR_CPUS;\n\tpcpu_high_unit_cpu = NR_CPUS;\n\n\tfor (group = 0, unit = 0; group < ai->nr_groups; group++, unit += i) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\n\t\tgroup_offsets[group] = gi->base_offset;\n\t\tgroup_sizes[group] = gi->nr_units * ai->unit_size;\n\n\t\tfor (i = 0; i < gi->nr_units; i++) {\n\t\t\tcpu = gi->cpu_map[i];\n\t\t\tif (cpu == NR_CPUS)\n\t\t\t\tcontinue;\n\n\t\t\tPCPU_SETUP_BUG_ON(cpu >= nr_cpu_ids);\n\t\t\tPCPU_SETUP_BUG_ON(!cpu_possible(cpu));\n\t\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] != UINT_MAX);\n\n\t\t\tunit_map[cpu] = unit + i;\n\t\t\tunit_off[cpu] = gi->base_offset + i * ai->unit_size;\n\n\t\t\t/* determine low/high unit_cpu */\n\t\t\tif (pcpu_low_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] < unit_off[pcpu_low_unit_cpu])\n\t\t\t\tpcpu_low_unit_cpu = cpu;\n\t\t\tif (pcpu_high_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] > unit_off[pcpu_high_unit_cpu])\n\t\t\t\tpcpu_high_unit_cpu = cpu;\n\t\t}\n\t}\n\tpcpu_nr_units = unit;\n\n\tfor_each_possible_cpu(cpu)\n\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] == UINT_MAX);\n\n\t/* we're done parsing the input, undefine BUG macro and dump config */\n#undef PCPU_SETUP_BUG_ON\n\tpcpu_dump_alloc_info(KERN_DEBUG, ai);\n\n\tpcpu_nr_groups = ai->nr_groups;\n\tpcpu_group_offsets = group_offsets;\n\tpcpu_group_sizes = group_sizes;\n\tpcpu_unit_map = unit_map;\n\tpcpu_unit_offsets = unit_off;\n\n\t/* determine basic parameters */\n\tpcpu_unit_pages = ai->unit_size >> PAGE_SHIFT;\n\tpcpu_unit_size = pcpu_unit_pages << PAGE_SHIFT;\n\tpcpu_atom_size = ai->atom_size;\n\tpcpu_chunk_struct_size = sizeof(struct pcpu_chunk) +\n\t\tBITS_TO_LONGS(pcpu_unit_pages) * sizeof(unsigned long);\n\n\tpcpu_stats_save_ai(ai);\n\n\t/*\n\t * Allocate chunk slots.  The additional last slot is for\n\t * empty chunks.\n\t */\n\tpcpu_nr_slots = __pcpu_size_to_slot(pcpu_unit_size) + 2;\n\tpcpu_slot = memblock_alloc(pcpu_nr_slots * sizeof(pcpu_slot[0]),\n\t\t\t\t   SMP_CACHE_BYTES);\n\tfor (i = 0; i < pcpu_nr_slots; i++)\n\t\tINIT_LIST_HEAD(&pcpu_slot[i]);\n\n\t/*\n\t * The end of the static region needs to be aligned with the\n\t * minimum allocation size as this offsets the reserved and\n\t * dynamic region.  The first chunk ends page aligned by\n\t * expanding the dynamic region, therefore the dynamic region\n\t * can be shrunk to compensate while still staying above the\n\t * configured sizes.\n\t */\n\tstatic_size = ALIGN(ai->static_size, PCPU_MIN_ALLOC_SIZE);\n\tdyn_size = ai->dyn_size - (static_size - ai->static_size);\n\n\t/*\n\t * Initialize first chunk.\n\t * If the reserved_size is non-zero, this initializes the reserved\n\t * chunk.  If the reserved_size is zero, the reserved chunk is NULL\n\t * and the dynamic region is initialized here.  The first chunk,\n\t * pcpu_first_chunk, will always point to the chunk that serves\n\t * the dynamic region.\n\t */\n\ttmp_addr = (unsigned long)base_addr + static_size;\n\tmap_size = ai->reserved_size ?: dyn_size;\n\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\n\t/* init dynamic chunk if necessary */\n\tif (ai->reserved_size) {\n\t\tpcpu_reserved_chunk = chunk;\n\n\t\ttmp_addr = (unsigned long)base_addr + static_size +\n\t\t\t   ai->reserved_size;\n\t\tmap_size = dyn_size;\n\t\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\t}\n\n\t/* link the first chunk in */\n\tpcpu_first_chunk = chunk;\n\tpcpu_nr_empty_pop_pages = pcpu_first_chunk->nr_empty_pop_pages;\n\tpcpu_chunk_relocate(pcpu_first_chunk, -1);\n\n\t/* include all regions of the first chunk */\n\tpcpu_nr_populated += PFN_DOWN(size_sum);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(base_addr);\n\n\t/* we're done */\n\tpcpu_base_addr = base_addr;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%d %s pages/cpu @%p s%zu r%zu d%zu\\n\"",
            "unit_pages",
            "psize_str",
            "vm.addr",
            "ai->static_size",
            "ai->reserved_size",
            "ai->dyn_size"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)unit_addr",
            "__per_cpu_load",
            "ai->static_size"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"failed to map percpu area, err=%d\\n\"",
            "rc"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "check_panic_on_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "1008-1028",
          "snippet": "static void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_panic_on_oom;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_panic_on_oom;\n\nstatic void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pcpu_map_pages",
          "args": [
            "unit_addr",
            "&pages[unit * unit_pages]",
            "unit_pages"
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "__pcpu_map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "193-198",
          "snippet": "static int __pcpu_map_pages(unsigned long addr, struct page **pages,\n\t\t\t    int nr_pages)\n{\n\treturn map_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT,\n\t\t\t\t\tPAGE_KERNEL, pages);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int __pcpu_map_pages(unsigned long addr, struct page **pages,\n\t\t\t    int nr_pages)\n{\n\treturn map_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT,\n\t\t\t\t\tPAGE_KERNEL, pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_pte_fn",
          "args": [
            "unit_addr + (i << PAGE_SHIFT)"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_area_register_early",
          "args": [
            "&vm",
            "PAGE_SIZE"
          ],
          "line": 2628
        },
        "resolved": true,
        "details": {
          "function_name": "vm_area_register_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1228-1239",
          "snippet": "void __init vm_area_register_early(struct vm_struct *vm, size_t align)\n{\n\tstatic size_t vm_init_off __initdata;\n\tunsigned long addr;\n\n\taddr = ALIGN(VMALLOC_START + vm_init_off, align);\n\tvm_init_off = PFN_ALIGN(addr + vm->size) - VMALLOC_START;\n\n\tvm->addr = (void *)addr;\n\n\tvm_area_add_early(vm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vm_struct *vmlist __initdata;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct vm_struct *vmlist __initdata;\n\nvoid __init vm_area_register_early(struct vm_struct *vm, size_t align)\n{\n\tstatic size_t vm_init_off __initdata;\n\tunsigned long addr;\n\n\taddr = ALIGN(VMALLOC_START + vm_init_off, align);\n\tvm_init_off = PFN_ALIGN(addr + vm->size) - VMALLOC_START;\n\n\tvm->addr = (void *)addr;\n\n\tvm_area_add_early(vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "ptr"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_free",
          "args": [
            "ptr"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1082-1094",
          "snippet": "void __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_free_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"failed to allocate %s page for cpu%u\\n\"",
            "psize_str",
            "cpu"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_fn",
          "args": [
            "cpu",
            "PAGE_SIZE",
            "PAGE_SIZE"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "pages_size",
            "SMP_CACHE_BYTES"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_ALIGN",
          "args": [
            "unit_pages * num_possible_cpus() *\n\t\t\t       sizeof(pages[0])"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ai->groups[0].nr_units != nr_g0_units"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "num_possible_cpus()",
            "upa"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ai->nr_groups != 1"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ai"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ai"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_build_alloc_info",
          "args": [
            "reserved_size",
            "0",
            "PAGE_SIZE",
            "NULL"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_build_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "2273-2406",
          "snippet": "static struct pcpu_alloc_info * __init pcpu_build_alloc_info(\n\t\t\t\tsize_t reserved_size, size_t dyn_size,\n\t\t\t\tsize_t atom_size,\n\t\t\t\tpcpu_fc_cpu_distance_fn_t cpu_distance_fn)\n{\n\tstatic int group_map[NR_CPUS] __initdata;\n\tstatic int group_cnt[NR_CPUS] __initdata;\n\tconst size_t static_size = __per_cpu_end - __per_cpu_start;\n\tint nr_groups = 1, nr_units = 0;\n\tsize_t size_sum, min_unit_size, alloc_size;\n\tint upa, max_upa, uninitialized_var(best_upa);\t/* units_per_alloc */\n\tint last_allocs, group, unit;\n\tunsigned int cpu, tcpu;\n\tstruct pcpu_alloc_info *ai;\n\tunsigned int *cpu_map;\n\n\t/* this function may be called multiple times */\n\tmemset(group_map, 0, sizeof(group_map));\n\tmemset(group_cnt, 0, sizeof(group_cnt));\n\n\t/* calculate size_sum and ensure dyn_size is enough for early alloc */\n\tsize_sum = PFN_ALIGN(static_size + reserved_size +\n\t\t\t    max_t(size_t, dyn_size, PERCPU_DYNAMIC_EARLY_SIZE));\n\tdyn_size = size_sum - static_size - reserved_size;\n\n\t/*\n\t * Determine min_unit_size, alloc_size and max_upa such that\n\t * alloc_size is multiple of atom_size and is the smallest\n\t * which can accommodate 4k aligned segments which are equal to\n\t * or larger than min_unit_size.\n\t */\n\tmin_unit_size = max_t(size_t, size_sum, PCPU_MIN_UNIT_SIZE);\n\n\t/* determine the maximum # of units that can fit in an allocation */\n\talloc_size = roundup(min_unit_size, atom_size);\n\tupa = alloc_size / min_unit_size;\n\twhile (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\tupa--;\n\tmax_upa = upa;\n\n\t/* group cpus according to their proximity */\n\tfor_each_possible_cpu(cpu) {\n\t\tgroup = 0;\n\tnext_group:\n\t\tfor_each_possible_cpu(tcpu) {\n\t\t\tif (cpu == tcpu)\n\t\t\t\tbreak;\n\t\t\tif (group_map[tcpu] == group && cpu_distance_fn &&\n\t\t\t    (cpu_distance_fn(cpu, tcpu) > LOCAL_DISTANCE ||\n\t\t\t     cpu_distance_fn(tcpu, cpu) > LOCAL_DISTANCE)) {\n\t\t\t\tgroup++;\n\t\t\t\tnr_groups = max(nr_groups, group + 1);\n\t\t\t\tgoto next_group;\n\t\t\t}\n\t\t}\n\t\tgroup_map[cpu] = group;\n\t\tgroup_cnt[group]++;\n\t}\n\n\t/*\n\t * Wasted space is caused by a ratio imbalance of upa to group_cnt.\n\t * Expand the unit_size until we use >= 75% of the units allocated.\n\t * Related to atom_size, which could be much larger than the unit_size.\n\t */\n\tlast_allocs = INT_MAX;\n\tfor (upa = max_upa; upa; upa--) {\n\t\tint allocs = 0, wasted = 0;\n\n\t\tif (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\t\tcontinue;\n\n\t\tfor (group = 0; group < nr_groups; group++) {\n\t\t\tint this_allocs = DIV_ROUND_UP(group_cnt[group], upa);\n\t\t\tallocs += this_allocs;\n\t\t\twasted += this_allocs * upa - group_cnt[group];\n\t\t}\n\n\t\t/*\n\t\t * Don't accept if wastage is over 1/3.  The\n\t\t * greater-than comparison ensures upa==1 always\n\t\t * passes the following check.\n\t\t */\n\t\tif (wasted > num_possible_cpus() / 3)\n\t\t\tcontinue;\n\n\t\t/* and then don't consume more memory */\n\t\tif (allocs > last_allocs)\n\t\t\tbreak;\n\t\tlast_allocs = allocs;\n\t\tbest_upa = upa;\n\t}\n\tupa = best_upa;\n\n\t/* allocate and fill alloc_info */\n\tfor (group = 0; group < nr_groups; group++)\n\t\tnr_units += roundup(group_cnt[group], upa);\n\n\tai = pcpu_alloc_alloc_info(nr_groups, nr_units);\n\tif (!ai)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcpu_map = ai->groups[0].cpu_map;\n\n\tfor (group = 0; group < nr_groups; group++) {\n\t\tai->groups[group].cpu_map = cpu_map;\n\t\tcpu_map += roundup(group_cnt[group], upa);\n\t}\n\n\tai->static_size = static_size;\n\tai->reserved_size = reserved_size;\n\tai->dyn_size = dyn_size;\n\tai->unit_size = alloc_size / upa;\n\tai->atom_size = atom_size;\n\tai->alloc_size = alloc_size;\n\n\tfor (group = 0, unit = 0; group_cnt[group]; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\n\t\t/*\n\t\t * Initialize base_offset as if all groups are located\n\t\t * back-to-back.  The caller should update this to\n\t\t * reflect actual allocation.\n\t\t */\n\t\tgi->base_offset = unit * ai->unit_size;\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tif (group_map[cpu] == group)\n\t\t\t\tgi->cpu_map[gi->nr_units++] = cpu;\n\t\tgi->nr_units = roundup(gi->nr_units, upa);\n\t\tunit += gi->nr_units;\n\t}\n\tBUG_ON(unit != nr_units);\n\n\treturn ai;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nstatic struct pcpu_alloc_info * __init pcpu_build_alloc_info(\n\t\t\t\tsize_t reserved_size, size_t dyn_size,\n\t\t\t\tsize_t atom_size,\n\t\t\t\tpcpu_fc_cpu_distance_fn_t cpu_distance_fn)\n{\n\tstatic int group_map[NR_CPUS] __initdata;\n\tstatic int group_cnt[NR_CPUS] __initdata;\n\tconst size_t static_size = __per_cpu_end - __per_cpu_start;\n\tint nr_groups = 1, nr_units = 0;\n\tsize_t size_sum, min_unit_size, alloc_size;\n\tint upa, max_upa, uninitialized_var(best_upa);\t/* units_per_alloc */\n\tint last_allocs, group, unit;\n\tunsigned int cpu, tcpu;\n\tstruct pcpu_alloc_info *ai;\n\tunsigned int *cpu_map;\n\n\t/* this function may be called multiple times */\n\tmemset(group_map, 0, sizeof(group_map));\n\tmemset(group_cnt, 0, sizeof(group_cnt));\n\n\t/* calculate size_sum and ensure dyn_size is enough for early alloc */\n\tsize_sum = PFN_ALIGN(static_size + reserved_size +\n\t\t\t    max_t(size_t, dyn_size, PERCPU_DYNAMIC_EARLY_SIZE));\n\tdyn_size = size_sum - static_size - reserved_size;\n\n\t/*\n\t * Determine min_unit_size, alloc_size and max_upa such that\n\t * alloc_size is multiple of atom_size and is the smallest\n\t * which can accommodate 4k aligned segments which are equal to\n\t * or larger than min_unit_size.\n\t */\n\tmin_unit_size = max_t(size_t, size_sum, PCPU_MIN_UNIT_SIZE);\n\n\t/* determine the maximum # of units that can fit in an allocation */\n\talloc_size = roundup(min_unit_size, atom_size);\n\tupa = alloc_size / min_unit_size;\n\twhile (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\tupa--;\n\tmax_upa = upa;\n\n\t/* group cpus according to their proximity */\n\tfor_each_possible_cpu(cpu) {\n\t\tgroup = 0;\n\tnext_group:\n\t\tfor_each_possible_cpu(tcpu) {\n\t\t\tif (cpu == tcpu)\n\t\t\t\tbreak;\n\t\t\tif (group_map[tcpu] == group && cpu_distance_fn &&\n\t\t\t    (cpu_distance_fn(cpu, tcpu) > LOCAL_DISTANCE ||\n\t\t\t     cpu_distance_fn(tcpu, cpu) > LOCAL_DISTANCE)) {\n\t\t\t\tgroup++;\n\t\t\t\tnr_groups = max(nr_groups, group + 1);\n\t\t\t\tgoto next_group;\n\t\t\t}\n\t\t}\n\t\tgroup_map[cpu] = group;\n\t\tgroup_cnt[group]++;\n\t}\n\n\t/*\n\t * Wasted space is caused by a ratio imbalance of upa to group_cnt.\n\t * Expand the unit_size until we use >= 75% of the units allocated.\n\t * Related to atom_size, which could be much larger than the unit_size.\n\t */\n\tlast_allocs = INT_MAX;\n\tfor (upa = max_upa; upa; upa--) {\n\t\tint allocs = 0, wasted = 0;\n\n\t\tif (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\t\tcontinue;\n\n\t\tfor (group = 0; group < nr_groups; group++) {\n\t\t\tint this_allocs = DIV_ROUND_UP(group_cnt[group], upa);\n\t\t\tallocs += this_allocs;\n\t\t\twasted += this_allocs * upa - group_cnt[group];\n\t\t}\n\n\t\t/*\n\t\t * Don't accept if wastage is over 1/3.  The\n\t\t * greater-than comparison ensures upa==1 always\n\t\t * passes the following check.\n\t\t */\n\t\tif (wasted > num_possible_cpus() / 3)\n\t\t\tcontinue;\n\n\t\t/* and then don't consume more memory */\n\t\tif (allocs > last_allocs)\n\t\t\tbreak;\n\t\tlast_allocs = allocs;\n\t\tbest_upa = upa;\n\t}\n\tupa = best_upa;\n\n\t/* allocate and fill alloc_info */\n\tfor (group = 0; group < nr_groups; group++)\n\t\tnr_units += roundup(group_cnt[group], upa);\n\n\tai = pcpu_alloc_alloc_info(nr_groups, nr_units);\n\tif (!ai)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcpu_map = ai->groups[0].cpu_map;\n\n\tfor (group = 0; group < nr_groups; group++) {\n\t\tai->groups[group].cpu_map = cpu_map;\n\t\tcpu_map += roundup(group_cnt[group], upa);\n\t}\n\n\tai->static_size = static_size;\n\tai->reserved_size = reserved_size;\n\tai->dyn_size = dyn_size;\n\tai->unit_size = alloc_size / upa;\n\tai->atom_size = atom_size;\n\tai->alloc_size = alloc_size;\n\n\tfor (group = 0, unit = 0; group_cnt[group]; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\n\t\t/*\n\t\t * Initialize base_offset as if all groups are located\n\t\t * back-to-back.  The caller should update this to\n\t\t * reflect actual allocation.\n\t\t */\n\t\tgi->base_offset = unit * ai->unit_size;\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tif (group_map[cpu] == group)\n\t\t\t\tgi->cpu_map[gi->nr_units++] = cpu;\n\t\tgi->nr_units = roundup(gi->nr_units, upa);\n\t\tunit += gi->nr_units;\n\t}\n\tBUG_ON(unit != nr_units);\n\n\treturn ai;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "psize_str",
            "sizeof(psize_str)",
            "\"%luK\"",
            "PAGE_SIZE >> 10"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct page *pcpu_addr_to_page(void *addr);\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nint __init pcpu_page_first_chunk(size_t reserved_size,\n\t\t\t\t pcpu_fc_alloc_fn_t alloc_fn,\n\t\t\t\t pcpu_fc_free_fn_t free_fn,\n\t\t\t\t pcpu_fc_populate_pte_fn_t populate_pte_fn)\n{\n\tstatic struct vm_struct vm;\n\tstruct pcpu_alloc_info *ai;\n\tchar psize_str[16];\n\tint unit_pages;\n\tsize_t pages_size;\n\tstruct page **pages;\n\tint unit, i, j, rc;\n\tint upa;\n\tint nr_g0_units;\n\n\tsnprintf(psize_str, sizeof(psize_str), \"%luK\", PAGE_SIZE >> 10);\n\n\tai = pcpu_build_alloc_info(reserved_size, 0, PAGE_SIZE, NULL);\n\tif (IS_ERR(ai))\n\t\treturn PTR_ERR(ai);\n\tBUG_ON(ai->nr_groups != 1);\n\tupa = ai->alloc_size/ai->unit_size;\n\tnr_g0_units = roundup(num_possible_cpus(), upa);\n\tif (WARN_ON(ai->groups[0].nr_units != nr_g0_units)) {\n\t\tpcpu_free_alloc_info(ai);\n\t\treturn -EINVAL;\n\t}\n\n\tunit_pages = ai->unit_size >> PAGE_SHIFT;\n\n\t/* unaligned allocations can't be freed, round up to page size */\n\tpages_size = PFN_ALIGN(unit_pages * num_possible_cpus() *\n\t\t\t       sizeof(pages[0]));\n\tpages = memblock_alloc(pages_size, SMP_CACHE_BYTES);\n\n\t/* allocate pages */\n\tj = 0;\n\tfor (unit = 0; unit < num_possible_cpus(); unit++) {\n\t\tunsigned int cpu = ai->groups[0].cpu_map[unit];\n\t\tfor (i = 0; i < unit_pages; i++) {\n\t\t\tvoid *ptr;\n\n\t\t\tptr = alloc_fn(cpu, PAGE_SIZE, PAGE_SIZE);\n\t\t\tif (!ptr) {\n\t\t\t\tpr_warn(\"failed to allocate %s page for cpu%u\\n\",\n\t\t\t\t\t\tpsize_str, cpu);\n\t\t\t\tgoto enomem;\n\t\t\t}\n\t\t\t/* kmemleak tracks the percpu allocations separately */\n\t\t\tkmemleak_free(ptr);\n\t\t\tpages[j++] = virt_to_page(ptr);\n\t\t}\n\t}\n\n\t/* allocate vm area, map the pages and copy static data */\n\tvm.flags = VM_ALLOC;\n\tvm.size = num_possible_cpus() * ai->unit_size;\n\tvm_area_register_early(&vm, PAGE_SIZE);\n\n\tfor (unit = 0; unit < num_possible_cpus(); unit++) {\n\t\tunsigned long unit_addr =\n\t\t\t(unsigned long)vm.addr + unit * ai->unit_size;\n\n\t\tfor (i = 0; i < unit_pages; i++)\n\t\t\tpopulate_pte_fn(unit_addr + (i << PAGE_SHIFT));\n\n\t\t/* pte already populated, the following shouldn't fail */\n\t\trc = __pcpu_map_pages(unit_addr, &pages[unit * unit_pages],\n\t\t\t\t      unit_pages);\n\t\tif (rc < 0)\n\t\t\tpanic(\"failed to map percpu area, err=%d\\n\", rc);\n\n\t\t/*\n\t\t * FIXME: Archs with virtual cache should flush local\n\t\t * cache for the linear mapping here - something\n\t\t * equivalent to flush_cache_vmap() on the local cpu.\n\t\t * flush_cache_vmap() can't be used as most supporting\n\t\t * data structures are not set up yet.\n\t\t */\n\n\t\t/* copy static data */\n\t\tmemcpy((void *)unit_addr, __per_cpu_load, ai->static_size);\n\t}\n\n\t/* we're ready, commit */\n\tpr_info(\"%d %s pages/cpu @%p s%zu r%zu d%zu\\n\",\n\t\tunit_pages, psize_str, vm.addr, ai->static_size,\n\t\tai->reserved_size, ai->dyn_size);\n\n\trc = pcpu_setup_first_chunk(ai, vm.addr);\n\tgoto out_free_ar;\n\nenomem:\n\twhile (--j >= 0)\n\t\tfree_fn(page_address(pages[j]), PAGE_SIZE);\n\trc = -ENOMEM;\nout_free_ar:\n\tmemblock_free_early(__pa(pages), pages_size);\n\tpcpu_free_alloc_info(ai);\n\treturn rc;\n}"
  },
  {
    "function_name": "pcpu_embed_first_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "2442-2551",
    "snippet": "int __init pcpu_embed_first_chunk(size_t reserved_size, size_t dyn_size,\n\t\t\t\t  size_t atom_size,\n\t\t\t\t  pcpu_fc_cpu_distance_fn_t cpu_distance_fn,\n\t\t\t\t  pcpu_fc_alloc_fn_t alloc_fn,\n\t\t\t\t  pcpu_fc_free_fn_t free_fn)\n{\n\tvoid *base = (void *)ULONG_MAX;\n\tvoid **areas = NULL;\n\tstruct pcpu_alloc_info *ai;\n\tsize_t size_sum, areas_size;\n\tunsigned long max_distance;\n\tint group, i, highest_group, rc;\n\n\tai = pcpu_build_alloc_info(reserved_size, dyn_size, atom_size,\n\t\t\t\t   cpu_distance_fn);\n\tif (IS_ERR(ai))\n\t\treturn PTR_ERR(ai);\n\n\tsize_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tareas_size = PFN_ALIGN(ai->nr_groups * sizeof(void *));\n\n\tareas = memblock_alloc_nopanic(areas_size, SMP_CACHE_BYTES);\n\tif (!areas) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* allocate, copy and determine base address & max_distance */\n\thighest_group = 0;\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\t\tunsigned int cpu = NR_CPUS;\n\t\tvoid *ptr;\n\n\t\tfor (i = 0; i < gi->nr_units && cpu == NR_CPUS; i++)\n\t\t\tcpu = gi->cpu_map[i];\n\t\tBUG_ON(cpu == NR_CPUS);\n\n\t\t/* allocate space for the whole group */\n\t\tptr = alloc_fn(cpu, gi->nr_units * ai->unit_size, atom_size);\n\t\tif (!ptr) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_free_areas;\n\t\t}\n\t\t/* kmemleak tracks the percpu allocations separately */\n\t\tkmemleak_free(ptr);\n\t\tareas[group] = ptr;\n\n\t\tbase = min(ptr, base);\n\t\tif (ptr > areas[highest_group])\n\t\t\thighest_group = group;\n\t}\n\tmax_distance = areas[highest_group] - base;\n\tmax_distance += ai->unit_size * ai->groups[highest_group].nr_units;\n\n\t/* warn if maximum distance is further than 75% of vmalloc space */\n\tif (max_distance > VMALLOC_TOTAL * 3 / 4) {\n\t\tpr_warn(\"max_distance=0x%lx too large for vmalloc space 0x%lx\\n\",\n\t\t\t\tmax_distance, VMALLOC_TOTAL);\n#ifdef CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK\n\t\t/* and fail if we have fallback */\n\t\trc = -EINVAL;\n\t\tgoto out_free_areas;\n#endif\n\t}\n\n\t/*\n\t * Copy data and free unused parts.  This should happen after all\n\t * allocations are complete; otherwise, we may end up with\n\t * overlapping groups.\n\t */\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\t\tvoid *ptr = areas[group];\n\n\t\tfor (i = 0; i < gi->nr_units; i++, ptr += ai->unit_size) {\n\t\t\tif (gi->cpu_map[i] == NR_CPUS) {\n\t\t\t\t/* unused unit, free whole */\n\t\t\t\tfree_fn(ptr, ai->unit_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* copy and return the unused part */\n\t\t\tmemcpy(ptr, __per_cpu_load, ai->static_size);\n\t\t\tfree_fn(ptr + size_sum, ai->unit_size - size_sum);\n\t\t}\n\t}\n\n\t/* base address is now known, determine group base offsets */\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tai->groups[group].base_offset = areas[group] - base;\n\t}\n\n\tpr_info(\"Embedded %zu pages/cpu @%p s%zu r%zu d%zu u%zu\\n\",\n\t\tPFN_DOWN(size_sum), base, ai->static_size, ai->reserved_size,\n\t\tai->dyn_size, ai->unit_size);\n\n\trc = pcpu_setup_first_chunk(ai, base);\n\tgoto out_free;\n\nout_free_areas:\n\tfor (group = 0; group < ai->nr_groups; group++)\n\t\tif (areas[group])\n\t\t\tfree_fn(areas[group],\n\t\t\t\tai->groups[group].nr_units * ai->unit_size);\nout_free:\n\tpcpu_free_alloc_info(ai);\n\tif (areas)\n\t\tmemblock_free_early(__pa(areas), areas_size);\n\treturn rc;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_free_early",
          "args": [
            "__pa(areas)",
            "areas_size"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "__memblock_free_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1547-1555",
          "snippet": "void __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "areas"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_free_alloc_info",
          "args": [
            "ai"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_free_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1914-1917",
          "snippet": "void __init pcpu_free_alloc_info(struct pcpu_alloc_info *ai)\n{\n\tmemblock_free_early(__pa(ai), ai->__ai_size);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nvoid __init pcpu_free_alloc_info(struct pcpu_alloc_info *ai)\n{\n\tmemblock_free_early(__pa(ai), ai->__ai_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_fn",
          "args": [
            "areas[group]",
            "ai->groups[group].nr_units * ai->unit_size"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_setup_first_chunk",
          "args": [
            "ai",
            "base"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_setup_first_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "2033-2201",
          "snippet": "int __init pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai,\n\t\t\t\t  void *base_addr)\n{\n\tsize_t size_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tsize_t static_size, dyn_size;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long *group_offsets;\n\tsize_t *group_sizes;\n\tunsigned long *unit_off;\n\tunsigned int cpu;\n\tint *unit_map;\n\tint group, unit, i;\n\tint map_size;\n\tunsigned long tmp_addr;\n\n#define PCPU_SETUP_BUG_ON(cond)\tdo {\t\t\t\t\t\\\n\tif (unlikely(cond)) {\t\t\t\t\t\t\\\n\t\tpr_emerg(\"failed to initialize, %s\\n\", #cond);\t\t\\\n\t\tpr_emerg(\"cpu_possible_mask=%*pb\\n\",\t\t\t\\\n\t\t\t cpumask_pr_args(cpu_possible_mask));\t\t\\\n\t\tpcpu_dump_alloc_info(KERN_EMERG, ai);\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\t/* sanity checks */\n\tPCPU_SETUP_BUG_ON(ai->nr_groups <= 0);\n#ifdef CONFIG_SMP\n\tPCPU_SETUP_BUG_ON(!ai->static_size);\n\tPCPU_SETUP_BUG_ON(offset_in_page(__per_cpu_start));\n#endif\n\tPCPU_SETUP_BUG_ON(!base_addr);\n\tPCPU_SETUP_BUG_ON(offset_in_page(base_addr));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < size_sum);\n\tPCPU_SETUP_BUG_ON(offset_in_page(ai->unit_size));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < PCPU_MIN_UNIT_SIZE);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->unit_size, PCPU_BITMAP_BLOCK_SIZE));\n\tPCPU_SETUP_BUG_ON(ai->dyn_size < PERCPU_DYNAMIC_EARLY_SIZE);\n\tPCPU_SETUP_BUG_ON(!ai->dyn_size);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->reserved_size, PCPU_MIN_ALLOC_SIZE));\n\tPCPU_SETUP_BUG_ON(!(IS_ALIGNED(PCPU_BITMAP_BLOCK_SIZE, PAGE_SIZE) ||\n\t\t\t    IS_ALIGNED(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE)));\n\tPCPU_SETUP_BUG_ON(pcpu_verify_alloc_info(ai) < 0);\n\n\t/* process group information and build config tables accordingly */\n\tgroup_offsets = memblock_alloc(ai->nr_groups * sizeof(group_offsets[0]),\n\t\t\t\t       SMP_CACHE_BYTES);\n\tgroup_sizes = memblock_alloc(ai->nr_groups * sizeof(group_sizes[0]),\n\t\t\t\t     SMP_CACHE_BYTES);\n\tunit_map = memblock_alloc(nr_cpu_ids * sizeof(unit_map[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\tunit_off = memblock_alloc(nr_cpu_ids * sizeof(unit_off[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tunit_map[cpu] = UINT_MAX;\n\n\tpcpu_low_unit_cpu = NR_CPUS;\n\tpcpu_high_unit_cpu = NR_CPUS;\n\n\tfor (group = 0, unit = 0; group < ai->nr_groups; group++, unit += i) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\n\t\tgroup_offsets[group] = gi->base_offset;\n\t\tgroup_sizes[group] = gi->nr_units * ai->unit_size;\n\n\t\tfor (i = 0; i < gi->nr_units; i++) {\n\t\t\tcpu = gi->cpu_map[i];\n\t\t\tif (cpu == NR_CPUS)\n\t\t\t\tcontinue;\n\n\t\t\tPCPU_SETUP_BUG_ON(cpu >= nr_cpu_ids);\n\t\t\tPCPU_SETUP_BUG_ON(!cpu_possible(cpu));\n\t\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] != UINT_MAX);\n\n\t\t\tunit_map[cpu] = unit + i;\n\t\t\tunit_off[cpu] = gi->base_offset + i * ai->unit_size;\n\n\t\t\t/* determine low/high unit_cpu */\n\t\t\tif (pcpu_low_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] < unit_off[pcpu_low_unit_cpu])\n\t\t\t\tpcpu_low_unit_cpu = cpu;\n\t\t\tif (pcpu_high_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] > unit_off[pcpu_high_unit_cpu])\n\t\t\t\tpcpu_high_unit_cpu = cpu;\n\t\t}\n\t}\n\tpcpu_nr_units = unit;\n\n\tfor_each_possible_cpu(cpu)\n\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] == UINT_MAX);\n\n\t/* we're done parsing the input, undefine BUG macro and dump config */\n#undef PCPU_SETUP_BUG_ON\n\tpcpu_dump_alloc_info(KERN_DEBUG, ai);\n\n\tpcpu_nr_groups = ai->nr_groups;\n\tpcpu_group_offsets = group_offsets;\n\tpcpu_group_sizes = group_sizes;\n\tpcpu_unit_map = unit_map;\n\tpcpu_unit_offsets = unit_off;\n\n\t/* determine basic parameters */\n\tpcpu_unit_pages = ai->unit_size >> PAGE_SHIFT;\n\tpcpu_unit_size = pcpu_unit_pages << PAGE_SHIFT;\n\tpcpu_atom_size = ai->atom_size;\n\tpcpu_chunk_struct_size = sizeof(struct pcpu_chunk) +\n\t\tBITS_TO_LONGS(pcpu_unit_pages) * sizeof(unsigned long);\n\n\tpcpu_stats_save_ai(ai);\n\n\t/*\n\t * Allocate chunk slots.  The additional last slot is for\n\t * empty chunks.\n\t */\n\tpcpu_nr_slots = __pcpu_size_to_slot(pcpu_unit_size) + 2;\n\tpcpu_slot = memblock_alloc(pcpu_nr_slots * sizeof(pcpu_slot[0]),\n\t\t\t\t   SMP_CACHE_BYTES);\n\tfor (i = 0; i < pcpu_nr_slots; i++)\n\t\tINIT_LIST_HEAD(&pcpu_slot[i]);\n\n\t/*\n\t * The end of the static region needs to be aligned with the\n\t * minimum allocation size as this offsets the reserved and\n\t * dynamic region.  The first chunk ends page aligned by\n\t * expanding the dynamic region, therefore the dynamic region\n\t * can be shrunk to compensate while still staying above the\n\t * configured sizes.\n\t */\n\tstatic_size = ALIGN(ai->static_size, PCPU_MIN_ALLOC_SIZE);\n\tdyn_size = ai->dyn_size - (static_size - ai->static_size);\n\n\t/*\n\t * Initialize first chunk.\n\t * If the reserved_size is non-zero, this initializes the reserved\n\t * chunk.  If the reserved_size is zero, the reserved chunk is NULL\n\t * and the dynamic region is initialized here.  The first chunk,\n\t * pcpu_first_chunk, will always point to the chunk that serves\n\t * the dynamic region.\n\t */\n\ttmp_addr = (unsigned long)base_addr + static_size;\n\tmap_size = ai->reserved_size ?: dyn_size;\n\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\n\t/* init dynamic chunk if necessary */\n\tif (ai->reserved_size) {\n\t\tpcpu_reserved_chunk = chunk;\n\n\t\ttmp_addr = (unsigned long)base_addr + static_size +\n\t\t\t   ai->reserved_size;\n\t\tmap_size = dyn_size;\n\t\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\t}\n\n\t/* link the first chunk in */\n\tpcpu_first_chunk = chunk;\n\tpcpu_nr_empty_pop_pages = pcpu_first_chunk->nr_empty_pop_pages;\n\tpcpu_chunk_relocate(pcpu_first_chunk, -1);\n\n\t/* include all regions of the first chunk */\n\tpcpu_nr_populated += PFN_DOWN(size_sum);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(base_addr);\n\n\t/* we're done */\n\tpcpu_base_addr = base_addr;\n\treturn 0;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_pages",
            "static int pcpu_unit_size",
            "static int pcpu_nr_units",
            "static int pcpu_atom_size",
            "int pcpu_nr_slots",
            "static size_t pcpu_chunk_struct_size",
            "static unsigned int pcpu_low_unit_cpu",
            "static unsigned int pcpu_high_unit_cpu",
            "void *pcpu_base_addr",
            "static const int *pcpu_unit_map",
            "const unsigned long *pcpu_unit_offsets",
            "static int pcpu_nr_groups",
            "static const unsigned long *pcpu_group_offsets",
            "static const size_t *pcpu_group_sizes",
            "struct pcpu_chunk *pcpu_first_chunk",
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "int pcpu_nr_empty_pop_pages;",
            "static unsigned long pcpu_nr_populated;",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic int pcpu_unit_size;\nstatic int pcpu_nr_units;\nstatic int pcpu_atom_size;\nint pcpu_nr_slots;\nstatic size_t pcpu_chunk_struct_size;\nstatic unsigned int pcpu_low_unit_cpu;\nstatic unsigned int pcpu_high_unit_cpu;\nvoid *pcpu_base_addr;\nstatic const int *pcpu_unit_map;\nconst unsigned long *pcpu_unit_offsets;\nstatic int pcpu_nr_groups;\nstatic const unsigned long *pcpu_group_offsets;\nstatic const size_t *pcpu_group_sizes;\nstruct pcpu_chunk *pcpu_first_chunk;\nstruct pcpu_chunk *pcpu_reserved_chunk;\nint pcpu_nr_empty_pop_pages;\nstatic unsigned long pcpu_nr_populated;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nint __init pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai,\n\t\t\t\t  void *base_addr)\n{\n\tsize_t size_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tsize_t static_size, dyn_size;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long *group_offsets;\n\tsize_t *group_sizes;\n\tunsigned long *unit_off;\n\tunsigned int cpu;\n\tint *unit_map;\n\tint group, unit, i;\n\tint map_size;\n\tunsigned long tmp_addr;\n\n#define PCPU_SETUP_BUG_ON(cond)\tdo {\t\t\t\t\t\\\n\tif (unlikely(cond)) {\t\t\t\t\t\t\\\n\t\tpr_emerg(\"failed to initialize, %s\\n\", #cond);\t\t\\\n\t\tpr_emerg(\"cpu_possible_mask=%*pb\\n\",\t\t\t\\\n\t\t\t cpumask_pr_args(cpu_possible_mask));\t\t\\\n\t\tpcpu_dump_alloc_info(KERN_EMERG, ai);\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\t/* sanity checks */\n\tPCPU_SETUP_BUG_ON(ai->nr_groups <= 0);\n#ifdef CONFIG_SMP\n\tPCPU_SETUP_BUG_ON(!ai->static_size);\n\tPCPU_SETUP_BUG_ON(offset_in_page(__per_cpu_start));\n#endif\n\tPCPU_SETUP_BUG_ON(!base_addr);\n\tPCPU_SETUP_BUG_ON(offset_in_page(base_addr));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < size_sum);\n\tPCPU_SETUP_BUG_ON(offset_in_page(ai->unit_size));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < PCPU_MIN_UNIT_SIZE);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->unit_size, PCPU_BITMAP_BLOCK_SIZE));\n\tPCPU_SETUP_BUG_ON(ai->dyn_size < PERCPU_DYNAMIC_EARLY_SIZE);\n\tPCPU_SETUP_BUG_ON(!ai->dyn_size);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->reserved_size, PCPU_MIN_ALLOC_SIZE));\n\tPCPU_SETUP_BUG_ON(!(IS_ALIGNED(PCPU_BITMAP_BLOCK_SIZE, PAGE_SIZE) ||\n\t\t\t    IS_ALIGNED(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE)));\n\tPCPU_SETUP_BUG_ON(pcpu_verify_alloc_info(ai) < 0);\n\n\t/* process group information and build config tables accordingly */\n\tgroup_offsets = memblock_alloc(ai->nr_groups * sizeof(group_offsets[0]),\n\t\t\t\t       SMP_CACHE_BYTES);\n\tgroup_sizes = memblock_alloc(ai->nr_groups * sizeof(group_sizes[0]),\n\t\t\t\t     SMP_CACHE_BYTES);\n\tunit_map = memblock_alloc(nr_cpu_ids * sizeof(unit_map[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\tunit_off = memblock_alloc(nr_cpu_ids * sizeof(unit_off[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tunit_map[cpu] = UINT_MAX;\n\n\tpcpu_low_unit_cpu = NR_CPUS;\n\tpcpu_high_unit_cpu = NR_CPUS;\n\n\tfor (group = 0, unit = 0; group < ai->nr_groups; group++, unit += i) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\n\t\tgroup_offsets[group] = gi->base_offset;\n\t\tgroup_sizes[group] = gi->nr_units * ai->unit_size;\n\n\t\tfor (i = 0; i < gi->nr_units; i++) {\n\t\t\tcpu = gi->cpu_map[i];\n\t\t\tif (cpu == NR_CPUS)\n\t\t\t\tcontinue;\n\n\t\t\tPCPU_SETUP_BUG_ON(cpu >= nr_cpu_ids);\n\t\t\tPCPU_SETUP_BUG_ON(!cpu_possible(cpu));\n\t\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] != UINT_MAX);\n\n\t\t\tunit_map[cpu] = unit + i;\n\t\t\tunit_off[cpu] = gi->base_offset + i * ai->unit_size;\n\n\t\t\t/* determine low/high unit_cpu */\n\t\t\tif (pcpu_low_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] < unit_off[pcpu_low_unit_cpu])\n\t\t\t\tpcpu_low_unit_cpu = cpu;\n\t\t\tif (pcpu_high_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] > unit_off[pcpu_high_unit_cpu])\n\t\t\t\tpcpu_high_unit_cpu = cpu;\n\t\t}\n\t}\n\tpcpu_nr_units = unit;\n\n\tfor_each_possible_cpu(cpu)\n\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] == UINT_MAX);\n\n\t/* we're done parsing the input, undefine BUG macro and dump config */\n#undef PCPU_SETUP_BUG_ON\n\tpcpu_dump_alloc_info(KERN_DEBUG, ai);\n\n\tpcpu_nr_groups = ai->nr_groups;\n\tpcpu_group_offsets = group_offsets;\n\tpcpu_group_sizes = group_sizes;\n\tpcpu_unit_map = unit_map;\n\tpcpu_unit_offsets = unit_off;\n\n\t/* determine basic parameters */\n\tpcpu_unit_pages = ai->unit_size >> PAGE_SHIFT;\n\tpcpu_unit_size = pcpu_unit_pages << PAGE_SHIFT;\n\tpcpu_atom_size = ai->atom_size;\n\tpcpu_chunk_struct_size = sizeof(struct pcpu_chunk) +\n\t\tBITS_TO_LONGS(pcpu_unit_pages) * sizeof(unsigned long);\n\n\tpcpu_stats_save_ai(ai);\n\n\t/*\n\t * Allocate chunk slots.  The additional last slot is for\n\t * empty chunks.\n\t */\n\tpcpu_nr_slots = __pcpu_size_to_slot(pcpu_unit_size) + 2;\n\tpcpu_slot = memblock_alloc(pcpu_nr_slots * sizeof(pcpu_slot[0]),\n\t\t\t\t   SMP_CACHE_BYTES);\n\tfor (i = 0; i < pcpu_nr_slots; i++)\n\t\tINIT_LIST_HEAD(&pcpu_slot[i]);\n\n\t/*\n\t * The end of the static region needs to be aligned with the\n\t * minimum allocation size as this offsets the reserved and\n\t * dynamic region.  The first chunk ends page aligned by\n\t * expanding the dynamic region, therefore the dynamic region\n\t * can be shrunk to compensate while still staying above the\n\t * configured sizes.\n\t */\n\tstatic_size = ALIGN(ai->static_size, PCPU_MIN_ALLOC_SIZE);\n\tdyn_size = ai->dyn_size - (static_size - ai->static_size);\n\n\t/*\n\t * Initialize first chunk.\n\t * If the reserved_size is non-zero, this initializes the reserved\n\t * chunk.  If the reserved_size is zero, the reserved chunk is NULL\n\t * and the dynamic region is initialized here.  The first chunk,\n\t * pcpu_first_chunk, will always point to the chunk that serves\n\t * the dynamic region.\n\t */\n\ttmp_addr = (unsigned long)base_addr + static_size;\n\tmap_size = ai->reserved_size ?: dyn_size;\n\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\n\t/* init dynamic chunk if necessary */\n\tif (ai->reserved_size) {\n\t\tpcpu_reserved_chunk = chunk;\n\n\t\ttmp_addr = (unsigned long)base_addr + static_size +\n\t\t\t   ai->reserved_size;\n\t\tmap_size = dyn_size;\n\t\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\t}\n\n\t/* link the first chunk in */\n\tpcpu_first_chunk = chunk;\n\tpcpu_nr_empty_pop_pages = pcpu_first_chunk->nr_empty_pop_pages;\n\tpcpu_chunk_relocate(pcpu_first_chunk, -1);\n\n\t/* include all regions of the first chunk */\n\tpcpu_nr_populated += PFN_DOWN(size_sum);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(base_addr);\n\n\t/* we're done */\n\tpcpu_base_addr = base_addr;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Embedded %zu pages/cpu @%p s%zu r%zu d%zu u%zu\\n\"",
            "PFN_DOWN(size_sum)",
            "base",
            "ai->static_size",
            "ai->reserved_size",
            "ai->dyn_size",
            "ai->unit_size"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "size_sum"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_fn",
          "args": [
            "ptr + size_sum",
            "ai->unit_size - size_sum"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "__per_cpu_load",
            "ai->static_size"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_fn",
          "args": [
            "ptr",
            "ai->unit_size"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"max_distance=0x%lx too large for vmalloc space 0x%lx\\n\"",
            "max_distance",
            "VMALLOC_TOTAL"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ptr",
            "base"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_free",
          "args": [
            "ptr"
          ],
          "line": 2487
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1082-1094",
          "snippet": "void __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_free_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_fn",
          "args": [
            "cpu",
            "gi->nr_units * ai->unit_size",
            "atom_size"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpu == NR_CPUS"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_nopanic",
          "args": [
            "areas_size",
            "SMP_CACHE_BYTES"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_ALIGN",
          "args": [
            "ai->nr_groups * sizeof(void *)"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ai"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ai"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_build_alloc_info",
          "args": [
            "reserved_size",
            "dyn_size",
            "atom_size",
            "cpu_distance_fn"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_build_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "2273-2406",
          "snippet": "static struct pcpu_alloc_info * __init pcpu_build_alloc_info(\n\t\t\t\tsize_t reserved_size, size_t dyn_size,\n\t\t\t\tsize_t atom_size,\n\t\t\t\tpcpu_fc_cpu_distance_fn_t cpu_distance_fn)\n{\n\tstatic int group_map[NR_CPUS] __initdata;\n\tstatic int group_cnt[NR_CPUS] __initdata;\n\tconst size_t static_size = __per_cpu_end - __per_cpu_start;\n\tint nr_groups = 1, nr_units = 0;\n\tsize_t size_sum, min_unit_size, alloc_size;\n\tint upa, max_upa, uninitialized_var(best_upa);\t/* units_per_alloc */\n\tint last_allocs, group, unit;\n\tunsigned int cpu, tcpu;\n\tstruct pcpu_alloc_info *ai;\n\tunsigned int *cpu_map;\n\n\t/* this function may be called multiple times */\n\tmemset(group_map, 0, sizeof(group_map));\n\tmemset(group_cnt, 0, sizeof(group_cnt));\n\n\t/* calculate size_sum and ensure dyn_size is enough for early alloc */\n\tsize_sum = PFN_ALIGN(static_size + reserved_size +\n\t\t\t    max_t(size_t, dyn_size, PERCPU_DYNAMIC_EARLY_SIZE));\n\tdyn_size = size_sum - static_size - reserved_size;\n\n\t/*\n\t * Determine min_unit_size, alloc_size and max_upa such that\n\t * alloc_size is multiple of atom_size and is the smallest\n\t * which can accommodate 4k aligned segments which are equal to\n\t * or larger than min_unit_size.\n\t */\n\tmin_unit_size = max_t(size_t, size_sum, PCPU_MIN_UNIT_SIZE);\n\n\t/* determine the maximum # of units that can fit in an allocation */\n\talloc_size = roundup(min_unit_size, atom_size);\n\tupa = alloc_size / min_unit_size;\n\twhile (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\tupa--;\n\tmax_upa = upa;\n\n\t/* group cpus according to their proximity */\n\tfor_each_possible_cpu(cpu) {\n\t\tgroup = 0;\n\tnext_group:\n\t\tfor_each_possible_cpu(tcpu) {\n\t\t\tif (cpu == tcpu)\n\t\t\t\tbreak;\n\t\t\tif (group_map[tcpu] == group && cpu_distance_fn &&\n\t\t\t    (cpu_distance_fn(cpu, tcpu) > LOCAL_DISTANCE ||\n\t\t\t     cpu_distance_fn(tcpu, cpu) > LOCAL_DISTANCE)) {\n\t\t\t\tgroup++;\n\t\t\t\tnr_groups = max(nr_groups, group + 1);\n\t\t\t\tgoto next_group;\n\t\t\t}\n\t\t}\n\t\tgroup_map[cpu] = group;\n\t\tgroup_cnt[group]++;\n\t}\n\n\t/*\n\t * Wasted space is caused by a ratio imbalance of upa to group_cnt.\n\t * Expand the unit_size until we use >= 75% of the units allocated.\n\t * Related to atom_size, which could be much larger than the unit_size.\n\t */\n\tlast_allocs = INT_MAX;\n\tfor (upa = max_upa; upa; upa--) {\n\t\tint allocs = 0, wasted = 0;\n\n\t\tif (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\t\tcontinue;\n\n\t\tfor (group = 0; group < nr_groups; group++) {\n\t\t\tint this_allocs = DIV_ROUND_UP(group_cnt[group], upa);\n\t\t\tallocs += this_allocs;\n\t\t\twasted += this_allocs * upa - group_cnt[group];\n\t\t}\n\n\t\t/*\n\t\t * Don't accept if wastage is over 1/3.  The\n\t\t * greater-than comparison ensures upa==1 always\n\t\t * passes the following check.\n\t\t */\n\t\tif (wasted > num_possible_cpus() / 3)\n\t\t\tcontinue;\n\n\t\t/* and then don't consume more memory */\n\t\tif (allocs > last_allocs)\n\t\t\tbreak;\n\t\tlast_allocs = allocs;\n\t\tbest_upa = upa;\n\t}\n\tupa = best_upa;\n\n\t/* allocate and fill alloc_info */\n\tfor (group = 0; group < nr_groups; group++)\n\t\tnr_units += roundup(group_cnt[group], upa);\n\n\tai = pcpu_alloc_alloc_info(nr_groups, nr_units);\n\tif (!ai)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcpu_map = ai->groups[0].cpu_map;\n\n\tfor (group = 0; group < nr_groups; group++) {\n\t\tai->groups[group].cpu_map = cpu_map;\n\t\tcpu_map += roundup(group_cnt[group], upa);\n\t}\n\n\tai->static_size = static_size;\n\tai->reserved_size = reserved_size;\n\tai->dyn_size = dyn_size;\n\tai->unit_size = alloc_size / upa;\n\tai->atom_size = atom_size;\n\tai->alloc_size = alloc_size;\n\n\tfor (group = 0, unit = 0; group_cnt[group]; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\n\t\t/*\n\t\t * Initialize base_offset as if all groups are located\n\t\t * back-to-back.  The caller should update this to\n\t\t * reflect actual allocation.\n\t\t */\n\t\tgi->base_offset = unit * ai->unit_size;\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tif (group_map[cpu] == group)\n\t\t\t\tgi->cpu_map[gi->nr_units++] = cpu;\n\t\tgi->nr_units = roundup(gi->nr_units, upa);\n\t\tunit += gi->nr_units;\n\t}\n\tBUG_ON(unit != nr_units);\n\n\treturn ai;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nstatic struct pcpu_alloc_info * __init pcpu_build_alloc_info(\n\t\t\t\tsize_t reserved_size, size_t dyn_size,\n\t\t\t\tsize_t atom_size,\n\t\t\t\tpcpu_fc_cpu_distance_fn_t cpu_distance_fn)\n{\n\tstatic int group_map[NR_CPUS] __initdata;\n\tstatic int group_cnt[NR_CPUS] __initdata;\n\tconst size_t static_size = __per_cpu_end - __per_cpu_start;\n\tint nr_groups = 1, nr_units = 0;\n\tsize_t size_sum, min_unit_size, alloc_size;\n\tint upa, max_upa, uninitialized_var(best_upa);\t/* units_per_alloc */\n\tint last_allocs, group, unit;\n\tunsigned int cpu, tcpu;\n\tstruct pcpu_alloc_info *ai;\n\tunsigned int *cpu_map;\n\n\t/* this function may be called multiple times */\n\tmemset(group_map, 0, sizeof(group_map));\n\tmemset(group_cnt, 0, sizeof(group_cnt));\n\n\t/* calculate size_sum and ensure dyn_size is enough for early alloc */\n\tsize_sum = PFN_ALIGN(static_size + reserved_size +\n\t\t\t    max_t(size_t, dyn_size, PERCPU_DYNAMIC_EARLY_SIZE));\n\tdyn_size = size_sum - static_size - reserved_size;\n\n\t/*\n\t * Determine min_unit_size, alloc_size and max_upa such that\n\t * alloc_size is multiple of atom_size and is the smallest\n\t * which can accommodate 4k aligned segments which are equal to\n\t * or larger than min_unit_size.\n\t */\n\tmin_unit_size = max_t(size_t, size_sum, PCPU_MIN_UNIT_SIZE);\n\n\t/* determine the maximum # of units that can fit in an allocation */\n\talloc_size = roundup(min_unit_size, atom_size);\n\tupa = alloc_size / min_unit_size;\n\twhile (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\tupa--;\n\tmax_upa = upa;\n\n\t/* group cpus according to their proximity */\n\tfor_each_possible_cpu(cpu) {\n\t\tgroup = 0;\n\tnext_group:\n\t\tfor_each_possible_cpu(tcpu) {\n\t\t\tif (cpu == tcpu)\n\t\t\t\tbreak;\n\t\t\tif (group_map[tcpu] == group && cpu_distance_fn &&\n\t\t\t    (cpu_distance_fn(cpu, tcpu) > LOCAL_DISTANCE ||\n\t\t\t     cpu_distance_fn(tcpu, cpu) > LOCAL_DISTANCE)) {\n\t\t\t\tgroup++;\n\t\t\t\tnr_groups = max(nr_groups, group + 1);\n\t\t\t\tgoto next_group;\n\t\t\t}\n\t\t}\n\t\tgroup_map[cpu] = group;\n\t\tgroup_cnt[group]++;\n\t}\n\n\t/*\n\t * Wasted space is caused by a ratio imbalance of upa to group_cnt.\n\t * Expand the unit_size until we use >= 75% of the units allocated.\n\t * Related to atom_size, which could be much larger than the unit_size.\n\t */\n\tlast_allocs = INT_MAX;\n\tfor (upa = max_upa; upa; upa--) {\n\t\tint allocs = 0, wasted = 0;\n\n\t\tif (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\t\tcontinue;\n\n\t\tfor (group = 0; group < nr_groups; group++) {\n\t\t\tint this_allocs = DIV_ROUND_UP(group_cnt[group], upa);\n\t\t\tallocs += this_allocs;\n\t\t\twasted += this_allocs * upa - group_cnt[group];\n\t\t}\n\n\t\t/*\n\t\t * Don't accept if wastage is over 1/3.  The\n\t\t * greater-than comparison ensures upa==1 always\n\t\t * passes the following check.\n\t\t */\n\t\tif (wasted > num_possible_cpus() / 3)\n\t\t\tcontinue;\n\n\t\t/* and then don't consume more memory */\n\t\tif (allocs > last_allocs)\n\t\t\tbreak;\n\t\tlast_allocs = allocs;\n\t\tbest_upa = upa;\n\t}\n\tupa = best_upa;\n\n\t/* allocate and fill alloc_info */\n\tfor (group = 0; group < nr_groups; group++)\n\t\tnr_units += roundup(group_cnt[group], upa);\n\n\tai = pcpu_alloc_alloc_info(nr_groups, nr_units);\n\tif (!ai)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcpu_map = ai->groups[0].cpu_map;\n\n\tfor (group = 0; group < nr_groups; group++) {\n\t\tai->groups[group].cpu_map = cpu_map;\n\t\tcpu_map += roundup(group_cnt[group], upa);\n\t}\n\n\tai->static_size = static_size;\n\tai->reserved_size = reserved_size;\n\tai->dyn_size = dyn_size;\n\tai->unit_size = alloc_size / upa;\n\tai->atom_size = atom_size;\n\tai->alloc_size = alloc_size;\n\n\tfor (group = 0, unit = 0; group_cnt[group]; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\n\t\t/*\n\t\t * Initialize base_offset as if all groups are located\n\t\t * back-to-back.  The caller should update this to\n\t\t * reflect actual allocation.\n\t\t */\n\t\tgi->base_offset = unit * ai->unit_size;\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tif (group_map[cpu] == group)\n\t\t\t\tgi->cpu_map[gi->nr_units++] = cpu;\n\t\tgi->nr_units = roundup(gi->nr_units, upa);\n\t\tunit += gi->nr_units;\n\t}\n\tBUG_ON(unit != nr_units);\n\n\treturn ai;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nint __init pcpu_embed_first_chunk(size_t reserved_size, size_t dyn_size,\n\t\t\t\t  size_t atom_size,\n\t\t\t\t  pcpu_fc_cpu_distance_fn_t cpu_distance_fn,\n\t\t\t\t  pcpu_fc_alloc_fn_t alloc_fn,\n\t\t\t\t  pcpu_fc_free_fn_t free_fn)\n{\n\tvoid *base = (void *)ULONG_MAX;\n\tvoid **areas = NULL;\n\tstruct pcpu_alloc_info *ai;\n\tsize_t size_sum, areas_size;\n\tunsigned long max_distance;\n\tint group, i, highest_group, rc;\n\n\tai = pcpu_build_alloc_info(reserved_size, dyn_size, atom_size,\n\t\t\t\t   cpu_distance_fn);\n\tif (IS_ERR(ai))\n\t\treturn PTR_ERR(ai);\n\n\tsize_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tareas_size = PFN_ALIGN(ai->nr_groups * sizeof(void *));\n\n\tareas = memblock_alloc_nopanic(areas_size, SMP_CACHE_BYTES);\n\tif (!areas) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* allocate, copy and determine base address & max_distance */\n\thighest_group = 0;\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\t\tunsigned int cpu = NR_CPUS;\n\t\tvoid *ptr;\n\n\t\tfor (i = 0; i < gi->nr_units && cpu == NR_CPUS; i++)\n\t\t\tcpu = gi->cpu_map[i];\n\t\tBUG_ON(cpu == NR_CPUS);\n\n\t\t/* allocate space for the whole group */\n\t\tptr = alloc_fn(cpu, gi->nr_units * ai->unit_size, atom_size);\n\t\tif (!ptr) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_free_areas;\n\t\t}\n\t\t/* kmemleak tracks the percpu allocations separately */\n\t\tkmemleak_free(ptr);\n\t\tareas[group] = ptr;\n\n\t\tbase = min(ptr, base);\n\t\tif (ptr > areas[highest_group])\n\t\t\thighest_group = group;\n\t}\n\tmax_distance = areas[highest_group] - base;\n\tmax_distance += ai->unit_size * ai->groups[highest_group].nr_units;\n\n\t/* warn if maximum distance is further than 75% of vmalloc space */\n\tif (max_distance > VMALLOC_TOTAL * 3 / 4) {\n\t\tpr_warn(\"max_distance=0x%lx too large for vmalloc space 0x%lx\\n\",\n\t\t\t\tmax_distance, VMALLOC_TOTAL);\n#ifdef CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK\n\t\t/* and fail if we have fallback */\n\t\trc = -EINVAL;\n\t\tgoto out_free_areas;\n#endif\n\t}\n\n\t/*\n\t * Copy data and free unused parts.  This should happen after all\n\t * allocations are complete; otherwise, we may end up with\n\t * overlapping groups.\n\t */\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\t\tvoid *ptr = areas[group];\n\n\t\tfor (i = 0; i < gi->nr_units; i++, ptr += ai->unit_size) {\n\t\t\tif (gi->cpu_map[i] == NR_CPUS) {\n\t\t\t\t/* unused unit, free whole */\n\t\t\t\tfree_fn(ptr, ai->unit_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* copy and return the unused part */\n\t\t\tmemcpy(ptr, __per_cpu_load, ai->static_size);\n\t\t\tfree_fn(ptr + size_sum, ai->unit_size - size_sum);\n\t\t}\n\t}\n\n\t/* base address is now known, determine group base offsets */\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tai->groups[group].base_offset = areas[group] - base;\n\t}\n\n\tpr_info(\"Embedded %zu pages/cpu @%p s%zu r%zu d%zu u%zu\\n\",\n\t\tPFN_DOWN(size_sum), base, ai->static_size, ai->reserved_size,\n\t\tai->dyn_size, ai->unit_size);\n\n\trc = pcpu_setup_first_chunk(ai, base);\n\tgoto out_free;\n\nout_free_areas:\n\tfor (group = 0; group < ai->nr_groups; group++)\n\t\tif (areas[group])\n\t\t\tfree_fn(areas[group],\n\t\t\t\tai->groups[group].nr_units * ai->unit_size);\nout_free:\n\tpcpu_free_alloc_info(ai);\n\tif (areas)\n\t\tmemblock_free_early(__pa(areas), areas_size);\n\treturn rc;\n}"
  },
  {
    "function_name": "pcpu_build_alloc_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "2273-2406",
    "snippet": "static struct pcpu_alloc_info * __init pcpu_build_alloc_info(\n\t\t\t\tsize_t reserved_size, size_t dyn_size,\n\t\t\t\tsize_t atom_size,\n\t\t\t\tpcpu_fc_cpu_distance_fn_t cpu_distance_fn)\n{\n\tstatic int group_map[NR_CPUS] __initdata;\n\tstatic int group_cnt[NR_CPUS] __initdata;\n\tconst size_t static_size = __per_cpu_end - __per_cpu_start;\n\tint nr_groups = 1, nr_units = 0;\n\tsize_t size_sum, min_unit_size, alloc_size;\n\tint upa, max_upa, uninitialized_var(best_upa);\t/* units_per_alloc */\n\tint last_allocs, group, unit;\n\tunsigned int cpu, tcpu;\n\tstruct pcpu_alloc_info *ai;\n\tunsigned int *cpu_map;\n\n\t/* this function may be called multiple times */\n\tmemset(group_map, 0, sizeof(group_map));\n\tmemset(group_cnt, 0, sizeof(group_cnt));\n\n\t/* calculate size_sum and ensure dyn_size is enough for early alloc */\n\tsize_sum = PFN_ALIGN(static_size + reserved_size +\n\t\t\t    max_t(size_t, dyn_size, PERCPU_DYNAMIC_EARLY_SIZE));\n\tdyn_size = size_sum - static_size - reserved_size;\n\n\t/*\n\t * Determine min_unit_size, alloc_size and max_upa such that\n\t * alloc_size is multiple of atom_size and is the smallest\n\t * which can accommodate 4k aligned segments which are equal to\n\t * or larger than min_unit_size.\n\t */\n\tmin_unit_size = max_t(size_t, size_sum, PCPU_MIN_UNIT_SIZE);\n\n\t/* determine the maximum # of units that can fit in an allocation */\n\talloc_size = roundup(min_unit_size, atom_size);\n\tupa = alloc_size / min_unit_size;\n\twhile (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\tupa--;\n\tmax_upa = upa;\n\n\t/* group cpus according to their proximity */\n\tfor_each_possible_cpu(cpu) {\n\t\tgroup = 0;\n\tnext_group:\n\t\tfor_each_possible_cpu(tcpu) {\n\t\t\tif (cpu == tcpu)\n\t\t\t\tbreak;\n\t\t\tif (group_map[tcpu] == group && cpu_distance_fn &&\n\t\t\t    (cpu_distance_fn(cpu, tcpu) > LOCAL_DISTANCE ||\n\t\t\t     cpu_distance_fn(tcpu, cpu) > LOCAL_DISTANCE)) {\n\t\t\t\tgroup++;\n\t\t\t\tnr_groups = max(nr_groups, group + 1);\n\t\t\t\tgoto next_group;\n\t\t\t}\n\t\t}\n\t\tgroup_map[cpu] = group;\n\t\tgroup_cnt[group]++;\n\t}\n\n\t/*\n\t * Wasted space is caused by a ratio imbalance of upa to group_cnt.\n\t * Expand the unit_size until we use >= 75% of the units allocated.\n\t * Related to atom_size, which could be much larger than the unit_size.\n\t */\n\tlast_allocs = INT_MAX;\n\tfor (upa = max_upa; upa; upa--) {\n\t\tint allocs = 0, wasted = 0;\n\n\t\tif (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\t\tcontinue;\n\n\t\tfor (group = 0; group < nr_groups; group++) {\n\t\t\tint this_allocs = DIV_ROUND_UP(group_cnt[group], upa);\n\t\t\tallocs += this_allocs;\n\t\t\twasted += this_allocs * upa - group_cnt[group];\n\t\t}\n\n\t\t/*\n\t\t * Don't accept if wastage is over 1/3.  The\n\t\t * greater-than comparison ensures upa==1 always\n\t\t * passes the following check.\n\t\t */\n\t\tif (wasted > num_possible_cpus() / 3)\n\t\t\tcontinue;\n\n\t\t/* and then don't consume more memory */\n\t\tif (allocs > last_allocs)\n\t\t\tbreak;\n\t\tlast_allocs = allocs;\n\t\tbest_upa = upa;\n\t}\n\tupa = best_upa;\n\n\t/* allocate and fill alloc_info */\n\tfor (group = 0; group < nr_groups; group++)\n\t\tnr_units += roundup(group_cnt[group], upa);\n\n\tai = pcpu_alloc_alloc_info(nr_groups, nr_units);\n\tif (!ai)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcpu_map = ai->groups[0].cpu_map;\n\n\tfor (group = 0; group < nr_groups; group++) {\n\t\tai->groups[group].cpu_map = cpu_map;\n\t\tcpu_map += roundup(group_cnt[group], upa);\n\t}\n\n\tai->static_size = static_size;\n\tai->reserved_size = reserved_size;\n\tai->dyn_size = dyn_size;\n\tai->unit_size = alloc_size / upa;\n\tai->atom_size = atom_size;\n\tai->alloc_size = alloc_size;\n\n\tfor (group = 0, unit = 0; group_cnt[group]; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\n\t\t/*\n\t\t * Initialize base_offset as if all groups are located\n\t\t * back-to-back.  The caller should update this to\n\t\t * reflect actual allocation.\n\t\t */\n\t\tgi->base_offset = unit * ai->unit_size;\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tif (group_map[cpu] == group)\n\t\t\t\tgi->cpu_map[gi->nr_units++] = cpu;\n\t\tgi->nr_units = roundup(gi->nr_units, upa);\n\t\tunit += gi->nr_units;\n\t}\n\tBUG_ON(unit != nr_units);\n\n\treturn ai;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "unit != nr_units"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "gi->nr_units",
            "upa"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "group_cnt[group]",
            "upa"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_alloc_alloc_info",
          "args": [
            "nr_groups",
            "nr_units"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_alloc_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1879-1906",
          "snippet": "struct pcpu_alloc_info * __init pcpu_alloc_alloc_info(int nr_groups,\n\t\t\t\t\t\t      int nr_units)\n{\n\tstruct pcpu_alloc_info *ai;\n\tsize_t base_size, ai_size;\n\tvoid *ptr;\n\tint unit;\n\n\tbase_size = ALIGN(sizeof(*ai) + nr_groups * sizeof(ai->groups[0]),\n\t\t\t  __alignof__(ai->groups[0].cpu_map[0]));\n\tai_size = base_size + nr_units * sizeof(ai->groups[0].cpu_map[0]);\n\n\tptr = memblock_alloc_nopanic(PFN_ALIGN(ai_size), PAGE_SIZE);\n\tif (!ptr)\n\t\treturn NULL;\n\tai = ptr;\n\tptr += base_size;\n\n\tai->groups[0].cpu_map = ptr;\n\n\tfor (unit = 0; unit < nr_units; unit++)\n\t\tai->groups[0].cpu_map[unit] = NR_CPUS;\n\n\tai->nr_groups = nr_groups;\n\tai->__ai_size = PFN_ALIGN(ai_size);\n\n\treturn ai;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nstruct pcpu_alloc_info * __init pcpu_alloc_alloc_info(int nr_groups,\n\t\t\t\t\t\t      int nr_units)\n{\n\tstruct pcpu_alloc_info *ai;\n\tsize_t base_size, ai_size;\n\tvoid *ptr;\n\tint unit;\n\n\tbase_size = ALIGN(sizeof(*ai) + nr_groups * sizeof(ai->groups[0]),\n\t\t\t  __alignof__(ai->groups[0].cpu_map[0]));\n\tai_size = base_size + nr_units * sizeof(ai->groups[0].cpu_map[0]);\n\n\tptr = memblock_alloc_nopanic(PFN_ALIGN(ai_size), PAGE_SIZE);\n\tif (!ptr)\n\t\treturn NULL;\n\tai = ptr;\n\tptr += base_size;\n\n\tai->groups[0].cpu_map = ptr;\n\n\tfor (unit = 0; unit < nr_units; unit++)\n\t\tai->groups[0].cpu_map[unit] = NR_CPUS;\n\n\tai->nr_groups = nr_groups;\n\tai->__ai_size = PFN_ALIGN(ai_size);\n\n\treturn ai;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "group_cnt[group]",
            "upa"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "group_cnt[group]",
            "upa"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "alloc_size / upa"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nr_groups",
            "group + 1"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_distance_fn",
          "args": [
            "tcpu",
            "cpu"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_distance_fn",
          "args": [
            "cpu",
            "tcpu"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "alloc_size / upa"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "min_unit_size",
            "atom_size"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "size_sum",
            "PCPU_MIN_UNIT_SIZE"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_ALIGN",
          "args": [
            "static_size + reserved_size +\n\t\t\t    max_t(size_t, dyn_size, PERCPU_DYNAMIC_EARLY_SIZE)"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "dyn_size",
            "PERCPU_DYNAMIC_EARLY_SIZE"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "group_cnt",
            "0",
            "sizeof(group_cnt)"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nstatic struct pcpu_alloc_info * __init pcpu_build_alloc_info(\n\t\t\t\tsize_t reserved_size, size_t dyn_size,\n\t\t\t\tsize_t atom_size,\n\t\t\t\tpcpu_fc_cpu_distance_fn_t cpu_distance_fn)\n{\n\tstatic int group_map[NR_CPUS] __initdata;\n\tstatic int group_cnt[NR_CPUS] __initdata;\n\tconst size_t static_size = __per_cpu_end - __per_cpu_start;\n\tint nr_groups = 1, nr_units = 0;\n\tsize_t size_sum, min_unit_size, alloc_size;\n\tint upa, max_upa, uninitialized_var(best_upa);\t/* units_per_alloc */\n\tint last_allocs, group, unit;\n\tunsigned int cpu, tcpu;\n\tstruct pcpu_alloc_info *ai;\n\tunsigned int *cpu_map;\n\n\t/* this function may be called multiple times */\n\tmemset(group_map, 0, sizeof(group_map));\n\tmemset(group_cnt, 0, sizeof(group_cnt));\n\n\t/* calculate size_sum and ensure dyn_size is enough for early alloc */\n\tsize_sum = PFN_ALIGN(static_size + reserved_size +\n\t\t\t    max_t(size_t, dyn_size, PERCPU_DYNAMIC_EARLY_SIZE));\n\tdyn_size = size_sum - static_size - reserved_size;\n\n\t/*\n\t * Determine min_unit_size, alloc_size and max_upa such that\n\t * alloc_size is multiple of atom_size and is the smallest\n\t * which can accommodate 4k aligned segments which are equal to\n\t * or larger than min_unit_size.\n\t */\n\tmin_unit_size = max_t(size_t, size_sum, PCPU_MIN_UNIT_SIZE);\n\n\t/* determine the maximum # of units that can fit in an allocation */\n\talloc_size = roundup(min_unit_size, atom_size);\n\tupa = alloc_size / min_unit_size;\n\twhile (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\tupa--;\n\tmax_upa = upa;\n\n\t/* group cpus according to their proximity */\n\tfor_each_possible_cpu(cpu) {\n\t\tgroup = 0;\n\tnext_group:\n\t\tfor_each_possible_cpu(tcpu) {\n\t\t\tif (cpu == tcpu)\n\t\t\t\tbreak;\n\t\t\tif (group_map[tcpu] == group && cpu_distance_fn &&\n\t\t\t    (cpu_distance_fn(cpu, tcpu) > LOCAL_DISTANCE ||\n\t\t\t     cpu_distance_fn(tcpu, cpu) > LOCAL_DISTANCE)) {\n\t\t\t\tgroup++;\n\t\t\t\tnr_groups = max(nr_groups, group + 1);\n\t\t\t\tgoto next_group;\n\t\t\t}\n\t\t}\n\t\tgroup_map[cpu] = group;\n\t\tgroup_cnt[group]++;\n\t}\n\n\t/*\n\t * Wasted space is caused by a ratio imbalance of upa to group_cnt.\n\t * Expand the unit_size until we use >= 75% of the units allocated.\n\t * Related to atom_size, which could be much larger than the unit_size.\n\t */\n\tlast_allocs = INT_MAX;\n\tfor (upa = max_upa; upa; upa--) {\n\t\tint allocs = 0, wasted = 0;\n\n\t\tif (alloc_size % upa || (offset_in_page(alloc_size / upa)))\n\t\t\tcontinue;\n\n\t\tfor (group = 0; group < nr_groups; group++) {\n\t\t\tint this_allocs = DIV_ROUND_UP(group_cnt[group], upa);\n\t\t\tallocs += this_allocs;\n\t\t\twasted += this_allocs * upa - group_cnt[group];\n\t\t}\n\n\t\t/*\n\t\t * Don't accept if wastage is over 1/3.  The\n\t\t * greater-than comparison ensures upa==1 always\n\t\t * passes the following check.\n\t\t */\n\t\tif (wasted > num_possible_cpus() / 3)\n\t\t\tcontinue;\n\n\t\t/* and then don't consume more memory */\n\t\tif (allocs > last_allocs)\n\t\t\tbreak;\n\t\tlast_allocs = allocs;\n\t\tbest_upa = upa;\n\t}\n\tupa = best_upa;\n\n\t/* allocate and fill alloc_info */\n\tfor (group = 0; group < nr_groups; group++)\n\t\tnr_units += roundup(group_cnt[group], upa);\n\n\tai = pcpu_alloc_alloc_info(nr_groups, nr_units);\n\tif (!ai)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcpu_map = ai->groups[0].cpu_map;\n\n\tfor (group = 0; group < nr_groups; group++) {\n\t\tai->groups[group].cpu_map = cpu_map;\n\t\tcpu_map += roundup(group_cnt[group], upa);\n\t}\n\n\tai->static_size = static_size;\n\tai->reserved_size = reserved_size;\n\tai->dyn_size = dyn_size;\n\tai->unit_size = alloc_size / upa;\n\tai->atom_size = atom_size;\n\tai->alloc_size = alloc_size;\n\n\tfor (group = 0, unit = 0; group_cnt[group]; group++) {\n\t\tstruct pcpu_group_info *gi = &ai->groups[group];\n\n\t\t/*\n\t\t * Initialize base_offset as if all groups are located\n\t\t * back-to-back.  The caller should update this to\n\t\t * reflect actual allocation.\n\t\t */\n\t\tgi->base_offset = unit * ai->unit_size;\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tif (group_map[cpu] == group)\n\t\t\t\tgi->cpu_map[gi->nr_units++] = cpu;\n\t\tgi->nr_units = roundup(gi->nr_units, upa);\n\t\tunit += gi->nr_units;\n\t}\n\tBUG_ON(unit != nr_units);\n\n\treturn ai;\n}"
  },
  {
    "function_name": "percpu_alloc_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "2213-2232",
    "snippet": "static int __init percpu_alloc_setup(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (0)\n\t\t/* nada */;\n#ifdef CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK\n\telse if (!strcmp(str, \"embed\"))\n\t\tpcpu_chosen_fc = PCPU_FC_EMBED;\n#endif\n#ifdef CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK\n\telse if (!strcmp(str, \"page\"))\n\t\tpcpu_chosen_fc = PCPU_FC_PAGE;\n#endif\n\telse\n\t\tpr_warn(\"unknown allocator %s specified\\n\", str);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"page\""
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"embed\""
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init percpu_alloc_setup(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (0)\n\t\t/* nada */;\n#ifdef CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK\n\telse if (!strcmp(str, \"embed\"))\n\t\tpcpu_chosen_fc = PCPU_FC_EMBED;\n#endif\n#ifdef CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK\n\telse if (!strcmp(str, \"page\"))\n\t\tpcpu_chosen_fc = PCPU_FC_PAGE;\n#endif\n\telse\n\t\tpr_warn(\"unknown allocator %s specified\\n\", str);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pcpu_setup_first_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "2033-2201",
    "snippet": "int __init pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai,\n\t\t\t\t  void *base_addr)\n{\n\tsize_t size_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tsize_t static_size, dyn_size;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long *group_offsets;\n\tsize_t *group_sizes;\n\tunsigned long *unit_off;\n\tunsigned int cpu;\n\tint *unit_map;\n\tint group, unit, i;\n\tint map_size;\n\tunsigned long tmp_addr;\n\n#define PCPU_SETUP_BUG_ON(cond)\tdo {\t\t\t\t\t\\\n\tif (unlikely(cond)) {\t\t\t\t\t\t\\\n\t\tpr_emerg(\"failed to initialize, %s\\n\", #cond);\t\t\\\n\t\tpr_emerg(\"cpu_possible_mask=%*pb\\n\",\t\t\t\\\n\t\t\t cpumask_pr_args(cpu_possible_mask));\t\t\\\n\t\tpcpu_dump_alloc_info(KERN_EMERG, ai);\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\t/* sanity checks */\n\tPCPU_SETUP_BUG_ON(ai->nr_groups <= 0);\n#ifdef CONFIG_SMP\n\tPCPU_SETUP_BUG_ON(!ai->static_size);\n\tPCPU_SETUP_BUG_ON(offset_in_page(__per_cpu_start));\n#endif\n\tPCPU_SETUP_BUG_ON(!base_addr);\n\tPCPU_SETUP_BUG_ON(offset_in_page(base_addr));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < size_sum);\n\tPCPU_SETUP_BUG_ON(offset_in_page(ai->unit_size));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < PCPU_MIN_UNIT_SIZE);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->unit_size, PCPU_BITMAP_BLOCK_SIZE));\n\tPCPU_SETUP_BUG_ON(ai->dyn_size < PERCPU_DYNAMIC_EARLY_SIZE);\n\tPCPU_SETUP_BUG_ON(!ai->dyn_size);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->reserved_size, PCPU_MIN_ALLOC_SIZE));\n\tPCPU_SETUP_BUG_ON(!(IS_ALIGNED(PCPU_BITMAP_BLOCK_SIZE, PAGE_SIZE) ||\n\t\t\t    IS_ALIGNED(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE)));\n\tPCPU_SETUP_BUG_ON(pcpu_verify_alloc_info(ai) < 0);\n\n\t/* process group information and build config tables accordingly */\n\tgroup_offsets = memblock_alloc(ai->nr_groups * sizeof(group_offsets[0]),\n\t\t\t\t       SMP_CACHE_BYTES);\n\tgroup_sizes = memblock_alloc(ai->nr_groups * sizeof(group_sizes[0]),\n\t\t\t\t     SMP_CACHE_BYTES);\n\tunit_map = memblock_alloc(nr_cpu_ids * sizeof(unit_map[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\tunit_off = memblock_alloc(nr_cpu_ids * sizeof(unit_off[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tunit_map[cpu] = UINT_MAX;\n\n\tpcpu_low_unit_cpu = NR_CPUS;\n\tpcpu_high_unit_cpu = NR_CPUS;\n\n\tfor (group = 0, unit = 0; group < ai->nr_groups; group++, unit += i) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\n\t\tgroup_offsets[group] = gi->base_offset;\n\t\tgroup_sizes[group] = gi->nr_units * ai->unit_size;\n\n\t\tfor (i = 0; i < gi->nr_units; i++) {\n\t\t\tcpu = gi->cpu_map[i];\n\t\t\tif (cpu == NR_CPUS)\n\t\t\t\tcontinue;\n\n\t\t\tPCPU_SETUP_BUG_ON(cpu >= nr_cpu_ids);\n\t\t\tPCPU_SETUP_BUG_ON(!cpu_possible(cpu));\n\t\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] != UINT_MAX);\n\n\t\t\tunit_map[cpu] = unit + i;\n\t\t\tunit_off[cpu] = gi->base_offset + i * ai->unit_size;\n\n\t\t\t/* determine low/high unit_cpu */\n\t\t\tif (pcpu_low_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] < unit_off[pcpu_low_unit_cpu])\n\t\t\t\tpcpu_low_unit_cpu = cpu;\n\t\t\tif (pcpu_high_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] > unit_off[pcpu_high_unit_cpu])\n\t\t\t\tpcpu_high_unit_cpu = cpu;\n\t\t}\n\t}\n\tpcpu_nr_units = unit;\n\n\tfor_each_possible_cpu(cpu)\n\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] == UINT_MAX);\n\n\t/* we're done parsing the input, undefine BUG macro and dump config */\n#undef PCPU_SETUP_BUG_ON\n\tpcpu_dump_alloc_info(KERN_DEBUG, ai);\n\n\tpcpu_nr_groups = ai->nr_groups;\n\tpcpu_group_offsets = group_offsets;\n\tpcpu_group_sizes = group_sizes;\n\tpcpu_unit_map = unit_map;\n\tpcpu_unit_offsets = unit_off;\n\n\t/* determine basic parameters */\n\tpcpu_unit_pages = ai->unit_size >> PAGE_SHIFT;\n\tpcpu_unit_size = pcpu_unit_pages << PAGE_SHIFT;\n\tpcpu_atom_size = ai->atom_size;\n\tpcpu_chunk_struct_size = sizeof(struct pcpu_chunk) +\n\t\tBITS_TO_LONGS(pcpu_unit_pages) * sizeof(unsigned long);\n\n\tpcpu_stats_save_ai(ai);\n\n\t/*\n\t * Allocate chunk slots.  The additional last slot is for\n\t * empty chunks.\n\t */\n\tpcpu_nr_slots = __pcpu_size_to_slot(pcpu_unit_size) + 2;\n\tpcpu_slot = memblock_alloc(pcpu_nr_slots * sizeof(pcpu_slot[0]),\n\t\t\t\t   SMP_CACHE_BYTES);\n\tfor (i = 0; i < pcpu_nr_slots; i++)\n\t\tINIT_LIST_HEAD(&pcpu_slot[i]);\n\n\t/*\n\t * The end of the static region needs to be aligned with the\n\t * minimum allocation size as this offsets the reserved and\n\t * dynamic region.  The first chunk ends page aligned by\n\t * expanding the dynamic region, therefore the dynamic region\n\t * can be shrunk to compensate while still staying above the\n\t * configured sizes.\n\t */\n\tstatic_size = ALIGN(ai->static_size, PCPU_MIN_ALLOC_SIZE);\n\tdyn_size = ai->dyn_size - (static_size - ai->static_size);\n\n\t/*\n\t * Initialize first chunk.\n\t * If the reserved_size is non-zero, this initializes the reserved\n\t * chunk.  If the reserved_size is zero, the reserved chunk is NULL\n\t * and the dynamic region is initialized here.  The first chunk,\n\t * pcpu_first_chunk, will always point to the chunk that serves\n\t * the dynamic region.\n\t */\n\ttmp_addr = (unsigned long)base_addr + static_size;\n\tmap_size = ai->reserved_size ?: dyn_size;\n\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\n\t/* init dynamic chunk if necessary */\n\tif (ai->reserved_size) {\n\t\tpcpu_reserved_chunk = chunk;\n\n\t\ttmp_addr = (unsigned long)base_addr + static_size +\n\t\t\t   ai->reserved_size;\n\t\tmap_size = dyn_size;\n\t\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\t}\n\n\t/* link the first chunk in */\n\tpcpu_first_chunk = chunk;\n\tpcpu_nr_empty_pop_pages = pcpu_first_chunk->nr_empty_pop_pages;\n\tpcpu_chunk_relocate(pcpu_first_chunk, -1);\n\n\t/* include all regions of the first chunk */\n\tpcpu_nr_populated += PFN_DOWN(size_sum);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(base_addr);\n\n\t/* we're done */\n\tpcpu_base_addr = base_addr;\n\treturn 0;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pcpu_unit_pages",
      "static int pcpu_unit_size",
      "static int pcpu_nr_units",
      "static int pcpu_atom_size",
      "int pcpu_nr_slots",
      "static size_t pcpu_chunk_struct_size",
      "static unsigned int pcpu_low_unit_cpu",
      "static unsigned int pcpu_high_unit_cpu",
      "void *pcpu_base_addr",
      "static const int *pcpu_unit_map",
      "const unsigned long *pcpu_unit_offsets",
      "static int pcpu_nr_groups",
      "static const unsigned long *pcpu_group_offsets",
      "static const size_t *pcpu_group_sizes",
      "struct pcpu_chunk *pcpu_first_chunk",
      "struct pcpu_chunk *pcpu_reserved_chunk",
      "int pcpu_nr_empty_pop_pages;",
      "static unsigned long pcpu_nr_populated;",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
      "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_percpu_create_chunk",
          "args": [
            "base_addr"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_stats_chunk_alloc",
          "args": [],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_stats_chunk_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "215-217",
          "snippet": "static inline void pcpu_stats_chunk_alloc(void)\n{\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline void pcpu_stats_chunk_alloc(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "size_sum"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_relocate",
          "args": [
            "pcpu_first_chunk",
            "-1"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_relocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "504-514",
          "snippet": "static void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_alloc_first_chunk",
          "args": [
            "tmp_addr",
            "map_size"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_alloc_first_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1083-1163",
          "snippet": "static struct pcpu_chunk * __init pcpu_alloc_first_chunk(unsigned long tmp_addr,\n\t\t\t\t\t\t\t int map_size)\n{\n\tstruct pcpu_chunk *chunk;\n\tunsigned long aligned_addr, lcm_align;\n\tint start_offset, offset_bits, region_size, region_bits;\n\n\t/* region calculations */\n\taligned_addr = tmp_addr & PAGE_MASK;\n\n\tstart_offset = tmp_addr - aligned_addr;\n\n\t/*\n\t * Align the end of the region with the LCM of PAGE_SIZE and\n\t * PCPU_BITMAP_BLOCK_SIZE.  One of these constants is a multiple of\n\t * the other.\n\t */\n\tlcm_align = lcm(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE);\n\tregion_size = ALIGN(start_offset + map_size, lcm_align);\n\n\t/* allocate chunk */\n\tchunk = memblock_alloc(sizeof(struct pcpu_chunk) +\n\t\t\t       BITS_TO_LONGS(region_size >> PAGE_SHIFT),\n\t\t\t       SMP_CACHE_BYTES);\n\n\tINIT_LIST_HEAD(&chunk->list);\n\n\tchunk->base_addr = (void *)aligned_addr;\n\tchunk->start_offset = start_offset;\n\tchunk->end_offset = region_size - chunk->start_offset - map_size;\n\n\tchunk->nr_pages = region_size >> PAGE_SHIFT;\n\tregion_bits = pcpu_chunk_map_bits(chunk);\n\n\tchunk->alloc_map = memblock_alloc(BITS_TO_LONGS(region_bits) * sizeof(chunk->alloc_map[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tchunk->bound_map = memblock_alloc(BITS_TO_LONGS(region_bits + 1) * sizeof(chunk->bound_map[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tchunk->md_blocks = memblock_alloc(pcpu_chunk_nr_blocks(chunk) * sizeof(chunk->md_blocks[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tpcpu_init_md_blocks(chunk);\n\n\t/* manage populated page bitmap */\n\tchunk->immutable = true;\n\tbitmap_fill(chunk->populated, chunk->nr_pages);\n\tchunk->nr_populated = chunk->nr_pages;\n\tchunk->nr_empty_pop_pages =\n\t\tpcpu_cnt_pop_pages(chunk, start_offset / PCPU_MIN_ALLOC_SIZE,\n\t\t\t\t   map_size / PCPU_MIN_ALLOC_SIZE);\n\n\tchunk->contig_bits = map_size / PCPU_MIN_ALLOC_SIZE;\n\tchunk->free_bytes = map_size;\n\n\tif (chunk->start_offset) {\n\t\t/* hide the beginning of the bitmap */\n\t\toffset_bits = chunk->start_offset / PCPU_MIN_ALLOC_SIZE;\n\t\tbitmap_set(chunk->alloc_map, 0, offset_bits);\n\t\tset_bit(0, chunk->bound_map);\n\t\tset_bit(offset_bits, chunk->bound_map);\n\n\t\tchunk->first_bit = offset_bits;\n\n\t\tpcpu_block_update_hint_alloc(chunk, 0, offset_bits);\n\t}\n\n\tif (chunk->end_offset) {\n\t\t/* hide the end of the bitmap */\n\t\toffset_bits = chunk->end_offset / PCPU_MIN_ALLOC_SIZE;\n\t\tbitmap_set(chunk->alloc_map,\n\t\t\t   pcpu_chunk_map_bits(chunk) - offset_bits,\n\t\t\t   offset_bits);\n\t\tset_bit((start_offset + map_size) / PCPU_MIN_ALLOC_SIZE,\n\t\t\tchunk->bound_map);\n\t\tset_bit(region_bits, chunk->bound_map);\n\n\t\tpcpu_block_update_hint_alloc(chunk, pcpu_chunk_map_bits(chunk)\n\t\t\t\t\t     - offset_bits, offset_bits);\n\t}\n\n\treturn chunk;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic struct pcpu_chunk * __init pcpu_alloc_first_chunk(unsigned long tmp_addr,\n\t\t\t\t\t\t\t int map_size)\n{\n\tstruct pcpu_chunk *chunk;\n\tunsigned long aligned_addr, lcm_align;\n\tint start_offset, offset_bits, region_size, region_bits;\n\n\t/* region calculations */\n\taligned_addr = tmp_addr & PAGE_MASK;\n\n\tstart_offset = tmp_addr - aligned_addr;\n\n\t/*\n\t * Align the end of the region with the LCM of PAGE_SIZE and\n\t * PCPU_BITMAP_BLOCK_SIZE.  One of these constants is a multiple of\n\t * the other.\n\t */\n\tlcm_align = lcm(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE);\n\tregion_size = ALIGN(start_offset + map_size, lcm_align);\n\n\t/* allocate chunk */\n\tchunk = memblock_alloc(sizeof(struct pcpu_chunk) +\n\t\t\t       BITS_TO_LONGS(region_size >> PAGE_SHIFT),\n\t\t\t       SMP_CACHE_BYTES);\n\n\tINIT_LIST_HEAD(&chunk->list);\n\n\tchunk->base_addr = (void *)aligned_addr;\n\tchunk->start_offset = start_offset;\n\tchunk->end_offset = region_size - chunk->start_offset - map_size;\n\n\tchunk->nr_pages = region_size >> PAGE_SHIFT;\n\tregion_bits = pcpu_chunk_map_bits(chunk);\n\n\tchunk->alloc_map = memblock_alloc(BITS_TO_LONGS(region_bits) * sizeof(chunk->alloc_map[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tchunk->bound_map = memblock_alloc(BITS_TO_LONGS(region_bits + 1) * sizeof(chunk->bound_map[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tchunk->md_blocks = memblock_alloc(pcpu_chunk_nr_blocks(chunk) * sizeof(chunk->md_blocks[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tpcpu_init_md_blocks(chunk);\n\n\t/* manage populated page bitmap */\n\tchunk->immutable = true;\n\tbitmap_fill(chunk->populated, chunk->nr_pages);\n\tchunk->nr_populated = chunk->nr_pages;\n\tchunk->nr_empty_pop_pages =\n\t\tpcpu_cnt_pop_pages(chunk, start_offset / PCPU_MIN_ALLOC_SIZE,\n\t\t\t\t   map_size / PCPU_MIN_ALLOC_SIZE);\n\n\tchunk->contig_bits = map_size / PCPU_MIN_ALLOC_SIZE;\n\tchunk->free_bytes = map_size;\n\n\tif (chunk->start_offset) {\n\t\t/* hide the beginning of the bitmap */\n\t\toffset_bits = chunk->start_offset / PCPU_MIN_ALLOC_SIZE;\n\t\tbitmap_set(chunk->alloc_map, 0, offset_bits);\n\t\tset_bit(0, chunk->bound_map);\n\t\tset_bit(offset_bits, chunk->bound_map);\n\n\t\tchunk->first_bit = offset_bits;\n\n\t\tpcpu_block_update_hint_alloc(chunk, 0, offset_bits);\n\t}\n\n\tif (chunk->end_offset) {\n\t\t/* hide the end of the bitmap */\n\t\toffset_bits = chunk->end_offset / PCPU_MIN_ALLOC_SIZE;\n\t\tbitmap_set(chunk->alloc_map,\n\t\t\t   pcpu_chunk_map_bits(chunk) - offset_bits,\n\t\t\t   offset_bits);\n\t\tset_bit((start_offset + map_size) / PCPU_MIN_ALLOC_SIZE,\n\t\t\tchunk->bound_map);\n\t\tset_bit(region_bits, chunk->bound_map);\n\n\t\tpcpu_block_update_hint_alloc(chunk, pcpu_chunk_map_bits(chunk)\n\t\t\t\t\t     - offset_bits, offset_bits);\n\t}\n\n\treturn chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "ai->static_size",
            "PCPU_MIN_ALLOC_SIZE"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pcpu_slot[i]"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "pcpu_nr_slots * sizeof(pcpu_slot[0])",
            "SMP_CACHE_BYTES"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pcpu_size_to_slot",
          "args": [
            "pcpu_unit_size"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "__pcpu_size_to_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "219-223",
          "snippet": "static int __pcpu_size_to_slot(int size)\n{\n\tint highbit = fls(size);\t/* size is in bytes */\n\treturn max(highbit - PCPU_SLOT_BASE_SHIFT + 2, 1);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [
            "#define PCPU_SLOT_BASE_SHIFT\t\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\n#define PCPU_SLOT_BASE_SHIFT\t\t5\n\nstatic int __pcpu_size_to_slot(int size)\n{\n\tint highbit = fls(size);\t/* size is in bytes */\n\treturn max(highbit - PCPU_SLOT_BASE_SHIFT + 2, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_stats_save_ai",
          "args": [
            "ai"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_stats_save_ai",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "203-205",
          "snippet": "static inline void pcpu_stats_save_ai(const struct pcpu_alloc_info *ai)\n{\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline void pcpu_stats_save_ai(const struct pcpu_alloc_info *ai)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "pcpu_unit_pages"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_dump_alloc_info",
          "args": [
            "KERN_DEBUG",
            "ai"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_dump_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1926-1974",
          "snippet": "static void pcpu_dump_alloc_info(const char *lvl,\n\t\t\t\t const struct pcpu_alloc_info *ai)\n{\n\tint group_width = 1, cpu_width = 1, width;\n\tchar empty_str[] = \"--------\";\n\tint alloc = 0, alloc_end = 0;\n\tint group, v;\n\tint upa, apl;\t/* units per alloc, allocs per line */\n\n\tv = ai->nr_groups;\n\twhile (v /= 10)\n\t\tgroup_width++;\n\n\tv = num_possible_cpus();\n\twhile (v /= 10)\n\t\tcpu_width++;\n\tempty_str[min_t(int, cpu_width, sizeof(empty_str) - 1)] = '\\0';\n\n\tupa = ai->alloc_size / ai->unit_size;\n\twidth = upa * (cpu_width + 1) + group_width + 3;\n\tapl = rounddown_pow_of_two(max(60 / width, 1));\n\n\tprintk(\"%spcpu-alloc: s%zu r%zu d%zu u%zu alloc=%zu*%zu\",\n\t       lvl, ai->static_size, ai->reserved_size, ai->dyn_size,\n\t       ai->unit_size, ai->alloc_size / ai->atom_size, ai->atom_size);\n\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\t\tint unit = 0, unit_end = 0;\n\n\t\tBUG_ON(gi->nr_units % upa);\n\t\tfor (alloc_end += gi->nr_units / upa;\n\t\t     alloc < alloc_end; alloc++) {\n\t\t\tif (!(alloc % apl)) {\n\t\t\t\tpr_cont(\"\\n\");\n\t\t\t\tprintk(\"%spcpu-alloc: \", lvl);\n\t\t\t}\n\t\t\tpr_cont(\"[%0*d] \", group_width, group);\n\n\t\t\tfor (unit_end += upa; unit < unit_end; unit++)\n\t\t\t\tif (gi->cpu_map[unit] != NR_CPUS)\n\t\t\t\t\tpr_cont(\"%0*d \",\n\t\t\t\t\t\tcpu_width, gi->cpu_map[unit]);\n\t\t\t\telse\n\t\t\t\t\tpr_cont(\"%s \", empty_str);\n\t\t}\n\t}\n\tpr_cont(\"\\n\");\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nstatic void pcpu_dump_alloc_info(const char *lvl,\n\t\t\t\t const struct pcpu_alloc_info *ai)\n{\n\tint group_width = 1, cpu_width = 1, width;\n\tchar empty_str[] = \"--------\";\n\tint alloc = 0, alloc_end = 0;\n\tint group, v;\n\tint upa, apl;\t/* units per alloc, allocs per line */\n\n\tv = ai->nr_groups;\n\twhile (v /= 10)\n\t\tgroup_width++;\n\n\tv = num_possible_cpus();\n\twhile (v /= 10)\n\t\tcpu_width++;\n\tempty_str[min_t(int, cpu_width, sizeof(empty_str) - 1)] = '\\0';\n\n\tupa = ai->alloc_size / ai->unit_size;\n\twidth = upa * (cpu_width + 1) + group_width + 3;\n\tapl = rounddown_pow_of_two(max(60 / width, 1));\n\n\tprintk(\"%spcpu-alloc: s%zu r%zu d%zu u%zu alloc=%zu*%zu\",\n\t       lvl, ai->static_size, ai->reserved_size, ai->dyn_size,\n\t       ai->unit_size, ai->alloc_size / ai->atom_size, ai->atom_size);\n\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\t\tint unit = 0, unit_end = 0;\n\n\t\tBUG_ON(gi->nr_units % upa);\n\t\tfor (alloc_end += gi->nr_units / upa;\n\t\t     alloc < alloc_end; alloc++) {\n\t\t\tif (!(alloc % apl)) {\n\t\t\t\tpr_cont(\"\\n\");\n\t\t\t\tprintk(\"%spcpu-alloc: \", lvl);\n\t\t\t}\n\t\t\tpr_cont(\"[%0*d] \", group_width, group);\n\n\t\t\tfor (unit_end += upa; unit < unit_end; unit++)\n\t\t\t\tif (gi->cpu_map[unit] != NR_CPUS)\n\t\t\t\t\tpr_cont(\"%0*d \",\n\t\t\t\t\t\tcpu_width, gi->cpu_map[unit]);\n\t\t\t\telse\n\t\t\t\t\tpr_cont(\"%s \", empty_str);\n\t\t}\n\t}\n\tpr_cont(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "unit_map[cpu] != UINT_MAX"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "!cpu_possible(cpu)"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_possible",
          "args": [
            "cpu"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "cpu >= nr_cpu_ids"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "nr_cpu_ids * sizeof(unit_off[0])",
            "SMP_CACHE_BYTES"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "nr_cpu_ids * sizeof(unit_map[0])",
            "SMP_CACHE_BYTES"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "ai->nr_groups * sizeof(group_sizes[0])",
            "SMP_CACHE_BYTES"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "ai->nr_groups * sizeof(group_offsets[0])",
            "SMP_CACHE_BYTES"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "pcpu_verify_alloc_info(ai) < 0"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_verify_alloc_info",
          "args": [
            "ai"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_verify_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-km.c",
          "lines": "101-119",
          "snippet": "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai)\n{\n\tsize_t nr_pages, alloc_pages;\n\n\t/* all units must be in a single group */\n\tif (ai->nr_groups != 1) {\n\t\tpr_crit(\"can't handle more than one group\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnr_pages = (ai->groups[0].nr_units * ai->unit_size) >> PAGE_SHIFT;\n\talloc_pages = roundup_pow_of_two(nr_pages);\n\n\tif (alloc_pages > nr_pages)\n\t\tpr_warn(\"wasting %zu pages per chunk\\n\",\n\t\t\talloc_pages - nr_pages);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai)\n{\n\tsize_t nr_pages, alloc_pages;\n\n\t/* all units must be in a single group */\n\tif (ai->nr_groups != 1) {\n\t\tpr_crit(\"can't handle more than one group\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnr_pages = (ai->groups[0].nr_units * ai->unit_size) >> PAGE_SHIFT;\n\talloc_pages = roundup_pow_of_two(nr_pages);\n\n\tif (alloc_pages > nr_pages)\n\t\tpr_warn(\"wasting %zu pages per chunk\\n\",\n\t\t\talloc_pages - nr_pages);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "!(IS_ALIGNED(PCPU_BITMAP_BLOCK_SIZE, PAGE_SIZE) ||\n\t\t\t    IS_ALIGNED(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE))"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "PAGE_SIZE",
            "PCPU_BITMAP_BLOCK_SIZE"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "PCPU_BITMAP_BLOCK_SIZE",
            "PAGE_SIZE"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "!IS_ALIGNED(ai->reserved_size, PCPU_MIN_ALLOC_SIZE)"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "ai->reserved_size",
            "PCPU_MIN_ALLOC_SIZE"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "!ai->dyn_size"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "ai->dyn_size < PERCPU_DYNAMIC_EARLY_SIZE"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "!IS_ALIGNED(ai->unit_size, PCPU_BITMAP_BLOCK_SIZE)"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "ai->unit_size",
            "PCPU_BITMAP_BLOCK_SIZE"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "ai->unit_size < PCPU_MIN_UNIT_SIZE"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "offset_in_page(ai->unit_size)"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "ai->unit_size"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "ai->unit_size < size_sum"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "offset_in_page(base_addr)"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "base_addr"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "!base_addr"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "offset_in_page(__per_cpu_start)"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "__per_cpu_start"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "!ai->static_size"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCPU_SETUP_BUG_ON",
          "args": [
            "ai->nr_groups <= 0"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic int pcpu_unit_size;\nstatic int pcpu_nr_units;\nstatic int pcpu_atom_size;\nint pcpu_nr_slots;\nstatic size_t pcpu_chunk_struct_size;\nstatic unsigned int pcpu_low_unit_cpu;\nstatic unsigned int pcpu_high_unit_cpu;\nvoid *pcpu_base_addr;\nstatic const int *pcpu_unit_map;\nconst unsigned long *pcpu_unit_offsets;\nstatic int pcpu_nr_groups;\nstatic const unsigned long *pcpu_group_offsets;\nstatic const size_t *pcpu_group_sizes;\nstruct pcpu_chunk *pcpu_first_chunk;\nstruct pcpu_chunk *pcpu_reserved_chunk;\nint pcpu_nr_empty_pop_pages;\nstatic unsigned long pcpu_nr_populated;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nint __init pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai,\n\t\t\t\t  void *base_addr)\n{\n\tsize_t size_sum = ai->static_size + ai->reserved_size + ai->dyn_size;\n\tsize_t static_size, dyn_size;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long *group_offsets;\n\tsize_t *group_sizes;\n\tunsigned long *unit_off;\n\tunsigned int cpu;\n\tint *unit_map;\n\tint group, unit, i;\n\tint map_size;\n\tunsigned long tmp_addr;\n\n#define PCPU_SETUP_BUG_ON(cond)\tdo {\t\t\t\t\t\\\n\tif (unlikely(cond)) {\t\t\t\t\t\t\\\n\t\tpr_emerg(\"failed to initialize, %s\\n\", #cond);\t\t\\\n\t\tpr_emerg(\"cpu_possible_mask=%*pb\\n\",\t\t\t\\\n\t\t\t cpumask_pr_args(cpu_possible_mask));\t\t\\\n\t\tpcpu_dump_alloc_info(KERN_EMERG, ai);\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\t/* sanity checks */\n\tPCPU_SETUP_BUG_ON(ai->nr_groups <= 0);\n#ifdef CONFIG_SMP\n\tPCPU_SETUP_BUG_ON(!ai->static_size);\n\tPCPU_SETUP_BUG_ON(offset_in_page(__per_cpu_start));\n#endif\n\tPCPU_SETUP_BUG_ON(!base_addr);\n\tPCPU_SETUP_BUG_ON(offset_in_page(base_addr));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < size_sum);\n\tPCPU_SETUP_BUG_ON(offset_in_page(ai->unit_size));\n\tPCPU_SETUP_BUG_ON(ai->unit_size < PCPU_MIN_UNIT_SIZE);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->unit_size, PCPU_BITMAP_BLOCK_SIZE));\n\tPCPU_SETUP_BUG_ON(ai->dyn_size < PERCPU_DYNAMIC_EARLY_SIZE);\n\tPCPU_SETUP_BUG_ON(!ai->dyn_size);\n\tPCPU_SETUP_BUG_ON(!IS_ALIGNED(ai->reserved_size, PCPU_MIN_ALLOC_SIZE));\n\tPCPU_SETUP_BUG_ON(!(IS_ALIGNED(PCPU_BITMAP_BLOCK_SIZE, PAGE_SIZE) ||\n\t\t\t    IS_ALIGNED(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE)));\n\tPCPU_SETUP_BUG_ON(pcpu_verify_alloc_info(ai) < 0);\n\n\t/* process group information and build config tables accordingly */\n\tgroup_offsets = memblock_alloc(ai->nr_groups * sizeof(group_offsets[0]),\n\t\t\t\t       SMP_CACHE_BYTES);\n\tgroup_sizes = memblock_alloc(ai->nr_groups * sizeof(group_sizes[0]),\n\t\t\t\t     SMP_CACHE_BYTES);\n\tunit_map = memblock_alloc(nr_cpu_ids * sizeof(unit_map[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\tunit_off = memblock_alloc(nr_cpu_ids * sizeof(unit_off[0]),\n\t\t\t\t  SMP_CACHE_BYTES);\n\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tunit_map[cpu] = UINT_MAX;\n\n\tpcpu_low_unit_cpu = NR_CPUS;\n\tpcpu_high_unit_cpu = NR_CPUS;\n\n\tfor (group = 0, unit = 0; group < ai->nr_groups; group++, unit += i) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\n\t\tgroup_offsets[group] = gi->base_offset;\n\t\tgroup_sizes[group] = gi->nr_units * ai->unit_size;\n\n\t\tfor (i = 0; i < gi->nr_units; i++) {\n\t\t\tcpu = gi->cpu_map[i];\n\t\t\tif (cpu == NR_CPUS)\n\t\t\t\tcontinue;\n\n\t\t\tPCPU_SETUP_BUG_ON(cpu >= nr_cpu_ids);\n\t\t\tPCPU_SETUP_BUG_ON(!cpu_possible(cpu));\n\t\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] != UINT_MAX);\n\n\t\t\tunit_map[cpu] = unit + i;\n\t\t\tunit_off[cpu] = gi->base_offset + i * ai->unit_size;\n\n\t\t\t/* determine low/high unit_cpu */\n\t\t\tif (pcpu_low_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] < unit_off[pcpu_low_unit_cpu])\n\t\t\t\tpcpu_low_unit_cpu = cpu;\n\t\t\tif (pcpu_high_unit_cpu == NR_CPUS ||\n\t\t\t    unit_off[cpu] > unit_off[pcpu_high_unit_cpu])\n\t\t\t\tpcpu_high_unit_cpu = cpu;\n\t\t}\n\t}\n\tpcpu_nr_units = unit;\n\n\tfor_each_possible_cpu(cpu)\n\t\tPCPU_SETUP_BUG_ON(unit_map[cpu] == UINT_MAX);\n\n\t/* we're done parsing the input, undefine BUG macro and dump config */\n#undef PCPU_SETUP_BUG_ON\n\tpcpu_dump_alloc_info(KERN_DEBUG, ai);\n\n\tpcpu_nr_groups = ai->nr_groups;\n\tpcpu_group_offsets = group_offsets;\n\tpcpu_group_sizes = group_sizes;\n\tpcpu_unit_map = unit_map;\n\tpcpu_unit_offsets = unit_off;\n\n\t/* determine basic parameters */\n\tpcpu_unit_pages = ai->unit_size >> PAGE_SHIFT;\n\tpcpu_unit_size = pcpu_unit_pages << PAGE_SHIFT;\n\tpcpu_atom_size = ai->atom_size;\n\tpcpu_chunk_struct_size = sizeof(struct pcpu_chunk) +\n\t\tBITS_TO_LONGS(pcpu_unit_pages) * sizeof(unsigned long);\n\n\tpcpu_stats_save_ai(ai);\n\n\t/*\n\t * Allocate chunk slots.  The additional last slot is for\n\t * empty chunks.\n\t */\n\tpcpu_nr_slots = __pcpu_size_to_slot(pcpu_unit_size) + 2;\n\tpcpu_slot = memblock_alloc(pcpu_nr_slots * sizeof(pcpu_slot[0]),\n\t\t\t\t   SMP_CACHE_BYTES);\n\tfor (i = 0; i < pcpu_nr_slots; i++)\n\t\tINIT_LIST_HEAD(&pcpu_slot[i]);\n\n\t/*\n\t * The end of the static region needs to be aligned with the\n\t * minimum allocation size as this offsets the reserved and\n\t * dynamic region.  The first chunk ends page aligned by\n\t * expanding the dynamic region, therefore the dynamic region\n\t * can be shrunk to compensate while still staying above the\n\t * configured sizes.\n\t */\n\tstatic_size = ALIGN(ai->static_size, PCPU_MIN_ALLOC_SIZE);\n\tdyn_size = ai->dyn_size - (static_size - ai->static_size);\n\n\t/*\n\t * Initialize first chunk.\n\t * If the reserved_size is non-zero, this initializes the reserved\n\t * chunk.  If the reserved_size is zero, the reserved chunk is NULL\n\t * and the dynamic region is initialized here.  The first chunk,\n\t * pcpu_first_chunk, will always point to the chunk that serves\n\t * the dynamic region.\n\t */\n\ttmp_addr = (unsigned long)base_addr + static_size;\n\tmap_size = ai->reserved_size ?: dyn_size;\n\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\n\t/* init dynamic chunk if necessary */\n\tif (ai->reserved_size) {\n\t\tpcpu_reserved_chunk = chunk;\n\n\t\ttmp_addr = (unsigned long)base_addr + static_size +\n\t\t\t   ai->reserved_size;\n\t\tmap_size = dyn_size;\n\t\tchunk = pcpu_alloc_first_chunk(tmp_addr, map_size);\n\t}\n\n\t/* link the first chunk in */\n\tpcpu_first_chunk = chunk;\n\tpcpu_nr_empty_pop_pages = pcpu_first_chunk->nr_empty_pop_pages;\n\tpcpu_chunk_relocate(pcpu_first_chunk, -1);\n\n\t/* include all regions of the first chunk */\n\tpcpu_nr_populated += PFN_DOWN(size_sum);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(base_addr);\n\n\t/* we're done */\n\tpcpu_base_addr = base_addr;\n\treturn 0;\n}"
  },
  {
    "function_name": "pcpu_dump_alloc_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1926-1974",
    "snippet": "static void pcpu_dump_alloc_info(const char *lvl,\n\t\t\t\t const struct pcpu_alloc_info *ai)\n{\n\tint group_width = 1, cpu_width = 1, width;\n\tchar empty_str[] = \"--------\";\n\tint alloc = 0, alloc_end = 0;\n\tint group, v;\n\tint upa, apl;\t/* units per alloc, allocs per line */\n\n\tv = ai->nr_groups;\n\twhile (v /= 10)\n\t\tgroup_width++;\n\n\tv = num_possible_cpus();\n\twhile (v /= 10)\n\t\tcpu_width++;\n\tempty_str[min_t(int, cpu_width, sizeof(empty_str) - 1)] = '\\0';\n\n\tupa = ai->alloc_size / ai->unit_size;\n\twidth = upa * (cpu_width + 1) + group_width + 3;\n\tapl = rounddown_pow_of_two(max(60 / width, 1));\n\n\tprintk(\"%spcpu-alloc: s%zu r%zu d%zu u%zu alloc=%zu*%zu\",\n\t       lvl, ai->static_size, ai->reserved_size, ai->dyn_size,\n\t       ai->unit_size, ai->alloc_size / ai->atom_size, ai->atom_size);\n\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\t\tint unit = 0, unit_end = 0;\n\n\t\tBUG_ON(gi->nr_units % upa);\n\t\tfor (alloc_end += gi->nr_units / upa;\n\t\t     alloc < alloc_end; alloc++) {\n\t\t\tif (!(alloc % apl)) {\n\t\t\t\tpr_cont(\"\\n\");\n\t\t\t\tprintk(\"%spcpu-alloc: \", lvl);\n\t\t\t}\n\t\t\tpr_cont(\"[%0*d] \", group_width, group);\n\n\t\t\tfor (unit_end += upa; unit < unit_end; unit++)\n\t\t\t\tif (gi->cpu_map[unit] != NR_CPUS)\n\t\t\t\t\tpr_cont(\"%0*d \",\n\t\t\t\t\t\tcpu_width, gi->cpu_map[unit]);\n\t\t\t\telse\n\t\t\t\t\tpr_cont(\"%s \", empty_str);\n\t\t}\n\t}\n\tpr_cont(\"\\n\");\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s \"",
            "empty_str"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%0*d \"",
            "cpu_width",
            "gi->cpu_map[unit]"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"[%0*d] \"",
            "group_width",
            "group"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%spcpu-alloc: \"",
            "lvl"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "gi->nr_units % upa"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%spcpu-alloc: s%zu r%zu d%zu u%zu alloc=%zu*%zu\"",
            "lvl",
            "ai->static_size",
            "ai->reserved_size",
            "ai->dyn_size",
            "ai->unit_size",
            "ai->alloc_size / ai->atom_size",
            "ai->atom_size"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "mminit_dprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "417-420",
          "snippet": "static inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rounddown_pow_of_two",
          "args": [
            "max(60 / width, 1)"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "60 / width",
            "1"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "cpu_width",
            "sizeof(empty_str) - 1"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nstatic void pcpu_dump_alloc_info(const char *lvl,\n\t\t\t\t const struct pcpu_alloc_info *ai)\n{\n\tint group_width = 1, cpu_width = 1, width;\n\tchar empty_str[] = \"--------\";\n\tint alloc = 0, alloc_end = 0;\n\tint group, v;\n\tint upa, apl;\t/* units per alloc, allocs per line */\n\n\tv = ai->nr_groups;\n\twhile (v /= 10)\n\t\tgroup_width++;\n\n\tv = num_possible_cpus();\n\twhile (v /= 10)\n\t\tcpu_width++;\n\tempty_str[min_t(int, cpu_width, sizeof(empty_str) - 1)] = '\\0';\n\n\tupa = ai->alloc_size / ai->unit_size;\n\twidth = upa * (cpu_width + 1) + group_width + 3;\n\tapl = rounddown_pow_of_two(max(60 / width, 1));\n\n\tprintk(\"%spcpu-alloc: s%zu r%zu d%zu u%zu alloc=%zu*%zu\",\n\t       lvl, ai->static_size, ai->reserved_size, ai->dyn_size,\n\t       ai->unit_size, ai->alloc_size / ai->atom_size, ai->atom_size);\n\n\tfor (group = 0; group < ai->nr_groups; group++) {\n\t\tconst struct pcpu_group_info *gi = &ai->groups[group];\n\t\tint unit = 0, unit_end = 0;\n\n\t\tBUG_ON(gi->nr_units % upa);\n\t\tfor (alloc_end += gi->nr_units / upa;\n\t\t     alloc < alloc_end; alloc++) {\n\t\t\tif (!(alloc % apl)) {\n\t\t\t\tpr_cont(\"\\n\");\n\t\t\t\tprintk(\"%spcpu-alloc: \", lvl);\n\t\t\t}\n\t\t\tpr_cont(\"[%0*d] \", group_width, group);\n\n\t\t\tfor (unit_end += upa; unit < unit_end; unit++)\n\t\t\t\tif (gi->cpu_map[unit] != NR_CPUS)\n\t\t\t\t\tpr_cont(\"%0*d \",\n\t\t\t\t\t\tcpu_width, gi->cpu_map[unit]);\n\t\t\t\telse\n\t\t\t\t\tpr_cont(\"%s \", empty_str);\n\t\t}\n\t}\n\tpr_cont(\"\\n\");\n}"
  },
  {
    "function_name": "pcpu_free_alloc_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1914-1917",
    "snippet": "void __init pcpu_free_alloc_info(struct pcpu_alloc_info *ai)\n{\n\tmemblock_free_early(__pa(ai), ai->__ai_size);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_free_early",
          "args": [
            "__pa(ai)",
            "ai->__ai_size"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "__memblock_free_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1547-1555",
          "snippet": "void __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "ai"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nvoid __init pcpu_free_alloc_info(struct pcpu_alloc_info *ai)\n{\n\tmemblock_free_early(__pa(ai), ai->__ai_size);\n}"
  },
  {
    "function_name": "pcpu_alloc_alloc_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1879-1906",
    "snippet": "struct pcpu_alloc_info * __init pcpu_alloc_alloc_info(int nr_groups,\n\t\t\t\t\t\t      int nr_units)\n{\n\tstruct pcpu_alloc_info *ai;\n\tsize_t base_size, ai_size;\n\tvoid *ptr;\n\tint unit;\n\n\tbase_size = ALIGN(sizeof(*ai) + nr_groups * sizeof(ai->groups[0]),\n\t\t\t  __alignof__(ai->groups[0].cpu_map[0]));\n\tai_size = base_size + nr_units * sizeof(ai->groups[0].cpu_map[0]);\n\n\tptr = memblock_alloc_nopanic(PFN_ALIGN(ai_size), PAGE_SIZE);\n\tif (!ptr)\n\t\treturn NULL;\n\tai = ptr;\n\tptr += base_size;\n\n\tai->groups[0].cpu_map = ptr;\n\n\tfor (unit = 0; unit < nr_units; unit++)\n\t\tai->groups[0].cpu_map[unit] = NR_CPUS;\n\n\tai->nr_groups = nr_groups;\n\tai->__ai_size = PFN_ALIGN(ai_size);\n\n\treturn ai;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PFN_ALIGN",
          "args": [
            "ai_size"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_nopanic",
          "args": [
            "PFN_ALIGN(ai_size)",
            "PAGE_SIZE"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_ALIGN",
          "args": [
            "ai_size"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "sizeof(*ai) + nr_groups * sizeof(ai->groups[0])",
            "__alignof__(ai->groups[0].cpu_map[0]"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai);\n\nstruct pcpu_alloc_info * __init pcpu_alloc_alloc_info(int nr_groups,\n\t\t\t\t\t\t      int nr_units)\n{\n\tstruct pcpu_alloc_info *ai;\n\tsize_t base_size, ai_size;\n\tvoid *ptr;\n\tint unit;\n\n\tbase_size = ALIGN(sizeof(*ai) + nr_groups * sizeof(ai->groups[0]),\n\t\t\t  __alignof__(ai->groups[0].cpu_map[0]));\n\tai_size = base_size + nr_units * sizeof(ai->groups[0].cpu_map[0]);\n\n\tptr = memblock_alloc_nopanic(PFN_ALIGN(ai_size), PAGE_SIZE);\n\tif (!ptr)\n\t\treturn NULL;\n\tai = ptr;\n\tptr += base_size;\n\n\tai->groups[0].cpu_map = ptr;\n\n\tfor (unit = 0; unit < nr_units; unit++)\n\t\tai->groups[0].cpu_map[unit] = NR_CPUS;\n\n\tai->nr_groups = nr_groups;\n\tai->__ai_size = PFN_ALIGN(ai_size);\n\n\treturn ai;\n}"
  },
  {
    "function_name": "per_cpu_ptr_to_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1820-1862",
    "snippet": "phys_addr_t per_cpu_ptr_to_phys(void *addr)\n{\n\tvoid __percpu *base = __addr_to_pcpu_ptr(pcpu_base_addr);\n\tbool in_first_chunk = false;\n\tunsigned long first_low, first_high;\n\tunsigned int cpu;\n\n\t/*\n\t * The following test on unit_low/high isn't strictly\n\t * necessary but will speed up lookups of addresses which\n\t * aren't in the first chunk.\n\t *\n\t * The address check is against full chunk sizes.  pcpu_base_addr\n\t * points to the beginning of the first chunk including the\n\t * static region.  Assumes good intent as the first chunk may\n\t * not be full (ie. < pcpu_unit_pages in size).\n\t */\n\tfirst_low = (unsigned long)pcpu_base_addr +\n\t\t    pcpu_unit_page_offset(pcpu_low_unit_cpu, 0);\n\tfirst_high = (unsigned long)pcpu_base_addr +\n\t\t     pcpu_unit_page_offset(pcpu_high_unit_cpu, pcpu_unit_pages);\n\tif ((unsigned long)addr >= first_low &&\n\t    (unsigned long)addr < first_high) {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tvoid *start = per_cpu_ptr(base, cpu);\n\n\t\t\tif (addr >= start && addr < start + pcpu_unit_size) {\n\t\t\t\tin_first_chunk = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (in_first_chunk) {\n\t\tif (!is_vmalloc_addr(addr))\n\t\t\treturn __pa(addr);\n\t\telse\n\t\t\treturn page_to_phys(vmalloc_to_page(addr)) +\n\t\t\t       offset_in_page(addr);\n\t} else\n\t\treturn page_to_phys(pcpu_addr_to_page(addr)) +\n\t\t       offset_in_page(addr);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pcpu_unit_pages",
      "static int pcpu_unit_size",
      "static unsigned int pcpu_low_unit_cpu",
      "static unsigned int pcpu_high_unit_cpu",
      "void *pcpu_base_addr",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
      "static struct page *pcpu_addr_to_page(void *addr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "addr"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "pcpu_addr_to_page(addr)"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_addr_to_page",
          "args": [
            "addr"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_addr_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-km.c",
          "lines": "96-99",
          "snippet": "static struct page *pcpu_addr_to_page(void *addr)\n{\n\treturn virt_to_page(addr);\n}",
          "includes": [
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n\nstatic struct page *pcpu_addr_to_page(void *addr)\n{\n\treturn virt_to_page(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "addr"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "vmalloc_to_page(addr)"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "addr"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "264-267",
          "snippet": "struct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "addr"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "addr"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "base",
            "cpu"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_unit_page_offset",
          "args": [
            "pcpu_high_unit_cpu",
            "pcpu_unit_pages"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_unit_page_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "257-260",
          "snippet": "static unsigned long pcpu_unit_page_offset(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_offsets[cpu] + (page_idx << PAGE_SHIFT);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const unsigned long *pcpu_unit_offsets"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nconst unsigned long *pcpu_unit_offsets;\n\nstatic unsigned long pcpu_unit_page_offset(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_offsets[cpu] + (page_idx << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__addr_to_pcpu_ptr",
          "args": [
            "pcpu_base_addr"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic int pcpu_unit_size;\nstatic unsigned int pcpu_low_unit_cpu;\nstatic unsigned int pcpu_high_unit_cpu;\nvoid *pcpu_base_addr;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nphys_addr_t per_cpu_ptr_to_phys(void *addr)\n{\n\tvoid __percpu *base = __addr_to_pcpu_ptr(pcpu_base_addr);\n\tbool in_first_chunk = false;\n\tunsigned long first_low, first_high;\n\tunsigned int cpu;\n\n\t/*\n\t * The following test on unit_low/high isn't strictly\n\t * necessary but will speed up lookups of addresses which\n\t * aren't in the first chunk.\n\t *\n\t * The address check is against full chunk sizes.  pcpu_base_addr\n\t * points to the beginning of the first chunk including the\n\t * static region.  Assumes good intent as the first chunk may\n\t * not be full (ie. < pcpu_unit_pages in size).\n\t */\n\tfirst_low = (unsigned long)pcpu_base_addr +\n\t\t    pcpu_unit_page_offset(pcpu_low_unit_cpu, 0);\n\tfirst_high = (unsigned long)pcpu_base_addr +\n\t\t     pcpu_unit_page_offset(pcpu_high_unit_cpu, pcpu_unit_pages);\n\tif ((unsigned long)addr >= first_low &&\n\t    (unsigned long)addr < first_high) {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tvoid *start = per_cpu_ptr(base, cpu);\n\n\t\t\tif (addr >= start && addr < start + pcpu_unit_size) {\n\t\t\t\tin_first_chunk = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (in_first_chunk) {\n\t\tif (!is_vmalloc_addr(addr))\n\t\t\treturn __pa(addr);\n\t\telse\n\t\t\treturn page_to_phys(vmalloc_to_page(addr)) +\n\t\t\t       offset_in_page(addr);\n\t} else\n\t\treturn page_to_phys(pcpu_addr_to_page(addr)) +\n\t\t       offset_in_page(addr);\n}"
  },
  {
    "function_name": "is_kernel_percpu_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1792-1795",
    "snippet": "bool is_kernel_percpu_address(unsigned long addr)\n{\n\treturn __is_kernel_percpu_address(addr, NULL);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct page *pcpu_addr_to_page(void *addr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__is_kernel_percpu_address",
          "args": [
            "addr",
            "NULL"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "__is_kernel_percpu_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1756-1779",
          "snippet": "bool __is_kernel_percpu_address(unsigned long addr, unsigned long *can_addr)\n{\n#ifdef CONFIG_SMP\n\tconst size_t static_size = __per_cpu_end - __per_cpu_start;\n\tvoid __percpu *base = __addr_to_pcpu_ptr(pcpu_base_addr);\n\tunsigned int cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tvoid *start = per_cpu_ptr(base, cpu);\n\t\tvoid *va = (void *)addr;\n\n\t\tif (va >= start && va < start + static_size) {\n\t\t\tif (can_addr) {\n\t\t\t\t*can_addr = (unsigned long) (va - start);\n\t\t\t\t*can_addr += (unsigned long)\n\t\t\t\t\tper_cpu_ptr(base, get_boot_cpu_id());\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n#endif\n\t/* on UP, can't distinguish from other static vars, always false */\n\treturn false;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *pcpu_base_addr",
            "static struct page *pcpu_addr_to_page(void *addr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nvoid *pcpu_base_addr;\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nbool __is_kernel_percpu_address(unsigned long addr, unsigned long *can_addr)\n{\n#ifdef CONFIG_SMP\n\tconst size_t static_size = __per_cpu_end - __per_cpu_start;\n\tvoid __percpu *base = __addr_to_pcpu_ptr(pcpu_base_addr);\n\tunsigned int cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tvoid *start = per_cpu_ptr(base, cpu);\n\t\tvoid *va = (void *)addr;\n\n\t\tif (va >= start && va < start + static_size) {\n\t\t\tif (can_addr) {\n\t\t\t\t*can_addr = (unsigned long) (va - start);\n\t\t\t\t*can_addr += (unsigned long)\n\t\t\t\t\tper_cpu_ptr(base, get_boot_cpu_id());\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n#endif\n\t/* on UP, can't distinguish from other static vars, always false */\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nbool is_kernel_percpu_address(unsigned long addr)\n{\n\treturn __is_kernel_percpu_address(addr, NULL);\n}"
  },
  {
    "function_name": "__is_kernel_percpu_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1756-1779",
    "snippet": "bool __is_kernel_percpu_address(unsigned long addr, unsigned long *can_addr)\n{\n#ifdef CONFIG_SMP\n\tconst size_t static_size = __per_cpu_end - __per_cpu_start;\n\tvoid __percpu *base = __addr_to_pcpu_ptr(pcpu_base_addr);\n\tunsigned int cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tvoid *start = per_cpu_ptr(base, cpu);\n\t\tvoid *va = (void *)addr;\n\n\t\tif (va >= start && va < start + static_size) {\n\t\t\tif (can_addr) {\n\t\t\t\t*can_addr = (unsigned long) (va - start);\n\t\t\t\t*can_addr += (unsigned long)\n\t\t\t\t\tper_cpu_ptr(base, get_boot_cpu_id());\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n#endif\n\t/* on UP, can't distinguish from other static vars, always false */\n\treturn false;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *pcpu_base_addr",
      "static struct page *pcpu_addr_to_page(void *addr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "base",
            "get_boot_cpu_id()"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_boot_cpu_id",
          "args": [],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "base",
            "cpu"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__addr_to_pcpu_ptr",
          "args": [
            "pcpu_base_addr"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nvoid *pcpu_base_addr;\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nbool __is_kernel_percpu_address(unsigned long addr, unsigned long *can_addr)\n{\n#ifdef CONFIG_SMP\n\tconst size_t static_size = __per_cpu_end - __per_cpu_start;\n\tvoid __percpu *base = __addr_to_pcpu_ptr(pcpu_base_addr);\n\tunsigned int cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tvoid *start = per_cpu_ptr(base, cpu);\n\t\tvoid *va = (void *)addr;\n\n\t\tif (va >= start && va < start + static_size) {\n\t\t\tif (can_addr) {\n\t\t\t\t*can_addr = (unsigned long) (va - start);\n\t\t\t\t*can_addr += (unsigned long)\n\t\t\t\t\tper_cpu_ptr(base, get_boot_cpu_id());\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n#endif\n\t/* on UP, can't distinguish from other static vars, always false */\n\treturn false;\n}"
  },
  {
    "function_name": "free_percpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1718-1753",
    "snippet": "void free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pcpu_unit_size",
      "int pcpu_nr_slots",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
      "static struct page *pcpu_addr_to_page(void *addr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pcpu_lock",
            "flags"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_percpu_free_percpu",
          "args": [
            "chunk->base_addr",
            "off",
            "ptr"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_schedule_balance_work",
          "args": [],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_schedule_balance_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "191-195",
          "snippet": "static void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool pcpu_async_enabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic bool pcpu_async_enabled;\n\nstatic void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "&pcpu_slot[pcpu_nr_slots - 1]",
            "list"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_free_area",
          "args": [
            "chunk",
            "off"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_free_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1029-1055",
          "snippet": "static void pcpu_free_area(struct pcpu_chunk *chunk, int off)\n{\n\tint bit_off, bits, end, oslot;\n\n\tlockdep_assert_held(&pcpu_lock);\n\tpcpu_stats_area_dealloc(chunk);\n\n\toslot = pcpu_chunk_slot(chunk);\n\n\tbit_off = off / PCPU_MIN_ALLOC_SIZE;\n\n\t/* find end index */\n\tend = find_next_bit(chunk->bound_map, pcpu_chunk_map_bits(chunk),\n\t\t\t    bit_off + 1);\n\tbits = end - bit_off;\n\tbitmap_clear(chunk->alloc_map, bit_off, bits);\n\n\t/* update metadata */\n\tchunk->free_bytes += bits * PCPU_MIN_ALLOC_SIZE;\n\n\t/* update first free bit */\n\tchunk->first_bit = min(chunk->first_bit, bit_off);\n\n\tpcpu_block_update_hint_free(chunk, bit_off, bits);\n\n\tpcpu_chunk_relocate(chunk, oslot);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_free_area(struct pcpu_chunk *chunk, int off)\n{\n\tint bit_off, bits, end, oslot;\n\n\tlockdep_assert_held(&pcpu_lock);\n\tpcpu_stats_area_dealloc(chunk);\n\n\toslot = pcpu_chunk_slot(chunk);\n\n\tbit_off = off / PCPU_MIN_ALLOC_SIZE;\n\n\t/* find end index */\n\tend = find_next_bit(chunk->bound_map, pcpu_chunk_map_bits(chunk),\n\t\t\t    bit_off + 1);\n\tbits = end - bit_off;\n\tbitmap_clear(chunk->alloc_map, bit_off, bits);\n\n\t/* update metadata */\n\tchunk->free_bytes += bits * PCPU_MIN_ALLOC_SIZE;\n\n\t/* update first free bit */\n\tchunk->first_bit = min(chunk->first_bit, bit_off);\n\n\tpcpu_block_update_hint_free(chunk, bit_off, bits);\n\n\tpcpu_chunk_relocate(chunk, oslot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_addr_search",
          "args": [
            "addr"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_addr_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1316-1335",
          "snippet": "static struct pcpu_chunk *pcpu_chunk_addr_search(void *addr)\n{\n\t/* is it in the dynamic region (first chunk)? */\n\tif (pcpu_addr_in_chunk(pcpu_first_chunk, addr))\n\t\treturn pcpu_first_chunk;\n\n\t/* is it in the reserved region? */\n\tif (pcpu_addr_in_chunk(pcpu_reserved_chunk, addr))\n\t\treturn pcpu_reserved_chunk;\n\n\t/*\n\t * The address is relative to unit0 which might be unused and\n\t * thus unmapped.  Offset the address to the unit space of the\n\t * current processor before looking it up in the vmalloc\n\t * space.  Note that any possible cpu id can be used here, so\n\t * there's no need to worry about preemption or cpu hotplug.\n\t */\n\taddr += pcpu_unit_offsets[raw_smp_processor_id()];\n\treturn pcpu_get_page_chunk(pcpu_addr_to_page(addr));\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const unsigned long *pcpu_unit_offsets",
            "struct pcpu_chunk *pcpu_first_chunk",
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static struct page *pcpu_addr_to_page(void *addr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nconst unsigned long *pcpu_unit_offsets;\nstruct pcpu_chunk *pcpu_first_chunk;\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nstatic struct pcpu_chunk *pcpu_chunk_addr_search(void *addr)\n{\n\t/* is it in the dynamic region (first chunk)? */\n\tif (pcpu_addr_in_chunk(pcpu_first_chunk, addr))\n\t\treturn pcpu_first_chunk;\n\n\t/* is it in the reserved region? */\n\tif (pcpu_addr_in_chunk(pcpu_reserved_chunk, addr))\n\t\treturn pcpu_reserved_chunk;\n\n\t/*\n\t * The address is relative to unit0 which might be unused and\n\t * thus unmapped.  Offset the address to the unit space of the\n\t * current processor before looking it up in the vmalloc\n\t * space.  Note that any possible cpu id can be used here, so\n\t * there's no need to worry about preemption or cpu hotplug.\n\t */\n\taddr += pcpu_unit_offsets[raw_smp_processor_id()];\n\treturn pcpu_get_page_chunk(pcpu_addr_to_page(addr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pcpu_lock",
            "flags"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pcpu_ptr_to_addr",
          "args": [
            "ptr"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_free_percpu",
          "args": [
            "ptr"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1082-1094",
          "snippet": "void __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_free_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nvoid free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}"
  },
  {
    "function_name": "pcpu_balance_workfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1595-1707",
    "snippet": "static void pcpu_balance_workfn(struct work_struct *work)\n{\n\t/* gfp flags passed to underlying allocators */\n\tconst gfp_t gfp = GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN;\n\tLIST_HEAD(to_free);\n\tstruct list_head *free_head = &pcpu_slot[pcpu_nr_slots - 1];\n\tstruct pcpu_chunk *chunk, *next;\n\tint slot, nr_to_pop, ret;\n\n\t/*\n\t * There's no reason to keep around multiple unused chunks and VM\n\t * areas can be scarce.  Destroy all free chunks except for one.\n\t */\n\tmutex_lock(&pcpu_alloc_mutex);\n\tspin_lock_irq(&pcpu_lock);\n\n\tlist_for_each_entry_safe(chunk, next, free_head, list) {\n\t\tWARN_ON(chunk->immutable);\n\n\t\t/* spare the first one */\n\t\tif (chunk == list_first_entry(free_head, struct pcpu_chunk, list))\n\t\t\tcontinue;\n\n\t\tlist_move(&chunk->list, &to_free);\n\t}\n\n\tspin_unlock_irq(&pcpu_lock);\n\n\tlist_for_each_entry_safe(chunk, next, &to_free, list) {\n\t\tint rs, re;\n\n\t\tpcpu_for_each_pop_region(chunk->populated, rs, re, 0,\n\t\t\t\t\t chunk->nr_pages) {\n\t\t\tpcpu_depopulate_chunk(chunk, rs, re);\n\t\t\tspin_lock_irq(&pcpu_lock);\n\t\t\tpcpu_chunk_depopulated(chunk, rs, re);\n\t\t\tspin_unlock_irq(&pcpu_lock);\n\t\t}\n\t\tpcpu_destroy_chunk(chunk);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Ensure there are certain number of free populated pages for\n\t * atomic allocs.  Fill up from the most packed so that atomic\n\t * allocs don't increase fragmentation.  If atomic allocation\n\t * failed previously, always populate the maximum amount.  This\n\t * should prevent atomic allocs larger than PAGE_SIZE from keeping\n\t * failing indefinitely; however, large atomic allocs are not\n\t * something we support properly and can be highly unreliable and\n\t * inefficient.\n\t */\nretry_pop:\n\tif (pcpu_atomic_alloc_failed) {\n\t\tnr_to_pop = PCPU_EMPTY_POP_PAGES_HIGH;\n\t\t/* best effort anyway, don't worry about synchronization */\n\t\tpcpu_atomic_alloc_failed = false;\n\t} else {\n\t\tnr_to_pop = clamp(PCPU_EMPTY_POP_PAGES_HIGH -\n\t\t\t\t  pcpu_nr_empty_pop_pages,\n\t\t\t\t  0, PCPU_EMPTY_POP_PAGES_HIGH);\n\t}\n\n\tfor (slot = pcpu_size_to_slot(PAGE_SIZE); slot < pcpu_nr_slots; slot++) {\n\t\tint nr_unpop = 0, rs, re;\n\n\t\tif (!nr_to_pop)\n\t\t\tbreak;\n\n\t\tspin_lock_irq(&pcpu_lock);\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\tnr_unpop = chunk->nr_pages - chunk->nr_populated;\n\t\t\tif (nr_unpop)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&pcpu_lock);\n\n\t\tif (!nr_unpop)\n\t\t\tcontinue;\n\n\t\t/* @chunk can't go away while pcpu_alloc_mutex is held */\n\t\tpcpu_for_each_unpop_region(chunk->populated, rs, re, 0,\n\t\t\t\t\t   chunk->nr_pages) {\n\t\t\tint nr = min(re - rs, nr_to_pop);\n\n\t\t\tret = pcpu_populate_chunk(chunk, rs, rs + nr, gfp);\n\t\t\tif (!ret) {\n\t\t\t\tnr_to_pop -= nr;\n\t\t\t\tspin_lock_irq(&pcpu_lock);\n\t\t\t\tpcpu_chunk_populated(chunk, rs, rs + nr, false);\n\t\t\t\tspin_unlock_irq(&pcpu_lock);\n\t\t\t} else {\n\t\t\t\tnr_to_pop = 0;\n\t\t\t}\n\n\t\t\tif (!nr_to_pop)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (nr_to_pop) {\n\t\t/* ran out of chunks to populate, create a new one and retry */\n\t\tchunk = pcpu_create_chunk(gfp);\n\t\tif (chunk) {\n\t\t\tspin_lock_irq(&pcpu_lock);\n\t\t\tpcpu_chunk_relocate(chunk, -1);\n\t\t\tspin_unlock_irq(&pcpu_lock);\n\t\t\tgoto retry_pop;\n\t\t}\n\t}\n\n\tmutex_unlock(&pcpu_alloc_mutex);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [
      "#define PCPU_EMPTY_POP_PAGES_HIGH\t4"
    ],
    "globals_used": [
      "int pcpu_nr_slots",
      "static DEFINE_MUTEX(pcpu_alloc_mutex);",
      "int pcpu_nr_empty_pop_pages;",
      "static void pcpu_balance_workfn(struct work_struct *work);",
      "static DECLARE_WORK(pcpu_balance_work, pcpu_balance_workfn);",
      "static bool pcpu_atomic_alloc_failed;",
      "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);",
      "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pcpu_alloc_mutex"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_relocate",
          "args": [
            "chunk",
            "-1"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_relocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "504-514",
          "snippet": "static void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_create_chunk",
          "args": [
            "gfp"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_create_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-km.c",
          "lines": "48-79",
          "snippet": "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp)\n{\n\tconst int nr_pages = pcpu_group_sizes[0] >> PAGE_SHIFT;\n\tstruct pcpu_chunk *chunk;\n\tstruct page *pages;\n\tint i;\n\n\tchunk = pcpu_alloc_chunk(gfp);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tpages = alloc_pages(gfp, order_base_2(nr_pages));\n\tif (!pages) {\n\t\tpcpu_free_chunk(chunk);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++)\n\t\tpcpu_set_page_chunk(nth_page(pages, i), chunk);\n\n\tchunk->data = pages;\n\tchunk->base_addr = page_address(pages) - pcpu_group_offsets[0];\n\n\tspin_lock_irq(&pcpu_lock);\n\tpcpu_chunk_populated(chunk, 0, nr_pages, false);\n\tspin_unlock_irq(&pcpu_lock);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(chunk->base_addr);\n\n\treturn chunk;\n}",
          "includes": [
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp)\n{\n\tconst int nr_pages = pcpu_group_sizes[0] >> PAGE_SHIFT;\n\tstruct pcpu_chunk *chunk;\n\tstruct page *pages;\n\tint i;\n\n\tchunk = pcpu_alloc_chunk(gfp);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tpages = alloc_pages(gfp, order_base_2(nr_pages));\n\tif (!pages) {\n\t\tpcpu_free_chunk(chunk);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++)\n\t\tpcpu_set_page_chunk(nth_page(pages, i), chunk);\n\n\tchunk->data = pages;\n\tchunk->base_addr = page_address(pages) - pcpu_group_offsets[0];\n\n\tspin_lock_irq(&pcpu_lock);\n\tpcpu_chunk_populated(chunk, 0, nr_pages, false);\n\tspin_unlock_irq(&pcpu_lock);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(chunk->base_addr);\n\n\treturn chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_populated",
          "args": [
            "chunk",
            "rs",
            "rs + nr",
            "false"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1235-1250",
          "snippet": "static void pcpu_chunk_populated(struct pcpu_chunk *chunk, int page_start,\n\t\t\t\t int page_end, bool for_alloc)\n{\n\tint nr = page_end - page_start;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\tbitmap_set(chunk->populated, page_start, nr);\n\tchunk->nr_populated += nr;\n\tpcpu_nr_populated += nr;\n\n\tif (!for_alloc) {\n\t\tchunk->nr_empty_pop_pages += nr;\n\t\tpcpu_nr_empty_pop_pages += nr;\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcpu_nr_empty_pop_pages;",
            "static unsigned long pcpu_nr_populated;",
            "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nint pcpu_nr_empty_pop_pages;\nstatic unsigned long pcpu_nr_populated;\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_populated(struct pcpu_chunk *chunk, int page_start,\n\t\t\t\t int page_end, bool for_alloc)\n{\n\tint nr = page_end - page_start;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\tbitmap_set(chunk->populated, page_start, nr);\n\tchunk->nr_populated += nr;\n\tpcpu_nr_populated += nr;\n\n\tif (!for_alloc) {\n\t\tchunk->nr_empty_pop_pages += nr;\n\t\tpcpu_nr_empty_pop_pages += nr;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_populate_chunk",
          "args": [
            "chunk",
            "rs",
            "rs + nr",
            "gfp"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_populate_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-km.c",
          "lines": "36-40",
          "snippet": "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "re - rs",
            "nr_to_pop"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_for_each_unpop_region",
          "args": [
            "chunk->populated",
            "rs",
            "re",
            "0",
            "chunk->nr_pages"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "chunk",
            "&pcpu_slot[slot]",
            "list"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_size_to_slot",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_size_to_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "225-230",
          "snippet": "static int pcpu_size_to_slot(int size)\n{\n\tif (size == pcpu_unit_size)\n\t\treturn pcpu_nr_slots - 1;\n\treturn __pcpu_size_to_slot(size);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_size",
            "int pcpu_nr_slots"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\n\nstatic int pcpu_size_to_slot(int size)\n{\n\tif (size == pcpu_unit_size)\n\t\treturn pcpu_nr_slots - 1;\n\treturn __pcpu_size_to_slot(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "PCPU_EMPTY_POP_PAGES_HIGH -\n\t\t\t\t  pcpu_nr_empty_pop_pages",
            "0",
            "PCPU_EMPTY_POP_PAGES_HIGH"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_destroy_chunk",
          "args": [
            "chunk"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_destroy_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-km.c",
          "lines": "81-94",
          "snippet": "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk)\n{\n\tconst int nr_pages = pcpu_group_sizes[0] >> PAGE_SHIFT;\n\n\tif (!chunk)\n\t\treturn;\n\n\tpcpu_stats_chunk_dealloc();\n\ttrace_percpu_destroy_chunk(chunk->base_addr);\n\n\tif (chunk->data)\n\t\t__free_pages(chunk->data, order_base_2(nr_pages));\n\tpcpu_free_chunk(chunk);\n}",
          "includes": [
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk)\n{\n\tconst int nr_pages = pcpu_group_sizes[0] >> PAGE_SHIFT;\n\n\tif (!chunk)\n\t\treturn;\n\n\tpcpu_stats_chunk_dealloc();\n\ttrace_percpu_destroy_chunk(chunk->base_addr);\n\n\tif (chunk->data)\n\t\t__free_pages(chunk->data, order_base_2(nr_pages));\n\tpcpu_free_chunk(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_depopulated",
          "args": [
            "chunk",
            "rs",
            "re"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_depopulated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1262-1274",
          "snippet": "static void pcpu_chunk_depopulated(struct pcpu_chunk *chunk,\n\t\t\t\t   int page_start, int page_end)\n{\n\tint nr = page_end - page_start;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\tbitmap_clear(chunk->populated, page_start, nr);\n\tchunk->nr_populated -= nr;\n\tchunk->nr_empty_pop_pages -= nr;\n\tpcpu_nr_empty_pop_pages -= nr;\n\tpcpu_nr_populated -= nr;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcpu_nr_empty_pop_pages;",
            "static unsigned long pcpu_nr_populated;",
            "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nint pcpu_nr_empty_pop_pages;\nstatic unsigned long pcpu_nr_populated;\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_depopulated(struct pcpu_chunk *chunk,\n\t\t\t\t   int page_start, int page_end)\n{\n\tint nr = page_end - page_start;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\tbitmap_clear(chunk->populated, page_start, nr);\n\tchunk->nr_populated -= nr;\n\tchunk->nr_empty_pop_pages -= nr;\n\tpcpu_nr_empty_pop_pages -= nr;\n\tpcpu_nr_populated -= nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_depopulate_chunk",
          "args": [
            "chunk",
            "rs",
            "re"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_depopulate_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-km.c",
          "lines": "42-46",
          "snippet": "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end)\n{\n\t/* nada */\n}",
          "includes": [
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end)\n{\n\t/* nada */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_for_each_pop_region",
          "args": [
            "chunk->populated",
            "rs",
            "re",
            "0",
            "chunk->nr_pages"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "chunk",
            "next",
            "&to_free",
            "list"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&chunk->list",
            "&to_free"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "free_head",
            "structpcpu_chunk",
            "list"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "chunk->immutable"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "chunk",
            "next",
            "free_head",
            "list"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pcpu_alloc_mutex"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "to_free"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\n#define PCPU_EMPTY_POP_PAGES_HIGH\t4\n\nint pcpu_nr_slots;\nstatic DEFINE_MUTEX(pcpu_alloc_mutex);\nint pcpu_nr_empty_pop_pages;\nstatic void pcpu_balance_workfn(struct work_struct *work);\nstatic DECLARE_WORK(pcpu_balance_work, pcpu_balance_workfn);\nstatic bool pcpu_atomic_alloc_failed;\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_balance_workfn(struct work_struct *work)\n{\n\t/* gfp flags passed to underlying allocators */\n\tconst gfp_t gfp = GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN;\n\tLIST_HEAD(to_free);\n\tstruct list_head *free_head = &pcpu_slot[pcpu_nr_slots - 1];\n\tstruct pcpu_chunk *chunk, *next;\n\tint slot, nr_to_pop, ret;\n\n\t/*\n\t * There's no reason to keep around multiple unused chunks and VM\n\t * areas can be scarce.  Destroy all free chunks except for one.\n\t */\n\tmutex_lock(&pcpu_alloc_mutex);\n\tspin_lock_irq(&pcpu_lock);\n\n\tlist_for_each_entry_safe(chunk, next, free_head, list) {\n\t\tWARN_ON(chunk->immutable);\n\n\t\t/* spare the first one */\n\t\tif (chunk == list_first_entry(free_head, struct pcpu_chunk, list))\n\t\t\tcontinue;\n\n\t\tlist_move(&chunk->list, &to_free);\n\t}\n\n\tspin_unlock_irq(&pcpu_lock);\n\n\tlist_for_each_entry_safe(chunk, next, &to_free, list) {\n\t\tint rs, re;\n\n\t\tpcpu_for_each_pop_region(chunk->populated, rs, re, 0,\n\t\t\t\t\t chunk->nr_pages) {\n\t\t\tpcpu_depopulate_chunk(chunk, rs, re);\n\t\t\tspin_lock_irq(&pcpu_lock);\n\t\t\tpcpu_chunk_depopulated(chunk, rs, re);\n\t\t\tspin_unlock_irq(&pcpu_lock);\n\t\t}\n\t\tpcpu_destroy_chunk(chunk);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Ensure there are certain number of free populated pages for\n\t * atomic allocs.  Fill up from the most packed so that atomic\n\t * allocs don't increase fragmentation.  If atomic allocation\n\t * failed previously, always populate the maximum amount.  This\n\t * should prevent atomic allocs larger than PAGE_SIZE from keeping\n\t * failing indefinitely; however, large atomic allocs are not\n\t * something we support properly and can be highly unreliable and\n\t * inefficient.\n\t */\nretry_pop:\n\tif (pcpu_atomic_alloc_failed) {\n\t\tnr_to_pop = PCPU_EMPTY_POP_PAGES_HIGH;\n\t\t/* best effort anyway, don't worry about synchronization */\n\t\tpcpu_atomic_alloc_failed = false;\n\t} else {\n\t\tnr_to_pop = clamp(PCPU_EMPTY_POP_PAGES_HIGH -\n\t\t\t\t  pcpu_nr_empty_pop_pages,\n\t\t\t\t  0, PCPU_EMPTY_POP_PAGES_HIGH);\n\t}\n\n\tfor (slot = pcpu_size_to_slot(PAGE_SIZE); slot < pcpu_nr_slots; slot++) {\n\t\tint nr_unpop = 0, rs, re;\n\n\t\tif (!nr_to_pop)\n\t\t\tbreak;\n\n\t\tspin_lock_irq(&pcpu_lock);\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\tnr_unpop = chunk->nr_pages - chunk->nr_populated;\n\t\t\tif (nr_unpop)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&pcpu_lock);\n\n\t\tif (!nr_unpop)\n\t\t\tcontinue;\n\n\t\t/* @chunk can't go away while pcpu_alloc_mutex is held */\n\t\tpcpu_for_each_unpop_region(chunk->populated, rs, re, 0,\n\t\t\t\t\t   chunk->nr_pages) {\n\t\t\tint nr = min(re - rs, nr_to_pop);\n\n\t\t\tret = pcpu_populate_chunk(chunk, rs, rs + nr, gfp);\n\t\t\tif (!ret) {\n\t\t\t\tnr_to_pop -= nr;\n\t\t\t\tspin_lock_irq(&pcpu_lock);\n\t\t\t\tpcpu_chunk_populated(chunk, rs, rs + nr, false);\n\t\t\t\tspin_unlock_irq(&pcpu_lock);\n\t\t\t} else {\n\t\t\t\tnr_to_pop = 0;\n\t\t\t}\n\n\t\t\tif (!nr_to_pop)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (nr_to_pop) {\n\t\t/* ran out of chunks to populate, create a new one and retry */\n\t\tchunk = pcpu_create_chunk(gfp);\n\t\tif (chunk) {\n\t\t\tspin_lock_irq(&pcpu_lock);\n\t\t\tpcpu_chunk_relocate(chunk, -1);\n\t\t\tspin_unlock_irq(&pcpu_lock);\n\t\t\tgoto retry_pop;\n\t\t}\n\t}\n\n\tmutex_unlock(&pcpu_alloc_mutex);\n}"
  },
  {
    "function_name": "__alloc_reserved_percpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1579-1582",
    "snippet": "void __percpu *__alloc_reserved_percpu(size_t size, size_t align)\n{\n\treturn pcpu_alloc(size, align, true, GFP_KERNEL);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_alloc",
          "args": [
            "size",
            "align",
            "true",
            "GFP_KERNEL"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1352-1527",
          "snippet": "static void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved,\n\t\t\t\t gfp_t gfp)\n{\n\t/* whitelisted flags that can be passed to the backing allocators */\n\tgfp_t pcpu_gfp = gfp & (GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tbool is_atomic = (gfp & GFP_KERNEL) != GFP_KERNEL;\n\tbool do_warn = !(gfp & __GFP_NOWARN);\n\tstatic int warn_limit = 10;\n\tstruct pcpu_chunk *chunk;\n\tconst char *err;\n\tint slot, off, cpu, ret;\n\tunsigned long flags;\n\tvoid __percpu *ptr;\n\tsize_t bits, bit_align;\n\n\t/*\n\t * There is now a minimum allocation size of PCPU_MIN_ALLOC_SIZE,\n\t * therefore alignment must be a minimum of that many bytes.\n\t * An allocation may have internal fragmentation from rounding up\n\t * of up to PCPU_MIN_ALLOC_SIZE - 1 bytes.\n\t */\n\tif (unlikely(align < PCPU_MIN_ALLOC_SIZE))\n\t\talign = PCPU_MIN_ALLOC_SIZE;\n\n\tsize = ALIGN(size, PCPU_MIN_ALLOC_SIZE);\n\tbits = size >> PCPU_MIN_ALLOC_SHIFT;\n\tbit_align = align >> PCPU_MIN_ALLOC_SHIFT;\n\n\tif (unlikely(!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE ||\n\t\t     !is_power_of_2(align))) {\n\t\tWARN(do_warn, \"illegal size (%zu) or align (%zu) for percpu allocation\\n\",\n\t\t     size, align);\n\t\treturn NULL;\n\t}\n\n\tif (!is_atomic) {\n\t\t/*\n\t\t * pcpu_balance_workfn() allocates memory under this mutex,\n\t\t * and it may wait for memory reclaim. Allow current task\n\t\t * to become OOM victim, in case of memory pressure.\n\t\t */\n\t\tif (gfp & __GFP_NOFAIL)\n\t\t\tmutex_lock(&pcpu_alloc_mutex);\n\t\telse if (mutex_lock_killable(&pcpu_alloc_mutex))\n\t\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\t/* serve reserved allocations from the reserved chunk if available */\n\tif (reserved && pcpu_reserved_chunk) {\n\t\tchunk = pcpu_reserved_chunk;\n\n\t\toff = pcpu_find_block_fit(chunk, bits, bit_align, is_atomic);\n\t\tif (off < 0) {\n\t\t\terr = \"alloc from reserved chunk failed\";\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\tif (off >= 0)\n\t\t\tgoto area_found;\n\n\t\terr = \"alloc from reserved chunk failed\";\n\t\tgoto fail_unlock;\n\t}\n\nrestart:\n\t/* search through normal chunks */\n\tfor (slot = pcpu_size_to_slot(size); slot < pcpu_nr_slots; slot++) {\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\toff = pcpu_find_block_fit(chunk, bits, bit_align,\n\t\t\t\t\t\t  is_atomic);\n\t\t\tif (off < 0)\n\t\t\t\tcontinue;\n\n\t\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\t\tif (off >= 0)\n\t\t\t\tgoto area_found;\n\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/*\n\t * No space left.  Create a new chunk.  We don't want multiple\n\t * tasks to create chunks simultaneously.  Serialize and create iff\n\t * there's still no empty chunk after grabbing the mutex.\n\t */\n\tif (is_atomic) {\n\t\terr = \"atomic alloc failed, no space left\";\n\t\tgoto fail;\n\t}\n\n\tif (list_empty(&pcpu_slot[pcpu_nr_slots - 1])) {\n\t\tchunk = pcpu_create_chunk(pcpu_gfp);\n\t\tif (!chunk) {\n\t\t\terr = \"failed to allocate new chunk\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\tpcpu_chunk_relocate(chunk, -1);\n\t} else {\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t}\n\n\tgoto restart;\n\narea_found:\n\tpcpu_stats_area_alloc(chunk, size);\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/* populate if not all pages are already there */\n\tif (!is_atomic) {\n\t\tint page_start, page_end, rs, re;\n\n\t\tpage_start = PFN_DOWN(off);\n\t\tpage_end = PFN_UP(off + size);\n\n\t\tpcpu_for_each_unpop_region(chunk->populated, rs, re,\n\t\t\t\t\t   page_start, page_end) {\n\t\t\tWARN_ON(chunk->immutable);\n\n\t\t\tret = pcpu_populate_chunk(chunk, rs, re, pcpu_gfp);\n\n\t\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\t\tif (ret) {\n\t\t\t\tpcpu_free_area(chunk, off);\n\t\t\t\terr = \"failed to populate\";\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t\tpcpu_chunk_populated(chunk, rs, re, true);\n\t\t\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\t\t}\n\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\n\tif (pcpu_nr_empty_pop_pages < PCPU_EMPTY_POP_PAGES_LOW)\n\t\tpcpu_schedule_balance_work();\n\n\t/* clear the areas and return address relative to base address */\n\tfor_each_possible_cpu(cpu)\n\t\tmemset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);\n\n\tptr = __addr_to_pcpu_ptr(chunk->base_addr + off);\n\tkmemleak_alloc_percpu(ptr, size, gfp);\n\n\ttrace_percpu_alloc_percpu(reserved, is_atomic, size, align,\n\t\t\tchunk->base_addr, off, ptr);\n\n\treturn ptr;\n\nfail_unlock:\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\nfail:\n\ttrace_percpu_alloc_percpu_fail(reserved, is_atomic, size, align);\n\n\tif (!is_atomic && do_warn && warn_limit) {\n\t\tpr_warn(\"allocation failed, size=%zu align=%zu atomic=%d, %s\\n\",\n\t\t\tsize, align, is_atomic, err);\n\t\tdump_stack();\n\t\tif (!--warn_limit)\n\t\t\tpr_info(\"limit reached, disable warning\\n\");\n\t}\n\tif (is_atomic) {\n\t\t/* see the flag handling in pcpu_blance_workfn() */\n\t\tpcpu_atomic_alloc_failed = true;\n\t\tpcpu_schedule_balance_work();\n\t} else {\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [
            "#define PCPU_EMPTY_POP_PAGES_LOW\t2"
          ],
          "globals_used": [
            "int pcpu_nr_slots",
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "static DEFINE_MUTEX(pcpu_alloc_mutex);",
            "int pcpu_nr_empty_pop_pages;",
            "static DECLARE_WORK(pcpu_balance_work, pcpu_balance_workfn);",
            "static bool pcpu_atomic_alloc_failed;",
            "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);",
            "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
            "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\n#define PCPU_EMPTY_POP_PAGES_LOW\t2\n\nint pcpu_nr_slots;\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic DEFINE_MUTEX(pcpu_alloc_mutex);\nint pcpu_nr_empty_pop_pages;\nstatic DECLARE_WORK(pcpu_balance_work, pcpu_balance_workfn);\nstatic bool pcpu_atomic_alloc_failed;\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved,\n\t\t\t\t gfp_t gfp)\n{\n\t/* whitelisted flags that can be passed to the backing allocators */\n\tgfp_t pcpu_gfp = gfp & (GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tbool is_atomic = (gfp & GFP_KERNEL) != GFP_KERNEL;\n\tbool do_warn = !(gfp & __GFP_NOWARN);\n\tstatic int warn_limit = 10;\n\tstruct pcpu_chunk *chunk;\n\tconst char *err;\n\tint slot, off, cpu, ret;\n\tunsigned long flags;\n\tvoid __percpu *ptr;\n\tsize_t bits, bit_align;\n\n\t/*\n\t * There is now a minimum allocation size of PCPU_MIN_ALLOC_SIZE,\n\t * therefore alignment must be a minimum of that many bytes.\n\t * An allocation may have internal fragmentation from rounding up\n\t * of up to PCPU_MIN_ALLOC_SIZE - 1 bytes.\n\t */\n\tif (unlikely(align < PCPU_MIN_ALLOC_SIZE))\n\t\talign = PCPU_MIN_ALLOC_SIZE;\n\n\tsize = ALIGN(size, PCPU_MIN_ALLOC_SIZE);\n\tbits = size >> PCPU_MIN_ALLOC_SHIFT;\n\tbit_align = align >> PCPU_MIN_ALLOC_SHIFT;\n\n\tif (unlikely(!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE ||\n\t\t     !is_power_of_2(align))) {\n\t\tWARN(do_warn, \"illegal size (%zu) or align (%zu) for percpu allocation\\n\",\n\t\t     size, align);\n\t\treturn NULL;\n\t}\n\n\tif (!is_atomic) {\n\t\t/*\n\t\t * pcpu_balance_workfn() allocates memory under this mutex,\n\t\t * and it may wait for memory reclaim. Allow current task\n\t\t * to become OOM victim, in case of memory pressure.\n\t\t */\n\t\tif (gfp & __GFP_NOFAIL)\n\t\t\tmutex_lock(&pcpu_alloc_mutex);\n\t\telse if (mutex_lock_killable(&pcpu_alloc_mutex))\n\t\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\t/* serve reserved allocations from the reserved chunk if available */\n\tif (reserved && pcpu_reserved_chunk) {\n\t\tchunk = pcpu_reserved_chunk;\n\n\t\toff = pcpu_find_block_fit(chunk, bits, bit_align, is_atomic);\n\t\tif (off < 0) {\n\t\t\terr = \"alloc from reserved chunk failed\";\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\tif (off >= 0)\n\t\t\tgoto area_found;\n\n\t\terr = \"alloc from reserved chunk failed\";\n\t\tgoto fail_unlock;\n\t}\n\nrestart:\n\t/* search through normal chunks */\n\tfor (slot = pcpu_size_to_slot(size); slot < pcpu_nr_slots; slot++) {\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\toff = pcpu_find_block_fit(chunk, bits, bit_align,\n\t\t\t\t\t\t  is_atomic);\n\t\t\tif (off < 0)\n\t\t\t\tcontinue;\n\n\t\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\t\tif (off >= 0)\n\t\t\t\tgoto area_found;\n\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/*\n\t * No space left.  Create a new chunk.  We don't want multiple\n\t * tasks to create chunks simultaneously.  Serialize and create iff\n\t * there's still no empty chunk after grabbing the mutex.\n\t */\n\tif (is_atomic) {\n\t\terr = \"atomic alloc failed, no space left\";\n\t\tgoto fail;\n\t}\n\n\tif (list_empty(&pcpu_slot[pcpu_nr_slots - 1])) {\n\t\tchunk = pcpu_create_chunk(pcpu_gfp);\n\t\tif (!chunk) {\n\t\t\terr = \"failed to allocate new chunk\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\tpcpu_chunk_relocate(chunk, -1);\n\t} else {\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t}\n\n\tgoto restart;\n\narea_found:\n\tpcpu_stats_area_alloc(chunk, size);\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/* populate if not all pages are already there */\n\tif (!is_atomic) {\n\t\tint page_start, page_end, rs, re;\n\n\t\tpage_start = PFN_DOWN(off);\n\t\tpage_end = PFN_UP(off + size);\n\n\t\tpcpu_for_each_unpop_region(chunk->populated, rs, re,\n\t\t\t\t\t   page_start, page_end) {\n\t\t\tWARN_ON(chunk->immutable);\n\n\t\t\tret = pcpu_populate_chunk(chunk, rs, re, pcpu_gfp);\n\n\t\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\t\tif (ret) {\n\t\t\t\tpcpu_free_area(chunk, off);\n\t\t\t\terr = \"failed to populate\";\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t\tpcpu_chunk_populated(chunk, rs, re, true);\n\t\t\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\t\t}\n\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\n\tif (pcpu_nr_empty_pop_pages < PCPU_EMPTY_POP_PAGES_LOW)\n\t\tpcpu_schedule_balance_work();\n\n\t/* clear the areas and return address relative to base address */\n\tfor_each_possible_cpu(cpu)\n\t\tmemset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);\n\n\tptr = __addr_to_pcpu_ptr(chunk->base_addr + off);\n\tkmemleak_alloc_percpu(ptr, size, gfp);\n\n\ttrace_percpu_alloc_percpu(reserved, is_atomic, size, align,\n\t\t\tchunk->base_addr, off, ptr);\n\n\treturn ptr;\n\nfail_unlock:\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\nfail:\n\ttrace_percpu_alloc_percpu_fail(reserved, is_atomic, size, align);\n\n\tif (!is_atomic && do_warn && warn_limit) {\n\t\tpr_warn(\"allocation failed, size=%zu align=%zu atomic=%d, %s\\n\",\n\t\t\tsize, align, is_atomic, err);\n\t\tdump_stack();\n\t\tif (!--warn_limit)\n\t\t\tpr_info(\"limit reached, disable warning\\n\");\n\t}\n\tif (is_atomic) {\n\t\t/* see the flag handling in pcpu_blance_workfn() */\n\t\tpcpu_atomic_alloc_failed = true;\n\t\tpcpu_schedule_balance_work();\n\t} else {\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nvoid __percpu *__alloc_reserved_percpu(size_t size, size_t align)\n{\n\treturn pcpu_alloc(size, align, true, GFP_KERNEL);\n}"
  },
  {
    "function_name": "__alloc_percpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1557-1560",
    "snippet": "void __percpu *__alloc_percpu(size_t size, size_t align)\n{\n\treturn pcpu_alloc(size, align, false, GFP_KERNEL);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_alloc",
          "args": [
            "size",
            "align",
            "false",
            "GFP_KERNEL"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1352-1527",
          "snippet": "static void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved,\n\t\t\t\t gfp_t gfp)\n{\n\t/* whitelisted flags that can be passed to the backing allocators */\n\tgfp_t pcpu_gfp = gfp & (GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tbool is_atomic = (gfp & GFP_KERNEL) != GFP_KERNEL;\n\tbool do_warn = !(gfp & __GFP_NOWARN);\n\tstatic int warn_limit = 10;\n\tstruct pcpu_chunk *chunk;\n\tconst char *err;\n\tint slot, off, cpu, ret;\n\tunsigned long flags;\n\tvoid __percpu *ptr;\n\tsize_t bits, bit_align;\n\n\t/*\n\t * There is now a minimum allocation size of PCPU_MIN_ALLOC_SIZE,\n\t * therefore alignment must be a minimum of that many bytes.\n\t * An allocation may have internal fragmentation from rounding up\n\t * of up to PCPU_MIN_ALLOC_SIZE - 1 bytes.\n\t */\n\tif (unlikely(align < PCPU_MIN_ALLOC_SIZE))\n\t\talign = PCPU_MIN_ALLOC_SIZE;\n\n\tsize = ALIGN(size, PCPU_MIN_ALLOC_SIZE);\n\tbits = size >> PCPU_MIN_ALLOC_SHIFT;\n\tbit_align = align >> PCPU_MIN_ALLOC_SHIFT;\n\n\tif (unlikely(!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE ||\n\t\t     !is_power_of_2(align))) {\n\t\tWARN(do_warn, \"illegal size (%zu) or align (%zu) for percpu allocation\\n\",\n\t\t     size, align);\n\t\treturn NULL;\n\t}\n\n\tif (!is_atomic) {\n\t\t/*\n\t\t * pcpu_balance_workfn() allocates memory under this mutex,\n\t\t * and it may wait for memory reclaim. Allow current task\n\t\t * to become OOM victim, in case of memory pressure.\n\t\t */\n\t\tif (gfp & __GFP_NOFAIL)\n\t\t\tmutex_lock(&pcpu_alloc_mutex);\n\t\telse if (mutex_lock_killable(&pcpu_alloc_mutex))\n\t\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\t/* serve reserved allocations from the reserved chunk if available */\n\tif (reserved && pcpu_reserved_chunk) {\n\t\tchunk = pcpu_reserved_chunk;\n\n\t\toff = pcpu_find_block_fit(chunk, bits, bit_align, is_atomic);\n\t\tif (off < 0) {\n\t\t\terr = \"alloc from reserved chunk failed\";\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\tif (off >= 0)\n\t\t\tgoto area_found;\n\n\t\terr = \"alloc from reserved chunk failed\";\n\t\tgoto fail_unlock;\n\t}\n\nrestart:\n\t/* search through normal chunks */\n\tfor (slot = pcpu_size_to_slot(size); slot < pcpu_nr_slots; slot++) {\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\toff = pcpu_find_block_fit(chunk, bits, bit_align,\n\t\t\t\t\t\t  is_atomic);\n\t\t\tif (off < 0)\n\t\t\t\tcontinue;\n\n\t\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\t\tif (off >= 0)\n\t\t\t\tgoto area_found;\n\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/*\n\t * No space left.  Create a new chunk.  We don't want multiple\n\t * tasks to create chunks simultaneously.  Serialize and create iff\n\t * there's still no empty chunk after grabbing the mutex.\n\t */\n\tif (is_atomic) {\n\t\terr = \"atomic alloc failed, no space left\";\n\t\tgoto fail;\n\t}\n\n\tif (list_empty(&pcpu_slot[pcpu_nr_slots - 1])) {\n\t\tchunk = pcpu_create_chunk(pcpu_gfp);\n\t\tif (!chunk) {\n\t\t\terr = \"failed to allocate new chunk\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\tpcpu_chunk_relocate(chunk, -1);\n\t} else {\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t}\n\n\tgoto restart;\n\narea_found:\n\tpcpu_stats_area_alloc(chunk, size);\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/* populate if not all pages are already there */\n\tif (!is_atomic) {\n\t\tint page_start, page_end, rs, re;\n\n\t\tpage_start = PFN_DOWN(off);\n\t\tpage_end = PFN_UP(off + size);\n\n\t\tpcpu_for_each_unpop_region(chunk->populated, rs, re,\n\t\t\t\t\t   page_start, page_end) {\n\t\t\tWARN_ON(chunk->immutable);\n\n\t\t\tret = pcpu_populate_chunk(chunk, rs, re, pcpu_gfp);\n\n\t\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\t\tif (ret) {\n\t\t\t\tpcpu_free_area(chunk, off);\n\t\t\t\terr = \"failed to populate\";\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t\tpcpu_chunk_populated(chunk, rs, re, true);\n\t\t\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\t\t}\n\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\n\tif (pcpu_nr_empty_pop_pages < PCPU_EMPTY_POP_PAGES_LOW)\n\t\tpcpu_schedule_balance_work();\n\n\t/* clear the areas and return address relative to base address */\n\tfor_each_possible_cpu(cpu)\n\t\tmemset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);\n\n\tptr = __addr_to_pcpu_ptr(chunk->base_addr + off);\n\tkmemleak_alloc_percpu(ptr, size, gfp);\n\n\ttrace_percpu_alloc_percpu(reserved, is_atomic, size, align,\n\t\t\tchunk->base_addr, off, ptr);\n\n\treturn ptr;\n\nfail_unlock:\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\nfail:\n\ttrace_percpu_alloc_percpu_fail(reserved, is_atomic, size, align);\n\n\tif (!is_atomic && do_warn && warn_limit) {\n\t\tpr_warn(\"allocation failed, size=%zu align=%zu atomic=%d, %s\\n\",\n\t\t\tsize, align, is_atomic, err);\n\t\tdump_stack();\n\t\tif (!--warn_limit)\n\t\t\tpr_info(\"limit reached, disable warning\\n\");\n\t}\n\tif (is_atomic) {\n\t\t/* see the flag handling in pcpu_blance_workfn() */\n\t\tpcpu_atomic_alloc_failed = true;\n\t\tpcpu_schedule_balance_work();\n\t} else {\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [
            "#define PCPU_EMPTY_POP_PAGES_LOW\t2"
          ],
          "globals_used": [
            "int pcpu_nr_slots",
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "static DEFINE_MUTEX(pcpu_alloc_mutex);",
            "int pcpu_nr_empty_pop_pages;",
            "static DECLARE_WORK(pcpu_balance_work, pcpu_balance_workfn);",
            "static bool pcpu_atomic_alloc_failed;",
            "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);",
            "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
            "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\n#define PCPU_EMPTY_POP_PAGES_LOW\t2\n\nint pcpu_nr_slots;\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic DEFINE_MUTEX(pcpu_alloc_mutex);\nint pcpu_nr_empty_pop_pages;\nstatic DECLARE_WORK(pcpu_balance_work, pcpu_balance_workfn);\nstatic bool pcpu_atomic_alloc_failed;\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved,\n\t\t\t\t gfp_t gfp)\n{\n\t/* whitelisted flags that can be passed to the backing allocators */\n\tgfp_t pcpu_gfp = gfp & (GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tbool is_atomic = (gfp & GFP_KERNEL) != GFP_KERNEL;\n\tbool do_warn = !(gfp & __GFP_NOWARN);\n\tstatic int warn_limit = 10;\n\tstruct pcpu_chunk *chunk;\n\tconst char *err;\n\tint slot, off, cpu, ret;\n\tunsigned long flags;\n\tvoid __percpu *ptr;\n\tsize_t bits, bit_align;\n\n\t/*\n\t * There is now a minimum allocation size of PCPU_MIN_ALLOC_SIZE,\n\t * therefore alignment must be a minimum of that many bytes.\n\t * An allocation may have internal fragmentation from rounding up\n\t * of up to PCPU_MIN_ALLOC_SIZE - 1 bytes.\n\t */\n\tif (unlikely(align < PCPU_MIN_ALLOC_SIZE))\n\t\talign = PCPU_MIN_ALLOC_SIZE;\n\n\tsize = ALIGN(size, PCPU_MIN_ALLOC_SIZE);\n\tbits = size >> PCPU_MIN_ALLOC_SHIFT;\n\tbit_align = align >> PCPU_MIN_ALLOC_SHIFT;\n\n\tif (unlikely(!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE ||\n\t\t     !is_power_of_2(align))) {\n\t\tWARN(do_warn, \"illegal size (%zu) or align (%zu) for percpu allocation\\n\",\n\t\t     size, align);\n\t\treturn NULL;\n\t}\n\n\tif (!is_atomic) {\n\t\t/*\n\t\t * pcpu_balance_workfn() allocates memory under this mutex,\n\t\t * and it may wait for memory reclaim. Allow current task\n\t\t * to become OOM victim, in case of memory pressure.\n\t\t */\n\t\tif (gfp & __GFP_NOFAIL)\n\t\t\tmutex_lock(&pcpu_alloc_mutex);\n\t\telse if (mutex_lock_killable(&pcpu_alloc_mutex))\n\t\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\t/* serve reserved allocations from the reserved chunk if available */\n\tif (reserved && pcpu_reserved_chunk) {\n\t\tchunk = pcpu_reserved_chunk;\n\n\t\toff = pcpu_find_block_fit(chunk, bits, bit_align, is_atomic);\n\t\tif (off < 0) {\n\t\t\terr = \"alloc from reserved chunk failed\";\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\tif (off >= 0)\n\t\t\tgoto area_found;\n\n\t\terr = \"alloc from reserved chunk failed\";\n\t\tgoto fail_unlock;\n\t}\n\nrestart:\n\t/* search through normal chunks */\n\tfor (slot = pcpu_size_to_slot(size); slot < pcpu_nr_slots; slot++) {\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\toff = pcpu_find_block_fit(chunk, bits, bit_align,\n\t\t\t\t\t\t  is_atomic);\n\t\t\tif (off < 0)\n\t\t\t\tcontinue;\n\n\t\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\t\tif (off >= 0)\n\t\t\t\tgoto area_found;\n\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/*\n\t * No space left.  Create a new chunk.  We don't want multiple\n\t * tasks to create chunks simultaneously.  Serialize and create iff\n\t * there's still no empty chunk after grabbing the mutex.\n\t */\n\tif (is_atomic) {\n\t\terr = \"atomic alloc failed, no space left\";\n\t\tgoto fail;\n\t}\n\n\tif (list_empty(&pcpu_slot[pcpu_nr_slots - 1])) {\n\t\tchunk = pcpu_create_chunk(pcpu_gfp);\n\t\tif (!chunk) {\n\t\t\terr = \"failed to allocate new chunk\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\tpcpu_chunk_relocate(chunk, -1);\n\t} else {\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t}\n\n\tgoto restart;\n\narea_found:\n\tpcpu_stats_area_alloc(chunk, size);\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/* populate if not all pages are already there */\n\tif (!is_atomic) {\n\t\tint page_start, page_end, rs, re;\n\n\t\tpage_start = PFN_DOWN(off);\n\t\tpage_end = PFN_UP(off + size);\n\n\t\tpcpu_for_each_unpop_region(chunk->populated, rs, re,\n\t\t\t\t\t   page_start, page_end) {\n\t\t\tWARN_ON(chunk->immutable);\n\n\t\t\tret = pcpu_populate_chunk(chunk, rs, re, pcpu_gfp);\n\n\t\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\t\tif (ret) {\n\t\t\t\tpcpu_free_area(chunk, off);\n\t\t\t\terr = \"failed to populate\";\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t\tpcpu_chunk_populated(chunk, rs, re, true);\n\t\t\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\t\t}\n\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\n\tif (pcpu_nr_empty_pop_pages < PCPU_EMPTY_POP_PAGES_LOW)\n\t\tpcpu_schedule_balance_work();\n\n\t/* clear the areas and return address relative to base address */\n\tfor_each_possible_cpu(cpu)\n\t\tmemset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);\n\n\tptr = __addr_to_pcpu_ptr(chunk->base_addr + off);\n\tkmemleak_alloc_percpu(ptr, size, gfp);\n\n\ttrace_percpu_alloc_percpu(reserved, is_atomic, size, align,\n\t\t\tchunk->base_addr, off, ptr);\n\n\treturn ptr;\n\nfail_unlock:\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\nfail:\n\ttrace_percpu_alloc_percpu_fail(reserved, is_atomic, size, align);\n\n\tif (!is_atomic && do_warn && warn_limit) {\n\t\tpr_warn(\"allocation failed, size=%zu align=%zu atomic=%d, %s\\n\",\n\t\t\tsize, align, is_atomic, err);\n\t\tdump_stack();\n\t\tif (!--warn_limit)\n\t\t\tpr_info(\"limit reached, disable warning\\n\");\n\t}\n\tif (is_atomic) {\n\t\t/* see the flag handling in pcpu_blance_workfn() */\n\t\tpcpu_atomic_alloc_failed = true;\n\t\tpcpu_schedule_balance_work();\n\t} else {\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nvoid __percpu *__alloc_percpu(size_t size, size_t align)\n{\n\treturn pcpu_alloc(size, align, false, GFP_KERNEL);\n}"
  },
  {
    "function_name": "__alloc_percpu_gfp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1544-1547",
    "snippet": "void __percpu *__alloc_percpu_gfp(size_t size, size_t align, gfp_t gfp)\n{\n\treturn pcpu_alloc(size, align, false, gfp);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);",
      "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_alloc",
          "args": [
            "size",
            "align",
            "false",
            "gfp"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1352-1527",
          "snippet": "static void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved,\n\t\t\t\t gfp_t gfp)\n{\n\t/* whitelisted flags that can be passed to the backing allocators */\n\tgfp_t pcpu_gfp = gfp & (GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tbool is_atomic = (gfp & GFP_KERNEL) != GFP_KERNEL;\n\tbool do_warn = !(gfp & __GFP_NOWARN);\n\tstatic int warn_limit = 10;\n\tstruct pcpu_chunk *chunk;\n\tconst char *err;\n\tint slot, off, cpu, ret;\n\tunsigned long flags;\n\tvoid __percpu *ptr;\n\tsize_t bits, bit_align;\n\n\t/*\n\t * There is now a minimum allocation size of PCPU_MIN_ALLOC_SIZE,\n\t * therefore alignment must be a minimum of that many bytes.\n\t * An allocation may have internal fragmentation from rounding up\n\t * of up to PCPU_MIN_ALLOC_SIZE - 1 bytes.\n\t */\n\tif (unlikely(align < PCPU_MIN_ALLOC_SIZE))\n\t\talign = PCPU_MIN_ALLOC_SIZE;\n\n\tsize = ALIGN(size, PCPU_MIN_ALLOC_SIZE);\n\tbits = size >> PCPU_MIN_ALLOC_SHIFT;\n\tbit_align = align >> PCPU_MIN_ALLOC_SHIFT;\n\n\tif (unlikely(!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE ||\n\t\t     !is_power_of_2(align))) {\n\t\tWARN(do_warn, \"illegal size (%zu) or align (%zu) for percpu allocation\\n\",\n\t\t     size, align);\n\t\treturn NULL;\n\t}\n\n\tif (!is_atomic) {\n\t\t/*\n\t\t * pcpu_balance_workfn() allocates memory under this mutex,\n\t\t * and it may wait for memory reclaim. Allow current task\n\t\t * to become OOM victim, in case of memory pressure.\n\t\t */\n\t\tif (gfp & __GFP_NOFAIL)\n\t\t\tmutex_lock(&pcpu_alloc_mutex);\n\t\telse if (mutex_lock_killable(&pcpu_alloc_mutex))\n\t\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\t/* serve reserved allocations from the reserved chunk if available */\n\tif (reserved && pcpu_reserved_chunk) {\n\t\tchunk = pcpu_reserved_chunk;\n\n\t\toff = pcpu_find_block_fit(chunk, bits, bit_align, is_atomic);\n\t\tif (off < 0) {\n\t\t\terr = \"alloc from reserved chunk failed\";\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\tif (off >= 0)\n\t\t\tgoto area_found;\n\n\t\terr = \"alloc from reserved chunk failed\";\n\t\tgoto fail_unlock;\n\t}\n\nrestart:\n\t/* search through normal chunks */\n\tfor (slot = pcpu_size_to_slot(size); slot < pcpu_nr_slots; slot++) {\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\toff = pcpu_find_block_fit(chunk, bits, bit_align,\n\t\t\t\t\t\t  is_atomic);\n\t\t\tif (off < 0)\n\t\t\t\tcontinue;\n\n\t\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\t\tif (off >= 0)\n\t\t\t\tgoto area_found;\n\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/*\n\t * No space left.  Create a new chunk.  We don't want multiple\n\t * tasks to create chunks simultaneously.  Serialize and create iff\n\t * there's still no empty chunk after grabbing the mutex.\n\t */\n\tif (is_atomic) {\n\t\terr = \"atomic alloc failed, no space left\";\n\t\tgoto fail;\n\t}\n\n\tif (list_empty(&pcpu_slot[pcpu_nr_slots - 1])) {\n\t\tchunk = pcpu_create_chunk(pcpu_gfp);\n\t\tif (!chunk) {\n\t\t\terr = \"failed to allocate new chunk\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\tpcpu_chunk_relocate(chunk, -1);\n\t} else {\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t}\n\n\tgoto restart;\n\narea_found:\n\tpcpu_stats_area_alloc(chunk, size);\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/* populate if not all pages are already there */\n\tif (!is_atomic) {\n\t\tint page_start, page_end, rs, re;\n\n\t\tpage_start = PFN_DOWN(off);\n\t\tpage_end = PFN_UP(off + size);\n\n\t\tpcpu_for_each_unpop_region(chunk->populated, rs, re,\n\t\t\t\t\t   page_start, page_end) {\n\t\t\tWARN_ON(chunk->immutable);\n\n\t\t\tret = pcpu_populate_chunk(chunk, rs, re, pcpu_gfp);\n\n\t\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\t\tif (ret) {\n\t\t\t\tpcpu_free_area(chunk, off);\n\t\t\t\terr = \"failed to populate\";\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t\tpcpu_chunk_populated(chunk, rs, re, true);\n\t\t\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\t\t}\n\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\n\tif (pcpu_nr_empty_pop_pages < PCPU_EMPTY_POP_PAGES_LOW)\n\t\tpcpu_schedule_balance_work();\n\n\t/* clear the areas and return address relative to base address */\n\tfor_each_possible_cpu(cpu)\n\t\tmemset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);\n\n\tptr = __addr_to_pcpu_ptr(chunk->base_addr + off);\n\tkmemleak_alloc_percpu(ptr, size, gfp);\n\n\ttrace_percpu_alloc_percpu(reserved, is_atomic, size, align,\n\t\t\tchunk->base_addr, off, ptr);\n\n\treturn ptr;\n\nfail_unlock:\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\nfail:\n\ttrace_percpu_alloc_percpu_fail(reserved, is_atomic, size, align);\n\n\tif (!is_atomic && do_warn && warn_limit) {\n\t\tpr_warn(\"allocation failed, size=%zu align=%zu atomic=%d, %s\\n\",\n\t\t\tsize, align, is_atomic, err);\n\t\tdump_stack();\n\t\tif (!--warn_limit)\n\t\t\tpr_info(\"limit reached, disable warning\\n\");\n\t}\n\tif (is_atomic) {\n\t\t/* see the flag handling in pcpu_blance_workfn() */\n\t\tpcpu_atomic_alloc_failed = true;\n\t\tpcpu_schedule_balance_work();\n\t} else {\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [
            "#define PCPU_EMPTY_POP_PAGES_LOW\t2"
          ],
          "globals_used": [
            "int pcpu_nr_slots",
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "static DEFINE_MUTEX(pcpu_alloc_mutex);",
            "int pcpu_nr_empty_pop_pages;",
            "static DECLARE_WORK(pcpu_balance_work, pcpu_balance_workfn);",
            "static bool pcpu_atomic_alloc_failed;",
            "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);",
            "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
            "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\n#define PCPU_EMPTY_POP_PAGES_LOW\t2\n\nint pcpu_nr_slots;\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic DEFINE_MUTEX(pcpu_alloc_mutex);\nint pcpu_nr_empty_pop_pages;\nstatic DECLARE_WORK(pcpu_balance_work, pcpu_balance_workfn);\nstatic bool pcpu_atomic_alloc_failed;\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved,\n\t\t\t\t gfp_t gfp)\n{\n\t/* whitelisted flags that can be passed to the backing allocators */\n\tgfp_t pcpu_gfp = gfp & (GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tbool is_atomic = (gfp & GFP_KERNEL) != GFP_KERNEL;\n\tbool do_warn = !(gfp & __GFP_NOWARN);\n\tstatic int warn_limit = 10;\n\tstruct pcpu_chunk *chunk;\n\tconst char *err;\n\tint slot, off, cpu, ret;\n\tunsigned long flags;\n\tvoid __percpu *ptr;\n\tsize_t bits, bit_align;\n\n\t/*\n\t * There is now a minimum allocation size of PCPU_MIN_ALLOC_SIZE,\n\t * therefore alignment must be a minimum of that many bytes.\n\t * An allocation may have internal fragmentation from rounding up\n\t * of up to PCPU_MIN_ALLOC_SIZE - 1 bytes.\n\t */\n\tif (unlikely(align < PCPU_MIN_ALLOC_SIZE))\n\t\talign = PCPU_MIN_ALLOC_SIZE;\n\n\tsize = ALIGN(size, PCPU_MIN_ALLOC_SIZE);\n\tbits = size >> PCPU_MIN_ALLOC_SHIFT;\n\tbit_align = align >> PCPU_MIN_ALLOC_SHIFT;\n\n\tif (unlikely(!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE ||\n\t\t     !is_power_of_2(align))) {\n\t\tWARN(do_warn, \"illegal size (%zu) or align (%zu) for percpu allocation\\n\",\n\t\t     size, align);\n\t\treturn NULL;\n\t}\n\n\tif (!is_atomic) {\n\t\t/*\n\t\t * pcpu_balance_workfn() allocates memory under this mutex,\n\t\t * and it may wait for memory reclaim. Allow current task\n\t\t * to become OOM victim, in case of memory pressure.\n\t\t */\n\t\tif (gfp & __GFP_NOFAIL)\n\t\t\tmutex_lock(&pcpu_alloc_mutex);\n\t\telse if (mutex_lock_killable(&pcpu_alloc_mutex))\n\t\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\t/* serve reserved allocations from the reserved chunk if available */\n\tif (reserved && pcpu_reserved_chunk) {\n\t\tchunk = pcpu_reserved_chunk;\n\n\t\toff = pcpu_find_block_fit(chunk, bits, bit_align, is_atomic);\n\t\tif (off < 0) {\n\t\t\terr = \"alloc from reserved chunk failed\";\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\tif (off >= 0)\n\t\t\tgoto area_found;\n\n\t\terr = \"alloc from reserved chunk failed\";\n\t\tgoto fail_unlock;\n\t}\n\nrestart:\n\t/* search through normal chunks */\n\tfor (slot = pcpu_size_to_slot(size); slot < pcpu_nr_slots; slot++) {\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\toff = pcpu_find_block_fit(chunk, bits, bit_align,\n\t\t\t\t\t\t  is_atomic);\n\t\t\tif (off < 0)\n\t\t\t\tcontinue;\n\n\t\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\t\tif (off >= 0)\n\t\t\t\tgoto area_found;\n\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/*\n\t * No space left.  Create a new chunk.  We don't want multiple\n\t * tasks to create chunks simultaneously.  Serialize and create iff\n\t * there's still no empty chunk after grabbing the mutex.\n\t */\n\tif (is_atomic) {\n\t\terr = \"atomic alloc failed, no space left\";\n\t\tgoto fail;\n\t}\n\n\tif (list_empty(&pcpu_slot[pcpu_nr_slots - 1])) {\n\t\tchunk = pcpu_create_chunk(pcpu_gfp);\n\t\tif (!chunk) {\n\t\t\terr = \"failed to allocate new chunk\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\tpcpu_chunk_relocate(chunk, -1);\n\t} else {\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t}\n\n\tgoto restart;\n\narea_found:\n\tpcpu_stats_area_alloc(chunk, size);\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/* populate if not all pages are already there */\n\tif (!is_atomic) {\n\t\tint page_start, page_end, rs, re;\n\n\t\tpage_start = PFN_DOWN(off);\n\t\tpage_end = PFN_UP(off + size);\n\n\t\tpcpu_for_each_unpop_region(chunk->populated, rs, re,\n\t\t\t\t\t   page_start, page_end) {\n\t\t\tWARN_ON(chunk->immutable);\n\n\t\t\tret = pcpu_populate_chunk(chunk, rs, re, pcpu_gfp);\n\n\t\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\t\tif (ret) {\n\t\t\t\tpcpu_free_area(chunk, off);\n\t\t\t\terr = \"failed to populate\";\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t\tpcpu_chunk_populated(chunk, rs, re, true);\n\t\t\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\t\t}\n\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\n\tif (pcpu_nr_empty_pop_pages < PCPU_EMPTY_POP_PAGES_LOW)\n\t\tpcpu_schedule_balance_work();\n\n\t/* clear the areas and return address relative to base address */\n\tfor_each_possible_cpu(cpu)\n\t\tmemset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);\n\n\tptr = __addr_to_pcpu_ptr(chunk->base_addr + off);\n\tkmemleak_alloc_percpu(ptr, size, gfp);\n\n\ttrace_percpu_alloc_percpu(reserved, is_atomic, size, align,\n\t\t\tchunk->base_addr, off, ptr);\n\n\treturn ptr;\n\nfail_unlock:\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\nfail:\n\ttrace_percpu_alloc_percpu_fail(reserved, is_atomic, size, align);\n\n\tif (!is_atomic && do_warn && warn_limit) {\n\t\tpr_warn(\"allocation failed, size=%zu align=%zu atomic=%d, %s\\n\",\n\t\t\tsize, align, is_atomic, err);\n\t\tdump_stack();\n\t\tif (!--warn_limit)\n\t\t\tpr_info(\"limit reached, disable warning\\n\");\n\t}\n\tif (is_atomic) {\n\t\t/* see the flag handling in pcpu_blance_workfn() */\n\t\tpcpu_atomic_alloc_failed = true;\n\t\tpcpu_schedule_balance_work();\n\t} else {\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);\n\nvoid __percpu *__alloc_percpu_gfp(size_t size, size_t align, gfp_t gfp)\n{\n\treturn pcpu_alloc(size, align, false, gfp);\n}"
  },
  {
    "function_name": "pcpu_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1352-1527",
    "snippet": "static void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved,\n\t\t\t\t gfp_t gfp)\n{\n\t/* whitelisted flags that can be passed to the backing allocators */\n\tgfp_t pcpu_gfp = gfp & (GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tbool is_atomic = (gfp & GFP_KERNEL) != GFP_KERNEL;\n\tbool do_warn = !(gfp & __GFP_NOWARN);\n\tstatic int warn_limit = 10;\n\tstruct pcpu_chunk *chunk;\n\tconst char *err;\n\tint slot, off, cpu, ret;\n\tunsigned long flags;\n\tvoid __percpu *ptr;\n\tsize_t bits, bit_align;\n\n\t/*\n\t * There is now a minimum allocation size of PCPU_MIN_ALLOC_SIZE,\n\t * therefore alignment must be a minimum of that many bytes.\n\t * An allocation may have internal fragmentation from rounding up\n\t * of up to PCPU_MIN_ALLOC_SIZE - 1 bytes.\n\t */\n\tif (unlikely(align < PCPU_MIN_ALLOC_SIZE))\n\t\talign = PCPU_MIN_ALLOC_SIZE;\n\n\tsize = ALIGN(size, PCPU_MIN_ALLOC_SIZE);\n\tbits = size >> PCPU_MIN_ALLOC_SHIFT;\n\tbit_align = align >> PCPU_MIN_ALLOC_SHIFT;\n\n\tif (unlikely(!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE ||\n\t\t     !is_power_of_2(align))) {\n\t\tWARN(do_warn, \"illegal size (%zu) or align (%zu) for percpu allocation\\n\",\n\t\t     size, align);\n\t\treturn NULL;\n\t}\n\n\tif (!is_atomic) {\n\t\t/*\n\t\t * pcpu_balance_workfn() allocates memory under this mutex,\n\t\t * and it may wait for memory reclaim. Allow current task\n\t\t * to become OOM victim, in case of memory pressure.\n\t\t */\n\t\tif (gfp & __GFP_NOFAIL)\n\t\t\tmutex_lock(&pcpu_alloc_mutex);\n\t\telse if (mutex_lock_killable(&pcpu_alloc_mutex))\n\t\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\t/* serve reserved allocations from the reserved chunk if available */\n\tif (reserved && pcpu_reserved_chunk) {\n\t\tchunk = pcpu_reserved_chunk;\n\n\t\toff = pcpu_find_block_fit(chunk, bits, bit_align, is_atomic);\n\t\tif (off < 0) {\n\t\t\terr = \"alloc from reserved chunk failed\";\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\tif (off >= 0)\n\t\t\tgoto area_found;\n\n\t\terr = \"alloc from reserved chunk failed\";\n\t\tgoto fail_unlock;\n\t}\n\nrestart:\n\t/* search through normal chunks */\n\tfor (slot = pcpu_size_to_slot(size); slot < pcpu_nr_slots; slot++) {\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\toff = pcpu_find_block_fit(chunk, bits, bit_align,\n\t\t\t\t\t\t  is_atomic);\n\t\t\tif (off < 0)\n\t\t\t\tcontinue;\n\n\t\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\t\tif (off >= 0)\n\t\t\t\tgoto area_found;\n\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/*\n\t * No space left.  Create a new chunk.  We don't want multiple\n\t * tasks to create chunks simultaneously.  Serialize and create iff\n\t * there's still no empty chunk after grabbing the mutex.\n\t */\n\tif (is_atomic) {\n\t\terr = \"atomic alloc failed, no space left\";\n\t\tgoto fail;\n\t}\n\n\tif (list_empty(&pcpu_slot[pcpu_nr_slots - 1])) {\n\t\tchunk = pcpu_create_chunk(pcpu_gfp);\n\t\tif (!chunk) {\n\t\t\terr = \"failed to allocate new chunk\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\tpcpu_chunk_relocate(chunk, -1);\n\t} else {\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t}\n\n\tgoto restart;\n\narea_found:\n\tpcpu_stats_area_alloc(chunk, size);\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/* populate if not all pages are already there */\n\tif (!is_atomic) {\n\t\tint page_start, page_end, rs, re;\n\n\t\tpage_start = PFN_DOWN(off);\n\t\tpage_end = PFN_UP(off + size);\n\n\t\tpcpu_for_each_unpop_region(chunk->populated, rs, re,\n\t\t\t\t\t   page_start, page_end) {\n\t\t\tWARN_ON(chunk->immutable);\n\n\t\t\tret = pcpu_populate_chunk(chunk, rs, re, pcpu_gfp);\n\n\t\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\t\tif (ret) {\n\t\t\t\tpcpu_free_area(chunk, off);\n\t\t\t\terr = \"failed to populate\";\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t\tpcpu_chunk_populated(chunk, rs, re, true);\n\t\t\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\t\t}\n\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\n\tif (pcpu_nr_empty_pop_pages < PCPU_EMPTY_POP_PAGES_LOW)\n\t\tpcpu_schedule_balance_work();\n\n\t/* clear the areas and return address relative to base address */\n\tfor_each_possible_cpu(cpu)\n\t\tmemset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);\n\n\tptr = __addr_to_pcpu_ptr(chunk->base_addr + off);\n\tkmemleak_alloc_percpu(ptr, size, gfp);\n\n\ttrace_percpu_alloc_percpu(reserved, is_atomic, size, align,\n\t\t\tchunk->base_addr, off, ptr);\n\n\treturn ptr;\n\nfail_unlock:\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\nfail:\n\ttrace_percpu_alloc_percpu_fail(reserved, is_atomic, size, align);\n\n\tif (!is_atomic && do_warn && warn_limit) {\n\t\tpr_warn(\"allocation failed, size=%zu align=%zu atomic=%d, %s\\n\",\n\t\t\tsize, align, is_atomic, err);\n\t\tdump_stack();\n\t\tif (!--warn_limit)\n\t\t\tpr_info(\"limit reached, disable warning\\n\");\n\t}\n\tif (is_atomic) {\n\t\t/* see the flag handling in pcpu_blance_workfn() */\n\t\tpcpu_atomic_alloc_failed = true;\n\t\tpcpu_schedule_balance_work();\n\t} else {\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [
      "#define PCPU_EMPTY_POP_PAGES_LOW\t2"
    ],
    "globals_used": [
      "int pcpu_nr_slots",
      "struct pcpu_chunk *pcpu_reserved_chunk",
      "static DEFINE_MUTEX(pcpu_alloc_mutex);",
      "int pcpu_nr_empty_pop_pages;",
      "static DECLARE_WORK(pcpu_balance_work, pcpu_balance_workfn);",
      "static bool pcpu_atomic_alloc_failed;",
      "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);",
      "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
      "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pcpu_alloc_mutex"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_schedule_balance_work",
          "args": [],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_schedule_balance_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "191-195",
          "snippet": "static void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool pcpu_async_enabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic bool pcpu_async_enabled;\n\nstatic void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"limit reached, disable warning\\n\""
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"allocation failed, size=%zu align=%zu atomic=%d, %s\\n\"",
            "size",
            "align",
            "is_atomic",
            "err"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_percpu_alloc_percpu_fail",
          "args": [
            "reserved",
            "is_atomic",
            "size",
            "align"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pcpu_lock",
            "flags"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_percpu_alloc_percpu",
          "args": [
            "reserved",
            "is_atomic",
            "size",
            "align",
            "chunk->base_addr",
            "off",
            "ptr"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_alloc_percpu",
          "args": [
            "ptr",
            "size",
            "gfp"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "987-1004",
          "snippet": "void __ref kmemleak_alloc_percpu(const void __percpu *ptr, size_t size,\n\t\t\t\t gfp_t gfp)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p, %zu)\\n\", __func__, ptr, size);\n\n\t/*\n\t * Percpu allocations are only scanned and not reported as leaks\n\t * (min_count is set to 0).\n\t */\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tcreate_object((unsigned long)per_cpu_ptr(ptr, cpu),\n\t\t\t\t      size, 0, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_ALLOC_PERCPU, ptr, size, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_alloc_percpu(const void __percpu *ptr, size_t size,\n\t\t\t\t gfp_t gfp)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p, %zu)\\n\", __func__, ptr, size);\n\n\t/*\n\t * Percpu allocations are only scanned and not reported as leaks\n\t * (min_count is set to 0).\n\t */\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tcreate_object((unsigned long)per_cpu_ptr(ptr, cpu),\n\t\t\t\t      size, 0, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_ALLOC_PERCPU, ptr, size, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__addr_to_pcpu_ptr",
          "args": [
            "chunk->base_addr + off"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_addr",
          "args": [
            "chunk",
            "cpu",
            "0"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "262-267",
          "snippet": "static unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pcpu_alloc_mutex"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pcpu_lock",
            "flags"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_populated",
          "args": [
            "chunk",
            "rs",
            "re",
            "true"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1235-1250",
          "snippet": "static void pcpu_chunk_populated(struct pcpu_chunk *chunk, int page_start,\n\t\t\t\t int page_end, bool for_alloc)\n{\n\tint nr = page_end - page_start;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\tbitmap_set(chunk->populated, page_start, nr);\n\tchunk->nr_populated += nr;\n\tpcpu_nr_populated += nr;\n\n\tif (!for_alloc) {\n\t\tchunk->nr_empty_pop_pages += nr;\n\t\tpcpu_nr_empty_pop_pages += nr;\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcpu_nr_empty_pop_pages;",
            "static unsigned long pcpu_nr_populated;",
            "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nint pcpu_nr_empty_pop_pages;\nstatic unsigned long pcpu_nr_populated;\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_populated(struct pcpu_chunk *chunk, int page_start,\n\t\t\t\t int page_end, bool for_alloc)\n{\n\tint nr = page_end - page_start;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\tbitmap_set(chunk->populated, page_start, nr);\n\tchunk->nr_populated += nr;\n\tpcpu_nr_populated += nr;\n\n\tif (!for_alloc) {\n\t\tchunk->nr_empty_pop_pages += nr;\n\t\tpcpu_nr_empty_pop_pages += nr;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_free_area",
          "args": [
            "chunk",
            "off"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_free_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1029-1055",
          "snippet": "static void pcpu_free_area(struct pcpu_chunk *chunk, int off)\n{\n\tint bit_off, bits, end, oslot;\n\n\tlockdep_assert_held(&pcpu_lock);\n\tpcpu_stats_area_dealloc(chunk);\n\n\toslot = pcpu_chunk_slot(chunk);\n\n\tbit_off = off / PCPU_MIN_ALLOC_SIZE;\n\n\t/* find end index */\n\tend = find_next_bit(chunk->bound_map, pcpu_chunk_map_bits(chunk),\n\t\t\t    bit_off + 1);\n\tbits = end - bit_off;\n\tbitmap_clear(chunk->alloc_map, bit_off, bits);\n\n\t/* update metadata */\n\tchunk->free_bytes += bits * PCPU_MIN_ALLOC_SIZE;\n\n\t/* update first free bit */\n\tchunk->first_bit = min(chunk->first_bit, bit_off);\n\n\tpcpu_block_update_hint_free(chunk, bit_off, bits);\n\n\tpcpu_chunk_relocate(chunk, oslot);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_free_area(struct pcpu_chunk *chunk, int off)\n{\n\tint bit_off, bits, end, oslot;\n\n\tlockdep_assert_held(&pcpu_lock);\n\tpcpu_stats_area_dealloc(chunk);\n\n\toslot = pcpu_chunk_slot(chunk);\n\n\tbit_off = off / PCPU_MIN_ALLOC_SIZE;\n\n\t/* find end index */\n\tend = find_next_bit(chunk->bound_map, pcpu_chunk_map_bits(chunk),\n\t\t\t    bit_off + 1);\n\tbits = end - bit_off;\n\tbitmap_clear(chunk->alloc_map, bit_off, bits);\n\n\t/* update metadata */\n\tchunk->free_bytes += bits * PCPU_MIN_ALLOC_SIZE;\n\n\t/* update first free bit */\n\tchunk->first_bit = min(chunk->first_bit, bit_off);\n\n\tpcpu_block_update_hint_free(chunk, bit_off, bits);\n\n\tpcpu_chunk_relocate(chunk, oslot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pcpu_lock",
            "flags"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_populate_chunk",
          "args": [
            "chunk",
            "rs",
            "re",
            "pcpu_gfp"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_populate_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-km.c",
          "lines": "36-40",
          "snippet": "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "chunk->immutable"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_for_each_unpop_region",
          "args": [
            "chunk->populated",
            "rs",
            "re",
            "page_start",
            "page_end"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "off + size"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "off"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pcpu_lock",
            "flags"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_stats_area_alloc",
          "args": [
            "chunk",
            "size"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_stats_area_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "207-209",
          "snippet": "static inline void pcpu_stats_area_alloc(struct pcpu_chunk *chunk, size_t size)\n{\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline void pcpu_stats_area_alloc(struct pcpu_chunk *chunk, size_t size)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pcpu_lock",
            "flags"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_relocate",
          "args": [
            "chunk",
            "-1"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_relocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "504-514",
          "snippet": "static void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pcpu_lock",
            "flags"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_create_chunk",
          "args": [
            "pcpu_gfp"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_create_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-km.c",
          "lines": "48-79",
          "snippet": "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp)\n{\n\tconst int nr_pages = pcpu_group_sizes[0] >> PAGE_SHIFT;\n\tstruct pcpu_chunk *chunk;\n\tstruct page *pages;\n\tint i;\n\n\tchunk = pcpu_alloc_chunk(gfp);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tpages = alloc_pages(gfp, order_base_2(nr_pages));\n\tif (!pages) {\n\t\tpcpu_free_chunk(chunk);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++)\n\t\tpcpu_set_page_chunk(nth_page(pages, i), chunk);\n\n\tchunk->data = pages;\n\tchunk->base_addr = page_address(pages) - pcpu_group_offsets[0];\n\n\tspin_lock_irq(&pcpu_lock);\n\tpcpu_chunk_populated(chunk, 0, nr_pages, false);\n\tspin_unlock_irq(&pcpu_lock);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(chunk->base_addr);\n\n\treturn chunk;\n}",
          "includes": [
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp)\n{\n\tconst int nr_pages = pcpu_group_sizes[0] >> PAGE_SHIFT;\n\tstruct pcpu_chunk *chunk;\n\tstruct page *pages;\n\tint i;\n\n\tchunk = pcpu_alloc_chunk(gfp);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tpages = alloc_pages(gfp, order_base_2(nr_pages));\n\tif (!pages) {\n\t\tpcpu_free_chunk(chunk);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++)\n\t\tpcpu_set_page_chunk(nth_page(pages, i), chunk);\n\n\tchunk->data = pages;\n\tchunk->base_addr = page_address(pages) - pcpu_group_offsets[0];\n\n\tspin_lock_irq(&pcpu_lock);\n\tpcpu_chunk_populated(chunk, 0, nr_pages, false);\n\tspin_unlock_irq(&pcpu_lock);\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(chunk->base_addr);\n\n\treturn chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pcpu_slot[pcpu_nr_slots - 1]"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pcpu_lock",
            "flags"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_alloc_area",
          "args": [
            "chunk",
            "bits",
            "bit_align",
            "off"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_alloc_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "978-1019",
          "snippet": "static int pcpu_alloc_area(struct pcpu_chunk *chunk, int alloc_bits,\n\t\t\t   size_t align, int start)\n{\n\tsize_t align_mask = (align) ? (align - 1) : 0;\n\tint bit_off, end, oslot;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\toslot = pcpu_chunk_slot(chunk);\n\n\t/*\n\t * Search to find a fit.\n\t */\n\tend = start + alloc_bits + PCPU_BITMAP_BLOCK_BITS;\n\tbit_off = bitmap_find_next_zero_area(chunk->alloc_map, end, start,\n\t\t\t\t\t     alloc_bits, align_mask);\n\tif (bit_off >= end)\n\t\treturn -1;\n\n\t/* update alloc map */\n\tbitmap_set(chunk->alloc_map, bit_off, alloc_bits);\n\n\t/* update boundary map */\n\tset_bit(bit_off, chunk->bound_map);\n\tbitmap_clear(chunk->bound_map, bit_off + 1, alloc_bits - 1);\n\tset_bit(bit_off + alloc_bits, chunk->bound_map);\n\n\tchunk->free_bytes -= alloc_bits * PCPU_MIN_ALLOC_SIZE;\n\n\t/* update first free bit */\n\tif (bit_off == chunk->first_bit)\n\t\tchunk->first_bit = find_next_zero_bit(\n\t\t\t\t\tchunk->alloc_map,\n\t\t\t\t\tpcpu_chunk_map_bits(chunk),\n\t\t\t\t\tbit_off + alloc_bits);\n\n\tpcpu_block_update_hint_alloc(chunk, bit_off, alloc_bits);\n\n\tpcpu_chunk_relocate(chunk, oslot);\n\n\treturn bit_off * PCPU_MIN_ALLOC_SIZE;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic int pcpu_alloc_area(struct pcpu_chunk *chunk, int alloc_bits,\n\t\t\t   size_t align, int start)\n{\n\tsize_t align_mask = (align) ? (align - 1) : 0;\n\tint bit_off, end, oslot;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\toslot = pcpu_chunk_slot(chunk);\n\n\t/*\n\t * Search to find a fit.\n\t */\n\tend = start + alloc_bits + PCPU_BITMAP_BLOCK_BITS;\n\tbit_off = bitmap_find_next_zero_area(chunk->alloc_map, end, start,\n\t\t\t\t\t     alloc_bits, align_mask);\n\tif (bit_off >= end)\n\t\treturn -1;\n\n\t/* update alloc map */\n\tbitmap_set(chunk->alloc_map, bit_off, alloc_bits);\n\n\t/* update boundary map */\n\tset_bit(bit_off, chunk->bound_map);\n\tbitmap_clear(chunk->bound_map, bit_off + 1, alloc_bits - 1);\n\tset_bit(bit_off + alloc_bits, chunk->bound_map);\n\n\tchunk->free_bytes -= alloc_bits * PCPU_MIN_ALLOC_SIZE;\n\n\t/* update first free bit */\n\tif (bit_off == chunk->first_bit)\n\t\tchunk->first_bit = find_next_zero_bit(\n\t\t\t\t\tchunk->alloc_map,\n\t\t\t\t\tpcpu_chunk_map_bits(chunk),\n\t\t\t\t\tbit_off + alloc_bits);\n\n\tpcpu_block_update_hint_alloc(chunk, bit_off, alloc_bits);\n\n\tpcpu_chunk_relocate(chunk, oslot);\n\n\treturn bit_off * PCPU_MIN_ALLOC_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_find_block_fit",
          "args": [
            "chunk",
            "bits",
            "bit_align",
            "is_atomic"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_find_block_fit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "926-957",
          "snippet": "static int pcpu_find_block_fit(struct pcpu_chunk *chunk, int alloc_bits,\n\t\t\t       size_t align, bool pop_only)\n{\n\tint bit_off, bits, next_off;\n\n\t/*\n\t * Check to see if the allocation can fit in the chunk's contig hint.\n\t * This is an optimization to prevent scanning by assuming if it\n\t * cannot fit in the global hint, there is memory pressure and creating\n\t * a new chunk would happen soon.\n\t */\n\tbit_off = ALIGN(chunk->contig_bits_start, align) -\n\t\t  chunk->contig_bits_start;\n\tif (bit_off + alloc_bits > chunk->contig_bits)\n\t\treturn -1;\n\n\tbit_off = chunk->first_bit;\n\tbits = 0;\n\tpcpu_for_each_fit_region(chunk, alloc_bits, align, bit_off, bits) {\n\t\tif (!pop_only || pcpu_is_populated(chunk, bit_off, bits,\n\t\t\t\t\t\t   &next_off))\n\t\t\tbreak;\n\n\t\tbit_off = next_off;\n\t\tbits = 0;\n\t}\n\n\tif (bit_off == pcpu_chunk_map_bits(chunk))\n\t\treturn -1;\n\n\treturn bit_off;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic int pcpu_find_block_fit(struct pcpu_chunk *chunk, int alloc_bits,\n\t\t\t       size_t align, bool pop_only)\n{\n\tint bit_off, bits, next_off;\n\n\t/*\n\t * Check to see if the allocation can fit in the chunk's contig hint.\n\t * This is an optimization to prevent scanning by assuming if it\n\t * cannot fit in the global hint, there is memory pressure and creating\n\t * a new chunk would happen soon.\n\t */\n\tbit_off = ALIGN(chunk->contig_bits_start, align) -\n\t\t  chunk->contig_bits_start;\n\tif (bit_off + alloc_bits > chunk->contig_bits)\n\t\treturn -1;\n\n\tbit_off = chunk->first_bit;\n\tbits = 0;\n\tpcpu_for_each_fit_region(chunk, alloc_bits, align, bit_off, bits) {\n\t\tif (!pop_only || pcpu_is_populated(chunk, bit_off, bits,\n\t\t\t\t\t\t   &next_off))\n\t\t\tbreak;\n\n\t\tbit_off = next_off;\n\t\tbits = 0;\n\t}\n\n\tif (bit_off == pcpu_chunk_map_bits(chunk))\n\t\treturn -1;\n\n\treturn bit_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "chunk",
            "&pcpu_slot[slot]",
            "list"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_size_to_slot",
          "args": [
            "size"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_size_to_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "225-230",
          "snippet": "static int pcpu_size_to_slot(int size)\n{\n\tif (size == pcpu_unit_size)\n\t\treturn pcpu_nr_slots - 1;\n\treturn __pcpu_size_to_slot(size);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_size",
            "int pcpu_nr_slots"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\n\nstatic int pcpu_size_to_slot(int size)\n{\n\tif (size == pcpu_unit_size)\n\t\treturn pcpu_nr_slots - 1;\n\treturn __pcpu_size_to_slot(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pcpu_lock",
            "flags"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_killable",
          "args": [
            "&pcpu_alloc_mutex"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pcpu_alloc_mutex"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "do_warn",
            "\"illegal size (%zu) or align (%zu) for percpu allocation\\n\"",
            "size",
            "align"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE ||\n\t\t     !is_power_of_2(align)"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "align"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "PCPU_MIN_ALLOC_SIZE"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "align < PCPU_MIN_ALLOC_SIZE"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\n#define PCPU_EMPTY_POP_PAGES_LOW\t2\n\nint pcpu_nr_slots;\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic DEFINE_MUTEX(pcpu_alloc_mutex);\nint pcpu_nr_empty_pop_pages;\nstatic DECLARE_WORK(pcpu_balance_work, pcpu_balance_workfn);\nstatic bool pcpu_atomic_alloc_failed;\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved,\n\t\t\t\t gfp_t gfp)\n{\n\t/* whitelisted flags that can be passed to the backing allocators */\n\tgfp_t pcpu_gfp = gfp & (GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tbool is_atomic = (gfp & GFP_KERNEL) != GFP_KERNEL;\n\tbool do_warn = !(gfp & __GFP_NOWARN);\n\tstatic int warn_limit = 10;\n\tstruct pcpu_chunk *chunk;\n\tconst char *err;\n\tint slot, off, cpu, ret;\n\tunsigned long flags;\n\tvoid __percpu *ptr;\n\tsize_t bits, bit_align;\n\n\t/*\n\t * There is now a minimum allocation size of PCPU_MIN_ALLOC_SIZE,\n\t * therefore alignment must be a minimum of that many bytes.\n\t * An allocation may have internal fragmentation from rounding up\n\t * of up to PCPU_MIN_ALLOC_SIZE - 1 bytes.\n\t */\n\tif (unlikely(align < PCPU_MIN_ALLOC_SIZE))\n\t\talign = PCPU_MIN_ALLOC_SIZE;\n\n\tsize = ALIGN(size, PCPU_MIN_ALLOC_SIZE);\n\tbits = size >> PCPU_MIN_ALLOC_SHIFT;\n\tbit_align = align >> PCPU_MIN_ALLOC_SHIFT;\n\n\tif (unlikely(!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE ||\n\t\t     !is_power_of_2(align))) {\n\t\tWARN(do_warn, \"illegal size (%zu) or align (%zu) for percpu allocation\\n\",\n\t\t     size, align);\n\t\treturn NULL;\n\t}\n\n\tif (!is_atomic) {\n\t\t/*\n\t\t * pcpu_balance_workfn() allocates memory under this mutex,\n\t\t * and it may wait for memory reclaim. Allow current task\n\t\t * to become OOM victim, in case of memory pressure.\n\t\t */\n\t\tif (gfp & __GFP_NOFAIL)\n\t\t\tmutex_lock(&pcpu_alloc_mutex);\n\t\telse if (mutex_lock_killable(&pcpu_alloc_mutex))\n\t\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\t/* serve reserved allocations from the reserved chunk if available */\n\tif (reserved && pcpu_reserved_chunk) {\n\t\tchunk = pcpu_reserved_chunk;\n\n\t\toff = pcpu_find_block_fit(chunk, bits, bit_align, is_atomic);\n\t\tif (off < 0) {\n\t\t\terr = \"alloc from reserved chunk failed\";\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\tif (off >= 0)\n\t\t\tgoto area_found;\n\n\t\terr = \"alloc from reserved chunk failed\";\n\t\tgoto fail_unlock;\n\t}\n\nrestart:\n\t/* search through normal chunks */\n\tfor (slot = pcpu_size_to_slot(size); slot < pcpu_nr_slots; slot++) {\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\toff = pcpu_find_block_fit(chunk, bits, bit_align,\n\t\t\t\t\t\t  is_atomic);\n\t\t\tif (off < 0)\n\t\t\t\tcontinue;\n\n\t\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);\n\t\t\tif (off >= 0)\n\t\t\t\tgoto area_found;\n\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/*\n\t * No space left.  Create a new chunk.  We don't want multiple\n\t * tasks to create chunks simultaneously.  Serialize and create iff\n\t * there's still no empty chunk after grabbing the mutex.\n\t */\n\tif (is_atomic) {\n\t\terr = \"atomic alloc failed, no space left\";\n\t\tgoto fail;\n\t}\n\n\tif (list_empty(&pcpu_slot[pcpu_nr_slots - 1])) {\n\t\tchunk = pcpu_create_chunk(pcpu_gfp);\n\t\tif (!chunk) {\n\t\t\terr = \"failed to allocate new chunk\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\tpcpu_chunk_relocate(chunk, -1);\n\t} else {\n\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t}\n\n\tgoto restart;\n\narea_found:\n\tpcpu_stats_area_alloc(chunk, size);\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/* populate if not all pages are already there */\n\tif (!is_atomic) {\n\t\tint page_start, page_end, rs, re;\n\n\t\tpage_start = PFN_DOWN(off);\n\t\tpage_end = PFN_UP(off + size);\n\n\t\tpcpu_for_each_unpop_region(chunk->populated, rs, re,\n\t\t\t\t\t   page_start, page_end) {\n\t\t\tWARN_ON(chunk->immutable);\n\n\t\t\tret = pcpu_populate_chunk(chunk, rs, re, pcpu_gfp);\n\n\t\t\tspin_lock_irqsave(&pcpu_lock, flags);\n\t\t\tif (ret) {\n\t\t\t\tpcpu_free_area(chunk, off);\n\t\t\t\terr = \"failed to populate\";\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t\tpcpu_chunk_populated(chunk, rs, re, true);\n\t\t\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\t\t}\n\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\n\tif (pcpu_nr_empty_pop_pages < PCPU_EMPTY_POP_PAGES_LOW)\n\t\tpcpu_schedule_balance_work();\n\n\t/* clear the areas and return address relative to base address */\n\tfor_each_possible_cpu(cpu)\n\t\tmemset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);\n\n\tptr = __addr_to_pcpu_ptr(chunk->base_addr + off);\n\tkmemleak_alloc_percpu(ptr, size, gfp);\n\n\ttrace_percpu_alloc_percpu(reserved, is_atomic, size, align,\n\t\t\tchunk->base_addr, off, ptr);\n\n\treturn ptr;\n\nfail_unlock:\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\nfail:\n\ttrace_percpu_alloc_percpu_fail(reserved, is_atomic, size, align);\n\n\tif (!is_atomic && do_warn && warn_limit) {\n\t\tpr_warn(\"allocation failed, size=%zu align=%zu atomic=%d, %s\\n\",\n\t\t\tsize, align, is_atomic, err);\n\t\tdump_stack();\n\t\tif (!--warn_limit)\n\t\t\tpr_info(\"limit reached, disable warning\\n\");\n\t}\n\tif (is_atomic) {\n\t\t/* see the flag handling in pcpu_blance_workfn() */\n\t\tpcpu_atomic_alloc_failed = true;\n\t\tpcpu_schedule_balance_work();\n\t} else {\n\t\tmutex_unlock(&pcpu_alloc_mutex);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "pcpu_chunk_addr_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1316-1335",
    "snippet": "static struct pcpu_chunk *pcpu_chunk_addr_search(void *addr)\n{\n\t/* is it in the dynamic region (first chunk)? */\n\tif (pcpu_addr_in_chunk(pcpu_first_chunk, addr))\n\t\treturn pcpu_first_chunk;\n\n\t/* is it in the reserved region? */\n\tif (pcpu_addr_in_chunk(pcpu_reserved_chunk, addr))\n\t\treturn pcpu_reserved_chunk;\n\n\t/*\n\t * The address is relative to unit0 which might be unused and\n\t * thus unmapped.  Offset the address to the unit space of the\n\t * current processor before looking it up in the vmalloc\n\t * space.  Note that any possible cpu id can be used here, so\n\t * there's no need to worry about preemption or cpu hotplug.\n\t */\n\taddr += pcpu_unit_offsets[raw_smp_processor_id()];\n\treturn pcpu_get_page_chunk(pcpu_addr_to_page(addr));\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const unsigned long *pcpu_unit_offsets",
      "struct pcpu_chunk *pcpu_first_chunk",
      "struct pcpu_chunk *pcpu_reserved_chunk",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
      "static struct page *pcpu_addr_to_page(void *addr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_get_page_chunk",
          "args": [
            "pcpu_addr_to_page(addr)"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_addr_to_page",
          "args": [
            "addr"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_addr_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-km.c",
          "lines": "96-99",
          "snippet": "static struct page *pcpu_addr_to_page(void *addr)\n{\n\treturn virt_to_page(addr);\n}",
          "includes": [
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n\nstatic struct page *pcpu_addr_to_page(void *addr)\n{\n\treturn virt_to_page(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_addr_in_chunk",
          "args": [
            "pcpu_reserved_chunk",
            "addr"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_addr_in_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "205-217",
          "snippet": "static bool pcpu_addr_in_chunk(struct pcpu_chunk *chunk, void *addr)\n{\n\tvoid *start_addr, *end_addr;\n\n\tif (!chunk)\n\t\treturn false;\n\n\tstart_addr = chunk->base_addr + chunk->start_offset;\n\tend_addr = chunk->base_addr + chunk->nr_pages * PAGE_SIZE -\n\t\t   chunk->end_offset;\n\n\treturn addr >= start_addr && addr < end_addr;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static struct page *pcpu_addr_to_page(void *addr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nstatic bool pcpu_addr_in_chunk(struct pcpu_chunk *chunk, void *addr)\n{\n\tvoid *start_addr, *end_addr;\n\n\tif (!chunk)\n\t\treturn false;\n\n\tstart_addr = chunk->base_addr + chunk->start_offset;\n\tend_addr = chunk->base_addr + chunk->nr_pages * PAGE_SIZE -\n\t\t   chunk->end_offset;\n\n\treturn addr >= start_addr && addr < end_addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nconst unsigned long *pcpu_unit_offsets;\nstruct pcpu_chunk *pcpu_first_chunk;\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nstatic struct pcpu_chunk *pcpu_chunk_addr_search(void *addr)\n{\n\t/* is it in the dynamic region (first chunk)? */\n\tif (pcpu_addr_in_chunk(pcpu_first_chunk, addr))\n\t\treturn pcpu_first_chunk;\n\n\t/* is it in the reserved region? */\n\tif (pcpu_addr_in_chunk(pcpu_reserved_chunk, addr))\n\t\treturn pcpu_reserved_chunk;\n\n\t/*\n\t * The address is relative to unit0 which might be unused and\n\t * thus unmapped.  Offset the address to the unit space of the\n\t * current processor before looking it up in the vmalloc\n\t * space.  Note that any possible cpu id can be used here, so\n\t * there's no need to worry about preemption or cpu hotplug.\n\t */\n\taddr += pcpu_unit_offsets[raw_smp_processor_id()];\n\treturn pcpu_get_page_chunk(pcpu_addr_to_page(addr));\n}"
  },
  {
    "function_name": "pcpu_chunk_depopulated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1262-1274",
    "snippet": "static void pcpu_chunk_depopulated(struct pcpu_chunk *chunk,\n\t\t\t\t   int page_start, int page_end)\n{\n\tint nr = page_end - page_start;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\tbitmap_clear(chunk->populated, page_start, nr);\n\tchunk->nr_populated -= nr;\n\tchunk->nr_empty_pop_pages -= nr;\n\tpcpu_nr_empty_pop_pages -= nr;\n\tpcpu_nr_populated -= nr;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int pcpu_nr_empty_pop_pages;",
      "static unsigned long pcpu_nr_populated;",
      "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_clear",
          "args": [
            "chunk->populated",
            "page_start",
            "nr"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nint pcpu_nr_empty_pop_pages;\nstatic unsigned long pcpu_nr_populated;\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_depopulated(struct pcpu_chunk *chunk,\n\t\t\t\t   int page_start, int page_end)\n{\n\tint nr = page_end - page_start;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\tbitmap_clear(chunk->populated, page_start, nr);\n\tchunk->nr_populated -= nr;\n\tchunk->nr_empty_pop_pages -= nr;\n\tpcpu_nr_empty_pop_pages -= nr;\n\tpcpu_nr_populated -= nr;\n}"
  },
  {
    "function_name": "pcpu_chunk_populated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1235-1250",
    "snippet": "static void pcpu_chunk_populated(struct pcpu_chunk *chunk, int page_start,\n\t\t\t\t int page_end, bool for_alloc)\n{\n\tint nr = page_end - page_start;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\tbitmap_set(chunk->populated, page_start, nr);\n\tchunk->nr_populated += nr;\n\tpcpu_nr_populated += nr;\n\n\tif (!for_alloc) {\n\t\tchunk->nr_empty_pop_pages += nr;\n\t\tpcpu_nr_empty_pop_pages += nr;\n\t}\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int pcpu_nr_empty_pop_pages;",
      "static unsigned long pcpu_nr_populated;",
      "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "chunk->populated",
            "page_start",
            "nr"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nint pcpu_nr_empty_pop_pages;\nstatic unsigned long pcpu_nr_populated;\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_populated(struct pcpu_chunk *chunk, int page_start,\n\t\t\t\t int page_end, bool for_alloc)\n{\n\tint nr = page_end - page_start;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\tbitmap_set(chunk->populated, page_start, nr);\n\tchunk->nr_populated += nr;\n\tpcpu_nr_populated += nr;\n\n\tif (!for_alloc) {\n\t\tchunk->nr_empty_pop_pages += nr;\n\t\tpcpu_nr_empty_pop_pages += nr;\n\t}\n}"
  },
  {
    "function_name": "pcpu_free_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1211-1219",
    "snippet": "static void pcpu_free_chunk(struct pcpu_chunk *chunk)\n{\n\tif (!chunk)\n\t\treturn;\n\tpcpu_mem_free(chunk->md_blocks);\n\tpcpu_mem_free(chunk->bound_map);\n\tpcpu_mem_free(chunk->alloc_map);\n\tpcpu_mem_free(chunk);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_mem_free",
          "args": [
            "chunk"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_mem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "486-489",
          "snippet": "static void pcpu_mem_free(void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_mem_free(void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_free_chunk(struct pcpu_chunk *chunk)\n{\n\tif (!chunk)\n\t\treturn;\n\tpcpu_mem_free(chunk->md_blocks);\n\tpcpu_mem_free(chunk->bound_map);\n\tpcpu_mem_free(chunk->alloc_map);\n\tpcpu_mem_free(chunk);\n}"
  },
  {
    "function_name": "pcpu_alloc_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1165-1209",
    "snippet": "static struct pcpu_chunk *pcpu_alloc_chunk(gfp_t gfp)\n{\n\tstruct pcpu_chunk *chunk;\n\tint region_bits;\n\n\tchunk = pcpu_mem_zalloc(pcpu_chunk_struct_size, gfp);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->list);\n\tchunk->nr_pages = pcpu_unit_pages;\n\tregion_bits = pcpu_chunk_map_bits(chunk);\n\n\tchunk->alloc_map = pcpu_mem_zalloc(BITS_TO_LONGS(region_bits) *\n\t\t\t\t\t   sizeof(chunk->alloc_map[0]), gfp);\n\tif (!chunk->alloc_map)\n\t\tgoto alloc_map_fail;\n\n\tchunk->bound_map = pcpu_mem_zalloc(BITS_TO_LONGS(region_bits + 1) *\n\t\t\t\t\t   sizeof(chunk->bound_map[0]), gfp);\n\tif (!chunk->bound_map)\n\t\tgoto bound_map_fail;\n\n\tchunk->md_blocks = pcpu_mem_zalloc(pcpu_chunk_nr_blocks(chunk) *\n\t\t\t\t\t   sizeof(chunk->md_blocks[0]), gfp);\n\tif (!chunk->md_blocks)\n\t\tgoto md_blocks_fail;\n\n\tpcpu_init_md_blocks(chunk);\n\n\t/* init metadata */\n\tchunk->contig_bits = region_bits;\n\tchunk->free_bytes = chunk->nr_pages * PAGE_SIZE;\n\n\treturn chunk;\n\nmd_blocks_fail:\n\tpcpu_mem_free(chunk->bound_map);\nbound_map_fail:\n\tpcpu_mem_free(chunk->alloc_map);\nalloc_map_fail:\n\tpcpu_mem_free(chunk);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pcpu_unit_pages",
      "static size_t pcpu_chunk_struct_size",
      "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);",
      "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_mem_free",
          "args": [
            "chunk"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_mem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "486-489",
          "snippet": "static void pcpu_mem_free(void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_mem_free(void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_init_md_blocks",
          "args": [
            "chunk"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_init_md_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1057-1068",
          "snippet": "static void pcpu_init_md_blocks(struct pcpu_chunk *chunk)\n{\n\tstruct pcpu_block_md *md_block;\n\n\tfor (md_block = chunk->md_blocks;\n\t     md_block != chunk->md_blocks + pcpu_chunk_nr_blocks(chunk);\n\t     md_block++) {\n\t\tmd_block->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_init_md_blocks(struct pcpu_chunk *chunk)\n{\n\tstruct pcpu_block_md *md_block;\n\n\tfor (md_block = chunk->md_blocks;\n\t     md_block != chunk->md_blocks + pcpu_chunk_nr_blocks(chunk);\n\t     md_block++) {\n\t\tmd_block->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_mem_zalloc",
          "args": [
            "pcpu_chunk_nr_blocks(chunk) *\n\t\t\t\t\t   sizeof(chunk->md_blocks[0])",
            "gfp"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_mem_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "469-478",
          "snippet": "static void *pcpu_mem_zalloc(size_t size, gfp_t gfp)\n{\n\tif (WARN_ON_ONCE(!slab_is_available()))\n\t\treturn NULL;\n\n\tif (size <= PAGE_SIZE)\n\t\treturn kzalloc(size, gfp);\n\telse\n\t\treturn __vmalloc(size, gfp | __GFP_ZERO, PAGE_KERNEL);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);",
            "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);\n\nstatic void *pcpu_mem_zalloc(size_t size, gfp_t gfp)\n{\n\tif (WARN_ON_ONCE(!slab_is_available()))\n\t\treturn NULL;\n\n\tif (size <= PAGE_SIZE)\n\t\treturn kzalloc(size, gfp);\n\telse\n\t\treturn __vmalloc(size, gfp | __GFP_ZERO, PAGE_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_nr_blocks",
          "args": [
            "chunk"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_nr_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "73-76",
          "snippet": "static inline int pcpu_chunk_nr_blocks(struct pcpu_chunk *chunk)\n{\n\treturn chunk->nr_pages * PAGE_SIZE / PCPU_BITMAP_BLOCK_SIZE;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_nr_blocks(struct pcpu_chunk *chunk)\n{\n\treturn chunk->nr_pages * PAGE_SIZE / PCPU_BITMAP_BLOCK_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "region_bits + 1"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "region_bits"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_map_bits",
          "args": [
            "chunk"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_map_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "97-100",
          "snippet": "static inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&chunk->list"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic size_t pcpu_chunk_struct_size;\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic struct pcpu_chunk *pcpu_alloc_chunk(gfp_t gfp)\n{\n\tstruct pcpu_chunk *chunk;\n\tint region_bits;\n\n\tchunk = pcpu_mem_zalloc(pcpu_chunk_struct_size, gfp);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->list);\n\tchunk->nr_pages = pcpu_unit_pages;\n\tregion_bits = pcpu_chunk_map_bits(chunk);\n\n\tchunk->alloc_map = pcpu_mem_zalloc(BITS_TO_LONGS(region_bits) *\n\t\t\t\t\t   sizeof(chunk->alloc_map[0]), gfp);\n\tif (!chunk->alloc_map)\n\t\tgoto alloc_map_fail;\n\n\tchunk->bound_map = pcpu_mem_zalloc(BITS_TO_LONGS(region_bits + 1) *\n\t\t\t\t\t   sizeof(chunk->bound_map[0]), gfp);\n\tif (!chunk->bound_map)\n\t\tgoto bound_map_fail;\n\n\tchunk->md_blocks = pcpu_mem_zalloc(pcpu_chunk_nr_blocks(chunk) *\n\t\t\t\t\t   sizeof(chunk->md_blocks[0]), gfp);\n\tif (!chunk->md_blocks)\n\t\tgoto md_blocks_fail;\n\n\tpcpu_init_md_blocks(chunk);\n\n\t/* init metadata */\n\tchunk->contig_bits = region_bits;\n\tchunk->free_bytes = chunk->nr_pages * PAGE_SIZE;\n\n\treturn chunk;\n\nmd_blocks_fail:\n\tpcpu_mem_free(chunk->bound_map);\nbound_map_fail:\n\tpcpu_mem_free(chunk->alloc_map);\nalloc_map_fail:\n\tpcpu_mem_free(chunk);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pcpu_alloc_first_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1083-1163",
    "snippet": "static struct pcpu_chunk * __init pcpu_alloc_first_chunk(unsigned long tmp_addr,\n\t\t\t\t\t\t\t int map_size)\n{\n\tstruct pcpu_chunk *chunk;\n\tunsigned long aligned_addr, lcm_align;\n\tint start_offset, offset_bits, region_size, region_bits;\n\n\t/* region calculations */\n\taligned_addr = tmp_addr & PAGE_MASK;\n\n\tstart_offset = tmp_addr - aligned_addr;\n\n\t/*\n\t * Align the end of the region with the LCM of PAGE_SIZE and\n\t * PCPU_BITMAP_BLOCK_SIZE.  One of these constants is a multiple of\n\t * the other.\n\t */\n\tlcm_align = lcm(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE);\n\tregion_size = ALIGN(start_offset + map_size, lcm_align);\n\n\t/* allocate chunk */\n\tchunk = memblock_alloc(sizeof(struct pcpu_chunk) +\n\t\t\t       BITS_TO_LONGS(region_size >> PAGE_SHIFT),\n\t\t\t       SMP_CACHE_BYTES);\n\n\tINIT_LIST_HEAD(&chunk->list);\n\n\tchunk->base_addr = (void *)aligned_addr;\n\tchunk->start_offset = start_offset;\n\tchunk->end_offset = region_size - chunk->start_offset - map_size;\n\n\tchunk->nr_pages = region_size >> PAGE_SHIFT;\n\tregion_bits = pcpu_chunk_map_bits(chunk);\n\n\tchunk->alloc_map = memblock_alloc(BITS_TO_LONGS(region_bits) * sizeof(chunk->alloc_map[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tchunk->bound_map = memblock_alloc(BITS_TO_LONGS(region_bits + 1) * sizeof(chunk->bound_map[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tchunk->md_blocks = memblock_alloc(pcpu_chunk_nr_blocks(chunk) * sizeof(chunk->md_blocks[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tpcpu_init_md_blocks(chunk);\n\n\t/* manage populated page bitmap */\n\tchunk->immutable = true;\n\tbitmap_fill(chunk->populated, chunk->nr_pages);\n\tchunk->nr_populated = chunk->nr_pages;\n\tchunk->nr_empty_pop_pages =\n\t\tpcpu_cnt_pop_pages(chunk, start_offset / PCPU_MIN_ALLOC_SIZE,\n\t\t\t\t   map_size / PCPU_MIN_ALLOC_SIZE);\n\n\tchunk->contig_bits = map_size / PCPU_MIN_ALLOC_SIZE;\n\tchunk->free_bytes = map_size;\n\n\tif (chunk->start_offset) {\n\t\t/* hide the beginning of the bitmap */\n\t\toffset_bits = chunk->start_offset / PCPU_MIN_ALLOC_SIZE;\n\t\tbitmap_set(chunk->alloc_map, 0, offset_bits);\n\t\tset_bit(0, chunk->bound_map);\n\t\tset_bit(offset_bits, chunk->bound_map);\n\n\t\tchunk->first_bit = offset_bits;\n\n\t\tpcpu_block_update_hint_alloc(chunk, 0, offset_bits);\n\t}\n\n\tif (chunk->end_offset) {\n\t\t/* hide the end of the bitmap */\n\t\toffset_bits = chunk->end_offset / PCPU_MIN_ALLOC_SIZE;\n\t\tbitmap_set(chunk->alloc_map,\n\t\t\t   pcpu_chunk_map_bits(chunk) - offset_bits,\n\t\t\t   offset_bits);\n\t\tset_bit((start_offset + map_size) / PCPU_MIN_ALLOC_SIZE,\n\t\t\tchunk->bound_map);\n\t\tset_bit(region_bits, chunk->bound_map);\n\n\t\tpcpu_block_update_hint_alloc(chunk, pcpu_chunk_map_bits(chunk)\n\t\t\t\t\t     - offset_bits, offset_bits);\n\t}\n\n\treturn chunk;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_block_update_hint_alloc",
          "args": [
            "chunk",
            "pcpu_chunk_map_bits(chunk)\n\t\t\t\t\t     - offset_bits",
            "offset_bits"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_block_update_hint_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "680-770",
          "snippet": "static void pcpu_block_update_hint_alloc(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\t int bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Update s_block.\n\t * block->first_free must be updated if the allocation takes its place.\n\t * If the allocation breaks the contig_hint, a scan is required to\n\t * restore this hint.\n\t */\n\tif (s_off == s_block->first_free)\n\t\ts_block->first_free = find_next_zero_bit(\n\t\t\t\t\tpcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS,\n\t\t\t\t\ts_off + bits);\n\n\tif (s_off >= s_block->contig_hint_start &&\n\t    s_off < s_block->contig_hint_start + s_block->contig_hint) {\n\t\t/* block contig hint is broken - scan to fix it */\n\t\tpcpu_block_refresh_hint(chunk, s_index);\n\t} else {\n\t\t/* update left and right contig manually */\n\t\ts_block->left_free = min(s_block->left_free, s_off);\n\t\tif (s_index == e_index)\n\t\t\ts_block->right_free = min_t(int, s_block->right_free,\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS - e_off);\n\t\telse\n\t\t\ts_block->right_free = 0;\n\t}\n\n\t/*\n\t * Update e_block.\n\t */\n\tif (s_index != e_index) {\n\t\t/*\n\t\t * When the allocation is across blocks, the end is along\n\t\t * the left part of the e_block.\n\t\t */\n\t\te_block->first_free = find_next_zero_bit(\n\t\t\t\tpcpu_index_alloc_map(chunk, e_index),\n\t\t\t\tPCPU_BITMAP_BLOCK_BITS, e_off);\n\n\t\tif (e_off == PCPU_BITMAP_BLOCK_BITS) {\n\t\t\t/* reset the block */\n\t\t\te_block++;\n\t\t} else {\n\t\t\tif (e_off > e_block->contig_hint_start) {\n\t\t\t\t/* contig hint is broken - scan to fix it */\n\t\t\t\tpcpu_block_refresh_hint(chunk, e_index);\n\t\t\t} else {\n\t\t\t\te_block->left_free = 0;\n\t\t\t\te_block->right_free =\n\t\t\t\t\tmin_t(int, e_block->right_free,\n\t\t\t\t\t      PCPU_BITMAP_BLOCK_BITS - e_off);\n\t\t\t}\n\t\t}\n\n\t\t/* update in-between md_blocks */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->contig_hint = 0;\n\t\t\tblock->left_free = 0;\n\t\t\tblock->right_free = 0;\n\t\t}\n\t}\n\n\t/*\n\t * The only time a full chunk scan is required is if the chunk\n\t * contig hint is broken.  Otherwise, it means a smaller space\n\t * was used and therefore the chunk contig hint is still correct.\n\t */\n\tif (bit_off >= chunk->contig_bits_start  &&\n\t    bit_off < chunk->contig_bits_start + chunk->contig_bits)\n\t\tpcpu_chunk_refresh_hint(chunk);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_block_update_hint_alloc(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\t int bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Update s_block.\n\t * block->first_free must be updated if the allocation takes its place.\n\t * If the allocation breaks the contig_hint, a scan is required to\n\t * restore this hint.\n\t */\n\tif (s_off == s_block->first_free)\n\t\ts_block->first_free = find_next_zero_bit(\n\t\t\t\t\tpcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS,\n\t\t\t\t\ts_off + bits);\n\n\tif (s_off >= s_block->contig_hint_start &&\n\t    s_off < s_block->contig_hint_start + s_block->contig_hint) {\n\t\t/* block contig hint is broken - scan to fix it */\n\t\tpcpu_block_refresh_hint(chunk, s_index);\n\t} else {\n\t\t/* update left and right contig manually */\n\t\ts_block->left_free = min(s_block->left_free, s_off);\n\t\tif (s_index == e_index)\n\t\t\ts_block->right_free = min_t(int, s_block->right_free,\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS - e_off);\n\t\telse\n\t\t\ts_block->right_free = 0;\n\t}\n\n\t/*\n\t * Update e_block.\n\t */\n\tif (s_index != e_index) {\n\t\t/*\n\t\t * When the allocation is across blocks, the end is along\n\t\t * the left part of the e_block.\n\t\t */\n\t\te_block->first_free = find_next_zero_bit(\n\t\t\t\tpcpu_index_alloc_map(chunk, e_index),\n\t\t\t\tPCPU_BITMAP_BLOCK_BITS, e_off);\n\n\t\tif (e_off == PCPU_BITMAP_BLOCK_BITS) {\n\t\t\t/* reset the block */\n\t\t\te_block++;\n\t\t} else {\n\t\t\tif (e_off > e_block->contig_hint_start) {\n\t\t\t\t/* contig hint is broken - scan to fix it */\n\t\t\t\tpcpu_block_refresh_hint(chunk, e_index);\n\t\t\t} else {\n\t\t\t\te_block->left_free = 0;\n\t\t\t\te_block->right_free =\n\t\t\t\t\tmin_t(int, e_block->right_free,\n\t\t\t\t\t      PCPU_BITMAP_BLOCK_BITS - e_off);\n\t\t\t}\n\t\t}\n\n\t\t/* update in-between md_blocks */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->contig_hint = 0;\n\t\t\tblock->left_free = 0;\n\t\t\tblock->right_free = 0;\n\t\t}\n\t}\n\n\t/*\n\t * The only time a full chunk scan is required is if the chunk\n\t * contig hint is broken.  Otherwise, it means a smaller space\n\t * was used and therefore the chunk contig hint is still correct.\n\t */\n\tif (bit_off >= chunk->contig_bits_start  &&\n\t    bit_off < chunk->contig_bits_start + chunk->contig_bits)\n\t\tpcpu_chunk_refresh_hint(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_map_bits",
          "args": [
            "chunk"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_map_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "97-100",
          "snippet": "static inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "region_bits",
            "chunk->bound_map"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "(start_offset + map_size) / PCPU_MIN_ALLOC_SIZE",
            "chunk->bound_map"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "chunk->alloc_map",
            "pcpu_chunk_map_bits(chunk) - offset_bits",
            "offset_bits"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "offset_bits",
            "chunk->bound_map"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "0",
            "chunk->bound_map"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "chunk->alloc_map",
            "0",
            "offset_bits"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_cnt_pop_pages",
          "args": [
            "chunk",
            "start_offset / PCPU_MIN_ALLOC_SIZE",
            "map_size / PCPU_MIN_ALLOC_SIZE"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_cnt_pop_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "529-547",
          "snippet": "static inline int pcpu_cnt_pop_pages(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t     int bits)\n{\n\tint page_start = PFN_UP(bit_off * PCPU_MIN_ALLOC_SIZE);\n\tint page_end = PFN_DOWN((bit_off + bits) * PCPU_MIN_ALLOC_SIZE);\n\n\tif (page_start >= page_end)\n\t\treturn 0;\n\n\t/*\n\t * bitmap_weight counts the number of bits set in a bitmap up to\n\t * the specified number of bits.  This is counting the populated\n\t * pages up to page_end and then subtracting the populated pages\n\t * up to page_start to count the populated pages in\n\t * [page_start, page_end).\n\t */\n\treturn bitmap_weight(chunk->populated, page_end) -\n\t       bitmap_weight(chunk->populated, page_start);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic inline int pcpu_cnt_pop_pages(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t     int bits)\n{\n\tint page_start = PFN_UP(bit_off * PCPU_MIN_ALLOC_SIZE);\n\tint page_end = PFN_DOWN((bit_off + bits) * PCPU_MIN_ALLOC_SIZE);\n\n\tif (page_start >= page_end)\n\t\treturn 0;\n\n\t/*\n\t * bitmap_weight counts the number of bits set in a bitmap up to\n\t * the specified number of bits.  This is counting the populated\n\t * pages up to page_end and then subtracting the populated pages\n\t * up to page_start to count the populated pages in\n\t * [page_start, page_end).\n\t */\n\treturn bitmap_weight(chunk->populated, page_end) -\n\t       bitmap_weight(chunk->populated, page_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_fill",
          "args": [
            "chunk->populated",
            "chunk->nr_pages"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_init_md_blocks",
          "args": [
            "chunk"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_init_md_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1057-1068",
          "snippet": "static void pcpu_init_md_blocks(struct pcpu_chunk *chunk)\n{\n\tstruct pcpu_block_md *md_block;\n\n\tfor (md_block = chunk->md_blocks;\n\t     md_block != chunk->md_blocks + pcpu_chunk_nr_blocks(chunk);\n\t     md_block++) {\n\t\tmd_block->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_init_md_blocks(struct pcpu_chunk *chunk)\n{\n\tstruct pcpu_block_md *md_block;\n\n\tfor (md_block = chunk->md_blocks;\n\t     md_block != chunk->md_blocks + pcpu_chunk_nr_blocks(chunk);\n\t     md_block++) {\n\t\tmd_block->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "pcpu_chunk_nr_blocks(chunk) * sizeof(chunk->md_blocks[0])",
            "SMP_CACHE_BYTES"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_nr_blocks",
          "args": [
            "chunk"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_nr_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "73-76",
          "snippet": "static inline int pcpu_chunk_nr_blocks(struct pcpu_chunk *chunk)\n{\n\treturn chunk->nr_pages * PAGE_SIZE / PCPU_BITMAP_BLOCK_SIZE;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_nr_blocks(struct pcpu_chunk *chunk)\n{\n\treturn chunk->nr_pages * PAGE_SIZE / PCPU_BITMAP_BLOCK_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "BITS_TO_LONGS(region_bits + 1) * sizeof(chunk->bound_map[0])",
            "SMP_CACHE_BYTES"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "region_bits + 1"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "BITS_TO_LONGS(region_bits) * sizeof(chunk->alloc_map[0])",
            "SMP_CACHE_BYTES"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "region_bits"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&chunk->list"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "sizeof(struct pcpu_chunk) +\n\t\t\t       BITS_TO_LONGS(region_size >> PAGE_SHIFT)",
            "SMP_CACHE_BYTES"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "region_size >> PAGE_SHIFT"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "start_offset + map_size",
            "lcm_align"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lcm",
          "args": [
            "PAGE_SIZE",
            "PCPU_BITMAP_BLOCK_SIZE"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic struct pcpu_chunk * __init pcpu_alloc_first_chunk(unsigned long tmp_addr,\n\t\t\t\t\t\t\t int map_size)\n{\n\tstruct pcpu_chunk *chunk;\n\tunsigned long aligned_addr, lcm_align;\n\tint start_offset, offset_bits, region_size, region_bits;\n\n\t/* region calculations */\n\taligned_addr = tmp_addr & PAGE_MASK;\n\n\tstart_offset = tmp_addr - aligned_addr;\n\n\t/*\n\t * Align the end of the region with the LCM of PAGE_SIZE and\n\t * PCPU_BITMAP_BLOCK_SIZE.  One of these constants is a multiple of\n\t * the other.\n\t */\n\tlcm_align = lcm(PAGE_SIZE, PCPU_BITMAP_BLOCK_SIZE);\n\tregion_size = ALIGN(start_offset + map_size, lcm_align);\n\n\t/* allocate chunk */\n\tchunk = memblock_alloc(sizeof(struct pcpu_chunk) +\n\t\t\t       BITS_TO_LONGS(region_size >> PAGE_SHIFT),\n\t\t\t       SMP_CACHE_BYTES);\n\n\tINIT_LIST_HEAD(&chunk->list);\n\n\tchunk->base_addr = (void *)aligned_addr;\n\tchunk->start_offset = start_offset;\n\tchunk->end_offset = region_size - chunk->start_offset - map_size;\n\n\tchunk->nr_pages = region_size >> PAGE_SHIFT;\n\tregion_bits = pcpu_chunk_map_bits(chunk);\n\n\tchunk->alloc_map = memblock_alloc(BITS_TO_LONGS(region_bits) * sizeof(chunk->alloc_map[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tchunk->bound_map = memblock_alloc(BITS_TO_LONGS(region_bits + 1) * sizeof(chunk->bound_map[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tchunk->md_blocks = memblock_alloc(pcpu_chunk_nr_blocks(chunk) * sizeof(chunk->md_blocks[0]),\n\t\t\t\t\t  SMP_CACHE_BYTES);\n\tpcpu_init_md_blocks(chunk);\n\n\t/* manage populated page bitmap */\n\tchunk->immutable = true;\n\tbitmap_fill(chunk->populated, chunk->nr_pages);\n\tchunk->nr_populated = chunk->nr_pages;\n\tchunk->nr_empty_pop_pages =\n\t\tpcpu_cnt_pop_pages(chunk, start_offset / PCPU_MIN_ALLOC_SIZE,\n\t\t\t\t   map_size / PCPU_MIN_ALLOC_SIZE);\n\n\tchunk->contig_bits = map_size / PCPU_MIN_ALLOC_SIZE;\n\tchunk->free_bytes = map_size;\n\n\tif (chunk->start_offset) {\n\t\t/* hide the beginning of the bitmap */\n\t\toffset_bits = chunk->start_offset / PCPU_MIN_ALLOC_SIZE;\n\t\tbitmap_set(chunk->alloc_map, 0, offset_bits);\n\t\tset_bit(0, chunk->bound_map);\n\t\tset_bit(offset_bits, chunk->bound_map);\n\n\t\tchunk->first_bit = offset_bits;\n\n\t\tpcpu_block_update_hint_alloc(chunk, 0, offset_bits);\n\t}\n\n\tif (chunk->end_offset) {\n\t\t/* hide the end of the bitmap */\n\t\toffset_bits = chunk->end_offset / PCPU_MIN_ALLOC_SIZE;\n\t\tbitmap_set(chunk->alloc_map,\n\t\t\t   pcpu_chunk_map_bits(chunk) - offset_bits,\n\t\t\t   offset_bits);\n\t\tset_bit((start_offset + map_size) / PCPU_MIN_ALLOC_SIZE,\n\t\t\tchunk->bound_map);\n\t\tset_bit(region_bits, chunk->bound_map);\n\n\t\tpcpu_block_update_hint_alloc(chunk, pcpu_chunk_map_bits(chunk)\n\t\t\t\t\t     - offset_bits, offset_bits);\n\t}\n\n\treturn chunk;\n}"
  },
  {
    "function_name": "pcpu_init_md_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1057-1068",
    "snippet": "static void pcpu_init_md_blocks(struct pcpu_chunk *chunk)\n{\n\tstruct pcpu_block_md *md_block;\n\n\tfor (md_block = chunk->md_blocks;\n\t     md_block != chunk->md_blocks + pcpu_chunk_nr_blocks(chunk);\n\t     md_block++) {\n\t\tmd_block->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t}\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_chunk_nr_blocks",
          "args": [
            "chunk"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_nr_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "73-76",
          "snippet": "static inline int pcpu_chunk_nr_blocks(struct pcpu_chunk *chunk)\n{\n\treturn chunk->nr_pages * PAGE_SIZE / PCPU_BITMAP_BLOCK_SIZE;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_nr_blocks(struct pcpu_chunk *chunk)\n{\n\treturn chunk->nr_pages * PAGE_SIZE / PCPU_BITMAP_BLOCK_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_init_md_blocks(struct pcpu_chunk *chunk)\n{\n\tstruct pcpu_block_md *md_block;\n\n\tfor (md_block = chunk->md_blocks;\n\t     md_block != chunk->md_blocks + pcpu_chunk_nr_blocks(chunk);\n\t     md_block++) {\n\t\tmd_block->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\tmd_block->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t}\n}"
  },
  {
    "function_name": "pcpu_free_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "1029-1055",
    "snippet": "static void pcpu_free_area(struct pcpu_chunk *chunk, int off)\n{\n\tint bit_off, bits, end, oslot;\n\n\tlockdep_assert_held(&pcpu_lock);\n\tpcpu_stats_area_dealloc(chunk);\n\n\toslot = pcpu_chunk_slot(chunk);\n\n\tbit_off = off / PCPU_MIN_ALLOC_SIZE;\n\n\t/* find end index */\n\tend = find_next_bit(chunk->bound_map, pcpu_chunk_map_bits(chunk),\n\t\t\t    bit_off + 1);\n\tbits = end - bit_off;\n\tbitmap_clear(chunk->alloc_map, bit_off, bits);\n\n\t/* update metadata */\n\tchunk->free_bytes += bits * PCPU_MIN_ALLOC_SIZE;\n\n\t/* update first free bit */\n\tchunk->first_bit = min(chunk->first_bit, bit_off);\n\n\tpcpu_block_update_hint_free(chunk, bit_off, bits);\n\n\tpcpu_chunk_relocate(chunk, oslot);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_chunk_relocate",
          "args": [
            "chunk",
            "oslot"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_relocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "504-514",
          "snippet": "static void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_block_update_hint_free",
          "args": [
            "chunk",
            "bit_off",
            "bits"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_block_update_hint_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "789-875",
          "snippet": "static void pcpu_block_update_hint_free(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\tint bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\tint start, end;\t\t/* start and end of the whole free area */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Check if the freed area aligns with the block->contig_hint.\n\t * If it does, then the scan to find the beginning/end of the\n\t * larger free area can be avoided.\n\t *\n\t * start and end refer to beginning and end of the free area\n\t * within each their respective blocks.  This is not necessarily\n\t * the entire free area as it may span blocks past the beginning\n\t * or end of the block.\n\t */\n\tstart = s_off;\n\tif (s_off == s_block->contig_hint + s_block->contig_hint_start) {\n\t\tstart = s_block->contig_hint_start;\n\t} else {\n\t\t/*\n\t\t * Scan backwards to find the extent of the free area.\n\t\t * find_last_bit returns the starting bit, so if the start bit\n\t\t * is returned, that means there was no last bit and the\n\t\t * remainder of the chunk is free.\n\t\t */\n\t\tint l_bit = find_last_bit(pcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\t  start);\n\t\tstart = (start == l_bit) ? 0 : l_bit + 1;\n\t}\n\n\tend = e_off;\n\tif (e_off == e_block->contig_hint_start)\n\t\tend = e_block->contig_hint_start + e_block->contig_hint;\n\telse\n\t\tend = find_next_bit(pcpu_index_alloc_map(chunk, e_index),\n\t\t\t\t    PCPU_BITMAP_BLOCK_BITS, end);\n\n\t/* update s_block */\n\te_off = (s_index == e_index) ? end : PCPU_BITMAP_BLOCK_BITS;\n\tpcpu_block_update(s_block, start, e_off);\n\n\t/* freeing in the same block */\n\tif (s_index != e_index) {\n\t\t/* update e_block */\n\t\tpcpu_block_update(e_block, 0, end);\n\n\t\t/* reset md_blocks in the middle */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->first_free = 0;\n\t\t\tblock->contig_hint_start = 0;\n\t\t\tblock->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t}\n\t}\n\n\t/*\n\t * Refresh chunk metadata when the free makes a page free, a block\n\t * free, or spans across blocks.  The contig hint may be off by up to\n\t * a page, but if the hint is contained in a block, it will be accurate\n\t * with the else condition below.\n\t */\n\tif ((ALIGN_DOWN(end, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS)) >\n\t     ALIGN(start, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS))) ||\n\t    s_index != e_index)\n\t\tpcpu_chunk_refresh_hint(chunk);\n\telse\n\t\tpcpu_chunk_update(chunk, pcpu_block_off_to_off(s_index, start),\n\t\t\t\t  s_block->contig_hint);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_block_update_hint_free(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\tint bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\tint start, end;\t\t/* start and end of the whole free area */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Check if the freed area aligns with the block->contig_hint.\n\t * If it does, then the scan to find the beginning/end of the\n\t * larger free area can be avoided.\n\t *\n\t * start and end refer to beginning and end of the free area\n\t * within each their respective blocks.  This is not necessarily\n\t * the entire free area as it may span blocks past the beginning\n\t * or end of the block.\n\t */\n\tstart = s_off;\n\tif (s_off == s_block->contig_hint + s_block->contig_hint_start) {\n\t\tstart = s_block->contig_hint_start;\n\t} else {\n\t\t/*\n\t\t * Scan backwards to find the extent of the free area.\n\t\t * find_last_bit returns the starting bit, so if the start bit\n\t\t * is returned, that means there was no last bit and the\n\t\t * remainder of the chunk is free.\n\t\t */\n\t\tint l_bit = find_last_bit(pcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\t  start);\n\t\tstart = (start == l_bit) ? 0 : l_bit + 1;\n\t}\n\n\tend = e_off;\n\tif (e_off == e_block->contig_hint_start)\n\t\tend = e_block->contig_hint_start + e_block->contig_hint;\n\telse\n\t\tend = find_next_bit(pcpu_index_alloc_map(chunk, e_index),\n\t\t\t\t    PCPU_BITMAP_BLOCK_BITS, end);\n\n\t/* update s_block */\n\te_off = (s_index == e_index) ? end : PCPU_BITMAP_BLOCK_BITS;\n\tpcpu_block_update(s_block, start, e_off);\n\n\t/* freeing in the same block */\n\tif (s_index != e_index) {\n\t\t/* update e_block */\n\t\tpcpu_block_update(e_block, 0, end);\n\n\t\t/* reset md_blocks in the middle */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->first_free = 0;\n\t\t\tblock->contig_hint_start = 0;\n\t\t\tblock->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t}\n\t}\n\n\t/*\n\t * Refresh chunk metadata when the free makes a page free, a block\n\t * free, or spans across blocks.  The contig hint may be off by up to\n\t * a page, but if the hint is contained in a block, it will be accurate\n\t * with the else condition below.\n\t */\n\tif ((ALIGN_DOWN(end, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS)) >\n\t     ALIGN(start, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS))) ||\n\t    s_index != e_index)\n\t\tpcpu_chunk_refresh_hint(chunk);\n\telse\n\t\tpcpu_chunk_update(chunk, pcpu_block_off_to_off(s_index, start),\n\t\t\t\t  s_block->contig_hint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "chunk->first_bit",
            "bit_off"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_clear",
          "args": [
            "chunk->alloc_map",
            "bit_off",
            "bits"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "chunk->bound_map",
            "pcpu_chunk_map_bits(chunk)",
            "bit_off + 1"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_map_bits",
          "args": [
            "chunk"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_map_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "97-100",
          "snippet": "static inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_slot",
          "args": [
            "chunk"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "232-238",
          "snippet": "static int pcpu_chunk_slot(const struct pcpu_chunk *chunk)\n{\n\tif (chunk->free_bytes < PCPU_MIN_ALLOC_SIZE || chunk->contig_bits == 0)\n\t\treturn 0;\n\n\treturn pcpu_size_to_slot(chunk->free_bytes);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic int pcpu_chunk_slot(const struct pcpu_chunk *chunk)\n{\n\tif (chunk->free_bytes < PCPU_MIN_ALLOC_SIZE || chunk->contig_bits == 0)\n\t\treturn 0;\n\n\treturn pcpu_size_to_slot(chunk->free_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_stats_area_dealloc",
          "args": [
            "chunk"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_stats_area_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "211-213",
          "snippet": "static inline void pcpu_stats_area_dealloc(struct pcpu_chunk *chunk)\n{\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline void pcpu_stats_area_dealloc(struct pcpu_chunk *chunk)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pcpu_lock"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_free_area(struct pcpu_chunk *chunk, int off)\n{\n\tint bit_off, bits, end, oslot;\n\n\tlockdep_assert_held(&pcpu_lock);\n\tpcpu_stats_area_dealloc(chunk);\n\n\toslot = pcpu_chunk_slot(chunk);\n\n\tbit_off = off / PCPU_MIN_ALLOC_SIZE;\n\n\t/* find end index */\n\tend = find_next_bit(chunk->bound_map, pcpu_chunk_map_bits(chunk),\n\t\t\t    bit_off + 1);\n\tbits = end - bit_off;\n\tbitmap_clear(chunk->alloc_map, bit_off, bits);\n\n\t/* update metadata */\n\tchunk->free_bytes += bits * PCPU_MIN_ALLOC_SIZE;\n\n\t/* update first free bit */\n\tchunk->first_bit = min(chunk->first_bit, bit_off);\n\n\tpcpu_block_update_hint_free(chunk, bit_off, bits);\n\n\tpcpu_chunk_relocate(chunk, oslot);\n}"
  },
  {
    "function_name": "pcpu_alloc_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "978-1019",
    "snippet": "static int pcpu_alloc_area(struct pcpu_chunk *chunk, int alloc_bits,\n\t\t\t   size_t align, int start)\n{\n\tsize_t align_mask = (align) ? (align - 1) : 0;\n\tint bit_off, end, oslot;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\toslot = pcpu_chunk_slot(chunk);\n\n\t/*\n\t * Search to find a fit.\n\t */\n\tend = start + alloc_bits + PCPU_BITMAP_BLOCK_BITS;\n\tbit_off = bitmap_find_next_zero_area(chunk->alloc_map, end, start,\n\t\t\t\t\t     alloc_bits, align_mask);\n\tif (bit_off >= end)\n\t\treturn -1;\n\n\t/* update alloc map */\n\tbitmap_set(chunk->alloc_map, bit_off, alloc_bits);\n\n\t/* update boundary map */\n\tset_bit(bit_off, chunk->bound_map);\n\tbitmap_clear(chunk->bound_map, bit_off + 1, alloc_bits - 1);\n\tset_bit(bit_off + alloc_bits, chunk->bound_map);\n\n\tchunk->free_bytes -= alloc_bits * PCPU_MIN_ALLOC_SIZE;\n\n\t/* update first free bit */\n\tif (bit_off == chunk->first_bit)\n\t\tchunk->first_bit = find_next_zero_bit(\n\t\t\t\t\tchunk->alloc_map,\n\t\t\t\t\tpcpu_chunk_map_bits(chunk),\n\t\t\t\t\tbit_off + alloc_bits);\n\n\tpcpu_block_update_hint_alloc(chunk, bit_off, alloc_bits);\n\n\tpcpu_chunk_relocate(chunk, oslot);\n\n\treturn bit_off * PCPU_MIN_ALLOC_SIZE;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_chunk_relocate",
          "args": [
            "chunk",
            "oslot"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_relocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "504-514",
          "snippet": "static void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_block_update_hint_alloc",
          "args": [
            "chunk",
            "bit_off",
            "alloc_bits"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_block_update_hint_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "680-770",
          "snippet": "static void pcpu_block_update_hint_alloc(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\t int bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Update s_block.\n\t * block->first_free must be updated if the allocation takes its place.\n\t * If the allocation breaks the contig_hint, a scan is required to\n\t * restore this hint.\n\t */\n\tif (s_off == s_block->first_free)\n\t\ts_block->first_free = find_next_zero_bit(\n\t\t\t\t\tpcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS,\n\t\t\t\t\ts_off + bits);\n\n\tif (s_off >= s_block->contig_hint_start &&\n\t    s_off < s_block->contig_hint_start + s_block->contig_hint) {\n\t\t/* block contig hint is broken - scan to fix it */\n\t\tpcpu_block_refresh_hint(chunk, s_index);\n\t} else {\n\t\t/* update left and right contig manually */\n\t\ts_block->left_free = min(s_block->left_free, s_off);\n\t\tif (s_index == e_index)\n\t\t\ts_block->right_free = min_t(int, s_block->right_free,\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS - e_off);\n\t\telse\n\t\t\ts_block->right_free = 0;\n\t}\n\n\t/*\n\t * Update e_block.\n\t */\n\tif (s_index != e_index) {\n\t\t/*\n\t\t * When the allocation is across blocks, the end is along\n\t\t * the left part of the e_block.\n\t\t */\n\t\te_block->first_free = find_next_zero_bit(\n\t\t\t\tpcpu_index_alloc_map(chunk, e_index),\n\t\t\t\tPCPU_BITMAP_BLOCK_BITS, e_off);\n\n\t\tif (e_off == PCPU_BITMAP_BLOCK_BITS) {\n\t\t\t/* reset the block */\n\t\t\te_block++;\n\t\t} else {\n\t\t\tif (e_off > e_block->contig_hint_start) {\n\t\t\t\t/* contig hint is broken - scan to fix it */\n\t\t\t\tpcpu_block_refresh_hint(chunk, e_index);\n\t\t\t} else {\n\t\t\t\te_block->left_free = 0;\n\t\t\t\te_block->right_free =\n\t\t\t\t\tmin_t(int, e_block->right_free,\n\t\t\t\t\t      PCPU_BITMAP_BLOCK_BITS - e_off);\n\t\t\t}\n\t\t}\n\n\t\t/* update in-between md_blocks */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->contig_hint = 0;\n\t\t\tblock->left_free = 0;\n\t\t\tblock->right_free = 0;\n\t\t}\n\t}\n\n\t/*\n\t * The only time a full chunk scan is required is if the chunk\n\t * contig hint is broken.  Otherwise, it means a smaller space\n\t * was used and therefore the chunk contig hint is still correct.\n\t */\n\tif (bit_off >= chunk->contig_bits_start  &&\n\t    bit_off < chunk->contig_bits_start + chunk->contig_bits)\n\t\tpcpu_chunk_refresh_hint(chunk);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_block_update_hint_alloc(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\t int bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Update s_block.\n\t * block->first_free must be updated if the allocation takes its place.\n\t * If the allocation breaks the contig_hint, a scan is required to\n\t * restore this hint.\n\t */\n\tif (s_off == s_block->first_free)\n\t\ts_block->first_free = find_next_zero_bit(\n\t\t\t\t\tpcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS,\n\t\t\t\t\ts_off + bits);\n\n\tif (s_off >= s_block->contig_hint_start &&\n\t    s_off < s_block->contig_hint_start + s_block->contig_hint) {\n\t\t/* block contig hint is broken - scan to fix it */\n\t\tpcpu_block_refresh_hint(chunk, s_index);\n\t} else {\n\t\t/* update left and right contig manually */\n\t\ts_block->left_free = min(s_block->left_free, s_off);\n\t\tif (s_index == e_index)\n\t\t\ts_block->right_free = min_t(int, s_block->right_free,\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS - e_off);\n\t\telse\n\t\t\ts_block->right_free = 0;\n\t}\n\n\t/*\n\t * Update e_block.\n\t */\n\tif (s_index != e_index) {\n\t\t/*\n\t\t * When the allocation is across blocks, the end is along\n\t\t * the left part of the e_block.\n\t\t */\n\t\te_block->first_free = find_next_zero_bit(\n\t\t\t\tpcpu_index_alloc_map(chunk, e_index),\n\t\t\t\tPCPU_BITMAP_BLOCK_BITS, e_off);\n\n\t\tif (e_off == PCPU_BITMAP_BLOCK_BITS) {\n\t\t\t/* reset the block */\n\t\t\te_block++;\n\t\t} else {\n\t\t\tif (e_off > e_block->contig_hint_start) {\n\t\t\t\t/* contig hint is broken - scan to fix it */\n\t\t\t\tpcpu_block_refresh_hint(chunk, e_index);\n\t\t\t} else {\n\t\t\t\te_block->left_free = 0;\n\t\t\t\te_block->right_free =\n\t\t\t\t\tmin_t(int, e_block->right_free,\n\t\t\t\t\t      PCPU_BITMAP_BLOCK_BITS - e_off);\n\t\t\t}\n\t\t}\n\n\t\t/* update in-between md_blocks */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->contig_hint = 0;\n\t\t\tblock->left_free = 0;\n\t\t\tblock->right_free = 0;\n\t\t}\n\t}\n\n\t/*\n\t * The only time a full chunk scan is required is if the chunk\n\t * contig hint is broken.  Otherwise, it means a smaller space\n\t * was used and therefore the chunk contig hint is still correct.\n\t */\n\tif (bit_off >= chunk->contig_bits_start  &&\n\t    bit_off < chunk->contig_bits_start + chunk->contig_bits)\n\t\tpcpu_chunk_refresh_hint(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "chunk->alloc_map",
            "pcpu_chunk_map_bits(chunk)",
            "bit_off + alloc_bits"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_map_bits",
          "args": [
            "chunk"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_map_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "97-100",
          "snippet": "static inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit_off + alloc_bits",
            "chunk->bound_map"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_clear",
          "args": [
            "chunk->bound_map",
            "bit_off + 1",
            "alloc_bits - 1"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit_off",
            "chunk->bound_map"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "chunk->alloc_map",
            "bit_off",
            "alloc_bits"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_find_next_zero_area",
          "args": [
            "chunk->alloc_map",
            "end",
            "start",
            "alloc_bits",
            "align_mask"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_slot",
          "args": [
            "chunk"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "232-238",
          "snippet": "static int pcpu_chunk_slot(const struct pcpu_chunk *chunk)\n{\n\tif (chunk->free_bytes < PCPU_MIN_ALLOC_SIZE || chunk->contig_bits == 0)\n\t\treturn 0;\n\n\treturn pcpu_size_to_slot(chunk->free_bytes);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic int pcpu_chunk_slot(const struct pcpu_chunk *chunk)\n{\n\tif (chunk->free_bytes < PCPU_MIN_ALLOC_SIZE || chunk->contig_bits == 0)\n\t\treturn 0;\n\n\treturn pcpu_size_to_slot(chunk->free_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pcpu_lock"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic int pcpu_alloc_area(struct pcpu_chunk *chunk, int alloc_bits,\n\t\t\t   size_t align, int start)\n{\n\tsize_t align_mask = (align) ? (align - 1) : 0;\n\tint bit_off, end, oslot;\n\n\tlockdep_assert_held(&pcpu_lock);\n\n\toslot = pcpu_chunk_slot(chunk);\n\n\t/*\n\t * Search to find a fit.\n\t */\n\tend = start + alloc_bits + PCPU_BITMAP_BLOCK_BITS;\n\tbit_off = bitmap_find_next_zero_area(chunk->alloc_map, end, start,\n\t\t\t\t\t     alloc_bits, align_mask);\n\tif (bit_off >= end)\n\t\treturn -1;\n\n\t/* update alloc map */\n\tbitmap_set(chunk->alloc_map, bit_off, alloc_bits);\n\n\t/* update boundary map */\n\tset_bit(bit_off, chunk->bound_map);\n\tbitmap_clear(chunk->bound_map, bit_off + 1, alloc_bits - 1);\n\tset_bit(bit_off + alloc_bits, chunk->bound_map);\n\n\tchunk->free_bytes -= alloc_bits * PCPU_MIN_ALLOC_SIZE;\n\n\t/* update first free bit */\n\tif (bit_off == chunk->first_bit)\n\t\tchunk->first_bit = find_next_zero_bit(\n\t\t\t\t\tchunk->alloc_map,\n\t\t\t\t\tpcpu_chunk_map_bits(chunk),\n\t\t\t\t\tbit_off + alloc_bits);\n\n\tpcpu_block_update_hint_alloc(chunk, bit_off, alloc_bits);\n\n\tpcpu_chunk_relocate(chunk, oslot);\n\n\treturn bit_off * PCPU_MIN_ALLOC_SIZE;\n}"
  },
  {
    "function_name": "pcpu_find_block_fit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "926-957",
    "snippet": "static int pcpu_find_block_fit(struct pcpu_chunk *chunk, int alloc_bits,\n\t\t\t       size_t align, bool pop_only)\n{\n\tint bit_off, bits, next_off;\n\n\t/*\n\t * Check to see if the allocation can fit in the chunk's contig hint.\n\t * This is an optimization to prevent scanning by assuming if it\n\t * cannot fit in the global hint, there is memory pressure and creating\n\t * a new chunk would happen soon.\n\t */\n\tbit_off = ALIGN(chunk->contig_bits_start, align) -\n\t\t  chunk->contig_bits_start;\n\tif (bit_off + alloc_bits > chunk->contig_bits)\n\t\treturn -1;\n\n\tbit_off = chunk->first_bit;\n\tbits = 0;\n\tpcpu_for_each_fit_region(chunk, alloc_bits, align, bit_off, bits) {\n\t\tif (!pop_only || pcpu_is_populated(chunk, bit_off, bits,\n\t\t\t\t\t\t   &next_off))\n\t\t\tbreak;\n\n\t\tbit_off = next_off;\n\t\tbits = 0;\n\t}\n\n\tif (bit_off == pcpu_chunk_map_bits(chunk))\n\t\treturn -1;\n\n\treturn bit_off;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_chunk_map_bits",
          "args": [
            "chunk"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_map_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "97-100",
          "snippet": "static inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_is_populated",
          "args": [
            "chunk",
            "bit_off",
            "bits",
            "&next_off"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_is_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "890-905",
          "snippet": "static bool pcpu_is_populated(struct pcpu_chunk *chunk, int bit_off, int bits,\n\t\t\t      int *next_off)\n{\n\tint page_start, page_end, rs, re;\n\n\tpage_start = PFN_DOWN(bit_off * PCPU_MIN_ALLOC_SIZE);\n\tpage_end = PFN_UP((bit_off + bits) * PCPU_MIN_ALLOC_SIZE);\n\n\trs = page_start;\n\tpcpu_next_unpop(chunk->populated, &rs, &re, page_end);\n\tif (rs >= page_end)\n\t\treturn true;\n\n\t*next_off = re * PAGE_SIZE / PCPU_MIN_ALLOC_SIZE;\n\treturn false;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic bool pcpu_is_populated(struct pcpu_chunk *chunk, int bit_off, int bits,\n\t\t\t      int *next_off)\n{\n\tint page_start, page_end, rs, re;\n\n\tpage_start = PFN_DOWN(bit_off * PCPU_MIN_ALLOC_SIZE);\n\tpage_end = PFN_UP((bit_off + bits) * PCPU_MIN_ALLOC_SIZE);\n\n\trs = page_start;\n\tpcpu_next_unpop(chunk->populated, &rs, &re, page_end);\n\tif (rs >= page_end)\n\t\treturn true;\n\n\t*next_off = re * PAGE_SIZE / PCPU_MIN_ALLOC_SIZE;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_for_each_fit_region",
          "args": [
            "chunk",
            "alloc_bits",
            "align",
            "bit_off",
            "bits"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "chunk->contig_bits_start",
            "align"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic int pcpu_find_block_fit(struct pcpu_chunk *chunk, int alloc_bits,\n\t\t\t       size_t align, bool pop_only)\n{\n\tint bit_off, bits, next_off;\n\n\t/*\n\t * Check to see if the allocation can fit in the chunk's contig hint.\n\t * This is an optimization to prevent scanning by assuming if it\n\t * cannot fit in the global hint, there is memory pressure and creating\n\t * a new chunk would happen soon.\n\t */\n\tbit_off = ALIGN(chunk->contig_bits_start, align) -\n\t\t  chunk->contig_bits_start;\n\tif (bit_off + alloc_bits > chunk->contig_bits)\n\t\treturn -1;\n\n\tbit_off = chunk->first_bit;\n\tbits = 0;\n\tpcpu_for_each_fit_region(chunk, alloc_bits, align, bit_off, bits) {\n\t\tif (!pop_only || pcpu_is_populated(chunk, bit_off, bits,\n\t\t\t\t\t\t   &next_off))\n\t\t\tbreak;\n\n\t\tbit_off = next_off;\n\t\tbits = 0;\n\t}\n\n\tif (bit_off == pcpu_chunk_map_bits(chunk))\n\t\treturn -1;\n\n\treturn bit_off;\n}"
  },
  {
    "function_name": "pcpu_is_populated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "890-905",
    "snippet": "static bool pcpu_is_populated(struct pcpu_chunk *chunk, int bit_off, int bits,\n\t\t\t      int *next_off)\n{\n\tint page_start, page_end, rs, re;\n\n\tpage_start = PFN_DOWN(bit_off * PCPU_MIN_ALLOC_SIZE);\n\tpage_end = PFN_UP((bit_off + bits) * PCPU_MIN_ALLOC_SIZE);\n\n\trs = page_start;\n\tpcpu_next_unpop(chunk->populated, &rs, &re, page_end);\n\tif (rs >= page_end)\n\t\treturn true;\n\n\t*next_off = re * PAGE_SIZE / PCPU_MIN_ALLOC_SIZE;\n\treturn false;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_next_unpop",
          "args": [
            "chunk->populated",
            "&rs",
            "&re",
            "page_end"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_next_unpop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "269-273",
          "snippet": "static void pcpu_next_unpop(unsigned long *bitmap, int *rs, int *re, int end)\n{\n\t*rs = find_next_zero_bit(bitmap, end, *rs);\n\t*re = find_next_bit(bitmap, end, *rs + 1);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_next_unpop(unsigned long *bitmap, int *rs, int *re, int end)\n{\n\t*rs = find_next_zero_bit(bitmap, end, *rs);\n\t*re = find_next_bit(bitmap, end, *rs + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "(bit_off + bits) * PCPU_MIN_ALLOC_SIZE"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "bit_off * PCPU_MIN_ALLOC_SIZE"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic bool pcpu_is_populated(struct pcpu_chunk *chunk, int bit_off, int bits,\n\t\t\t      int *next_off)\n{\n\tint page_start, page_end, rs, re;\n\n\tpage_start = PFN_DOWN(bit_off * PCPU_MIN_ALLOC_SIZE);\n\tpage_end = PFN_UP((bit_off + bits) * PCPU_MIN_ALLOC_SIZE);\n\n\trs = page_start;\n\tpcpu_next_unpop(chunk->populated, &rs, &re, page_end);\n\tif (rs >= page_end)\n\t\treturn true;\n\n\t*next_off = re * PAGE_SIZE / PCPU_MIN_ALLOC_SIZE;\n\treturn false;\n}"
  },
  {
    "function_name": "pcpu_block_update_hint_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "789-875",
    "snippet": "static void pcpu_block_update_hint_free(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\tint bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\tint start, end;\t\t/* start and end of the whole free area */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Check if the freed area aligns with the block->contig_hint.\n\t * If it does, then the scan to find the beginning/end of the\n\t * larger free area can be avoided.\n\t *\n\t * start and end refer to beginning and end of the free area\n\t * within each their respective blocks.  This is not necessarily\n\t * the entire free area as it may span blocks past the beginning\n\t * or end of the block.\n\t */\n\tstart = s_off;\n\tif (s_off == s_block->contig_hint + s_block->contig_hint_start) {\n\t\tstart = s_block->contig_hint_start;\n\t} else {\n\t\t/*\n\t\t * Scan backwards to find the extent of the free area.\n\t\t * find_last_bit returns the starting bit, so if the start bit\n\t\t * is returned, that means there was no last bit and the\n\t\t * remainder of the chunk is free.\n\t\t */\n\t\tint l_bit = find_last_bit(pcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\t  start);\n\t\tstart = (start == l_bit) ? 0 : l_bit + 1;\n\t}\n\n\tend = e_off;\n\tif (e_off == e_block->contig_hint_start)\n\t\tend = e_block->contig_hint_start + e_block->contig_hint;\n\telse\n\t\tend = find_next_bit(pcpu_index_alloc_map(chunk, e_index),\n\t\t\t\t    PCPU_BITMAP_BLOCK_BITS, end);\n\n\t/* update s_block */\n\te_off = (s_index == e_index) ? end : PCPU_BITMAP_BLOCK_BITS;\n\tpcpu_block_update(s_block, start, e_off);\n\n\t/* freeing in the same block */\n\tif (s_index != e_index) {\n\t\t/* update e_block */\n\t\tpcpu_block_update(e_block, 0, end);\n\n\t\t/* reset md_blocks in the middle */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->first_free = 0;\n\t\t\tblock->contig_hint_start = 0;\n\t\t\tblock->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t}\n\t}\n\n\t/*\n\t * Refresh chunk metadata when the free makes a page free, a block\n\t * free, or spans across blocks.  The contig hint may be off by up to\n\t * a page, but if the hint is contained in a block, it will be accurate\n\t * with the else condition below.\n\t */\n\tif ((ALIGN_DOWN(end, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS)) >\n\t     ALIGN(start, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS))) ||\n\t    s_index != e_index)\n\t\tpcpu_chunk_refresh_hint(chunk);\n\telse\n\t\tpcpu_chunk_update(chunk, pcpu_block_off_to_off(s_index, start),\n\t\t\t\t  s_block->contig_hint);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_chunk_update",
          "args": [
            "chunk",
            "pcpu_block_off_to_off(s_index, start)",
            "s_block->contig_hint"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "558-569",
          "snippet": "static void pcpu_chunk_update(struct pcpu_chunk *chunk, int bit_off, int bits)\n{\n\tif (bits > chunk->contig_bits) {\n\t\tchunk->contig_bits_start = bit_off;\n\t\tchunk->contig_bits = bits;\n\t} else if (bits == chunk->contig_bits && chunk->contig_bits_start &&\n\t\t   (!bit_off ||\n\t\t    __ffs(bit_off) > __ffs(chunk->contig_bits_start))) {\n\t\t/* use the start with the best alignment */\n\t\tchunk->contig_bits_start = bit_off;\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_update(struct pcpu_chunk *chunk, int bit_off, int bits)\n{\n\tif (bits > chunk->contig_bits) {\n\t\tchunk->contig_bits_start = bit_off;\n\t\tchunk->contig_bits = bits;\n\t} else if (bits == chunk->contig_bits && chunk->contig_bits_start &&\n\t\t   (!bit_off ||\n\t\t    __ffs(bit_off) > __ffs(chunk->contig_bits_start))) {\n\t\t/* use the start with the best alignment */\n\t\tchunk->contig_bits_start = bit_off;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_block_off_to_off",
          "args": [
            "s_index",
            "start"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_block_off_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "316-319",
          "snippet": "static unsigned long pcpu_block_off_to_off(int index, int off)\n{\n\treturn index * PCPU_BITMAP_BLOCK_BITS + off;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_block_off_to_off(int index, int off)\n{\n\treturn index * PCPU_BITMAP_BLOCK_BITS + off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_refresh_hint",
          "args": [
            "chunk"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_refresh_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "584-612",
          "snippet": "static void pcpu_chunk_refresh_hint(struct pcpu_chunk *chunk)\n{\n\tint bit_off, bits, nr_empty_pop_pages;\n\n\t/* clear metadata */\n\tchunk->contig_bits = 0;\n\n\tbit_off = chunk->first_bit;\n\tbits = nr_empty_pop_pages = 0;\n\tpcpu_for_each_md_free_region(chunk, bit_off, bits) {\n\t\tpcpu_chunk_update(chunk, bit_off, bits);\n\n\t\tnr_empty_pop_pages += pcpu_cnt_pop_pages(chunk, bit_off, bits);\n\t}\n\n\t/*\n\t * Keep track of nr_empty_pop_pages.\n\t *\n\t * The chunk maintains the previous number of free pages it held,\n\t * so the delta is used to update the global counter.  The reserved\n\t * chunk is not part of the free page count as they are populated\n\t * at init and are special to serving reserved allocations.\n\t */\n\tif (chunk != pcpu_reserved_chunk)\n\t\tpcpu_nr_empty_pop_pages +=\n\t\t\t(nr_empty_pop_pages - chunk->nr_empty_pop_pages);\n\n\tchunk->nr_empty_pop_pages = nr_empty_pop_pages;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "int pcpu_nr_empty_pop_pages;",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstruct pcpu_chunk *pcpu_reserved_chunk;\nint pcpu_nr_empty_pop_pages;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_refresh_hint(struct pcpu_chunk *chunk)\n{\n\tint bit_off, bits, nr_empty_pop_pages;\n\n\t/* clear metadata */\n\tchunk->contig_bits = 0;\n\n\tbit_off = chunk->first_bit;\n\tbits = nr_empty_pop_pages = 0;\n\tpcpu_for_each_md_free_region(chunk, bit_off, bits) {\n\t\tpcpu_chunk_update(chunk, bit_off, bits);\n\n\t\tnr_empty_pop_pages += pcpu_cnt_pop_pages(chunk, bit_off, bits);\n\t}\n\n\t/*\n\t * Keep track of nr_empty_pop_pages.\n\t *\n\t * The chunk maintains the previous number of free pages it held,\n\t * so the delta is used to update the global counter.  The reserved\n\t * chunk is not part of the free page count as they are populated\n\t * at init and are special to serving reserved allocations.\n\t */\n\tif (chunk != pcpu_reserved_chunk)\n\t\tpcpu_nr_empty_pop_pages +=\n\t\t\t(nr_empty_pop_pages - chunk->nr_empty_pop_pages);\n\n\tchunk->nr_empty_pop_pages = nr_empty_pop_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "start",
            "min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "PCPU_BITS_PER_PAGE",
            "PCPU_BITMAP_BLOCK_BITS"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "end",
            "min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS)"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_block_update",
          "args": [
            "e_block",
            "0",
            "end"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_block_update_hint_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "789-875",
          "snippet": "static void pcpu_block_update_hint_free(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\tint bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\tint start, end;\t\t/* start and end of the whole free area */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Check if the freed area aligns with the block->contig_hint.\n\t * If it does, then the scan to find the beginning/end of the\n\t * larger free area can be avoided.\n\t *\n\t * start and end refer to beginning and end of the free area\n\t * within each their respective blocks.  This is not necessarily\n\t * the entire free area as it may span blocks past the beginning\n\t * or end of the block.\n\t */\n\tstart = s_off;\n\tif (s_off == s_block->contig_hint + s_block->contig_hint_start) {\n\t\tstart = s_block->contig_hint_start;\n\t} else {\n\t\t/*\n\t\t * Scan backwards to find the extent of the free area.\n\t\t * find_last_bit returns the starting bit, so if the start bit\n\t\t * is returned, that means there was no last bit and the\n\t\t * remainder of the chunk is free.\n\t\t */\n\t\tint l_bit = find_last_bit(pcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\t  start);\n\t\tstart = (start == l_bit) ? 0 : l_bit + 1;\n\t}\n\n\tend = e_off;\n\tif (e_off == e_block->contig_hint_start)\n\t\tend = e_block->contig_hint_start + e_block->contig_hint;\n\telse\n\t\tend = find_next_bit(pcpu_index_alloc_map(chunk, e_index),\n\t\t\t\t    PCPU_BITMAP_BLOCK_BITS, end);\n\n\t/* update s_block */\n\te_off = (s_index == e_index) ? end : PCPU_BITMAP_BLOCK_BITS;\n\tpcpu_block_update(s_block, start, e_off);\n\n\t/* freeing in the same block */\n\tif (s_index != e_index) {\n\t\t/* update e_block */\n\t\tpcpu_block_update(e_block, 0, end);\n\n\t\t/* reset md_blocks in the middle */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->first_free = 0;\n\t\t\tblock->contig_hint_start = 0;\n\t\t\tblock->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t}\n\t}\n\n\t/*\n\t * Refresh chunk metadata when the free makes a page free, a block\n\t * free, or spans across blocks.  The contig hint may be off by up to\n\t * a page, but if the hint is contained in a block, it will be accurate\n\t * with the else condition below.\n\t */\n\tif ((ALIGN_DOWN(end, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS)) >\n\t     ALIGN(start, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS))) ||\n\t    s_index != e_index)\n\t\tpcpu_chunk_refresh_hint(chunk);\n\telse\n\t\tpcpu_chunk_update(chunk, pcpu_block_off_to_off(s_index, start),\n\t\t\t\t  s_block->contig_hint);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "pcpu_index_alloc_map(chunk, e_index)",
            "PCPU_BITMAP_BLOCK_BITS",
            "end"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_index_alloc_map",
          "args": [
            "chunk",
            "e_index"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_index_alloc_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "300-304",
          "snippet": "static unsigned long *pcpu_index_alloc_map(struct pcpu_chunk *chunk, int index)\n{\n\treturn chunk->alloc_map +\n\t       (index * PCPU_BITMAP_BLOCK_BITS / BITS_PER_LONG);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long *pcpu_index_alloc_map(struct pcpu_chunk *chunk, int index)\n{\n\treturn chunk->alloc_map +\n\t       (index * PCPU_BITMAP_BLOCK_BITS / BITS_PER_LONG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_last_bit",
          "args": [
            "pcpu_index_alloc_map(chunk, s_index)",
            "start"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_off_to_block_off",
          "args": [
            "bit_off + bits - 1"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_off_to_block_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "311-314",
          "snippet": "static unsigned long pcpu_off_to_block_off(int off)\n{\n\treturn off & (PCPU_BITMAP_BLOCK_BITS - 1);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_off_to_block_off(int off)\n{\n\treturn off & (PCPU_BITMAP_BLOCK_BITS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_off_to_block_index",
          "args": [
            "bit_off + bits - 1"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_off_to_block_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "306-309",
          "snippet": "static unsigned long pcpu_off_to_block_index(int off)\n{\n\treturn off / PCPU_BITMAP_BLOCK_BITS;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_off_to_block_index(int off)\n{\n\treturn off / PCPU_BITMAP_BLOCK_BITS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_block_update_hint_free(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\tint bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\tint start, end;\t\t/* start and end of the whole free area */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Check if the freed area aligns with the block->contig_hint.\n\t * If it does, then the scan to find the beginning/end of the\n\t * larger free area can be avoided.\n\t *\n\t * start and end refer to beginning and end of the free area\n\t * within each their respective blocks.  This is not necessarily\n\t * the entire free area as it may span blocks past the beginning\n\t * or end of the block.\n\t */\n\tstart = s_off;\n\tif (s_off == s_block->contig_hint + s_block->contig_hint_start) {\n\t\tstart = s_block->contig_hint_start;\n\t} else {\n\t\t/*\n\t\t * Scan backwards to find the extent of the free area.\n\t\t * find_last_bit returns the starting bit, so if the start bit\n\t\t * is returned, that means there was no last bit and the\n\t\t * remainder of the chunk is free.\n\t\t */\n\t\tint l_bit = find_last_bit(pcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\t  start);\n\t\tstart = (start == l_bit) ? 0 : l_bit + 1;\n\t}\n\n\tend = e_off;\n\tif (e_off == e_block->contig_hint_start)\n\t\tend = e_block->contig_hint_start + e_block->contig_hint;\n\telse\n\t\tend = find_next_bit(pcpu_index_alloc_map(chunk, e_index),\n\t\t\t\t    PCPU_BITMAP_BLOCK_BITS, end);\n\n\t/* update s_block */\n\te_off = (s_index == e_index) ? end : PCPU_BITMAP_BLOCK_BITS;\n\tpcpu_block_update(s_block, start, e_off);\n\n\t/* freeing in the same block */\n\tif (s_index != e_index) {\n\t\t/* update e_block */\n\t\tpcpu_block_update(e_block, 0, end);\n\n\t\t/* reset md_blocks in the middle */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->first_free = 0;\n\t\t\tblock->contig_hint_start = 0;\n\t\t\tblock->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t}\n\t}\n\n\t/*\n\t * Refresh chunk metadata when the free makes a page free, a block\n\t * free, or spans across blocks.  The contig hint may be off by up to\n\t * a page, but if the hint is contained in a block, it will be accurate\n\t * with the else condition below.\n\t */\n\tif ((ALIGN_DOWN(end, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS)) >\n\t     ALIGN(start, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS))) ||\n\t    s_index != e_index)\n\t\tpcpu_chunk_refresh_hint(chunk);\n\telse\n\t\tpcpu_chunk_update(chunk, pcpu_block_off_to_off(s_index, start),\n\t\t\t\t  s_block->contig_hint);\n}"
  },
  {
    "function_name": "pcpu_block_update_hint_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "680-770",
    "snippet": "static void pcpu_block_update_hint_alloc(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\t int bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Update s_block.\n\t * block->first_free must be updated if the allocation takes its place.\n\t * If the allocation breaks the contig_hint, a scan is required to\n\t * restore this hint.\n\t */\n\tif (s_off == s_block->first_free)\n\t\ts_block->first_free = find_next_zero_bit(\n\t\t\t\t\tpcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS,\n\t\t\t\t\ts_off + bits);\n\n\tif (s_off >= s_block->contig_hint_start &&\n\t    s_off < s_block->contig_hint_start + s_block->contig_hint) {\n\t\t/* block contig hint is broken - scan to fix it */\n\t\tpcpu_block_refresh_hint(chunk, s_index);\n\t} else {\n\t\t/* update left and right contig manually */\n\t\ts_block->left_free = min(s_block->left_free, s_off);\n\t\tif (s_index == e_index)\n\t\t\ts_block->right_free = min_t(int, s_block->right_free,\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS - e_off);\n\t\telse\n\t\t\ts_block->right_free = 0;\n\t}\n\n\t/*\n\t * Update e_block.\n\t */\n\tif (s_index != e_index) {\n\t\t/*\n\t\t * When the allocation is across blocks, the end is along\n\t\t * the left part of the e_block.\n\t\t */\n\t\te_block->first_free = find_next_zero_bit(\n\t\t\t\tpcpu_index_alloc_map(chunk, e_index),\n\t\t\t\tPCPU_BITMAP_BLOCK_BITS, e_off);\n\n\t\tif (e_off == PCPU_BITMAP_BLOCK_BITS) {\n\t\t\t/* reset the block */\n\t\t\te_block++;\n\t\t} else {\n\t\t\tif (e_off > e_block->contig_hint_start) {\n\t\t\t\t/* contig hint is broken - scan to fix it */\n\t\t\t\tpcpu_block_refresh_hint(chunk, e_index);\n\t\t\t} else {\n\t\t\t\te_block->left_free = 0;\n\t\t\t\te_block->right_free =\n\t\t\t\t\tmin_t(int, e_block->right_free,\n\t\t\t\t\t      PCPU_BITMAP_BLOCK_BITS - e_off);\n\t\t\t}\n\t\t}\n\n\t\t/* update in-between md_blocks */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->contig_hint = 0;\n\t\t\tblock->left_free = 0;\n\t\t\tblock->right_free = 0;\n\t\t}\n\t}\n\n\t/*\n\t * The only time a full chunk scan is required is if the chunk\n\t * contig hint is broken.  Otherwise, it means a smaller space\n\t * was used and therefore the chunk contig hint is still correct.\n\t */\n\tif (bit_off >= chunk->contig_bits_start  &&\n\t    bit_off < chunk->contig_bits_start + chunk->contig_bits)\n\t\tpcpu_chunk_refresh_hint(chunk);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_chunk_refresh_hint",
          "args": [
            "chunk"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_refresh_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "584-612",
          "snippet": "static void pcpu_chunk_refresh_hint(struct pcpu_chunk *chunk)\n{\n\tint bit_off, bits, nr_empty_pop_pages;\n\n\t/* clear metadata */\n\tchunk->contig_bits = 0;\n\n\tbit_off = chunk->first_bit;\n\tbits = nr_empty_pop_pages = 0;\n\tpcpu_for_each_md_free_region(chunk, bit_off, bits) {\n\t\tpcpu_chunk_update(chunk, bit_off, bits);\n\n\t\tnr_empty_pop_pages += pcpu_cnt_pop_pages(chunk, bit_off, bits);\n\t}\n\n\t/*\n\t * Keep track of nr_empty_pop_pages.\n\t *\n\t * The chunk maintains the previous number of free pages it held,\n\t * so the delta is used to update the global counter.  The reserved\n\t * chunk is not part of the free page count as they are populated\n\t * at init and are special to serving reserved allocations.\n\t */\n\tif (chunk != pcpu_reserved_chunk)\n\t\tpcpu_nr_empty_pop_pages +=\n\t\t\t(nr_empty_pop_pages - chunk->nr_empty_pop_pages);\n\n\tchunk->nr_empty_pop_pages = nr_empty_pop_pages;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pcpu_chunk *pcpu_reserved_chunk",
            "int pcpu_nr_empty_pop_pages;",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstruct pcpu_chunk *pcpu_reserved_chunk;\nint pcpu_nr_empty_pop_pages;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_refresh_hint(struct pcpu_chunk *chunk)\n{\n\tint bit_off, bits, nr_empty_pop_pages;\n\n\t/* clear metadata */\n\tchunk->contig_bits = 0;\n\n\tbit_off = chunk->first_bit;\n\tbits = nr_empty_pop_pages = 0;\n\tpcpu_for_each_md_free_region(chunk, bit_off, bits) {\n\t\tpcpu_chunk_update(chunk, bit_off, bits);\n\n\t\tnr_empty_pop_pages += pcpu_cnt_pop_pages(chunk, bit_off, bits);\n\t}\n\n\t/*\n\t * Keep track of nr_empty_pop_pages.\n\t *\n\t * The chunk maintains the previous number of free pages it held,\n\t * so the delta is used to update the global counter.  The reserved\n\t * chunk is not part of the free page count as they are populated\n\t * at init and are special to serving reserved allocations.\n\t */\n\tif (chunk != pcpu_reserved_chunk)\n\t\tpcpu_nr_empty_pop_pages +=\n\t\t\t(nr_empty_pop_pages - chunk->nr_empty_pop_pages);\n\n\tchunk->nr_empty_pop_pages = nr_empty_pop_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "e_block->right_free",
            "PCPU_BITMAP_BLOCK_BITS - e_off"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_block_refresh_hint",
          "args": [
            "chunk",
            "e_index"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_block_refresh_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "653-668",
          "snippet": "static void pcpu_block_refresh_hint(struct pcpu_chunk *chunk, int index)\n{\n\tstruct pcpu_block_md *block = chunk->md_blocks + index;\n\tunsigned long *alloc_map = pcpu_index_alloc_map(chunk, index);\n\tint rs, re;\t/* region start, region end */\n\n\t/* clear hints */\n\tblock->contig_hint = 0;\n\tblock->left_free = block->right_free = 0;\n\n\t/* iterate over free areas and update the contig hints */\n\tpcpu_for_each_unpop_region(alloc_map, rs, re, block->first_free,\n\t\t\t\t   PCPU_BITMAP_BLOCK_BITS) {\n\t\tpcpu_block_update(block, rs, re);\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_block_refresh_hint(struct pcpu_chunk *chunk, int index)\n{\n\tstruct pcpu_block_md *block = chunk->md_blocks + index;\n\tunsigned long *alloc_map = pcpu_index_alloc_map(chunk, index);\n\tint rs, re;\t/* region start, region end */\n\n\t/* clear hints */\n\tblock->contig_hint = 0;\n\tblock->left_free = block->right_free = 0;\n\n\t/* iterate over free areas and update the contig hints */\n\tpcpu_for_each_unpop_region(alloc_map, rs, re, block->first_free,\n\t\t\t\t   PCPU_BITMAP_BLOCK_BITS) {\n\t\tpcpu_block_update(block, rs, re);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "pcpu_index_alloc_map(chunk, e_index)",
            "PCPU_BITMAP_BLOCK_BITS",
            "e_off"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_index_alloc_map",
          "args": [
            "chunk",
            "e_index"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_index_alloc_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "300-304",
          "snippet": "static unsigned long *pcpu_index_alloc_map(struct pcpu_chunk *chunk, int index)\n{\n\treturn chunk->alloc_map +\n\t       (index * PCPU_BITMAP_BLOCK_BITS / BITS_PER_LONG);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long *pcpu_index_alloc_map(struct pcpu_chunk *chunk, int index)\n{\n\treturn chunk->alloc_map +\n\t       (index * PCPU_BITMAP_BLOCK_BITS / BITS_PER_LONG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "s_block->right_free",
            "PCPU_BITMAP_BLOCK_BITS - e_off"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "s_block->left_free",
            "s_off"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "pcpu_index_alloc_map(chunk, s_index)",
            "PCPU_BITMAP_BLOCK_BITS",
            "s_off + bits"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_off_to_block_off",
          "args": [
            "bit_off + bits - 1"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_off_to_block_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "311-314",
          "snippet": "static unsigned long pcpu_off_to_block_off(int off)\n{\n\treturn off & (PCPU_BITMAP_BLOCK_BITS - 1);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_off_to_block_off(int off)\n{\n\treturn off & (PCPU_BITMAP_BLOCK_BITS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_off_to_block_index",
          "args": [
            "bit_off + bits - 1"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_off_to_block_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "306-309",
          "snippet": "static unsigned long pcpu_off_to_block_index(int off)\n{\n\treturn off / PCPU_BITMAP_BLOCK_BITS;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_off_to_block_index(int off)\n{\n\treturn off / PCPU_BITMAP_BLOCK_BITS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_block_update_hint_alloc(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\t int bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Update s_block.\n\t * block->first_free must be updated if the allocation takes its place.\n\t * If the allocation breaks the contig_hint, a scan is required to\n\t * restore this hint.\n\t */\n\tif (s_off == s_block->first_free)\n\t\ts_block->first_free = find_next_zero_bit(\n\t\t\t\t\tpcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS,\n\t\t\t\t\ts_off + bits);\n\n\tif (s_off >= s_block->contig_hint_start &&\n\t    s_off < s_block->contig_hint_start + s_block->contig_hint) {\n\t\t/* block contig hint is broken - scan to fix it */\n\t\tpcpu_block_refresh_hint(chunk, s_index);\n\t} else {\n\t\t/* update left and right contig manually */\n\t\ts_block->left_free = min(s_block->left_free, s_off);\n\t\tif (s_index == e_index)\n\t\t\ts_block->right_free = min_t(int, s_block->right_free,\n\t\t\t\t\tPCPU_BITMAP_BLOCK_BITS - e_off);\n\t\telse\n\t\t\ts_block->right_free = 0;\n\t}\n\n\t/*\n\t * Update e_block.\n\t */\n\tif (s_index != e_index) {\n\t\t/*\n\t\t * When the allocation is across blocks, the end is along\n\t\t * the left part of the e_block.\n\t\t */\n\t\te_block->first_free = find_next_zero_bit(\n\t\t\t\tpcpu_index_alloc_map(chunk, e_index),\n\t\t\t\tPCPU_BITMAP_BLOCK_BITS, e_off);\n\n\t\tif (e_off == PCPU_BITMAP_BLOCK_BITS) {\n\t\t\t/* reset the block */\n\t\t\te_block++;\n\t\t} else {\n\t\t\tif (e_off > e_block->contig_hint_start) {\n\t\t\t\t/* contig hint is broken - scan to fix it */\n\t\t\t\tpcpu_block_refresh_hint(chunk, e_index);\n\t\t\t} else {\n\t\t\t\te_block->left_free = 0;\n\t\t\t\te_block->right_free =\n\t\t\t\t\tmin_t(int, e_block->right_free,\n\t\t\t\t\t      PCPU_BITMAP_BLOCK_BITS - e_off);\n\t\t\t}\n\t\t}\n\n\t\t/* update in-between md_blocks */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->contig_hint = 0;\n\t\t\tblock->left_free = 0;\n\t\t\tblock->right_free = 0;\n\t\t}\n\t}\n\n\t/*\n\t * The only time a full chunk scan is required is if the chunk\n\t * contig hint is broken.  Otherwise, it means a smaller space\n\t * was used and therefore the chunk contig hint is still correct.\n\t */\n\tif (bit_off >= chunk->contig_bits_start  &&\n\t    bit_off < chunk->contig_bits_start + chunk->contig_bits)\n\t\tpcpu_chunk_refresh_hint(chunk);\n}"
  },
  {
    "function_name": "pcpu_block_refresh_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "653-668",
    "snippet": "static void pcpu_block_refresh_hint(struct pcpu_chunk *chunk, int index)\n{\n\tstruct pcpu_block_md *block = chunk->md_blocks + index;\n\tunsigned long *alloc_map = pcpu_index_alloc_map(chunk, index);\n\tint rs, re;\t/* region start, region end */\n\n\t/* clear hints */\n\tblock->contig_hint = 0;\n\tblock->left_free = block->right_free = 0;\n\n\t/* iterate over free areas and update the contig hints */\n\tpcpu_for_each_unpop_region(alloc_map, rs, re, block->first_free,\n\t\t\t\t   PCPU_BITMAP_BLOCK_BITS) {\n\t\tpcpu_block_update(block, rs, re);\n\t}\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_block_update",
          "args": [
            "block",
            "rs",
            "re"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_block_update_hint_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "789-875",
          "snippet": "static void pcpu_block_update_hint_free(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\tint bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\tint start, end;\t\t/* start and end of the whole free area */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Check if the freed area aligns with the block->contig_hint.\n\t * If it does, then the scan to find the beginning/end of the\n\t * larger free area can be avoided.\n\t *\n\t * start and end refer to beginning and end of the free area\n\t * within each their respective blocks.  This is not necessarily\n\t * the entire free area as it may span blocks past the beginning\n\t * or end of the block.\n\t */\n\tstart = s_off;\n\tif (s_off == s_block->contig_hint + s_block->contig_hint_start) {\n\t\tstart = s_block->contig_hint_start;\n\t} else {\n\t\t/*\n\t\t * Scan backwards to find the extent of the free area.\n\t\t * find_last_bit returns the starting bit, so if the start bit\n\t\t * is returned, that means there was no last bit and the\n\t\t * remainder of the chunk is free.\n\t\t */\n\t\tint l_bit = find_last_bit(pcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\t  start);\n\t\tstart = (start == l_bit) ? 0 : l_bit + 1;\n\t}\n\n\tend = e_off;\n\tif (e_off == e_block->contig_hint_start)\n\t\tend = e_block->contig_hint_start + e_block->contig_hint;\n\telse\n\t\tend = find_next_bit(pcpu_index_alloc_map(chunk, e_index),\n\t\t\t\t    PCPU_BITMAP_BLOCK_BITS, end);\n\n\t/* update s_block */\n\te_off = (s_index == e_index) ? end : PCPU_BITMAP_BLOCK_BITS;\n\tpcpu_block_update(s_block, start, e_off);\n\n\t/* freeing in the same block */\n\tif (s_index != e_index) {\n\t\t/* update e_block */\n\t\tpcpu_block_update(e_block, 0, end);\n\n\t\t/* reset md_blocks in the middle */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->first_free = 0;\n\t\t\tblock->contig_hint_start = 0;\n\t\t\tblock->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t}\n\t}\n\n\t/*\n\t * Refresh chunk metadata when the free makes a page free, a block\n\t * free, or spans across blocks.  The contig hint may be off by up to\n\t * a page, but if the hint is contained in a block, it will be accurate\n\t * with the else condition below.\n\t */\n\tif ((ALIGN_DOWN(end, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS)) >\n\t     ALIGN(start, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS))) ||\n\t    s_index != e_index)\n\t\tpcpu_chunk_refresh_hint(chunk);\n\telse\n\t\tpcpu_chunk_update(chunk, pcpu_block_off_to_off(s_index, start),\n\t\t\t\t  s_block->contig_hint);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_block_update_hint_free(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t\tint bits)\n{\n\tstruct pcpu_block_md *s_block, *e_block, *block;\n\tint s_index, e_index;\t/* block indexes of the freed allocation */\n\tint s_off, e_off;\t/* block offsets of the freed allocation */\n\tint start, end;\t\t/* start and end of the whole free area */\n\n\t/*\n\t * Calculate per block offsets.\n\t * The calculation uses an inclusive range, but the resulting offsets\n\t * are [start, end).  e_index always points to the last block in the\n\t * range.\n\t */\n\ts_index = pcpu_off_to_block_index(bit_off);\n\te_index = pcpu_off_to_block_index(bit_off + bits - 1);\n\ts_off = pcpu_off_to_block_off(bit_off);\n\te_off = pcpu_off_to_block_off(bit_off + bits - 1) + 1;\n\n\ts_block = chunk->md_blocks + s_index;\n\te_block = chunk->md_blocks + e_index;\n\n\t/*\n\t * Check if the freed area aligns with the block->contig_hint.\n\t * If it does, then the scan to find the beginning/end of the\n\t * larger free area can be avoided.\n\t *\n\t * start and end refer to beginning and end of the free area\n\t * within each their respective blocks.  This is not necessarily\n\t * the entire free area as it may span blocks past the beginning\n\t * or end of the block.\n\t */\n\tstart = s_off;\n\tif (s_off == s_block->contig_hint + s_block->contig_hint_start) {\n\t\tstart = s_block->contig_hint_start;\n\t} else {\n\t\t/*\n\t\t * Scan backwards to find the extent of the free area.\n\t\t * find_last_bit returns the starting bit, so if the start bit\n\t\t * is returned, that means there was no last bit and the\n\t\t * remainder of the chunk is free.\n\t\t */\n\t\tint l_bit = find_last_bit(pcpu_index_alloc_map(chunk, s_index),\n\t\t\t\t\t  start);\n\t\tstart = (start == l_bit) ? 0 : l_bit + 1;\n\t}\n\n\tend = e_off;\n\tif (e_off == e_block->contig_hint_start)\n\t\tend = e_block->contig_hint_start + e_block->contig_hint;\n\telse\n\t\tend = find_next_bit(pcpu_index_alloc_map(chunk, e_index),\n\t\t\t\t    PCPU_BITMAP_BLOCK_BITS, end);\n\n\t/* update s_block */\n\te_off = (s_index == e_index) ? end : PCPU_BITMAP_BLOCK_BITS;\n\tpcpu_block_update(s_block, start, e_off);\n\n\t/* freeing in the same block */\n\tif (s_index != e_index) {\n\t\t/* update e_block */\n\t\tpcpu_block_update(e_block, 0, end);\n\n\t\t/* reset md_blocks in the middle */\n\t\tfor (block = s_block + 1; block < e_block; block++) {\n\t\t\tblock->first_free = 0;\n\t\t\tblock->contig_hint_start = 0;\n\t\t\tblock->contig_hint = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->left_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t\tblock->right_free = PCPU_BITMAP_BLOCK_BITS;\n\t\t}\n\t}\n\n\t/*\n\t * Refresh chunk metadata when the free makes a page free, a block\n\t * free, or spans across blocks.  The contig hint may be off by up to\n\t * a page, but if the hint is contained in a block, it will be accurate\n\t * with the else condition below.\n\t */\n\tif ((ALIGN_DOWN(end, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS)) >\n\t     ALIGN(start, min(PCPU_BITS_PER_PAGE, PCPU_BITMAP_BLOCK_BITS))) ||\n\t    s_index != e_index)\n\t\tpcpu_chunk_refresh_hint(chunk);\n\telse\n\t\tpcpu_chunk_update(chunk, pcpu_block_off_to_off(s_index, start),\n\t\t\t\t  s_block->contig_hint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_for_each_unpop_region",
          "args": [
            "alloc_map",
            "rs",
            "re",
            "block->first_free",
            "PCPU_BITMAP_BLOCK_BITS"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_index_alloc_map",
          "args": [
            "chunk",
            "index"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_index_alloc_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "300-304",
          "snippet": "static unsigned long *pcpu_index_alloc_map(struct pcpu_chunk *chunk, int index)\n{\n\treturn chunk->alloc_map +\n\t       (index * PCPU_BITMAP_BLOCK_BITS / BITS_PER_LONG);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long *pcpu_index_alloc_map(struct pcpu_chunk *chunk, int index)\n{\n\treturn chunk->alloc_map +\n\t       (index * PCPU_BITMAP_BLOCK_BITS / BITS_PER_LONG);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_block_refresh_hint(struct pcpu_chunk *chunk, int index)\n{\n\tstruct pcpu_block_md *block = chunk->md_blocks + index;\n\tunsigned long *alloc_map = pcpu_index_alloc_map(chunk, index);\n\tint rs, re;\t/* region start, region end */\n\n\t/* clear hints */\n\tblock->contig_hint = 0;\n\tblock->left_free = block->right_free = 0;\n\n\t/* iterate over free areas and update the contig hints */\n\tpcpu_for_each_unpop_region(alloc_map, rs, re, block->first_free,\n\t\t\t\t   PCPU_BITMAP_BLOCK_BITS) {\n\t\tpcpu_block_update(block, rs, re);\n\t}\n}"
  },
  {
    "function_name": "pcpu_block_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "624-643",
    "snippet": "static void pcpu_block_update(struct pcpu_block_md *block, int start, int end)\n{\n\tint contig = end - start;\n\n\tblock->first_free = min(block->first_free, start);\n\tif (start == 0)\n\t\tblock->left_free = contig;\n\n\tif (end == PCPU_BITMAP_BLOCK_BITS)\n\t\tblock->right_free = contig;\n\n\tif (contig > block->contig_hint) {\n\t\tblock->contig_hint_start = start;\n\t\tblock->contig_hint = contig;\n\t} else if (block->contig_hint_start && contig == block->contig_hint &&\n\t\t   (!start || __ffs(start) > __ffs(block->contig_hint_start))) {\n\t\t/* use the start with the best alignment */\n\t\tblock->contig_hint_start = start;\n\t}\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "block->contig_hint_start"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "start"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "block->first_free",
            "start"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_block_update(struct pcpu_block_md *block, int start, int end)\n{\n\tint contig = end - start;\n\n\tblock->first_free = min(block->first_free, start);\n\tif (start == 0)\n\t\tblock->left_free = contig;\n\n\tif (end == PCPU_BITMAP_BLOCK_BITS)\n\t\tblock->right_free = contig;\n\n\tif (contig > block->contig_hint) {\n\t\tblock->contig_hint_start = start;\n\t\tblock->contig_hint = contig;\n\t} else if (block->contig_hint_start && contig == block->contig_hint &&\n\t\t   (!start || __ffs(start) > __ffs(block->contig_hint_start))) {\n\t\t/* use the start with the best alignment */\n\t\tblock->contig_hint_start = start;\n\t}\n}"
  },
  {
    "function_name": "pcpu_chunk_refresh_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "584-612",
    "snippet": "static void pcpu_chunk_refresh_hint(struct pcpu_chunk *chunk)\n{\n\tint bit_off, bits, nr_empty_pop_pages;\n\n\t/* clear metadata */\n\tchunk->contig_bits = 0;\n\n\tbit_off = chunk->first_bit;\n\tbits = nr_empty_pop_pages = 0;\n\tpcpu_for_each_md_free_region(chunk, bit_off, bits) {\n\t\tpcpu_chunk_update(chunk, bit_off, bits);\n\n\t\tnr_empty_pop_pages += pcpu_cnt_pop_pages(chunk, bit_off, bits);\n\t}\n\n\t/*\n\t * Keep track of nr_empty_pop_pages.\n\t *\n\t * The chunk maintains the previous number of free pages it held,\n\t * so the delta is used to update the global counter.  The reserved\n\t * chunk is not part of the free page count as they are populated\n\t * at init and are special to serving reserved allocations.\n\t */\n\tif (chunk != pcpu_reserved_chunk)\n\t\tpcpu_nr_empty_pop_pages +=\n\t\t\t(nr_empty_pop_pages - chunk->nr_empty_pop_pages);\n\n\tchunk->nr_empty_pop_pages = nr_empty_pop_pages;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pcpu_chunk *pcpu_reserved_chunk",
      "int pcpu_nr_empty_pop_pages;",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_cnt_pop_pages",
          "args": [
            "chunk",
            "bit_off",
            "bits"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_cnt_pop_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "529-547",
          "snippet": "static inline int pcpu_cnt_pop_pages(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t     int bits)\n{\n\tint page_start = PFN_UP(bit_off * PCPU_MIN_ALLOC_SIZE);\n\tint page_end = PFN_DOWN((bit_off + bits) * PCPU_MIN_ALLOC_SIZE);\n\n\tif (page_start >= page_end)\n\t\treturn 0;\n\n\t/*\n\t * bitmap_weight counts the number of bits set in a bitmap up to\n\t * the specified number of bits.  This is counting the populated\n\t * pages up to page_end and then subtracting the populated pages\n\t * up to page_start to count the populated pages in\n\t * [page_start, page_end).\n\t */\n\treturn bitmap_weight(chunk->populated, page_end) -\n\t       bitmap_weight(chunk->populated, page_start);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic inline int pcpu_cnt_pop_pages(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t     int bits)\n{\n\tint page_start = PFN_UP(bit_off * PCPU_MIN_ALLOC_SIZE);\n\tint page_end = PFN_DOWN((bit_off + bits) * PCPU_MIN_ALLOC_SIZE);\n\n\tif (page_start >= page_end)\n\t\treturn 0;\n\n\t/*\n\t * bitmap_weight counts the number of bits set in a bitmap up to\n\t * the specified number of bits.  This is counting the populated\n\t * pages up to page_end and then subtracting the populated pages\n\t * up to page_start to count the populated pages in\n\t * [page_start, page_end).\n\t */\n\treturn bitmap_weight(chunk->populated, page_end) -\n\t       bitmap_weight(chunk->populated, page_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_update",
          "args": [
            "chunk",
            "bit_off",
            "bits"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "558-569",
          "snippet": "static void pcpu_chunk_update(struct pcpu_chunk *chunk, int bit_off, int bits)\n{\n\tif (bits > chunk->contig_bits) {\n\t\tchunk->contig_bits_start = bit_off;\n\t\tchunk->contig_bits = bits;\n\t} else if (bits == chunk->contig_bits && chunk->contig_bits_start &&\n\t\t   (!bit_off ||\n\t\t    __ffs(bit_off) > __ffs(chunk->contig_bits_start))) {\n\t\t/* use the start with the best alignment */\n\t\tchunk->contig_bits_start = bit_off;\n\t}\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_update(struct pcpu_chunk *chunk, int bit_off, int bits)\n{\n\tif (bits > chunk->contig_bits) {\n\t\tchunk->contig_bits_start = bit_off;\n\t\tchunk->contig_bits = bits;\n\t} else if (bits == chunk->contig_bits && chunk->contig_bits_start &&\n\t\t   (!bit_off ||\n\t\t    __ffs(bit_off) > __ffs(chunk->contig_bits_start))) {\n\t\t/* use the start with the best alignment */\n\t\tchunk->contig_bits_start = bit_off;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_for_each_md_free_region",
          "args": [
            "chunk",
            "bit_off",
            "bits"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstruct pcpu_chunk *pcpu_reserved_chunk;\nint pcpu_nr_empty_pop_pages;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_refresh_hint(struct pcpu_chunk *chunk)\n{\n\tint bit_off, bits, nr_empty_pop_pages;\n\n\t/* clear metadata */\n\tchunk->contig_bits = 0;\n\n\tbit_off = chunk->first_bit;\n\tbits = nr_empty_pop_pages = 0;\n\tpcpu_for_each_md_free_region(chunk, bit_off, bits) {\n\t\tpcpu_chunk_update(chunk, bit_off, bits);\n\n\t\tnr_empty_pop_pages += pcpu_cnt_pop_pages(chunk, bit_off, bits);\n\t}\n\n\t/*\n\t * Keep track of nr_empty_pop_pages.\n\t *\n\t * The chunk maintains the previous number of free pages it held,\n\t * so the delta is used to update the global counter.  The reserved\n\t * chunk is not part of the free page count as they are populated\n\t * at init and are special to serving reserved allocations.\n\t */\n\tif (chunk != pcpu_reserved_chunk)\n\t\tpcpu_nr_empty_pop_pages +=\n\t\t\t(nr_empty_pop_pages - chunk->nr_empty_pop_pages);\n\n\tchunk->nr_empty_pop_pages = nr_empty_pop_pages;\n}"
  },
  {
    "function_name": "pcpu_chunk_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "558-569",
    "snippet": "static void pcpu_chunk_update(struct pcpu_chunk *chunk, int bit_off, int bits)\n{\n\tif (bits > chunk->contig_bits) {\n\t\tchunk->contig_bits_start = bit_off;\n\t\tchunk->contig_bits = bits;\n\t} else if (bits == chunk->contig_bits && chunk->contig_bits_start &&\n\t\t   (!bit_off ||\n\t\t    __ffs(bit_off) > __ffs(chunk->contig_bits_start))) {\n\t\t/* use the start with the best alignment */\n\t\tchunk->contig_bits_start = bit_off;\n\t}\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "chunk->contig_bits_start"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "bit_off"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_update(struct pcpu_chunk *chunk, int bit_off, int bits)\n{\n\tif (bits > chunk->contig_bits) {\n\t\tchunk->contig_bits_start = bit_off;\n\t\tchunk->contig_bits = bits;\n\t} else if (bits == chunk->contig_bits && chunk->contig_bits_start &&\n\t\t   (!bit_off ||\n\t\t    __ffs(bit_off) > __ffs(chunk->contig_bits_start))) {\n\t\t/* use the start with the best alignment */\n\t\tchunk->contig_bits_start = bit_off;\n\t}\n}"
  },
  {
    "function_name": "pcpu_cnt_pop_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "529-547",
    "snippet": "static inline int pcpu_cnt_pop_pages(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t     int bits)\n{\n\tint page_start = PFN_UP(bit_off * PCPU_MIN_ALLOC_SIZE);\n\tint page_end = PFN_DOWN((bit_off + bits) * PCPU_MIN_ALLOC_SIZE);\n\n\tif (page_start >= page_end)\n\t\treturn 0;\n\n\t/*\n\t * bitmap_weight counts the number of bits set in a bitmap up to\n\t * the specified number of bits.  This is counting the populated\n\t * pages up to page_end and then subtracting the populated pages\n\t * up to page_start to count the populated pages in\n\t * [page_start, page_end).\n\t */\n\treturn bitmap_weight(chunk->populated, page_end) -\n\t       bitmap_weight(chunk->populated, page_start);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "chunk->populated",
            "page_start"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "chunk->populated",
            "page_end"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "(bit_off + bits) * PCPU_MIN_ALLOC_SIZE"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "bit_off * PCPU_MIN_ALLOC_SIZE"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic inline int pcpu_cnt_pop_pages(struct pcpu_chunk *chunk, int bit_off,\n\t\t\t\t     int bits)\n{\n\tint page_start = PFN_UP(bit_off * PCPU_MIN_ALLOC_SIZE);\n\tint page_end = PFN_DOWN((bit_off + bits) * PCPU_MIN_ALLOC_SIZE);\n\n\tif (page_start >= page_end)\n\t\treturn 0;\n\n\t/*\n\t * bitmap_weight counts the number of bits set in a bitmap up to\n\t * the specified number of bits.  This is counting the populated\n\t * pages up to page_end and then subtracting the populated pages\n\t * up to page_start to count the populated pages in\n\t * [page_start, page_end).\n\t */\n\treturn bitmap_weight(chunk->populated, page_end) -\n\t       bitmap_weight(chunk->populated, page_start);\n}"
  },
  {
    "function_name": "pcpu_chunk_relocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "504-514",
    "snippet": "static void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pcpu_chunk *pcpu_reserved_chunk",
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&chunk->list",
            "&pcpu_slot[nslot]"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&chunk->list",
            "&pcpu_slot[nslot]"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_slot",
          "args": [
            "chunk"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "232-238",
          "snippet": "static int pcpu_chunk_slot(const struct pcpu_chunk *chunk)\n{\n\tif (chunk->free_bytes < PCPU_MIN_ALLOC_SIZE || chunk->contig_bits == 0)\n\t\treturn 0;\n\n\treturn pcpu_size_to_slot(chunk->free_bytes);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic int pcpu_chunk_slot(const struct pcpu_chunk *chunk)\n{\n\tif (chunk->free_bytes < PCPU_MIN_ALLOC_SIZE || chunk->contig_bits == 0)\n\t\treturn 0;\n\n\treturn pcpu_size_to_slot(chunk->free_bytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstruct pcpu_chunk *pcpu_reserved_chunk;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)\n{\n\tint nslot = pcpu_chunk_slot(chunk);\n\n\tif (chunk != pcpu_reserved_chunk && oslot != nslot) {\n\t\tif (oslot < nslot)\n\t\t\tlist_move(&chunk->list, &pcpu_slot[nslot]);\n\t\telse\n\t\t\tlist_move_tail(&chunk->list, &pcpu_slot[nslot]);\n\t}\n}"
  },
  {
    "function_name": "pcpu_mem_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "486-489",
    "snippet": "static void pcpu_mem_free(void *ptr)\n{\n\tkvfree(ptr);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "ptr"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_mem_free(void *ptr)\n{\n\tkvfree(ptr);\n}"
  },
  {
    "function_name": "pcpu_mem_zalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "469-478",
    "snippet": "static void *pcpu_mem_zalloc(size_t size, gfp_t gfp)\n{\n\tif (WARN_ON_ONCE(!slab_is_available()))\n\t\treturn NULL;\n\n\tif (size <= PAGE_SIZE)\n\t\treturn kzalloc(size, gfp);\n\telse\n\t\treturn __vmalloc(size, gfp | __GFP_ZERO, PAGE_KERNEL);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);",
      "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "size",
            "gfp | __GFP_ZERO",
            "PAGE_KERNEL"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "240-243",
          "snippet": "void *__vmalloc_node_flags(unsigned long size, int node, gfp_t flags)\n{\n\treturn __vmalloc(size, flags, PAGE_KERNEL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid *__vmalloc_node_flags(unsigned long size, int node, gfp_t flags)\n{\n\treturn __vmalloc(size, flags, PAGE_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "gfp"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!slab_is_available()"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "slab_is_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "930-933",
          "snippet": "bool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum slab_state slab_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nenum slab_state slab_state;\n\nbool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);\n\nstatic void *pcpu_mem_zalloc(size_t size, gfp_t gfp)\n{\n\tif (WARN_ON_ONCE(!slab_is_available()))\n\t\treturn NULL;\n\n\tif (size <= PAGE_SIZE)\n\t\treturn kzalloc(size, gfp);\n\telse\n\t\treturn __vmalloc(size, gfp | __GFP_ZERO, PAGE_KERNEL);\n}"
  },
  {
    "function_name": "pcpu_next_fit_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "387-434",
    "snippet": "static void pcpu_next_fit_region(struct pcpu_chunk *chunk, int alloc_bits,\n\t\t\t\t int align, int *bit_off, int *bits)\n{\n\tint i = pcpu_off_to_block_index(*bit_off);\n\tint block_off = pcpu_off_to_block_off(*bit_off);\n\tstruct pcpu_block_md *block;\n\n\t*bits = 0;\n\tfor (block = chunk->md_blocks + i; i < pcpu_chunk_nr_blocks(chunk);\n\t     block++, i++) {\n\t\t/* handles contig area across blocks */\n\t\tif (*bits) {\n\t\t\t*bits += block->left_free;\n\t\t\tif (*bits >= alloc_bits)\n\t\t\t\treturn;\n\t\t\tif (block->left_free == PCPU_BITMAP_BLOCK_BITS)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* check block->contig_hint */\n\t\t*bits = ALIGN(block->contig_hint_start, align) -\n\t\t\tblock->contig_hint_start;\n\t\t/*\n\t\t * This uses the block offset to determine if this has been\n\t\t * checked in the prior iteration.\n\t\t */\n\t\tif (block->contig_hint &&\n\t\t    block->contig_hint_start >= block_off &&\n\t\t    block->contig_hint >= *bits + alloc_bits) {\n\t\t\t*bits += alloc_bits + block->contig_hint_start -\n\t\t\t\t block->first_free;\n\t\t\t*bit_off = pcpu_block_off_to_off(i, block->first_free);\n\t\t\treturn;\n\t\t}\n\t\t/* reset to satisfy the second predicate above */\n\t\tblock_off = 0;\n\n\t\t*bit_off = ALIGN(PCPU_BITMAP_BLOCK_BITS - block->right_free,\n\t\t\t\t align);\n\t\t*bits = PCPU_BITMAP_BLOCK_BITS - *bit_off;\n\t\t*bit_off = pcpu_block_off_to_off(i, *bit_off);\n\t\tif (*bits >= alloc_bits)\n\t\t\treturn;\n\t}\n\n\t/* no valid offsets were found - fail condition */\n\t*bit_off = pcpu_chunk_map_bits(chunk);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_chunk_map_bits",
          "args": [
            "chunk"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_map_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "97-100",
          "snippet": "static inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_block_off_to_off",
          "args": [
            "i",
            "*bit_off"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_block_off_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "316-319",
          "snippet": "static unsigned long pcpu_block_off_to_off(int index, int off)\n{\n\treturn index * PCPU_BITMAP_BLOCK_BITS + off;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_block_off_to_off(int index, int off)\n{\n\treturn index * PCPU_BITMAP_BLOCK_BITS + off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "PCPU_BITMAP_BLOCK_BITS - block->right_free",
            "align"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "block->contig_hint_start",
            "align"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_nr_blocks",
          "args": [
            "chunk"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_nr_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "73-76",
          "snippet": "static inline int pcpu_chunk_nr_blocks(struct pcpu_chunk *chunk)\n{\n\treturn chunk->nr_pages * PAGE_SIZE / PCPU_BITMAP_BLOCK_SIZE;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_nr_blocks(struct pcpu_chunk *chunk)\n{\n\treturn chunk->nr_pages * PAGE_SIZE / PCPU_BITMAP_BLOCK_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_off_to_block_off",
          "args": [
            "*bit_off"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_off_to_block_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "311-314",
          "snippet": "static unsigned long pcpu_off_to_block_off(int off)\n{\n\treturn off & (PCPU_BITMAP_BLOCK_BITS - 1);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_off_to_block_off(int off)\n{\n\treturn off & (PCPU_BITMAP_BLOCK_BITS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_off_to_block_index",
          "args": [
            "*bit_off"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_off_to_block_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "306-309",
          "snippet": "static unsigned long pcpu_off_to_block_index(int off)\n{\n\treturn off / PCPU_BITMAP_BLOCK_BITS;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_off_to_block_index(int off)\n{\n\treturn off / PCPU_BITMAP_BLOCK_BITS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_next_fit_region(struct pcpu_chunk *chunk, int alloc_bits,\n\t\t\t\t int align, int *bit_off, int *bits)\n{\n\tint i = pcpu_off_to_block_index(*bit_off);\n\tint block_off = pcpu_off_to_block_off(*bit_off);\n\tstruct pcpu_block_md *block;\n\n\t*bits = 0;\n\tfor (block = chunk->md_blocks + i; i < pcpu_chunk_nr_blocks(chunk);\n\t     block++, i++) {\n\t\t/* handles contig area across blocks */\n\t\tif (*bits) {\n\t\t\t*bits += block->left_free;\n\t\t\tif (*bits >= alloc_bits)\n\t\t\t\treturn;\n\t\t\tif (block->left_free == PCPU_BITMAP_BLOCK_BITS)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* check block->contig_hint */\n\t\t*bits = ALIGN(block->contig_hint_start, align) -\n\t\t\tblock->contig_hint_start;\n\t\t/*\n\t\t * This uses the block offset to determine if this has been\n\t\t * checked in the prior iteration.\n\t\t */\n\t\tif (block->contig_hint &&\n\t\t    block->contig_hint_start >= block_off &&\n\t\t    block->contig_hint >= *bits + alloc_bits) {\n\t\t\t*bits += alloc_bits + block->contig_hint_start -\n\t\t\t\t block->first_free;\n\t\t\t*bit_off = pcpu_block_off_to_off(i, block->first_free);\n\t\t\treturn;\n\t\t}\n\t\t/* reset to satisfy the second predicate above */\n\t\tblock_off = 0;\n\n\t\t*bit_off = ALIGN(PCPU_BITMAP_BLOCK_BITS - block->right_free,\n\t\t\t\t align);\n\t\t*bits = PCPU_BITMAP_BLOCK_BITS - *bit_off;\n\t\t*bit_off = pcpu_block_off_to_off(i, *bit_off);\n\t\tif (*bits >= alloc_bits)\n\t\t\treturn;\n\t}\n\n\t/* no valid offsets were found - fail condition */\n\t*bit_off = pcpu_chunk_map_bits(chunk);\n}"
  },
  {
    "function_name": "pcpu_next_md_free_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "332-371",
    "snippet": "static void pcpu_next_md_free_region(struct pcpu_chunk *chunk, int *bit_off,\n\t\t\t\t     int *bits)\n{\n\tint i = pcpu_off_to_block_index(*bit_off);\n\tint block_off = pcpu_off_to_block_off(*bit_off);\n\tstruct pcpu_block_md *block;\n\n\t*bits = 0;\n\tfor (block = chunk->md_blocks + i; i < pcpu_chunk_nr_blocks(chunk);\n\t     block++, i++) {\n\t\t/* handles contig area across blocks */\n\t\tif (*bits) {\n\t\t\t*bits += block->left_free;\n\t\t\tif (block->left_free == PCPU_BITMAP_BLOCK_BITS)\n\t\t\t\tcontinue;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * This checks three things.  First is there a contig_hint to\n\t\t * check.  Second, have we checked this hint before by\n\t\t * comparing the block_off.  Third, is this the same as the\n\t\t * right contig hint.  In the last case, it spills over into\n\t\t * the next block and should be handled by the contig area\n\t\t * across blocks code.\n\t\t */\n\t\t*bits = block->contig_hint;\n\t\tif (*bits && block->contig_hint_start >= block_off &&\n\t\t    *bits + block->contig_hint_start < PCPU_BITMAP_BLOCK_BITS) {\n\t\t\t*bit_off = pcpu_block_off_to_off(i,\n\t\t\t\t\tblock->contig_hint_start);\n\t\t\treturn;\n\t\t}\n\t\t/* reset to satisfy the second predicate above */\n\t\tblock_off = 0;\n\n\t\t*bits = block->right_free;\n\t\t*bit_off = (i + 1) * PCPU_BITMAP_BLOCK_BITS - block->right_free;\n\t}\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_block_off_to_off",
          "args": [
            "i",
            "block->contig_hint_start"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_block_off_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "316-319",
          "snippet": "static unsigned long pcpu_block_off_to_off(int index, int off)\n{\n\treturn index * PCPU_BITMAP_BLOCK_BITS + off;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_block_off_to_off(int index, int off)\n{\n\treturn index * PCPU_BITMAP_BLOCK_BITS + off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_nr_blocks",
          "args": [
            "chunk"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_nr_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "73-76",
          "snippet": "static inline int pcpu_chunk_nr_blocks(struct pcpu_chunk *chunk)\n{\n\treturn chunk->nr_pages * PAGE_SIZE / PCPU_BITMAP_BLOCK_SIZE;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_nr_blocks(struct pcpu_chunk *chunk)\n{\n\treturn chunk->nr_pages * PAGE_SIZE / PCPU_BITMAP_BLOCK_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_off_to_block_off",
          "args": [
            "*bit_off"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_off_to_block_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "311-314",
          "snippet": "static unsigned long pcpu_off_to_block_off(int off)\n{\n\treturn off & (PCPU_BITMAP_BLOCK_BITS - 1);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_off_to_block_off(int off)\n{\n\treturn off & (PCPU_BITMAP_BLOCK_BITS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_off_to_block_index",
          "args": [
            "*bit_off"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_off_to_block_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "306-309",
          "snippet": "static unsigned long pcpu_off_to_block_index(int off)\n{\n\treturn off / PCPU_BITMAP_BLOCK_BITS;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_off_to_block_index(int off)\n{\n\treturn off / PCPU_BITMAP_BLOCK_BITS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_next_md_free_region(struct pcpu_chunk *chunk, int *bit_off,\n\t\t\t\t     int *bits)\n{\n\tint i = pcpu_off_to_block_index(*bit_off);\n\tint block_off = pcpu_off_to_block_off(*bit_off);\n\tstruct pcpu_block_md *block;\n\n\t*bits = 0;\n\tfor (block = chunk->md_blocks + i; i < pcpu_chunk_nr_blocks(chunk);\n\t     block++, i++) {\n\t\t/* handles contig area across blocks */\n\t\tif (*bits) {\n\t\t\t*bits += block->left_free;\n\t\t\tif (block->left_free == PCPU_BITMAP_BLOCK_BITS)\n\t\t\t\tcontinue;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * This checks three things.  First is there a contig_hint to\n\t\t * check.  Second, have we checked this hint before by\n\t\t * comparing the block_off.  Third, is this the same as the\n\t\t * right contig hint.  In the last case, it spills over into\n\t\t * the next block and should be handled by the contig area\n\t\t * across blocks code.\n\t\t */\n\t\t*bits = block->contig_hint;\n\t\tif (*bits && block->contig_hint_start >= block_off &&\n\t\t    *bits + block->contig_hint_start < PCPU_BITMAP_BLOCK_BITS) {\n\t\t\t*bit_off = pcpu_block_off_to_off(i,\n\t\t\t\t\tblock->contig_hint_start);\n\t\t\treturn;\n\t\t}\n\t\t/* reset to satisfy the second predicate above */\n\t\tblock_off = 0;\n\n\t\t*bits = block->right_free;\n\t\t*bit_off = (i + 1) * PCPU_BITMAP_BLOCK_BITS - block->right_free;\n\t}\n}"
  },
  {
    "function_name": "pcpu_block_off_to_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "316-319",
    "snippet": "static unsigned long pcpu_block_off_to_off(int index, int off)\n{\n\treturn index * PCPU_BITMAP_BLOCK_BITS + off;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_block_off_to_off(int index, int off)\n{\n\treturn index * PCPU_BITMAP_BLOCK_BITS + off;\n}"
  },
  {
    "function_name": "pcpu_off_to_block_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "311-314",
    "snippet": "static unsigned long pcpu_off_to_block_off(int off)\n{\n\treturn off & (PCPU_BITMAP_BLOCK_BITS - 1);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_off_to_block_off(int off)\n{\n\treturn off & (PCPU_BITMAP_BLOCK_BITS - 1);\n}"
  },
  {
    "function_name": "pcpu_off_to_block_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "306-309",
    "snippet": "static unsigned long pcpu_off_to_block_index(int off)\n{\n\treturn off / PCPU_BITMAP_BLOCK_BITS;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic unsigned long pcpu_off_to_block_index(int off)\n{\n\treturn off / PCPU_BITMAP_BLOCK_BITS;\n}"
  },
  {
    "function_name": "pcpu_index_alloc_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "300-304",
    "snippet": "static unsigned long *pcpu_index_alloc_map(struct pcpu_chunk *chunk, int index)\n{\n\treturn chunk->alloc_map +\n\t       (index * PCPU_BITMAP_BLOCK_BITS / BITS_PER_LONG);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long *pcpu_index_alloc_map(struct pcpu_chunk *chunk, int index)\n{\n\treturn chunk->alloc_map +\n\t       (index * PCPU_BITMAP_BLOCK_BITS / BITS_PER_LONG);\n}"
  },
  {
    "function_name": "pcpu_next_pop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "275-279",
    "snippet": "static void pcpu_next_pop(unsigned long *bitmap, int *rs, int *re, int end)\n{\n\t*rs = find_next_bit(bitmap, end, *rs);\n\t*re = find_next_zero_bit(bitmap, end, *rs + 1);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "bitmap",
            "end",
            "*rs + 1"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "bitmap",
            "end",
            "*rs"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_next_pop(unsigned long *bitmap, int *rs, int *re, int end)\n{\n\t*rs = find_next_bit(bitmap, end, *rs);\n\t*re = find_next_zero_bit(bitmap, end, *rs + 1);\n}"
  },
  {
    "function_name": "pcpu_next_unpop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "269-273",
    "snippet": "static void pcpu_next_unpop(unsigned long *bitmap, int *rs, int *re, int end)\n{\n\t*rs = find_next_zero_bit(bitmap, end, *rs);\n\t*re = find_next_bit(bitmap, end, *rs + 1);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "bitmap",
            "end",
            "*rs + 1"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "bitmap",
            "end",
            "*rs"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_next_unpop(unsigned long *bitmap, int *rs, int *re, int end)\n{\n\t*rs = find_next_zero_bit(bitmap, end, *rs);\n\t*re = find_next_bit(bitmap, end, *rs + 1);\n}"
  },
  {
    "function_name": "pcpu_chunk_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "262-267",
    "snippet": "static unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_unit_page_offset",
          "args": [
            "cpu",
            "page_idx"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_unit_page_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "257-260",
          "snippet": "static unsigned long pcpu_unit_page_offset(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_offsets[cpu] + (page_idx << PAGE_SHIFT);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const unsigned long *pcpu_unit_offsets"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nconst unsigned long *pcpu_unit_offsets;\n\nstatic unsigned long pcpu_unit_page_offset(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_offsets[cpu] + (page_idx << PAGE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}"
  },
  {
    "function_name": "pcpu_unit_page_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "257-260",
    "snippet": "static unsigned long pcpu_unit_page_offset(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_offsets[cpu] + (page_idx << PAGE_SHIFT);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const unsigned long *pcpu_unit_offsets"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nconst unsigned long *pcpu_unit_offsets;\n\nstatic unsigned long pcpu_unit_page_offset(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_offsets[cpu] + (page_idx << PAGE_SHIFT);\n}"
  },
  {
    "function_name": "pcpu_page_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "252-255",
    "snippet": "static int __maybe_unused pcpu_page_idx(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_map[cpu] * pcpu_unit_pages + page_idx;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pcpu_unit_pages",
      "static const int *pcpu_unit_map"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic const int *pcpu_unit_map;\n\nstatic int __maybe_unused pcpu_page_idx(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_map[cpu] * pcpu_unit_pages + page_idx;\n}"
  },
  {
    "function_name": "pcpu_get_page_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "247-250",
    "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
  },
  {
    "function_name": "pcpu_set_page_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "241-244",
    "snippet": "static void pcpu_set_page_chunk(struct page *page, struct pcpu_chunk *pcpu)\n{\n\tpage->index = (unsigned long)pcpu;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_set_page_chunk(struct page *page, struct pcpu_chunk *pcpu)\n{\n\tpage->index = (unsigned long)pcpu;\n}"
  },
  {
    "function_name": "pcpu_chunk_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "232-238",
    "snippet": "static int pcpu_chunk_slot(const struct pcpu_chunk *chunk)\n{\n\tif (chunk->free_bytes < PCPU_MIN_ALLOC_SIZE || chunk->contig_bits == 0)\n\t\treturn 0;\n\n\treturn pcpu_size_to_slot(chunk->free_bytes);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_size_to_slot",
          "args": [
            "chunk->free_bytes"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_size_to_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "225-230",
          "snippet": "static int pcpu_size_to_slot(int size)\n{\n\tif (size == pcpu_unit_size)\n\t\treturn pcpu_nr_slots - 1;\n\treturn __pcpu_size_to_slot(size);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_size",
            "int pcpu_nr_slots"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\n\nstatic int pcpu_size_to_slot(int size)\n{\n\tif (size == pcpu_unit_size)\n\t\treturn pcpu_nr_slots - 1;\n\treturn __pcpu_size_to_slot(size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic int pcpu_chunk_slot(const struct pcpu_chunk *chunk)\n{\n\tif (chunk->free_bytes < PCPU_MIN_ALLOC_SIZE || chunk->contig_bits == 0)\n\t\treturn 0;\n\n\treturn pcpu_size_to_slot(chunk->free_bytes);\n}"
  },
  {
    "function_name": "pcpu_size_to_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "225-230",
    "snippet": "static int pcpu_size_to_slot(int size)\n{\n\tif (size == pcpu_unit_size)\n\t\treturn pcpu_nr_slots - 1;\n\treturn __pcpu_size_to_slot(size);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pcpu_unit_size",
      "int pcpu_nr_slots"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pcpu_size_to_slot",
          "args": [
            "size"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "__pcpu_size_to_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "219-223",
          "snippet": "static int __pcpu_size_to_slot(int size)\n{\n\tint highbit = fls(size);\t/* size is in bytes */\n\treturn max(highbit - PCPU_SLOT_BASE_SHIFT + 2, 1);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [
            "#define PCPU_SLOT_BASE_SHIFT\t\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\n#define PCPU_SLOT_BASE_SHIFT\t\t5\n\nstatic int __pcpu_size_to_slot(int size)\n{\n\tint highbit = fls(size);\t/* size is in bytes */\n\treturn max(highbit - PCPU_SLOT_BASE_SHIFT + 2, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\n\nstatic int pcpu_size_to_slot(int size)\n{\n\tif (size == pcpu_unit_size)\n\t\treturn pcpu_nr_slots - 1;\n\treturn __pcpu_size_to_slot(size);\n}"
  },
  {
    "function_name": "__pcpu_size_to_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "219-223",
    "snippet": "static int __pcpu_size_to_slot(int size)\n{\n\tint highbit = fls(size);\t/* size is in bytes */\n\treturn max(highbit - PCPU_SLOT_BASE_SHIFT + 2, 1);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [
      "#define PCPU_SLOT_BASE_SHIFT\t\t5"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "highbit - PCPU_SLOT_BASE_SHIFT + 2",
            "1"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "size"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\n#define PCPU_SLOT_BASE_SHIFT\t\t5\n\nstatic int __pcpu_size_to_slot(int size)\n{\n\tint highbit = fls(size);\t/* size is in bytes */\n\treturn max(highbit - PCPU_SLOT_BASE_SHIFT + 2, 1);\n}"
  },
  {
    "function_name": "pcpu_addr_in_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "205-217",
    "snippet": "static bool pcpu_addr_in_chunk(struct pcpu_chunk *chunk, void *addr)\n{\n\tvoid *start_addr, *end_addr;\n\n\tif (!chunk)\n\t\treturn false;\n\n\tstart_addr = chunk->base_addr + chunk->start_offset;\n\tend_addr = chunk->base_addr + chunk->nr_pages * PAGE_SIZE -\n\t\t   chunk->end_offset;\n\n\treturn addr >= start_addr && addr < end_addr;\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
      "static struct page *pcpu_addr_to_page(void *addr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nstatic bool pcpu_addr_in_chunk(struct pcpu_chunk *chunk, void *addr)\n{\n\tvoid *start_addr, *end_addr;\n\n\tif (!chunk)\n\t\treturn false;\n\n\tstart_addr = chunk->base_addr + chunk->start_offset;\n\tend_addr = chunk->base_addr + chunk->nr_pages * PAGE_SIZE -\n\t\t   chunk->end_offset;\n\n\treturn addr >= start_addr && addr < end_addr;\n}"
  },
  {
    "function_name": "pcpu_schedule_balance_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
    "lines": "191-195",
    "snippet": "static void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}",
    "includes": [
      "#include \"percpu-vm.c\"",
      "#include \"percpu-km.c\"",
      "#include \"percpu-internal.h\"",
      "#include <trace/events/percpu.h>",
      "#include <asm/io.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/sched.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pfn.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/log2.h>",
      "#include <linux/list.h>",
      "#include <linux/lcm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool pcpu_async_enabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&pcpu_balance_work"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic bool pcpu_async_enabled;\n\nstatic void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}"
  }
]