[
  {
    "function_name": "init_percpu_stats_debugfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-stats.c",
    "lines": "228-234",
    "snippet": "static int __init init_percpu_stats_debugfs(void)\n{\n\tdebugfs_create_file(\"percpu_stats\", 0444, NULL, NULL,\n\t\t\t&percpu_stats_fops);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"percpu-internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/percpu.h>",
      "#include <linux/list.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"percpu_stats\"",
            "0444",
            "NULL",
            "NULL",
            "&percpu_stats_fops"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/percpu.h>\n#include <linux/list.h>\n#include <linux/debugfs.h>\n\nstatic int __init init_percpu_stats_debugfs(void)\n{\n\tdebugfs_create_file(\"percpu_stats\", 0444, NULL, NULL,\n\t\t\t&percpu_stats_fops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "percpu_stats_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-stats.c",
    "lines": "135-225",
    "snippet": "static int percpu_stats_show(struct seq_file *m, void *v)\n{\n\tstruct pcpu_chunk *chunk;\n\tint slot, max_nr_alloc;\n\tint *buffer;\n\nalloc_buffer:\n\tspin_lock_irq(&pcpu_lock);\n\tmax_nr_alloc = find_max_nr_alloc();\n\tspin_unlock_irq(&pcpu_lock);\n\n\t/* there can be at most this many free and allocated fragments */\n\tbuffer = vmalloc(array_size(sizeof(int), (2 * max_nr_alloc + 1)));\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&pcpu_lock);\n\n\t/* if the buffer allocated earlier is too small */\n\tif (max_nr_alloc < find_max_nr_alloc()) {\n\t\tspin_unlock_irq(&pcpu_lock);\n\t\tvfree(buffer);\n\t\tgoto alloc_buffer;\n\t}\n\n#define PL(X) \\\n\tseq_printf(m, \"  %-20s: %12lld\\n\", #X, (long long int)pcpu_stats_ai.X)\n\n\tseq_printf(m,\n\t\t\t\"Percpu Memory Statistics\\n\"\n\t\t\t\"Allocation Info:\\n\"\n\t\t\t\"----------------------------------------\\n\");\n\tPL(unit_size);\n\tPL(static_size);\n\tPL(reserved_size);\n\tPL(dyn_size);\n\tPL(atom_size);\n\tPL(alloc_size);\n\tseq_putc(m, '\\n');\n\n#undef PL\n\n#define PU(X) \\\n\tseq_printf(m, \"  %-20s: %12llu\\n\", #X, (unsigned long long)pcpu_stats.X)\n\n\tseq_printf(m,\n\t\t\t\"Global Stats:\\n\"\n\t\t\t\"----------------------------------------\\n\");\n\tPU(nr_alloc);\n\tPU(nr_dealloc);\n\tPU(nr_cur_alloc);\n\tPU(nr_max_alloc);\n\tPU(nr_chunks);\n\tPU(nr_max_chunks);\n\tPU(min_alloc_size);\n\tPU(max_alloc_size);\n\tP(\"empty_pop_pages\", pcpu_nr_empty_pop_pages);\n\tseq_putc(m, '\\n');\n\n#undef PU\n\n\tseq_printf(m,\n\t\t\t\"Per Chunk Stats:\\n\"\n\t\t\t\"----------------------------------------\\n\");\n\n\tif (pcpu_reserved_chunk) {\n\t\tseq_puts(m, \"Chunk: <- Reserved Chunk\\n\");\n\t\tchunk_map_stats(m, pcpu_reserved_chunk, buffer);\n\t}\n\n\tfor (slot = 0; slot < pcpu_nr_slots; slot++) {\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\tif (chunk == pcpu_first_chunk) {\n\t\t\t\tseq_puts(m, \"Chunk: <- First Chunk\\n\");\n\t\t\t\tchunk_map_stats(m, chunk, buffer);\n\n\n\t\t\t} else {\n\t\t\t\tseq_puts(m, \"Chunk:\\n\");\n\t\t\t\tchunk_map_stats(m, chunk, buffer);\n\t\t\t}\n\n\t\t}\n\t}\n\n\tspin_unlock_irq(&pcpu_lock);\n\n\tvfree(buffer);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"percpu-internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/percpu.h>",
      "#include <linux/list.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct percpu_stats pcpu_stats;",
      "struct pcpu_alloc_info pcpu_stats_ai;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "buffer"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "vfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "224-227",
          "snippet": "void vfree(const void *addr)\n{\n\tkfree(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid vfree(const void *addr)\n{\n\tkfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chunk_map_stats",
          "args": [
            "m",
            "chunk",
            "buffer"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_map_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-stats.c",
          "lines": "53-133",
          "snippet": "static void chunk_map_stats(struct seq_file *m, struct pcpu_chunk *chunk,\n\t\t\t    int *buffer)\n{\n\tint i, last_alloc, as_len, start, end;\n\tint *alloc_sizes, *p;\n\t/* statistics */\n\tint sum_frag = 0, max_frag = 0;\n\tint cur_min_alloc = 0, cur_med_alloc = 0, cur_max_alloc = 0;\n\n\talloc_sizes = buffer;\n\n\t/*\n\t * find_last_bit returns the start value if nothing found.\n\t * Therefore, we must determine if it is a failure of find_last_bit\n\t * and set the appropriate value.\n\t */\n\tlast_alloc = find_last_bit(chunk->alloc_map,\n\t\t\t\t   pcpu_chunk_map_bits(chunk) -\n\t\t\t\t   chunk->end_offset / PCPU_MIN_ALLOC_SIZE - 1);\n\tlast_alloc = test_bit(last_alloc, chunk->alloc_map) ?\n\t\t     last_alloc + 1 : 0;\n\n\tas_len = 0;\n\tstart = chunk->start_offset / PCPU_MIN_ALLOC_SIZE;\n\n\t/*\n\t * If a bit is set in the allocation map, the bound_map identifies\n\t * where the allocation ends.  If the allocation is not set, the\n\t * bound_map does not identify free areas as it is only kept accurate\n\t * on allocation, not free.\n\t *\n\t * Positive values are allocations and negative values are free\n\t * fragments.\n\t */\n\twhile (start < last_alloc) {\n\t\tif (test_bit(start, chunk->alloc_map)) {\n\t\t\tend = find_next_bit(chunk->bound_map, last_alloc,\n\t\t\t\t\t    start + 1);\n\t\t\talloc_sizes[as_len] = 1;\n\t\t} else {\n\t\t\tend = find_next_bit(chunk->alloc_map, last_alloc,\n\t\t\t\t\t    start + 1);\n\t\t\talloc_sizes[as_len] = -1;\n\t\t}\n\n\t\talloc_sizes[as_len++] *= (end - start) * PCPU_MIN_ALLOC_SIZE;\n\n\t\tstart = end;\n\t}\n\n\t/*\n\t * The negative values are free fragments and thus sorting gives the\n\t * free fragments at the beginning in largest first order.\n\t */\n\tif (as_len > 0) {\n\t\tsort(alloc_sizes, as_len, sizeof(int), cmpint, NULL);\n\n\t\t/* iterate through the unallocated fragments */\n\t\tfor (i = 0, p = alloc_sizes; *p < 0 && i < as_len; i++, p++) {\n\t\t\tsum_frag -= *p;\n\t\t\tmax_frag = max(max_frag, -1 * (*p));\n\t\t}\n\n\t\tcur_min_alloc = alloc_sizes[i];\n\t\tcur_med_alloc = alloc_sizes[(i + as_len - 1) / 2];\n\t\tcur_max_alloc = alloc_sizes[as_len - 1];\n\t}\n\n\tP(\"nr_alloc\", chunk->nr_alloc);\n\tP(\"max_alloc_size\", chunk->max_alloc_size);\n\tP(\"empty_pop_pages\", chunk->nr_empty_pop_pages);\n\tP(\"first_bit\", chunk->first_bit);\n\tP(\"free_bytes\", chunk->free_bytes);\n\tP(\"contig_bytes\", chunk->contig_bits * PCPU_MIN_ALLOC_SIZE);\n\tP(\"sum_frag\", sum_frag);\n\tP(\"max_frag\", max_frag);\n\tP(\"cur_min_alloc\", cur_min_alloc);\n\tP(\"cur_med_alloc\", cur_med_alloc);\n\tP(\"cur_max_alloc\", cur_max_alloc);\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include \"percpu-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/percpu.h>",
            "#include <linux/list.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/percpu.h>\n#include <linux/list.h>\n#include <linux/debugfs.h>\n\nstatic void chunk_map_stats(struct seq_file *m, struct pcpu_chunk *chunk,\n\t\t\t    int *buffer)\n{\n\tint i, last_alloc, as_len, start, end;\n\tint *alloc_sizes, *p;\n\t/* statistics */\n\tint sum_frag = 0, max_frag = 0;\n\tint cur_min_alloc = 0, cur_med_alloc = 0, cur_max_alloc = 0;\n\n\talloc_sizes = buffer;\n\n\t/*\n\t * find_last_bit returns the start value if nothing found.\n\t * Therefore, we must determine if it is a failure of find_last_bit\n\t * and set the appropriate value.\n\t */\n\tlast_alloc = find_last_bit(chunk->alloc_map,\n\t\t\t\t   pcpu_chunk_map_bits(chunk) -\n\t\t\t\t   chunk->end_offset / PCPU_MIN_ALLOC_SIZE - 1);\n\tlast_alloc = test_bit(last_alloc, chunk->alloc_map) ?\n\t\t     last_alloc + 1 : 0;\n\n\tas_len = 0;\n\tstart = chunk->start_offset / PCPU_MIN_ALLOC_SIZE;\n\n\t/*\n\t * If a bit is set in the allocation map, the bound_map identifies\n\t * where the allocation ends.  If the allocation is not set, the\n\t * bound_map does not identify free areas as it is only kept accurate\n\t * on allocation, not free.\n\t *\n\t * Positive values are allocations and negative values are free\n\t * fragments.\n\t */\n\twhile (start < last_alloc) {\n\t\tif (test_bit(start, chunk->alloc_map)) {\n\t\t\tend = find_next_bit(chunk->bound_map, last_alloc,\n\t\t\t\t\t    start + 1);\n\t\t\talloc_sizes[as_len] = 1;\n\t\t} else {\n\t\t\tend = find_next_bit(chunk->alloc_map, last_alloc,\n\t\t\t\t\t    start + 1);\n\t\t\talloc_sizes[as_len] = -1;\n\t\t}\n\n\t\talloc_sizes[as_len++] *= (end - start) * PCPU_MIN_ALLOC_SIZE;\n\n\t\tstart = end;\n\t}\n\n\t/*\n\t * The negative values are free fragments and thus sorting gives the\n\t * free fragments at the beginning in largest first order.\n\t */\n\tif (as_len > 0) {\n\t\tsort(alloc_sizes, as_len, sizeof(int), cmpint, NULL);\n\n\t\t/* iterate through the unallocated fragments */\n\t\tfor (i = 0, p = alloc_sizes; *p < 0 && i < as_len; i++, p++) {\n\t\t\tsum_frag -= *p;\n\t\t\tmax_frag = max(max_frag, -1 * (*p));\n\t\t}\n\n\t\tcur_min_alloc = alloc_sizes[i];\n\t\tcur_med_alloc = alloc_sizes[(i + as_len - 1) / 2];\n\t\tcur_max_alloc = alloc_sizes[as_len - 1];\n\t}\n\n\tP(\"nr_alloc\", chunk->nr_alloc);\n\tP(\"max_alloc_size\", chunk->max_alloc_size);\n\tP(\"empty_pop_pages\", chunk->nr_empty_pop_pages);\n\tP(\"first_bit\", chunk->first_bit);\n\tP(\"free_bytes\", chunk->free_bytes);\n\tP(\"contig_bytes\", chunk->contig_bits * PCPU_MIN_ALLOC_SIZE);\n\tP(\"sum_frag\", sum_frag);\n\tP(\"max_frag\", max_frag);\n\tP(\"cur_min_alloc\", cur_min_alloc);\n\tP(\"cur_med_alloc\", cur_med_alloc);\n\tP(\"cur_max_alloc\", cur_max_alloc);\n\tseq_putc(m, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"Chunk:\\n\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"Chunk: <- First Chunk\\n\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "chunk",
            "&pcpu_slot[slot]",
            "list"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"Chunk: <- Reserved Chunk\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Per Chunk Stats:\\n\"\n\t\t\t\"----------------------------------------\\n\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "\"empty_pop_pages\"",
            "pcpu_nr_empty_pop_pages"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "__SetPageMovable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "112-117",
          "snippet": "void __SetPageMovable(struct page *page, struct address_space *mapping)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE((unsigned long)mapping & PAGE_MAPPING_MOVABLE, page);\n\tpage->mapping = (void *)((unsigned long)mapping | PAGE_MAPPING_MOVABLE);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid __SetPageMovable(struct page *page, struct address_space *mapping)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE((unsigned long)mapping & PAGE_MAPPING_MOVABLE, page);\n\tpage->mapping = (void *)((unsigned long)mapping | PAGE_MAPPING_MOVABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "max_alloc_size"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "min_alloc_size"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "nr_max_chunks"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "nr_chunks"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "nr_max_alloc"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "nr_cur_alloc"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "nr_dealloc"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "nr_alloc"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Global Stats:\\n\"\n\t\t\t\"----------------------------------------\\n\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PL",
          "args": [
            "alloc_size"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PL",
          "args": [
            "atom_size"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PL",
          "args": [
            "dyn_size"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PL",
          "args": [
            "reserved_size"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PL",
          "args": [
            "static_size"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PL",
          "args": [
            "unit_size"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Percpu Memory Statistics\\n\"\n\t\t\t\"Allocation Info:\\n\"\n\t\t\t\"----------------------------------------\\n\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_max_nr_alloc",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "find_max_nr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-stats.c",
          "lines": "34-45",
          "snippet": "static int find_max_nr_alloc(void)\n{\n\tstruct pcpu_chunk *chunk;\n\tint slot, max_nr_alloc;\n\n\tmax_nr_alloc = 0;\n\tfor (slot = 0; slot < pcpu_nr_slots; slot++)\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list)\n\t\t\tmax_nr_alloc = max(max_nr_alloc, chunk->nr_alloc);\n\n\treturn max_nr_alloc;\n}",
          "includes": [
            "#include \"percpu-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/percpu.h>",
            "#include <linux/list.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/percpu.h>\n#include <linux/list.h>\n#include <linux/debugfs.h>\n\nstatic int find_max_nr_alloc(void)\n{\n\tstruct pcpu_chunk *chunk;\n\tint slot, max_nr_alloc;\n\n\tmax_nr_alloc = 0;\n\tfor (slot = 0; slot < pcpu_nr_slots; slot++)\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list)\n\t\t\tmax_nr_alloc = max(max_nr_alloc, chunk->nr_alloc);\n\n\treturn max_nr_alloc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "array_size(sizeof(int), (2 * max_nr_alloc + 1))"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_32_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "407-414",
          "snippet": "void *vmalloc_32_user(unsigned long size)\n{\n\t/*\n\t * We'll have to sort out the ZONE_DMA bits for 64-bit,\n\t * but for now this can simply use vmalloc_user() directly.\n\t */\n\treturn vmalloc_user(size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid *vmalloc_32_user(unsigned long size)\n{\n\t/*\n\t * We'll have to sort out the ZONE_DMA bits for 64-bit,\n\t * but for now this can simply use vmalloc_user() directly.\n\t */\n\treturn vmalloc_user(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "sizeof(int)",
            "(2 * max_nr_alloc + 1)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pcpu_lock"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/percpu.h>\n#include <linux/list.h>\n#include <linux/debugfs.h>\n\nstruct percpu_stats pcpu_stats;\nstruct pcpu_alloc_info pcpu_stats_ai;\n\nstatic int percpu_stats_show(struct seq_file *m, void *v)\n{\n\tstruct pcpu_chunk *chunk;\n\tint slot, max_nr_alloc;\n\tint *buffer;\n\nalloc_buffer:\n\tspin_lock_irq(&pcpu_lock);\n\tmax_nr_alloc = find_max_nr_alloc();\n\tspin_unlock_irq(&pcpu_lock);\n\n\t/* there can be at most this many free and allocated fragments */\n\tbuffer = vmalloc(array_size(sizeof(int), (2 * max_nr_alloc + 1)));\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&pcpu_lock);\n\n\t/* if the buffer allocated earlier is too small */\n\tif (max_nr_alloc < find_max_nr_alloc()) {\n\t\tspin_unlock_irq(&pcpu_lock);\n\t\tvfree(buffer);\n\t\tgoto alloc_buffer;\n\t}\n\n#define PL(X) \\\n\tseq_printf(m, \"  %-20s: %12lld\\n\", #X, (long long int)pcpu_stats_ai.X)\n\n\tseq_printf(m,\n\t\t\t\"Percpu Memory Statistics\\n\"\n\t\t\t\"Allocation Info:\\n\"\n\t\t\t\"----------------------------------------\\n\");\n\tPL(unit_size);\n\tPL(static_size);\n\tPL(reserved_size);\n\tPL(dyn_size);\n\tPL(atom_size);\n\tPL(alloc_size);\n\tseq_putc(m, '\\n');\n\n#undef PL\n\n#define PU(X) \\\n\tseq_printf(m, \"  %-20s: %12llu\\n\", #X, (unsigned long long)pcpu_stats.X)\n\n\tseq_printf(m,\n\t\t\t\"Global Stats:\\n\"\n\t\t\t\"----------------------------------------\\n\");\n\tPU(nr_alloc);\n\tPU(nr_dealloc);\n\tPU(nr_cur_alloc);\n\tPU(nr_max_alloc);\n\tPU(nr_chunks);\n\tPU(nr_max_chunks);\n\tPU(min_alloc_size);\n\tPU(max_alloc_size);\n\tP(\"empty_pop_pages\", pcpu_nr_empty_pop_pages);\n\tseq_putc(m, '\\n');\n\n#undef PU\n\n\tseq_printf(m,\n\t\t\t\"Per Chunk Stats:\\n\"\n\t\t\t\"----------------------------------------\\n\");\n\n\tif (pcpu_reserved_chunk) {\n\t\tseq_puts(m, \"Chunk: <- Reserved Chunk\\n\");\n\t\tchunk_map_stats(m, pcpu_reserved_chunk, buffer);\n\t}\n\n\tfor (slot = 0; slot < pcpu_nr_slots; slot++) {\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list) {\n\t\t\tif (chunk == pcpu_first_chunk) {\n\t\t\t\tseq_puts(m, \"Chunk: <- First Chunk\\n\");\n\t\t\t\tchunk_map_stats(m, chunk, buffer);\n\n\n\t\t\t} else {\n\t\t\t\tseq_puts(m, \"Chunk:\\n\");\n\t\t\t\tchunk_map_stats(m, chunk, buffer);\n\t\t\t}\n\n\t\t}\n\t}\n\n\tspin_unlock_irq(&pcpu_lock);\n\n\tvfree(buffer);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "chunk_map_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-stats.c",
    "lines": "53-133",
    "snippet": "static void chunk_map_stats(struct seq_file *m, struct pcpu_chunk *chunk,\n\t\t\t    int *buffer)\n{\n\tint i, last_alloc, as_len, start, end;\n\tint *alloc_sizes, *p;\n\t/* statistics */\n\tint sum_frag = 0, max_frag = 0;\n\tint cur_min_alloc = 0, cur_med_alloc = 0, cur_max_alloc = 0;\n\n\talloc_sizes = buffer;\n\n\t/*\n\t * find_last_bit returns the start value if nothing found.\n\t * Therefore, we must determine if it is a failure of find_last_bit\n\t * and set the appropriate value.\n\t */\n\tlast_alloc = find_last_bit(chunk->alloc_map,\n\t\t\t\t   pcpu_chunk_map_bits(chunk) -\n\t\t\t\t   chunk->end_offset / PCPU_MIN_ALLOC_SIZE - 1);\n\tlast_alloc = test_bit(last_alloc, chunk->alloc_map) ?\n\t\t     last_alloc + 1 : 0;\n\n\tas_len = 0;\n\tstart = chunk->start_offset / PCPU_MIN_ALLOC_SIZE;\n\n\t/*\n\t * If a bit is set in the allocation map, the bound_map identifies\n\t * where the allocation ends.  If the allocation is not set, the\n\t * bound_map does not identify free areas as it is only kept accurate\n\t * on allocation, not free.\n\t *\n\t * Positive values are allocations and negative values are free\n\t * fragments.\n\t */\n\twhile (start < last_alloc) {\n\t\tif (test_bit(start, chunk->alloc_map)) {\n\t\t\tend = find_next_bit(chunk->bound_map, last_alloc,\n\t\t\t\t\t    start + 1);\n\t\t\talloc_sizes[as_len] = 1;\n\t\t} else {\n\t\t\tend = find_next_bit(chunk->alloc_map, last_alloc,\n\t\t\t\t\t    start + 1);\n\t\t\talloc_sizes[as_len] = -1;\n\t\t}\n\n\t\talloc_sizes[as_len++] *= (end - start) * PCPU_MIN_ALLOC_SIZE;\n\n\t\tstart = end;\n\t}\n\n\t/*\n\t * The negative values are free fragments and thus sorting gives the\n\t * free fragments at the beginning in largest first order.\n\t */\n\tif (as_len > 0) {\n\t\tsort(alloc_sizes, as_len, sizeof(int), cmpint, NULL);\n\n\t\t/* iterate through the unallocated fragments */\n\t\tfor (i = 0, p = alloc_sizes; *p < 0 && i < as_len; i++, p++) {\n\t\t\tsum_frag -= *p;\n\t\t\tmax_frag = max(max_frag, -1 * (*p));\n\t\t}\n\n\t\tcur_min_alloc = alloc_sizes[i];\n\t\tcur_med_alloc = alloc_sizes[(i + as_len - 1) / 2];\n\t\tcur_max_alloc = alloc_sizes[as_len - 1];\n\t}\n\n\tP(\"nr_alloc\", chunk->nr_alloc);\n\tP(\"max_alloc_size\", chunk->max_alloc_size);\n\tP(\"empty_pop_pages\", chunk->nr_empty_pop_pages);\n\tP(\"first_bit\", chunk->first_bit);\n\tP(\"free_bytes\", chunk->free_bytes);\n\tP(\"contig_bytes\", chunk->contig_bits * PCPU_MIN_ALLOC_SIZE);\n\tP(\"sum_frag\", sum_frag);\n\tP(\"max_frag\", max_frag);\n\tP(\"cur_min_alloc\", cur_min_alloc);\n\tP(\"cur_med_alloc\", cur_med_alloc);\n\tP(\"cur_max_alloc\", cur_max_alloc);\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"percpu-internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/percpu.h>",
      "#include <linux/list.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "\"cur_max_alloc\"",
            "cur_max_alloc"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "__SetPageMovable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "112-117",
          "snippet": "void __SetPageMovable(struct page *page, struct address_space *mapping)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE((unsigned long)mapping & PAGE_MAPPING_MOVABLE, page);\n\tpage->mapping = (void *)((unsigned long)mapping | PAGE_MAPPING_MOVABLE);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid __SetPageMovable(struct page *page, struct address_space *mapping)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE((unsigned long)mapping & PAGE_MAPPING_MOVABLE, page);\n\tpage->mapping = (void *)((unsigned long)mapping | PAGE_MAPPING_MOVABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "max_frag",
            "-1 * (*p)"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "alloc_sizes",
            "as_len",
            "sizeof(int)",
            "cmpint",
            "NULL"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "chunk->alloc_map",
            "last_alloc",
            "start + 1"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "chunk->bound_map",
            "last_alloc",
            "start + 1"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "start",
            "chunk->alloc_map"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "last_alloc",
            "chunk->alloc_map"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_last_bit",
          "args": [
            "chunk->alloc_map",
            "pcpu_chunk_map_bits(chunk) -\n\t\t\t\t   chunk->end_offset / PCPU_MIN_ALLOC_SIZE - 1"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_map_bits",
          "args": [
            "chunk"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_map_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "97-100",
          "snippet": "static inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline int pcpu_chunk_map_bits(struct pcpu_chunk *chunk)\n{\n\treturn pcpu_nr_pages_to_map_bits(chunk->nr_pages);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/percpu.h>\n#include <linux/list.h>\n#include <linux/debugfs.h>\n\nstatic void chunk_map_stats(struct seq_file *m, struct pcpu_chunk *chunk,\n\t\t\t    int *buffer)\n{\n\tint i, last_alloc, as_len, start, end;\n\tint *alloc_sizes, *p;\n\t/* statistics */\n\tint sum_frag = 0, max_frag = 0;\n\tint cur_min_alloc = 0, cur_med_alloc = 0, cur_max_alloc = 0;\n\n\talloc_sizes = buffer;\n\n\t/*\n\t * find_last_bit returns the start value if nothing found.\n\t * Therefore, we must determine if it is a failure of find_last_bit\n\t * and set the appropriate value.\n\t */\n\tlast_alloc = find_last_bit(chunk->alloc_map,\n\t\t\t\t   pcpu_chunk_map_bits(chunk) -\n\t\t\t\t   chunk->end_offset / PCPU_MIN_ALLOC_SIZE - 1);\n\tlast_alloc = test_bit(last_alloc, chunk->alloc_map) ?\n\t\t     last_alloc + 1 : 0;\n\n\tas_len = 0;\n\tstart = chunk->start_offset / PCPU_MIN_ALLOC_SIZE;\n\n\t/*\n\t * If a bit is set in the allocation map, the bound_map identifies\n\t * where the allocation ends.  If the allocation is not set, the\n\t * bound_map does not identify free areas as it is only kept accurate\n\t * on allocation, not free.\n\t *\n\t * Positive values are allocations and negative values are free\n\t * fragments.\n\t */\n\twhile (start < last_alloc) {\n\t\tif (test_bit(start, chunk->alloc_map)) {\n\t\t\tend = find_next_bit(chunk->bound_map, last_alloc,\n\t\t\t\t\t    start + 1);\n\t\t\talloc_sizes[as_len] = 1;\n\t\t} else {\n\t\t\tend = find_next_bit(chunk->alloc_map, last_alloc,\n\t\t\t\t\t    start + 1);\n\t\t\talloc_sizes[as_len] = -1;\n\t\t}\n\n\t\talloc_sizes[as_len++] *= (end - start) * PCPU_MIN_ALLOC_SIZE;\n\n\t\tstart = end;\n\t}\n\n\t/*\n\t * The negative values are free fragments and thus sorting gives the\n\t * free fragments at the beginning in largest first order.\n\t */\n\tif (as_len > 0) {\n\t\tsort(alloc_sizes, as_len, sizeof(int), cmpint, NULL);\n\n\t\t/* iterate through the unallocated fragments */\n\t\tfor (i = 0, p = alloc_sizes; *p < 0 && i < as_len; i++, p++) {\n\t\t\tsum_frag -= *p;\n\t\t\tmax_frag = max(max_frag, -1 * (*p));\n\t\t}\n\n\t\tcur_min_alloc = alloc_sizes[i];\n\t\tcur_med_alloc = alloc_sizes[(i + as_len - 1) / 2];\n\t\tcur_max_alloc = alloc_sizes[as_len - 1];\n\t}\n\n\tP(\"nr_alloc\", chunk->nr_alloc);\n\tP(\"max_alloc_size\", chunk->max_alloc_size);\n\tP(\"empty_pop_pages\", chunk->nr_empty_pop_pages);\n\tP(\"first_bit\", chunk->first_bit);\n\tP(\"free_bytes\", chunk->free_bytes);\n\tP(\"contig_bytes\", chunk->contig_bits * PCPU_MIN_ALLOC_SIZE);\n\tP(\"sum_frag\", sum_frag);\n\tP(\"max_frag\", max_frag);\n\tP(\"cur_min_alloc\", cur_min_alloc);\n\tP(\"cur_med_alloc\", cur_med_alloc);\n\tP(\"cur_max_alloc\", cur_max_alloc);\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "find_max_nr_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-stats.c",
    "lines": "34-45",
    "snippet": "static int find_max_nr_alloc(void)\n{\n\tstruct pcpu_chunk *chunk;\n\tint slot, max_nr_alloc;\n\n\tmax_nr_alloc = 0;\n\tfor (slot = 0; slot < pcpu_nr_slots; slot++)\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list)\n\t\t\tmax_nr_alloc = max(max_nr_alloc, chunk->nr_alloc);\n\n\treturn max_nr_alloc;\n}",
    "includes": [
      "#include \"percpu-internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/percpu.h>",
      "#include <linux/list.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "max_nr_alloc",
            "chunk->nr_alloc"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "chunk",
            "&pcpu_slot[slot]",
            "list"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/percpu.h>\n#include <linux/list.h>\n#include <linux/debugfs.h>\n\nstatic int find_max_nr_alloc(void)\n{\n\tstruct pcpu_chunk *chunk;\n\tint slot, max_nr_alloc;\n\n\tmax_nr_alloc = 0;\n\tfor (slot = 0; slot < pcpu_nr_slots; slot++)\n\t\tlist_for_each_entry(chunk, &pcpu_slot[slot], list)\n\t\t\tmax_nr_alloc = max(max_nr_alloc, chunk->nr_alloc);\n\n\treturn max_nr_alloc;\n}"
  },
  {
    "function_name": "cmpint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-stats.c",
    "lines": "26-29",
    "snippet": "static int cmpint(const void *a, const void *b)\n{\n\treturn *(int *)a - *(int *)b;\n}",
    "includes": [
      "#include \"percpu-internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/percpu.h>",
      "#include <linux/list.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/percpu.h>\n#include <linux/list.h>\n#include <linux/debugfs.h>\n\nstatic int cmpint(const void *a, const void *b)\n{\n\treturn *(int *)a - *(int *)b;\n}"
  }
]