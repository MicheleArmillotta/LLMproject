[
  {
    "function_name": "do_mincore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
    "lines": "177-198",
    "snippet": "static long do_mincore(unsigned long addr, unsigned long pages, unsigned char *vec)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long end;\n\tint err;\n\tstruct mm_walk mincore_walk = {\n\t\t.pmd_entry = mincore_pte_range,\n\t\t.pte_hole = mincore_unmapped_range,\n\t\t.hugetlb_entry = mincore_hugetlb,\n\t\t.private = vec,\n\t};\n\n\tvma = find_vma(current->mm, addr);\n\tif (!vma || addr < vma->vm_start)\n\t\treturn -ENOMEM;\n\tmincore_walk.mm = vma->vm_mm;\n\tend = min(vma->vm_end, addr + (pages << PAGE_SHIFT));\n\terr = walk_page_range(addr, end, &mincore_walk);\n\tif (err < 0)\n\t\treturn err;\n\treturn (end - addr) >> PAGE_SHIFT;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "addr",
            "end",
            "&mincore_walk"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "293-340",
          "snippet": "int walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "vma->vm_end",
            "addr + (pages << PAGE_SHIFT)"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "mincore_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
          "lines": "51-85",
          "snippet": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\n\t/*\n\t * When tmpfs swaps out a page from a file, any process mapping that\n\t * file will not get a swp_entry_t in its pte, but rather it is like\n\t * any other file mapping (ie. marked !present and faulted in with\n\t * tmpfs's .fault). So swapped out tmpfs mappings are tested here.\n\t */\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\t/*\n\t\t * shmem/tmpfs may return swap: account for swapcache\n\t\t * page too.\n\t\t */\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\n\treturn present;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nstatic unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\n\t/*\n\t * When tmpfs swaps out a page from a file, any process mapping that\n\t * file will not get a swp_entry_t in its pte, but rather it is like\n\t * any other file mapping (ie. marked !present and faulted in with\n\t * tmpfs's .fault). So swapped out tmpfs mappings are tested here.\n\t */\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\t/*\n\t\t * shmem/tmpfs may return swap: account for swapcache\n\t\t * page too.\n\t\t */\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\n\treturn present;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "current->mm",
            "addr"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nstatic long do_mincore(unsigned long addr, unsigned long pages, unsigned char *vec)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long end;\n\tint err;\n\tstruct mm_walk mincore_walk = {\n\t\t.pmd_entry = mincore_pte_range,\n\t\t.pte_hole = mincore_unmapped_range,\n\t\t.hugetlb_entry = mincore_hugetlb,\n\t\t.private = vec,\n\t};\n\n\tvma = find_vma(current->mm, addr);\n\tif (!vma || addr < vma->vm_start)\n\t\treturn -ENOMEM;\n\tmincore_walk.mm = vma->vm_mm;\n\tend = min(vma->vm_end, addr + (pages << PAGE_SHIFT));\n\terr = walk_page_range(addr, end, &mincore_walk);\n\tif (err < 0)\n\t\treturn err;\n\treturn (end - addr) >> PAGE_SHIFT;\n}"
  },
  {
    "function_name": "mincore_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
    "lines": "114-170",
    "snippet": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\n\tif (pmd_trans_unstable(pmd)) {\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n\t\tgoto out;\n\t}\n\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\n\t\tif (pte_none(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { /* pte is a swap entry */\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t/*\n\t\t\t\t * migration or hwpoison entries are always\n\t\t\t\t * uptodate\n\t\t\t\t */\n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep - 1",
            "ptl"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mincore_page",
          "args": [
            "swap_address_space(entry)",
            "swp_offset(entry)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "mincore_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
          "lines": "51-85",
          "snippet": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\n\t/*\n\t * When tmpfs swaps out a page from a file, any process mapping that\n\t * file will not get a swp_entry_t in its pte, but rather it is like\n\t * any other file mapping (ie. marked !present and faulted in with\n\t * tmpfs's .fault). So swapped out tmpfs mappings are tested here.\n\t */\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\t/*\n\t\t * shmem/tmpfs may return swap: account for swapcache\n\t\t * page too.\n\t\t */\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\n\treturn present;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nstatic unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\n\t/*\n\t * When tmpfs swaps out a page from a file, any process mapping that\n\t * file will not get a swp_entry_t in its pte, but rather it is like\n\t * any other file mapping (ie. marked !present and faulted in with\n\t * tmpfs's .fault). So swapped out tmpfs mappings are tested here.\n\t */\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\t/*\n\t\t * shmem/tmpfs may return swap: account for swapcache\n\t\t * page too.\n\t\t */\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\n\treturn present;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_address_space",
          "args": [
            "entry"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "exit_swap_address_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "602-611",
          "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pte"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mincore_unmapped_range",
          "args": [
            "addr",
            "addr + PAGE_SIZE",
            "vma",
            "vec"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__mincore_unmapped_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
          "lines": "87-104",
          "snippet": "static int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nstatic int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pte"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "walk->mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vec",
            "1",
            "nr"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge_lock",
          "args": [
            "pmd",
            "vma"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_trans_huge_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1957-1966",
          "snippet": "spinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nstatic int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\n\tif (pmd_trans_unstable(pmd)) {\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n\t\tgoto out;\n\t}\n\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\n\t\tif (pte_none(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { /* pte is a swap entry */\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t/*\n\t\t\t\t * migration or hwpoison entries are always\n\t\t\t\t * uptodate\n\t\t\t\t */\n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}"
  },
  {
    "function_name": "mincore_unmapped_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
    "lines": "106-112",
    "snippet": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mincore_unmapped_range",
          "args": [
            "addr",
            "end",
            "walk->vma",
            "walk->private"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__mincore_unmapped_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
          "lines": "87-104",
          "snippet": "static int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nstatic int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nstatic int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}"
  },
  {
    "function_name": "__mincore_unmapped_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
    "lines": "87-104",
    "snippet": "static int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mincore_page",
          "args": [
            "vma->vm_file->f_mapping",
            "pgoff"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "mincore_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
          "lines": "51-85",
          "snippet": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\n\t/*\n\t * When tmpfs swaps out a page from a file, any process mapping that\n\t * file will not get a swp_entry_t in its pte, but rather it is like\n\t * any other file mapping (ie. marked !present and faulted in with\n\t * tmpfs's .fault). So swapped out tmpfs mappings are tested here.\n\t */\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\t/*\n\t\t * shmem/tmpfs may return swap: account for swapcache\n\t\t * page too.\n\t\t */\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\n\treturn present;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nstatic unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\n\t/*\n\t * When tmpfs swaps out a page from a file, any process mapping that\n\t * file will not get a swp_entry_t in its pte, but rather it is like\n\t * any other file mapping (ie. marked !present and faulted in with\n\t * tmpfs's .fault). So swapped out tmpfs mappings are tested here.\n\t */\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\t/*\n\t\t * shmem/tmpfs may return swap: account for swapcache\n\t\t * page too.\n\t\t */\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\n\treturn present;\n}"
        }
      },
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "addr"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nstatic int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}"
  },
  {
    "function_name": "mincore_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
    "lines": "51-85",
    "snippet": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\n\t/*\n\t * When tmpfs swaps out a page from a file, any process mapping that\n\t * file will not get a swp_entry_t in its pte, but rather it is like\n\t * any other file mapping (ie. marked !present and faulted in with\n\t * tmpfs's .fault). So swapped out tmpfs mappings are tested here.\n\t */\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\t/*\n\t\t * shmem/tmpfs may return swap: account for swapcache\n\t\t * page too.\n\t\t */\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\n\treturn present;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "pgoff"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "pgoff"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "swap_address_space(swp)",
            "swp_offset(swp)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "swp"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_address_space",
          "args": [
            "swp"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "exit_swap_address_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "602-611",
          "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_to_swp_entry",
          "args": [
            "page"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_entry",
          "args": [
            "mapping",
            "pgoff"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1407-1448",
          "snippet": "struct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shmem_mapping",
          "args": [
            "mapping"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "2195-2198",
          "snippet": "bool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nbool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nstatic unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\n\t/*\n\t * When tmpfs swaps out a page from a file, any process mapping that\n\t * file will not get a swp_entry_t in its pte, but rather it is like\n\t * any other file mapping (ie. marked !present and faulted in with\n\t * tmpfs's .fault). So swapped out tmpfs mappings are tested here.\n\t */\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\t/*\n\t\t * shmem/tmpfs may return swap: account for swapcache\n\t\t * page too.\n\t\t */\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\n\treturn present;\n}"
  },
  {
    "function_name": "mincore_hugetlb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
    "lines": "24-43",
    "snippet": "static int mincore_hugetlb(pte_t *pte, unsigned long hmask, unsigned long addr,\n\t\t\tunsigned long end, struct mm_walk *walk)\n{\n#ifdef CONFIG_HUGETLB_PAGE\n\tunsigned char present;\n\tunsigned char *vec = walk->private;\n\n\t/*\n\t * Hugepages under user process are always in RAM and never\n\t * swapped out, but theoretically it needs to be checked.\n\t */\n\tpresent = pte && !huge_pte_none(huge_ptep_get(pte));\n\tfor (; addr != end; vec++, addr += PAGE_SIZE)\n\t\t*vec = present;\n\twalk->private = vec;\n#else\n\tBUG();\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "huge_ptep_get(pte)"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "pte"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nstatic int mincore_hugetlb(pte_t *pte, unsigned long hmask, unsigned long addr,\n\t\t\tunsigned long end, struct mm_walk *walk)\n{\n#ifdef CONFIG_HUGETLB_PAGE\n\tunsigned char present;\n\tunsigned char *vec = walk->private;\n\n\t/*\n\t * Hugepages under user process are always in RAM and never\n\t * swapped out, but theoretically it needs to be checked.\n\t */\n\tpresent = pte && !huge_pte_none(huge_ptep_get(pte));\n\tfor (; addr != end; vec++, addr += PAGE_SIZE)\n\t\t*vec = present;\n\twalk->private = vec;\n#else\n\tBUG();\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "mincore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mincore.c",
    "lines": "224-273",
    "snippet": "SYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len,\n\t\tunsigned char __user *, vec)\n{\n\tlong retval;\n\tunsigned long pages;\n\tunsigned char *tmp;\n\n\t/* Check the start address: needs to be page-aligned.. */\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\t/* ..and we need to be passed a valid user-space range */\n\tif (!access_ok(VERIFY_READ, (void __user *) start, len))\n\t\treturn -ENOMEM;\n\n\t/* This also avoids any overflows on PAGE_ALIGN */\n\tpages = len >> PAGE_SHIFT;\n\tpages += (offset_in_page(len)) != 0;\n\n\tif (!access_ok(VERIFY_WRITE, vec, pages))\n\t\treturn -EFAULT;\n\n\ttmp = (void *) __get_free_page(GFP_USER);\n\tif (!tmp)\n\t\treturn -EAGAIN;\n\n\tretval = 0;\n\twhile (pages) {\n\t\t/*\n\t\t * Do at most PAGE_SIZE entries per iteration, due to\n\t\t * the temporary buffer size.\n\t\t */\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tretval = do_mincore(start, min(pages, PAGE_SIZE), tmp);\n\t\tup_read(&current->mm->mmap_sem);\n\n\t\tif (retval <= 0)\n\t\t\tbreak;\n\t\tif (copy_to_user(vec, tmp, retval)) {\n\t\t\tretval = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tpages -= retval;\n\t\tvec += retval;\n\t\tstart += retval << PAGE_SHIFT;\n\t\tretval = 0;\n\t}\n\tfree_page((unsigned long) tmp);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n\nSYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len,\n\t\tunsigned char __user *, vec)\n{\n\tlong retval;\n\tunsigned long pages;\n\tunsigned char *tmp;\n\n\t/* Check the start address: needs to be page-aligned.. */\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\t/* ..and we need to be passed a valid user-space range */\n\tif (!access_ok(VERIFY_READ, (void __user *) start, len))\n\t\treturn -ENOMEM;\n\n\t/* This also avoids any overflows on PAGE_ALIGN */\n\tpages = len >> PAGE_SHIFT;\n\tpages += (offset_in_page(len)) != 0;\n\n\tif (!access_ok(VERIFY_WRITE, vec, pages))\n\t\treturn -EFAULT;\n\n\ttmp = (void *) __get_free_page(GFP_USER);\n\tif (!tmp)\n\t\treturn -EAGAIN;\n\n\tretval = 0;\n\twhile (pages) {\n\t\t/*\n\t\t * Do at most PAGE_SIZE entries per iteration, due to\n\t\t * the temporary buffer size.\n\t\t */\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tretval = do_mincore(start, min(pages, PAGE_SIZE), tmp);\n\t\tup_read(&current->mm->mmap_sem);\n\n\t\tif (retval <= 0)\n\t\t\tbreak;\n\t\tif (copy_to_user(vec, tmp, retval)) {\n\t\t\tretval = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tpages -= retval;\n\t\tvec += retval;\n\t\tstart += retval << PAGE_SHIFT;\n\t\tretval = 0;\n\t}\n\tfree_page((unsigned long) tmp);\n\treturn retval;\n}"
  }
]