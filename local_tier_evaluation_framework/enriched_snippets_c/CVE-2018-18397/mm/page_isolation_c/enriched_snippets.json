[
  {
    "function_name": "alloc_migrate_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
    "lines": "312-315",
    "snippet": "struct page *alloc_migrate_target(struct page *page, unsigned long private)\n{\n\treturn new_page_nodemask(page, numa_node_id(), &node_states[N_MEMORY]);\n}",
    "includes": [
      "#include <trace/events/page_isolation.h>",
      "#include \"internal.h\"",
      "#include <linux/migrate.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/memory.h>",
      "#include <linux/pageblock-flags.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_page_nodemask",
          "args": [
            "page",
            "numa_node_id()",
            "&node_states[N_MEMORY]"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstruct page *alloc_migrate_target(struct page *page, unsigned long private)\n{\n\treturn new_page_nodemask(page, numa_node_id(), &node_states[N_MEMORY]);\n}"
  },
  {
    "function_name": "test_pages_isolated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
    "lines": "280-310",
    "snippet": "int test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\tbool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn, flags;\n\tstruct page *page;\n\tstruct zone *zone;\n\n\t/*\n\t * Note: pageblock_nr_pages != MAX_ORDER. Then, chunks of free pages\n\t * are not aligned to pageblock_nr_pages.\n\t * Then we just check migratetype first.\n\t */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page && !is_migrate_isolate_page(page))\n\t\t\tbreak;\n\t}\n\tpage = __first_valid_page(start_pfn, end_pfn - start_pfn);\n\tif ((pfn < end_pfn) || !page)\n\t\treturn -EBUSY;\n\t/* Check all pages are free or marked as ISOLATED */\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tpfn = __test_page_isolated_in_pageblock(start_pfn, end_pfn,\n\t\t\t\t\t\tskip_hwpoisoned_pages);\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\n\ttrace_test_pages_isolated(start_pfn, end_pfn, pfn);\n\n\treturn pfn < end_pfn ? -EBUSY : 0;\n}",
    "includes": [
      "#include <trace/events/page_isolation.h>",
      "#include \"internal.h\"",
      "#include <linux/migrate.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/memory.h>",
      "#include <linux/pageblock-flags.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_test_pages_isolated",
          "args": [
            "start_pfn",
            "end_pfn",
            "pfn"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__test_page_isolated_in_pageblock",
          "args": [
            "start_pfn",
            "end_pfn",
            "skip_hwpoisoned_pages"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__test_page_isolated_in_pageblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "250-277",
          "snippet": "static unsigned long\n__test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn,\n\t\t\t\t  bool skip_hwpoisoned_pages)\n{\n\tstruct page *page;\n\n\twhile (pfn < end_pfn) {\n\t\tif (!pfn_valid_within(pfn)) {\n\t\t\tpfn++;\n\t\t\tcontinue;\n\t\t}\n\t\tpage = pfn_to_page(pfn);\n\t\tif (PageBuddy(page))\n\t\t\t/*\n\t\t\t * If the page is on a free list, it has to be on\n\t\t\t * the correct MIGRATE_ISOLATE freelist. There is no\n\t\t\t * simple way to verify that as VM_BUG_ON(), though.\n\t\t\t */\n\t\t\tpfn += 1 << page_order(page);\n\t\telse if (skip_hwpoisoned_pages && PageHWPoison(page))\n\t\t\t/* A HWPoisoned page cannot be also PageBuddy */\n\t\t\tpfn++;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn pfn;\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstatic unsigned long\n__test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn,\n\t\t\t\t  bool skip_hwpoisoned_pages)\n{\n\tstruct page *page;\n\n\twhile (pfn < end_pfn) {\n\t\tif (!pfn_valid_within(pfn)) {\n\t\t\tpfn++;\n\t\t\tcontinue;\n\t\t}\n\t\tpage = pfn_to_page(pfn);\n\t\tif (PageBuddy(page))\n\t\t\t/*\n\t\t\t * If the page is on a free list, it has to be on\n\t\t\t * the correct MIGRATE_ISOLATE freelist. There is no\n\t\t\t * simple way to verify that as VM_BUG_ON(), though.\n\t\t\t */\n\t\t\tpfn += 1 << page_order(page);\n\t\telse if (skip_hwpoisoned_pages && PageHWPoison(page))\n\t\t\t/* A HWPoisoned page cannot be also PageBuddy */\n\t\t\tpfn++;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__first_valid_page",
          "args": [
            "start_pfn",
            "end_pfn - start_pfn"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "__first_valid_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "147-163",
          "snippet": "static inline struct page *\n__first_valid_page(unsigned long pfn, unsigned long nr_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (!pfn_valid_within(pfn + i))\n\t\t\tcontinue;\n\t\tpage = pfn_to_online_page(pfn + i);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\treturn page;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstatic inline struct page *\n__first_valid_page(unsigned long pfn, unsigned long nr_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (!pfn_valid_within(pfn + i))\n\t\t\tcontinue;\n\t\tpage = pfn_to_online_page(pfn + i);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\treturn page;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate_page",
          "args": [
            "page"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nint test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\tbool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn, flags;\n\tstruct page *page;\n\tstruct zone *zone;\n\n\t/*\n\t * Note: pageblock_nr_pages != MAX_ORDER. Then, chunks of free pages\n\t * are not aligned to pageblock_nr_pages.\n\t * Then we just check migratetype first.\n\t */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page && !is_migrate_isolate_page(page))\n\t\t\tbreak;\n\t}\n\tpage = __first_valid_page(start_pfn, end_pfn - start_pfn);\n\tif ((pfn < end_pfn) || !page)\n\t\treturn -EBUSY;\n\t/* Check all pages are free or marked as ISOLATED */\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tpfn = __test_page_isolated_in_pageblock(start_pfn, end_pfn,\n\t\t\t\t\t\tskip_hwpoisoned_pages);\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\n\ttrace_test_pages_isolated(start_pfn, end_pfn, pfn);\n\n\treturn pfn < end_pfn ? -EBUSY : 0;\n}"
  },
  {
    "function_name": "__test_page_isolated_in_pageblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
    "lines": "250-277",
    "snippet": "static unsigned long\n__test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn,\n\t\t\t\t  bool skip_hwpoisoned_pages)\n{\n\tstruct page *page;\n\n\twhile (pfn < end_pfn) {\n\t\tif (!pfn_valid_within(pfn)) {\n\t\t\tpfn++;\n\t\t\tcontinue;\n\t\t}\n\t\tpage = pfn_to_page(pfn);\n\t\tif (PageBuddy(page))\n\t\t\t/*\n\t\t\t * If the page is on a free list, it has to be on\n\t\t\t * the correct MIGRATE_ISOLATE freelist. There is no\n\t\t\t * simple way to verify that as VM_BUG_ON(), though.\n\t\t\t */\n\t\t\tpfn += 1 << page_order(page);\n\t\telse if (skip_hwpoisoned_pages && PageHWPoison(page))\n\t\t\t/* A HWPoisoned page cannot be also PageBuddy */\n\t\t\tpfn++;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn pfn;\n}",
    "includes": [
      "#include <trace/events/page_isolation.h>",
      "#include \"internal.h\"",
      "#include <linux/migrate.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/memory.h>",
      "#include <linux/pageblock-flags.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "page"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "pfn"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstatic unsigned long\n__test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn,\n\t\t\t\t  bool skip_hwpoisoned_pages)\n{\n\tstruct page *page;\n\n\twhile (pfn < end_pfn) {\n\t\tif (!pfn_valid_within(pfn)) {\n\t\t\tpfn++;\n\t\t\tcontinue;\n\t\t}\n\t\tpage = pfn_to_page(pfn);\n\t\tif (PageBuddy(page))\n\t\t\t/*\n\t\t\t * If the page is on a free list, it has to be on\n\t\t\t * the correct MIGRATE_ISOLATE freelist. There is no\n\t\t\t * simple way to verify that as VM_BUG_ON(), though.\n\t\t\t */\n\t\t\tpfn += 1 << page_order(page);\n\t\telse if (skip_hwpoisoned_pages && PageHWPoison(page))\n\t\t\t/* A HWPoisoned page cannot be also PageBuddy */\n\t\t\tpfn++;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn pfn;\n}"
  },
  {
    "function_name": "undo_isolate_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
    "lines": "224-242",
    "snippet": "int undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t    unsigned migratetype)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (!page || !is_migrate_isolate_page(page))\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/page_isolation.h>",
      "#include \"internal.h\"",
      "#include <linux/migrate.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/memory.h>",
      "#include <linux/pageblock-flags.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unset_migratetype_isolate",
          "args": [
            "page",
            "migratetype"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "unset_migratetype_isolate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "91-145",
          "snippet": "static void unset_migratetype_isolate(struct page *page, unsigned migratetype)\n{\n\tstruct zone *zone;\n\tunsigned long flags, nr_pages;\n\tbool isolated_page = false;\n\tunsigned int order;\n\tunsigned long pfn, buddy_pfn;\n\tstruct page *buddy;\n\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tif (!is_migrate_isolate_page(page))\n\t\tgoto out;\n\n\t/*\n\t * Because freepage with more than pageblock_order on isolated\n\t * pageblock is restricted to merge due to freepage counting problem,\n\t * it is possible that there is free buddy page.\n\t * move_freepages_block() doesn't care of merge so we need other\n\t * approach in order to merge them. Isolation and free will make\n\t * these pages to be merged.\n\t */\n\tif (PageBuddy(page)) {\n\t\torder = page_order(page);\n\t\tif (order >= pageblock_order) {\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t\t    !is_migrate_isolate_page(buddy)) {\n\t\t\t\t__isolate_free_page(page, order);\n\t\t\t\tisolated_page = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If we isolate freepage with more than pageblock_order, there\n\t * should be no freepage in the range, so we could avoid costly\n\t * pageblock scanning for freepage moving.\n\t */\n\tif (!isolated_page) {\n\t\tnr_pages = move_freepages_block(zone, page, migratetype, NULL);\n\t\t__mod_zone_freepage_state(zone, nr_pages, migratetype);\n\t}\n\tset_pageblock_migratetype(page, migratetype);\n\tzone->nr_isolate_pageblock--;\nout:\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\tif (isolated_page) {\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\t__free_pages(page, order);\n\t}\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstatic void unset_migratetype_isolate(struct page *page, unsigned migratetype)\n{\n\tstruct zone *zone;\n\tunsigned long flags, nr_pages;\n\tbool isolated_page = false;\n\tunsigned int order;\n\tunsigned long pfn, buddy_pfn;\n\tstruct page *buddy;\n\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tif (!is_migrate_isolate_page(page))\n\t\tgoto out;\n\n\t/*\n\t * Because freepage with more than pageblock_order on isolated\n\t * pageblock is restricted to merge due to freepage counting problem,\n\t * it is possible that there is free buddy page.\n\t * move_freepages_block() doesn't care of merge so we need other\n\t * approach in order to merge them. Isolation and free will make\n\t * these pages to be merged.\n\t */\n\tif (PageBuddy(page)) {\n\t\torder = page_order(page);\n\t\tif (order >= pageblock_order) {\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t\t    !is_migrate_isolate_page(buddy)) {\n\t\t\t\t__isolate_free_page(page, order);\n\t\t\t\tisolated_page = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If we isolate freepage with more than pageblock_order, there\n\t * should be no freepage in the range, so we could avoid costly\n\t * pageblock scanning for freepage moving.\n\t */\n\tif (!isolated_page) {\n\t\tnr_pages = move_freepages_block(zone, page, migratetype, NULL);\n\t\t__mod_zone_freepage_state(zone, nr_pages, migratetype);\n\t}\n\tset_pageblock_migratetype(page, migratetype);\n\tzone->nr_isolate_pageblock--;\nout:\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\tif (isolated_page) {\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\t__free_pages(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate_page",
          "args": [
            "page"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__first_valid_page",
          "args": [
            "pfn",
            "pageblock_nr_pages"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "__first_valid_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "147-163",
          "snippet": "static inline struct page *\n__first_valid_page(unsigned long pfn, unsigned long nr_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (!pfn_valid_within(pfn + i))\n\t\t\tcontinue;\n\t\tpage = pfn_to_online_page(pfn + i);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\treturn page;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstatic inline struct page *\n__first_valid_page(unsigned long pfn, unsigned long nr_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (!pfn_valid_within(pfn + i))\n\t\t\tcontinue;\n\t\tpage = pfn_to_online_page(pfn + i);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\treturn page;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!IS_ALIGNED(end_pfn, pageblock_nr_pages)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "end_pfn",
            "pageblock_nr_pages"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!IS_ALIGNED(start_pfn, pageblock_nr_pages)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "start_pfn",
            "pageblock_nr_pages"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nint undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t    unsigned migratetype)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (!page || !is_migrate_isolate_page(page))\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "start_isolate_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
    "lines": "187-219",
    "snippet": "int start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t     unsigned migratetype, bool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn;\n\tunsigned long undo_pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page &&\n\t\t    set_migratetype_isolate(page, migratetype, skip_hwpoisoned_pages)) {\n\t\t\tundo_pfn = pfn;\n\t\t\tgoto undo;\n\t\t}\n\t}\n\treturn 0;\nundo:\n\tfor (pfn = start_pfn;\n\t     pfn < undo_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tstruct page *page = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\n\treturn -EBUSY;\n}",
    "includes": [
      "#include <trace/events/page_isolation.h>",
      "#include \"internal.h\"",
      "#include <linux/migrate.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/memory.h>",
      "#include <linux/pageblock-flags.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unset_migratetype_isolate",
          "args": [
            "page",
            "migratetype"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "unset_migratetype_isolate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "91-145",
          "snippet": "static void unset_migratetype_isolate(struct page *page, unsigned migratetype)\n{\n\tstruct zone *zone;\n\tunsigned long flags, nr_pages;\n\tbool isolated_page = false;\n\tunsigned int order;\n\tunsigned long pfn, buddy_pfn;\n\tstruct page *buddy;\n\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tif (!is_migrate_isolate_page(page))\n\t\tgoto out;\n\n\t/*\n\t * Because freepage with more than pageblock_order on isolated\n\t * pageblock is restricted to merge due to freepage counting problem,\n\t * it is possible that there is free buddy page.\n\t * move_freepages_block() doesn't care of merge so we need other\n\t * approach in order to merge them. Isolation and free will make\n\t * these pages to be merged.\n\t */\n\tif (PageBuddy(page)) {\n\t\torder = page_order(page);\n\t\tif (order >= pageblock_order) {\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t\t    !is_migrate_isolate_page(buddy)) {\n\t\t\t\t__isolate_free_page(page, order);\n\t\t\t\tisolated_page = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If we isolate freepage with more than pageblock_order, there\n\t * should be no freepage in the range, so we could avoid costly\n\t * pageblock scanning for freepage moving.\n\t */\n\tif (!isolated_page) {\n\t\tnr_pages = move_freepages_block(zone, page, migratetype, NULL);\n\t\t__mod_zone_freepage_state(zone, nr_pages, migratetype);\n\t}\n\tset_pageblock_migratetype(page, migratetype);\n\tzone->nr_isolate_pageblock--;\nout:\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\tif (isolated_page) {\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\t__free_pages(page, order);\n\t}\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstatic void unset_migratetype_isolate(struct page *page, unsigned migratetype)\n{\n\tstruct zone *zone;\n\tunsigned long flags, nr_pages;\n\tbool isolated_page = false;\n\tunsigned int order;\n\tunsigned long pfn, buddy_pfn;\n\tstruct page *buddy;\n\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tif (!is_migrate_isolate_page(page))\n\t\tgoto out;\n\n\t/*\n\t * Because freepage with more than pageblock_order on isolated\n\t * pageblock is restricted to merge due to freepage counting problem,\n\t * it is possible that there is free buddy page.\n\t * move_freepages_block() doesn't care of merge so we need other\n\t * approach in order to merge them. Isolation and free will make\n\t * these pages to be merged.\n\t */\n\tif (PageBuddy(page)) {\n\t\torder = page_order(page);\n\t\tif (order >= pageblock_order) {\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t\t    !is_migrate_isolate_page(buddy)) {\n\t\t\t\t__isolate_free_page(page, order);\n\t\t\t\tisolated_page = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If we isolate freepage with more than pageblock_order, there\n\t * should be no freepage in the range, so we could avoid costly\n\t * pageblock scanning for freepage moving.\n\t */\n\tif (!isolated_page) {\n\t\tnr_pages = move_freepages_block(zone, page, migratetype, NULL);\n\t\t__mod_zone_freepage_state(zone, nr_pages, migratetype);\n\t}\n\tset_pageblock_migratetype(page, migratetype);\n\tzone->nr_isolate_pageblock--;\nout:\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\tif (isolated_page) {\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\t__free_pages(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_online_page",
          "args": [
            "pfn"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_migratetype_isolate",
          "args": [
            "page",
            "migratetype",
            "skip_hwpoisoned_pages"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "set_migratetype_isolate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "18-89",
          "snippet": "static int set_migratetype_isolate(struct page *page, int migratetype,\n\t\t\t\tbool skip_hwpoisoned_pages)\n{\n\tstruct zone *zone;\n\tunsigned long flags, pfn;\n\tstruct memory_isolate_notify arg;\n\tint notifier_ret;\n\tint ret = -EBUSY;\n\n\tzone = page_zone(page);\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\t/*\n\t * We assume the caller intended to SET migrate type to isolate.\n\t * If it is already set, then someone else must have raced and\n\t * set it before us.  Return -EBUSY\n\t */\n\tif (is_migrate_isolate_page(page))\n\t\tgoto out;\n\n\tpfn = page_to_pfn(page);\n\targ.start_pfn = pfn;\n\targ.nr_pages = pageblock_nr_pages;\n\targ.pages_found = 0;\n\n\t/*\n\t * It may be possible to isolate a pageblock even if the\n\t * migratetype is not MIGRATE_MOVABLE. The memory isolation\n\t * notifier chain is used by balloon drivers to return the\n\t * number of pages in a range that are held by the balloon\n\t * driver to shrink memory. If all the pages are accounted for\n\t * by balloons, are free, or on the LRU, isolation can continue.\n\t * Later, for example, when memory hotplug notifier runs, these\n\t * pages reported as \"can be isolated\" should be isolated(freed)\n\t * by the balloon driver through the memory notifier chain.\n\t */\n\tnotifier_ret = memory_isolate_notify(MEM_ISOLATE_COUNT, &arg);\n\tnotifier_ret = notifier_to_errno(notifier_ret);\n\tif (notifier_ret)\n\t\tgoto out;\n\t/*\n\t * FIXME: Now, memory hotplug doesn't call shrink_slab() by itself.\n\t * We just check MOVABLE pages.\n\t */\n\tif (!has_unmovable_pages(zone, page, arg.pages_found, migratetype,\n\t\t\t\t skip_hwpoisoned_pages))\n\t\tret = 0;\n\n\t/*\n\t * immobile means \"not-on-lru\" pages. If immobile is larger than\n\t * removable-by-driver pages reported by notifier, we'll fail.\n\t */\n\nout:\n\tif (!ret) {\n\t\tunsigned long nr_pages;\n\t\tint mt = get_pageblock_migratetype(page);\n\n\t\tset_pageblock_migratetype(page, MIGRATE_ISOLATE);\n\t\tzone->nr_isolate_pageblock++;\n\t\tnr_pages = move_freepages_block(zone, page, MIGRATE_ISOLATE,\n\t\t\t\t\t\t\t\t\tNULL);\n\n\t\t__mod_zone_freepage_state(zone, -nr_pages, mt);\n\t}\n\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\tif (!ret)\n\t\tdrain_all_pages(zone);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstatic int set_migratetype_isolate(struct page *page, int migratetype,\n\t\t\t\tbool skip_hwpoisoned_pages)\n{\n\tstruct zone *zone;\n\tunsigned long flags, pfn;\n\tstruct memory_isolate_notify arg;\n\tint notifier_ret;\n\tint ret = -EBUSY;\n\n\tzone = page_zone(page);\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\t/*\n\t * We assume the caller intended to SET migrate type to isolate.\n\t * If it is already set, then someone else must have raced and\n\t * set it before us.  Return -EBUSY\n\t */\n\tif (is_migrate_isolate_page(page))\n\t\tgoto out;\n\n\tpfn = page_to_pfn(page);\n\targ.start_pfn = pfn;\n\targ.nr_pages = pageblock_nr_pages;\n\targ.pages_found = 0;\n\n\t/*\n\t * It may be possible to isolate a pageblock even if the\n\t * migratetype is not MIGRATE_MOVABLE. The memory isolation\n\t * notifier chain is used by balloon drivers to return the\n\t * number of pages in a range that are held by the balloon\n\t * driver to shrink memory. If all the pages are accounted for\n\t * by balloons, are free, or on the LRU, isolation can continue.\n\t * Later, for example, when memory hotplug notifier runs, these\n\t * pages reported as \"can be isolated\" should be isolated(freed)\n\t * by the balloon driver through the memory notifier chain.\n\t */\n\tnotifier_ret = memory_isolate_notify(MEM_ISOLATE_COUNT, &arg);\n\tnotifier_ret = notifier_to_errno(notifier_ret);\n\tif (notifier_ret)\n\t\tgoto out;\n\t/*\n\t * FIXME: Now, memory hotplug doesn't call shrink_slab() by itself.\n\t * We just check MOVABLE pages.\n\t */\n\tif (!has_unmovable_pages(zone, page, arg.pages_found, migratetype,\n\t\t\t\t skip_hwpoisoned_pages))\n\t\tret = 0;\n\n\t/*\n\t * immobile means \"not-on-lru\" pages. If immobile is larger than\n\t * removable-by-driver pages reported by notifier, we'll fail.\n\t */\n\nout:\n\tif (!ret) {\n\t\tunsigned long nr_pages;\n\t\tint mt = get_pageblock_migratetype(page);\n\n\t\tset_pageblock_migratetype(page, MIGRATE_ISOLATE);\n\t\tzone->nr_isolate_pageblock++;\n\t\tnr_pages = move_freepages_block(zone, page, MIGRATE_ISOLATE,\n\t\t\t\t\t\t\t\t\tNULL);\n\n\t\t__mod_zone_freepage_state(zone, -nr_pages, mt);\n\t}\n\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\tif (!ret)\n\t\tdrain_all_pages(zone);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__first_valid_page",
          "args": [
            "pfn",
            "pageblock_nr_pages"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__first_valid_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "147-163",
          "snippet": "static inline struct page *\n__first_valid_page(unsigned long pfn, unsigned long nr_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (!pfn_valid_within(pfn + i))\n\t\t\tcontinue;\n\t\tpage = pfn_to_online_page(pfn + i);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\treturn page;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstatic inline struct page *\n__first_valid_page(unsigned long pfn, unsigned long nr_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (!pfn_valid_within(pfn + i))\n\t\t\tcontinue;\n\t\tpage = pfn_to_online_page(pfn + i);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\treturn page;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!IS_ALIGNED(end_pfn, pageblock_nr_pages)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "end_pfn",
            "pageblock_nr_pages"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!IS_ALIGNED(start_pfn, pageblock_nr_pages)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "start_pfn",
            "pageblock_nr_pages"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nint start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t     unsigned migratetype, bool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn;\n\tunsigned long undo_pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page &&\n\t\t    set_migratetype_isolate(page, migratetype, skip_hwpoisoned_pages)) {\n\t\t\tundo_pfn = pfn;\n\t\t\tgoto undo;\n\t\t}\n\t}\n\treturn 0;\nundo:\n\tfor (pfn = start_pfn;\n\t     pfn < undo_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tstruct page *page = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\n\treturn -EBUSY;\n}"
  },
  {
    "function_name": "__first_valid_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
    "lines": "147-163",
    "snippet": "static inline struct page *\n__first_valid_page(unsigned long pfn, unsigned long nr_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (!pfn_valid_within(pfn + i))\n\t\t\tcontinue;\n\t\tpage = pfn_to_online_page(pfn + i);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\treturn page;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/page_isolation.h>",
      "#include \"internal.h\"",
      "#include <linux/migrate.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/memory.h>",
      "#include <linux/pageblock-flags.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_to_online_page",
          "args": [
            "pfn + i"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "pfn + i"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstatic inline struct page *\n__first_valid_page(unsigned long pfn, unsigned long nr_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (!pfn_valid_within(pfn + i))\n\t\t\tcontinue;\n\t\tpage = pfn_to_online_page(pfn + i);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\treturn page;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "unset_migratetype_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
    "lines": "91-145",
    "snippet": "static void unset_migratetype_isolate(struct page *page, unsigned migratetype)\n{\n\tstruct zone *zone;\n\tunsigned long flags, nr_pages;\n\tbool isolated_page = false;\n\tunsigned int order;\n\tunsigned long pfn, buddy_pfn;\n\tstruct page *buddy;\n\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tif (!is_migrate_isolate_page(page))\n\t\tgoto out;\n\n\t/*\n\t * Because freepage with more than pageblock_order on isolated\n\t * pageblock is restricted to merge due to freepage counting problem,\n\t * it is possible that there is free buddy page.\n\t * move_freepages_block() doesn't care of merge so we need other\n\t * approach in order to merge them. Isolation and free will make\n\t * these pages to be merged.\n\t */\n\tif (PageBuddy(page)) {\n\t\torder = page_order(page);\n\t\tif (order >= pageblock_order) {\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t\t    !is_migrate_isolate_page(buddy)) {\n\t\t\t\t__isolate_free_page(page, order);\n\t\t\t\tisolated_page = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If we isolate freepage with more than pageblock_order, there\n\t * should be no freepage in the range, so we could avoid costly\n\t * pageblock scanning for freepage moving.\n\t */\n\tif (!isolated_page) {\n\t\tnr_pages = move_freepages_block(zone, page, migratetype, NULL);\n\t\t__mod_zone_freepage_state(zone, nr_pages, migratetype);\n\t}\n\tset_pageblock_migratetype(page, migratetype);\n\tzone->nr_isolate_pageblock--;\nout:\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\tif (isolated_page) {\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\t__free_pages(page, order);\n\t}\n}",
    "includes": [
      "#include <trace/events/page_isolation.h>",
      "#include \"internal.h\"",
      "#include <linux/migrate.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/memory.h>",
      "#include <linux/pageblock-flags.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "order"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "post_alloc_hook",
          "args": [
            "page",
            "order",
            "__GFP_MOVABLE"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "post_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1908-1919",
          "snippet": "inline void post_alloc_hook(struct page *page, unsigned int order,\n\t\t\t\tgfp_t gfp_flags)\n{\n\tset_page_private(page, 0);\n\tset_page_refcounted(page);\n\n\tarch_alloc_page(page, order);\n\tkernel_map_pages(page, 1 << order, 1);\n\tkernel_poison_pages(page, 1 << order, 1);\n\tkasan_alloc_pages(page, order);\n\tset_page_owner(page, order, gfp_flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\ninline void post_alloc_hook(struct page *page, unsigned int order,\n\t\t\t\tgfp_t gfp_flags)\n{\n\tset_page_private(page, 0);\n\tset_page_refcounted(page);\n\n\tarch_alloc_page(page, order);\n\tkernel_map_pages(page, 1 << order, 1);\n\tkernel_poison_pages(page, 1 << order, 1);\n\tkasan_alloc_pages(page, order);\n\tset_page_owner(page, order, gfp_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pageblock_migratetype",
          "args": [
            "page",
            "migratetype"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "set_pageblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "450-458",
          "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mod_zone_freepage_state",
          "args": [
            "zone",
            "nr_pages",
            "migratetype"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_freepages_block",
          "args": [
            "zone",
            "page",
            "migratetype",
            "NULL"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "move_freepages_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2063-2086",
          "snippet": "int move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nint move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__isolate_free_page",
          "args": [
            "page",
            "order"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__isolate_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2859-2906",
          "snippet": "int __isolate_free_page(struct page *page, unsigned int order)\n{\n\tunsigned long watermark;\n\tstruct zone *zone;\n\tint mt;\n\n\tBUG_ON(!PageBuddy(page));\n\n\tzone = page_zone(page);\n\tmt = get_pageblock_migratetype(page);\n\n\tif (!is_migrate_isolate(mt)) {\n\t\t/*\n\t\t * Obey watermarks as if the page was being allocated. We can\n\t\t * emulate a high-order watermark check with a raised order-0\n\t\t * watermark, because we already know our high-order page\n\t\t * exists.\n\t\t */\n\t\twatermark = min_wmark_pages(zone) + (1UL << order);\n\t\tif (!zone_watermark_ok(zone, 0, watermark, 0, ALLOC_CMA))\n\t\t\treturn 0;\n\n\t\t__mod_zone_freepage_state(zone, -(1UL << order), mt);\n\t}\n\n\t/* Remove page from free list */\n\tlist_del(&page->lru);\n\tzone->free_area[order].nr_free--;\n\trmv_page_order(page);\n\n\t/*\n\t * Set the pageblock if the isolated page is at least half of a\n\t * pageblock\n\t */\n\tif (order >= pageblock_order - 1) {\n\t\tstruct page *endpage = page + (1 << order) - 1;\n\t\tfor (; page < endpage; page += pageblock_nr_pages) {\n\t\t\tint mt = get_pageblock_migratetype(page);\n\t\t\tif (!is_migrate_isolate(mt) && !is_migrate_cma(mt)\n\t\t\t    && !is_migrate_highatomic(mt))\n\t\t\t\tset_pageblock_migratetype(page,\n\t\t\t\t\t\t\t  MIGRATE_MOVABLE);\n\t\t}\n\t}\n\n\n\treturn 1UL << order;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nint __isolate_free_page(struct page *page, unsigned int order)\n{\n\tunsigned long watermark;\n\tstruct zone *zone;\n\tint mt;\n\n\tBUG_ON(!PageBuddy(page));\n\n\tzone = page_zone(page);\n\tmt = get_pageblock_migratetype(page);\n\n\tif (!is_migrate_isolate(mt)) {\n\t\t/*\n\t\t * Obey watermarks as if the page was being allocated. We can\n\t\t * emulate a high-order watermark check with a raised order-0\n\t\t * watermark, because we already know our high-order page\n\t\t * exists.\n\t\t */\n\t\twatermark = min_wmark_pages(zone) + (1UL << order);\n\t\tif (!zone_watermark_ok(zone, 0, watermark, 0, ALLOC_CMA))\n\t\t\treturn 0;\n\n\t\t__mod_zone_freepage_state(zone, -(1UL << order), mt);\n\t}\n\n\t/* Remove page from free list */\n\tlist_del(&page->lru);\n\tzone->free_area[order].nr_free--;\n\trmv_page_order(page);\n\n\t/*\n\t * Set the pageblock if the isolated page is at least half of a\n\t * pageblock\n\t */\n\tif (order >= pageblock_order - 1) {\n\t\tstruct page *endpage = page + (1 << order) - 1;\n\t\tfor (; page < endpage; page += pageblock_nr_pages) {\n\t\t\tint mt = get_pageblock_migratetype(page);\n\t\t\tif (!is_migrate_isolate(mt) && !is_migrate_cma(mt)\n\t\t\t    && !is_migrate_highatomic(mt))\n\t\t\t\tset_pageblock_migratetype(page,\n\t\t\t\t\t\t\t  MIGRATE_MOVABLE);\n\t\t}\n\t}\n\n\n\treturn 1UL << order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate_page",
          "args": [
            "buddy"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "buddy_pfn"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_buddy_pfn",
          "args": [
            "pfn",
            "order"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "__find_buddy_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "145-149",
          "snippet": "static inline unsigned long\n__find_buddy_pfn(unsigned long page_pfn, unsigned int order)\n{\n\treturn page_pfn ^ (1 << order);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\n__find_buddy_pfn(unsigned long page_pfn, unsigned int order)\n{\n\treturn page_pfn ^ (1 << order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "page"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate_page",
          "args": [
            "page"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstatic void unset_migratetype_isolate(struct page *page, unsigned migratetype)\n{\n\tstruct zone *zone;\n\tunsigned long flags, nr_pages;\n\tbool isolated_page = false;\n\tunsigned int order;\n\tunsigned long pfn, buddy_pfn;\n\tstruct page *buddy;\n\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tif (!is_migrate_isolate_page(page))\n\t\tgoto out;\n\n\t/*\n\t * Because freepage with more than pageblock_order on isolated\n\t * pageblock is restricted to merge due to freepage counting problem,\n\t * it is possible that there is free buddy page.\n\t * move_freepages_block() doesn't care of merge so we need other\n\t * approach in order to merge them. Isolation and free will make\n\t * these pages to be merged.\n\t */\n\tif (PageBuddy(page)) {\n\t\torder = page_order(page);\n\t\tif (order >= pageblock_order) {\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t\t    !is_migrate_isolate_page(buddy)) {\n\t\t\t\t__isolate_free_page(page, order);\n\t\t\t\tisolated_page = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If we isolate freepage with more than pageblock_order, there\n\t * should be no freepage in the range, so we could avoid costly\n\t * pageblock scanning for freepage moving.\n\t */\n\tif (!isolated_page) {\n\t\tnr_pages = move_freepages_block(zone, page, migratetype, NULL);\n\t\t__mod_zone_freepage_state(zone, nr_pages, migratetype);\n\t}\n\tset_pageblock_migratetype(page, migratetype);\n\tzone->nr_isolate_pageblock--;\nout:\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\tif (isolated_page) {\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\t__free_pages(page, order);\n\t}\n}"
  },
  {
    "function_name": "set_migratetype_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
    "lines": "18-89",
    "snippet": "static int set_migratetype_isolate(struct page *page, int migratetype,\n\t\t\t\tbool skip_hwpoisoned_pages)\n{\n\tstruct zone *zone;\n\tunsigned long flags, pfn;\n\tstruct memory_isolate_notify arg;\n\tint notifier_ret;\n\tint ret = -EBUSY;\n\n\tzone = page_zone(page);\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\t/*\n\t * We assume the caller intended to SET migrate type to isolate.\n\t * If it is already set, then someone else must have raced and\n\t * set it before us.  Return -EBUSY\n\t */\n\tif (is_migrate_isolate_page(page))\n\t\tgoto out;\n\n\tpfn = page_to_pfn(page);\n\targ.start_pfn = pfn;\n\targ.nr_pages = pageblock_nr_pages;\n\targ.pages_found = 0;\n\n\t/*\n\t * It may be possible to isolate a pageblock even if the\n\t * migratetype is not MIGRATE_MOVABLE. The memory isolation\n\t * notifier chain is used by balloon drivers to return the\n\t * number of pages in a range that are held by the balloon\n\t * driver to shrink memory. If all the pages are accounted for\n\t * by balloons, are free, or on the LRU, isolation can continue.\n\t * Later, for example, when memory hotplug notifier runs, these\n\t * pages reported as \"can be isolated\" should be isolated(freed)\n\t * by the balloon driver through the memory notifier chain.\n\t */\n\tnotifier_ret = memory_isolate_notify(MEM_ISOLATE_COUNT, &arg);\n\tnotifier_ret = notifier_to_errno(notifier_ret);\n\tif (notifier_ret)\n\t\tgoto out;\n\t/*\n\t * FIXME: Now, memory hotplug doesn't call shrink_slab() by itself.\n\t * We just check MOVABLE pages.\n\t */\n\tif (!has_unmovable_pages(zone, page, arg.pages_found, migratetype,\n\t\t\t\t skip_hwpoisoned_pages))\n\t\tret = 0;\n\n\t/*\n\t * immobile means \"not-on-lru\" pages. If immobile is larger than\n\t * removable-by-driver pages reported by notifier, we'll fail.\n\t */\n\nout:\n\tif (!ret) {\n\t\tunsigned long nr_pages;\n\t\tint mt = get_pageblock_migratetype(page);\n\n\t\tset_pageblock_migratetype(page, MIGRATE_ISOLATE);\n\t\tzone->nr_isolate_pageblock++;\n\t\tnr_pages = move_freepages_block(zone, page, MIGRATE_ISOLATE,\n\t\t\t\t\t\t\t\t\tNULL);\n\n\t\t__mod_zone_freepage_state(zone, -nr_pages, mt);\n\t}\n\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\tif (!ret)\n\t\tdrain_all_pages(zone);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/page_isolation.h>",
      "#include \"internal.h\"",
      "#include <linux/migrate.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/memory.h>",
      "#include <linux/pageblock-flags.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drain_all_pages",
          "args": [
            "zone"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2614-2682",
          "snippet": "void drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_zone_freepage_state",
          "args": [
            "zone",
            "-nr_pages",
            "mt"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_freepages_block",
          "args": [
            "zone",
            "page",
            "MIGRATE_ISOLATE",
            "NULL"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "move_freepages_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2063-2086",
          "snippet": "int move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nint move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pageblock_migratetype",
          "args": [
            "page",
            "MIGRATE_ISOLATE"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "set_pageblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "450-458",
          "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_unmovable_pages",
          "args": [
            "zone",
            "page",
            "arg.pages_found",
            "migratetype",
            "skip_hwpoisoned_pages"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notifier_to_errno",
          "args": [
            "notifier_ret"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_isolate_notify",
          "args": [
            "MEM_ISOLATE_COUNT",
            "&arg"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate_page",
          "args": [
            "page"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nstatic int set_migratetype_isolate(struct page *page, int migratetype,\n\t\t\t\tbool skip_hwpoisoned_pages)\n{\n\tstruct zone *zone;\n\tunsigned long flags, pfn;\n\tstruct memory_isolate_notify arg;\n\tint notifier_ret;\n\tint ret = -EBUSY;\n\n\tzone = page_zone(page);\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\t/*\n\t * We assume the caller intended to SET migrate type to isolate.\n\t * If it is already set, then someone else must have raced and\n\t * set it before us.  Return -EBUSY\n\t */\n\tif (is_migrate_isolate_page(page))\n\t\tgoto out;\n\n\tpfn = page_to_pfn(page);\n\targ.start_pfn = pfn;\n\targ.nr_pages = pageblock_nr_pages;\n\targ.pages_found = 0;\n\n\t/*\n\t * It may be possible to isolate a pageblock even if the\n\t * migratetype is not MIGRATE_MOVABLE. The memory isolation\n\t * notifier chain is used by balloon drivers to return the\n\t * number of pages in a range that are held by the balloon\n\t * driver to shrink memory. If all the pages are accounted for\n\t * by balloons, are free, or on the LRU, isolation can continue.\n\t * Later, for example, when memory hotplug notifier runs, these\n\t * pages reported as \"can be isolated\" should be isolated(freed)\n\t * by the balloon driver through the memory notifier chain.\n\t */\n\tnotifier_ret = memory_isolate_notify(MEM_ISOLATE_COUNT, &arg);\n\tnotifier_ret = notifier_to_errno(notifier_ret);\n\tif (notifier_ret)\n\t\tgoto out;\n\t/*\n\t * FIXME: Now, memory hotplug doesn't call shrink_slab() by itself.\n\t * We just check MOVABLE pages.\n\t */\n\tif (!has_unmovable_pages(zone, page, arg.pages_found, migratetype,\n\t\t\t\t skip_hwpoisoned_pages))\n\t\tret = 0;\n\n\t/*\n\t * immobile means \"not-on-lru\" pages. If immobile is larger than\n\t * removable-by-driver pages reported by notifier, we'll fail.\n\t */\n\nout:\n\tif (!ret) {\n\t\tunsigned long nr_pages;\n\t\tint mt = get_pageblock_migratetype(page);\n\n\t\tset_pageblock_migratetype(page, MIGRATE_ISOLATE);\n\t\tzone->nr_isolate_pageblock++;\n\t\tnr_pages = move_freepages_block(zone, page, MIGRATE_ISOLATE,\n\t\t\t\t\t\t\t\t\tNULL);\n\n\t\t__mod_zone_freepage_state(zone, -nr_pages, mt);\n\t}\n\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\tif (!ret)\n\t\tdrain_all_pages(zone);\n\treturn ret;\n}"
  }
]