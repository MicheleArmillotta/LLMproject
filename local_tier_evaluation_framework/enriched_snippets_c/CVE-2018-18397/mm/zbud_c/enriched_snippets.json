[
  {
    "function_name": "exit_zbud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "622-629",
    "snippet": "static void __exit exit_zbud(void)\n{\n#ifdef CONFIG_ZPOOL\n\tzpool_unregister_driver(&zbud_zpool_driver);\n#endif\n\n\tpr_info(\"unloaded\\n\");\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"unloaded\\n\""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zpool_unregister_driver",
          "args": [
            "&zbud_zpool_driver"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "zpool_unregister_driver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zpool.c",
          "lines": "58-72",
          "snippet": "int zpool_unregister_driver(struct zpool_driver *driver)\n{\n\tint ret = 0, refcount;\n\n\tspin_lock(&drivers_lock);\n\trefcount = atomic_read(&driver->refcount);\n\tWARN_ON(refcount < 0);\n\tif (refcount > 0)\n\t\tret = -EBUSY;\n\telse\n\t\tlist_del(&driver->list);\n\tspin_unlock(&drivers_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(drivers_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic DEFINE_SPINLOCK(drivers_lock);\n\nint zpool_unregister_driver(struct zpool_driver *driver)\n{\n\tint ret = 0, refcount;\n\n\tspin_lock(&drivers_lock);\n\trefcount = atomic_read(&driver->refcount);\n\tWARN_ON(refcount < 0);\n\tif (refcount > 0)\n\t\tret = -EBUSY;\n\telse\n\t\tlist_del(&driver->list);\n\tspin_unlock(&drivers_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic void __exit exit_zbud(void)\n{\n#ifdef CONFIG_ZPOOL\n\tzpool_unregister_driver(&zbud_zpool_driver);\n#endif\n\n\tpr_info(\"unloaded\\n\");\n}"
  },
  {
    "function_name": "init_zbud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "609-620",
    "snippet": "static int __init init_zbud(void)\n{\n\t/* Make sure the zbud header will fit in one chunk */\n\tBUILD_BUG_ON(sizeof(struct zbud_header) > ZHDR_SIZE_ALIGNED);\n\tpr_info(\"loaded\\n\");\n\n#ifdef CONFIG_ZPOOL\n\tzpool_register_driver(&zbud_zpool_driver);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define ZHDR_SIZE_ALIGNED CHUNK_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zpool_register_driver",
          "args": [
            "&zbud_zpool_driver"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "zpool_register_driver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zpool.c",
          "lines": "39-45",
          "snippet": "void zpool_register_driver(struct zpool_driver *driver)\n{\n\tspin_lock(&drivers_lock);\n\tatomic_set(&driver->refcount, 0);\n\tlist_add(&driver->list, &drivers_head);\n\tspin_unlock(&drivers_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(drivers_head);",
            "static DEFINE_SPINLOCK(drivers_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic LIST_HEAD(drivers_head);\nstatic DEFINE_SPINLOCK(drivers_lock);\n\nvoid zpool_register_driver(struct zpool_driver *driver)\n{\n\tspin_lock(&drivers_lock);\n\tatomic_set(&driver->refcount, 0);\n\tlist_add(&driver->list, &drivers_head);\n\tspin_unlock(&drivers_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"loaded\\n\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct zbud_header) > ZHDR_SIZE_ALIGNED"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define ZHDR_SIZE_ALIGNED CHUNK_SIZE\n\nstatic int __init init_zbud(void)\n{\n\t/* Make sure the zbud header will fit in one chunk */\n\tBUILD_BUG_ON(sizeof(struct zbud_header) > ZHDR_SIZE_ALIGNED);\n\tpr_info(\"loaded\\n\");\n\n#ifdef CONFIG_ZPOOL\n\tzpool_register_driver(&zbud_zpool_driver);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "zbud_get_pool_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "604-607",
    "snippet": "u64 zbud_get_pool_size(struct zbud_pool *pool)\n{\n\treturn pool->pages_nr;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nu64 zbud_get_pool_size(struct zbud_pool *pool)\n{\n\treturn pool->pages_nr;\n}"
  },
  {
    "function_name": "zbud_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "593-595",
    "snippet": "void zbud_unmap(struct zbud_pool *pool, unsigned long handle)\n{\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nvoid zbud_unmap(struct zbud_pool *pool, unsigned long handle)\n{\n}"
  },
  {
    "function_name": "zbud_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "583-586",
    "snippet": "void *zbud_map(struct zbud_pool *pool, unsigned long handle)\n{\n\treturn (void *)(handle);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nvoid *zbud_map(struct zbud_pool *pool, unsigned long handle)\n{\n\treturn (void *)(handle);\n}"
  },
  {
    "function_name": "zbud_reclaim_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "501-569",
    "snippet": "int zbud_reclaim_page(struct zbud_pool *pool, unsigned int retries)\n{\n\tint i, ret, freechunks;\n\tstruct zbud_header *zhdr;\n\tunsigned long first_handle = 0, last_handle = 0;\n\n\tspin_lock(&pool->lock);\n\tif (!pool->ops || !pool->ops->evict || list_empty(&pool->lru) ||\n\t\t\tretries == 0) {\n\t\tspin_unlock(&pool->lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < retries; i++) {\n\t\tzhdr = list_last_entry(&pool->lru, struct zbud_header, lru);\n\t\tlist_del(&zhdr->lru);\n\t\tlist_del(&zhdr->buddy);\n\t\t/* Protect zbud page against free */\n\t\tzhdr->under_reclaim = true;\n\t\t/*\n\t\t * We need encode the handles before unlocking, since we can\n\t\t * race with free that will set (first|last)_chunks to 0\n\t\t */\n\t\tfirst_handle = 0;\n\t\tlast_handle = 0;\n\t\tif (zhdr->first_chunks)\n\t\t\tfirst_handle = encode_handle(zhdr, FIRST);\n\t\tif (zhdr->last_chunks)\n\t\t\tlast_handle = encode_handle(zhdr, LAST);\n\t\tspin_unlock(&pool->lock);\n\n\t\t/* Issue the eviction callback(s) */\n\t\tif (first_handle) {\n\t\t\tret = pool->ops->evict(pool, first_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (last_handle) {\n\t\t\tret = pool->ops->evict(pool, last_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\nnext:\n\t\tspin_lock(&pool->lock);\n\t\tzhdr->under_reclaim = false;\n\t\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t\t/*\n\t\t\t * Both buddies are now free, free the zbud page and\n\t\t\t * return success.\n\t\t\t */\n\t\t\tfree_zbud_page(zhdr);\n\t\t\tpool->pages_nr--;\n\t\t\tspin_unlock(&pool->lock);\n\t\t\treturn 0;\n\t\t} else if (zhdr->first_chunks == 0 ||\n\t\t\t\tzhdr->last_chunks == 0) {\n\t\t\t/* add to unbuddied list */\n\t\t\tfreechunks = num_free_chunks(zhdr);\n\t\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t\t} else {\n\t\t\t/* add to buddied list */\n\t\t\tlist_add(&zhdr->buddy, &pool->buddied);\n\t\t}\n\n\t\t/* add to beginning of LRU */\n\t\tlist_add(&zhdr->lru, &pool->lru);\n\t}\n\tspin_unlock(&pool->lock);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&zhdr->lru",
            "&pool->lru"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&zhdr->buddy",
            "&pool->buddied"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&zhdr->buddy",
            "&pool->unbuddied[freechunks]"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_free_chunks",
          "args": [
            "zhdr"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "num_free_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "285-292",
          "snippet": "static int num_free_chunks(struct zbud_header *zhdr)\n{\n\t/*\n\t * Rather than branch for different situations, just use the fact that\n\t * free buddies have a length of zero to simplify everything.\n\t */\n\treturn NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n\nstatic int num_free_chunks(struct zbud_header *zhdr)\n{\n\t/*\n\t * Rather than branch for different situations, just use the fact that\n\t * free buddies have a length of zero to simplify everything.\n\t */\n\treturn NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_zbud_page",
          "args": [
            "zhdr"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "free_zbud_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "250-253",
          "snippet": "static void free_zbud_page(struct zbud_header *zhdr)\n{\n\t__free_page(virt_to_page(zhdr));\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic void free_zbud_page(struct zbud_header *zhdr)\n{\n\t__free_page(virt_to_page(zhdr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool->ops->evict",
          "args": [
            "pool",
            "last_handle"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool->ops->evict",
          "args": [
            "pool",
            "first_handle"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_handle",
          "args": [
            "zhdr",
            "LAST"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "encode_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "259-276",
          "snippet": "static unsigned long encode_handle(struct zbud_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\t/*\n\t * For now, the encoded handle is actually just the pointer to the data\n\t * but this might not always be the case.  A little information hiding.\n\t * Add CHUNK_SIZE to the handle if it is the first allocation to jump\n\t * over the zbud header in the first chunk.\n\t */\n\thandle = (unsigned long)zhdr;\n\tif (bud == FIRST)\n\t\t/* skip over zbud header */\n\t\thandle += ZHDR_SIZE_ALIGNED;\n\telse /* bud == LAST */\n\t\thandle += PAGE_SIZE - (zhdr->last_chunks  << CHUNK_SHIFT);\n\treturn handle;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define ZHDR_SIZE_ALIGNED CHUNK_SIZE",
            "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)",
            "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define ZHDR_SIZE_ALIGNED CHUNK_SIZE\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n\nstatic unsigned long encode_handle(struct zbud_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\t/*\n\t * For now, the encoded handle is actually just the pointer to the data\n\t * but this might not always be the case.  A little information hiding.\n\t * Add CHUNK_SIZE to the handle if it is the first allocation to jump\n\t * over the zbud header in the first chunk.\n\t */\n\thandle = (unsigned long)zhdr;\n\tif (bud == FIRST)\n\t\t/* skip over zbud header */\n\t\thandle += ZHDR_SIZE_ALIGNED;\n\telse /* bud == LAST */\n\t\thandle += PAGE_SIZE - (zhdr->last_chunks  << CHUNK_SHIFT);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&zhdr->lru"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_last_entry",
          "args": [
            "&pool->lru",
            "structzbud_header",
            "lru"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->lru"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nint zbud_reclaim_page(struct zbud_pool *pool, unsigned int retries)\n{\n\tint i, ret, freechunks;\n\tstruct zbud_header *zhdr;\n\tunsigned long first_handle = 0, last_handle = 0;\n\n\tspin_lock(&pool->lock);\n\tif (!pool->ops || !pool->ops->evict || list_empty(&pool->lru) ||\n\t\t\tretries == 0) {\n\t\tspin_unlock(&pool->lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < retries; i++) {\n\t\tzhdr = list_last_entry(&pool->lru, struct zbud_header, lru);\n\t\tlist_del(&zhdr->lru);\n\t\tlist_del(&zhdr->buddy);\n\t\t/* Protect zbud page against free */\n\t\tzhdr->under_reclaim = true;\n\t\t/*\n\t\t * We need encode the handles before unlocking, since we can\n\t\t * race with free that will set (first|last)_chunks to 0\n\t\t */\n\t\tfirst_handle = 0;\n\t\tlast_handle = 0;\n\t\tif (zhdr->first_chunks)\n\t\t\tfirst_handle = encode_handle(zhdr, FIRST);\n\t\tif (zhdr->last_chunks)\n\t\t\tlast_handle = encode_handle(zhdr, LAST);\n\t\tspin_unlock(&pool->lock);\n\n\t\t/* Issue the eviction callback(s) */\n\t\tif (first_handle) {\n\t\t\tret = pool->ops->evict(pool, first_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (last_handle) {\n\t\t\tret = pool->ops->evict(pool, last_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\nnext:\n\t\tspin_lock(&pool->lock);\n\t\tzhdr->under_reclaim = false;\n\t\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t\t/*\n\t\t\t * Both buddies are now free, free the zbud page and\n\t\t\t * return success.\n\t\t\t */\n\t\t\tfree_zbud_page(zhdr);\n\t\t\tpool->pages_nr--;\n\t\t\tspin_unlock(&pool->lock);\n\t\t\treturn 0;\n\t\t} else if (zhdr->first_chunks == 0 ||\n\t\t\t\tzhdr->last_chunks == 0) {\n\t\t\t/* add to unbuddied list */\n\t\t\tfreechunks = num_free_chunks(zhdr);\n\t\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t\t} else {\n\t\t\t/* add to buddied list */\n\t\t\tlist_add(&zhdr->buddy, &pool->buddied);\n\t\t}\n\n\t\t/* add to beginning of LRU */\n\t\tlist_add(&zhdr->lru, &pool->lru);\n\t}\n\tspin_unlock(&pool->lock);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "zbud_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "429-464",
    "snippet": "void zbud_free(struct zbud_pool *pool, unsigned long handle)\n{\n\tstruct zbud_header *zhdr;\n\tint freechunks;\n\n\tspin_lock(&pool->lock);\n\tzhdr = handle_to_zbud_header(handle);\n\n\t/* If first buddy, handle will be page aligned */\n\tif ((handle - ZHDR_SIZE_ALIGNED) & ~PAGE_MASK)\n\t\tzhdr->last_chunks = 0;\n\telse\n\t\tzhdr->first_chunks = 0;\n\n\tif (zhdr->under_reclaim) {\n\t\t/* zbud page is under reclaim, reclaim will free */\n\t\tspin_unlock(&pool->lock);\n\t\treturn;\n\t}\n\n\t/* Remove from existing buddy list */\n\tlist_del(&zhdr->buddy);\n\n\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t/* zbud page is empty, free */\n\t\tlist_del(&zhdr->lru);\n\t\tfree_zbud_page(zhdr);\n\t\tpool->pages_nr--;\n\t} else {\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t}\n\n\tspin_unlock(&pool->lock);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define ZHDR_SIZE_ALIGNED CHUNK_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&zhdr->buddy",
            "&pool->unbuddied[freechunks]"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_free_chunks",
          "args": [
            "zhdr"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "num_free_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "285-292",
          "snippet": "static int num_free_chunks(struct zbud_header *zhdr)\n{\n\t/*\n\t * Rather than branch for different situations, just use the fact that\n\t * free buddies have a length of zero to simplify everything.\n\t */\n\treturn NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n\nstatic int num_free_chunks(struct zbud_header *zhdr)\n{\n\t/*\n\t * Rather than branch for different situations, just use the fact that\n\t * free buddies have a length of zero to simplify everything.\n\t */\n\treturn NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_zbud_page",
          "args": [
            "zhdr"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "free_zbud_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "250-253",
          "snippet": "static void free_zbud_page(struct zbud_header *zhdr)\n{\n\t__free_page(virt_to_page(zhdr));\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic void free_zbud_page(struct zbud_header *zhdr)\n{\n\t__free_page(virt_to_page(zhdr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&zhdr->lru"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_to_zbud_header",
          "args": [
            "handle"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "handle_to_zbud_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "279-282",
          "snippet": "static struct zbud_header *handle_to_zbud_header(unsigned long handle)\n{\n\treturn (struct zbud_header *)(handle & PAGE_MASK);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic struct zbud_header *handle_to_zbud_header(unsigned long handle)\n{\n\treturn (struct zbud_header *)(handle & PAGE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define ZHDR_SIZE_ALIGNED CHUNK_SIZE\n\nvoid zbud_free(struct zbud_pool *pool, unsigned long handle)\n{\n\tstruct zbud_header *zhdr;\n\tint freechunks;\n\n\tspin_lock(&pool->lock);\n\tzhdr = handle_to_zbud_header(handle);\n\n\t/* If first buddy, handle will be page aligned */\n\tif ((handle - ZHDR_SIZE_ALIGNED) & ~PAGE_MASK)\n\t\tzhdr->last_chunks = 0;\n\telse\n\t\tzhdr->first_chunks = 0;\n\n\tif (zhdr->under_reclaim) {\n\t\t/* zbud page is under reclaim, reclaim will free */\n\t\tspin_unlock(&pool->lock);\n\t\treturn;\n\t}\n\n\t/* Remove from existing buddy list */\n\tlist_del(&zhdr->buddy);\n\n\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t/* zbud page is empty, free */\n\t\tlist_del(&zhdr->lru);\n\t\tfree_zbud_page(zhdr);\n\t\tpool->pages_nr--;\n\t} else {\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t}\n\n\tspin_unlock(&pool->lock);\n}"
  },
  {
    "function_name": "zbud_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "353-417",
    "snippet": "int zbud_alloc(struct zbud_pool *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\tint chunks, i, freechunks;\n\tstruct zbud_header *zhdr = NULL;\n\tenum buddy bud;\n\tstruct page *page;\n\n\tif (!size || (gfp & __GFP_HIGHMEM))\n\t\treturn -EINVAL;\n\tif (size > PAGE_SIZE - ZHDR_SIZE_ALIGNED - CHUNK_SIZE)\n\t\treturn -ENOSPC;\n\tchunks = size_to_chunks(size);\n\tspin_lock(&pool->lock);\n\n\t/* First, try to find an unbuddied zbud page. */\n\tzhdr = NULL;\n\tfor_each_unbuddied_list(i, chunks) {\n\t\tif (!list_empty(&pool->unbuddied[i])) {\n\t\t\tzhdr = list_first_entry(&pool->unbuddied[i],\n\t\t\t\t\tstruct zbud_header, buddy);\n\t\t\tlist_del(&zhdr->buddy);\n\t\t\tif (zhdr->first_chunks == 0)\n\t\t\t\tbud = FIRST;\n\t\t\telse\n\t\t\t\tbud = LAST;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* Couldn't find unbuddied zbud page, create new one */\n\tspin_unlock(&pool->lock);\n\tpage = alloc_page(gfp);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tspin_lock(&pool->lock);\n\tpool->pages_nr++;\n\tzhdr = init_zbud_page(page);\n\tbud = FIRST;\n\nfound:\n\tif (bud == FIRST)\n\t\tzhdr->first_chunks = chunks;\n\telse\n\t\tzhdr->last_chunks = chunks;\n\n\tif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0) {\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t} else {\n\t\t/* Add to buddied list */\n\t\tlist_add(&zhdr->buddy, &pool->buddied);\n\t}\n\n\t/* Add/move zbud page to beginning of LRU */\n\tif (!list_empty(&zhdr->lru))\n\t\tlist_del(&zhdr->lru);\n\tlist_add(&zhdr->lru, &pool->lru);\n\n\t*handle = encode_handle(zhdr, bud);\n\tspin_unlock(&pool->lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define ZHDR_SIZE_ALIGNED CHUNK_SIZE",
      "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_handle",
          "args": [
            "zhdr",
            "bud"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "encode_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "259-276",
          "snippet": "static unsigned long encode_handle(struct zbud_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\t/*\n\t * For now, the encoded handle is actually just the pointer to the data\n\t * but this might not always be the case.  A little information hiding.\n\t * Add CHUNK_SIZE to the handle if it is the first allocation to jump\n\t * over the zbud header in the first chunk.\n\t */\n\thandle = (unsigned long)zhdr;\n\tif (bud == FIRST)\n\t\t/* skip over zbud header */\n\t\thandle += ZHDR_SIZE_ALIGNED;\n\telse /* bud == LAST */\n\t\thandle += PAGE_SIZE - (zhdr->last_chunks  << CHUNK_SHIFT);\n\treturn handle;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define ZHDR_SIZE_ALIGNED CHUNK_SIZE",
            "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)",
            "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define ZHDR_SIZE_ALIGNED CHUNK_SIZE\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n\nstatic unsigned long encode_handle(struct zbud_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\t/*\n\t * For now, the encoded handle is actually just the pointer to the data\n\t * but this might not always be the case.  A little information hiding.\n\t * Add CHUNK_SIZE to the handle if it is the first allocation to jump\n\t * over the zbud header in the first chunk.\n\t */\n\thandle = (unsigned long)zhdr;\n\tif (bud == FIRST)\n\t\t/* skip over zbud header */\n\t\thandle += ZHDR_SIZE_ALIGNED;\n\telse /* bud == LAST */\n\t\thandle += PAGE_SIZE - (zhdr->last_chunks  << CHUNK_SHIFT);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&zhdr->lru",
            "&pool->lru"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&zhdr->lru"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&zhdr->lru"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&zhdr->buddy",
            "&pool->buddied"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&zhdr->buddy",
            "&pool->unbuddied[freechunks]"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_free_chunks",
          "args": [
            "zhdr"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "num_free_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "285-292",
          "snippet": "static int num_free_chunks(struct zbud_header *zhdr)\n{\n\t/*\n\t * Rather than branch for different situations, just use the fact that\n\t * free buddies have a length of zero to simplify everything.\n\t */\n\treturn NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n\nstatic int num_free_chunks(struct zbud_header *zhdr)\n{\n\t/*\n\t * Rather than branch for different situations, just use the fact that\n\t * free buddies have a length of zero to simplify everything.\n\t */\n\treturn NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_zbud_page",
          "args": [
            "page"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "init_zbud_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "238-247",
          "snippet": "static struct zbud_header *init_zbud_page(struct page *page)\n{\n\tstruct zbud_header *zhdr = page_address(page);\n\tzhdr->first_chunks = 0;\n\tzhdr->last_chunks = 0;\n\tINIT_LIST_HEAD(&zhdr->buddy);\n\tINIT_LIST_HEAD(&zhdr->lru);\n\tzhdr->under_reclaim = 0;\n\treturn zhdr;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic struct zbud_header *init_zbud_page(struct page *page)\n{\n\tstruct zbud_header *zhdr = page_address(page);\n\tzhdr->first_chunks = 0;\n\tzhdr->last_chunks = 0;\n\tINIT_LIST_HEAD(&zhdr->buddy);\n\tINIT_LIST_HEAD(&zhdr->lru);\n\tzhdr->under_reclaim = 0;\n\treturn zhdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_hstate_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2163-2184",
          "snippet": "static void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pool->unbuddied[i]",
            "structzbud_header",
            "buddy"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_unbuddied_list",
          "args": [
            "i",
            "chunks"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_to_chunks",
          "args": [
            "size"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "size_to_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "229-232",
          "snippet": "static int size_to_chunks(size_t size)\n{\n\treturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)",
            "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n\nstatic int size_to_chunks(size_t size)\n{\n\treturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define ZHDR_SIZE_ALIGNED CHUNK_SIZE\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n\nint zbud_alloc(struct zbud_pool *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\tint chunks, i, freechunks;\n\tstruct zbud_header *zhdr = NULL;\n\tenum buddy bud;\n\tstruct page *page;\n\n\tif (!size || (gfp & __GFP_HIGHMEM))\n\t\treturn -EINVAL;\n\tif (size > PAGE_SIZE - ZHDR_SIZE_ALIGNED - CHUNK_SIZE)\n\t\treturn -ENOSPC;\n\tchunks = size_to_chunks(size);\n\tspin_lock(&pool->lock);\n\n\t/* First, try to find an unbuddied zbud page. */\n\tzhdr = NULL;\n\tfor_each_unbuddied_list(i, chunks) {\n\t\tif (!list_empty(&pool->unbuddied[i])) {\n\t\t\tzhdr = list_first_entry(&pool->unbuddied[i],\n\t\t\t\t\tstruct zbud_header, buddy);\n\t\t\tlist_del(&zhdr->buddy);\n\t\t\tif (zhdr->first_chunks == 0)\n\t\t\t\tbud = FIRST;\n\t\t\telse\n\t\t\t\tbud = LAST;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* Couldn't find unbuddied zbud page, create new one */\n\tspin_unlock(&pool->lock);\n\tpage = alloc_page(gfp);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tspin_lock(&pool->lock);\n\tpool->pages_nr++;\n\tzhdr = init_zbud_page(page);\n\tbud = FIRST;\n\nfound:\n\tif (bud == FIRST)\n\t\tzhdr->first_chunks = chunks;\n\telse\n\t\tzhdr->last_chunks = chunks;\n\n\tif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0) {\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t} else {\n\t\t/* Add to buddied list */\n\t\tlist_add(&zhdr->buddy, &pool->buddied);\n\t}\n\n\t/* Add/move zbud page to beginning of LRU */\n\tif (!list_empty(&zhdr->lru))\n\t\tlist_del(&zhdr->lru);\n\tlist_add(&zhdr->lru, &pool->lru);\n\n\t*handle = encode_handle(zhdr, bud);\n\tspin_unlock(&pool->lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "zbud_destroy_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "329-332",
    "snippet": "void zbud_destroy_pool(struct zbud_pool *pool)\n{\n\tkfree(pool);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pool"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nvoid zbud_destroy_pool(struct zbud_pool *pool)\n{\n\tkfree(pool);\n}"
  },
  {
    "function_name": "zbud_create_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "305-321",
    "snippet": "struct zbud_pool *zbud_create_pool(gfp_t gfp, const struct zbud_ops *ops)\n{\n\tstruct zbud_pool *pool;\n\tint i;\n\n\tpool = kzalloc(sizeof(struct zbud_pool), gfp);\n\tif (!pool)\n\t\treturn NULL;\n\tspin_lock_init(&pool->lock);\n\tfor_each_unbuddied_list(i, 0)\n\t\tINIT_LIST_HEAD(&pool->unbuddied[i]);\n\tINIT_LIST_HEAD(&pool->buddied);\n\tINIT_LIST_HEAD(&pool->lru);\n\tpool->pages_nr = 0;\n\tpool->ops = ops;\n\treturn pool;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pool->lru"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pool->buddied"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pool->unbuddied[i]"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_unbuddied_list",
          "args": [
            "i",
            "0"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pool->lock"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct zbud_pool)",
            "gfp"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstruct zbud_pool *zbud_create_pool(gfp_t gfp, const struct zbud_ops *ops)\n{\n\tstruct zbud_pool *pool;\n\tint i;\n\n\tpool = kzalloc(sizeof(struct zbud_pool), gfp);\n\tif (!pool)\n\t\treturn NULL;\n\tspin_lock_init(&pool->lock);\n\tfor_each_unbuddied_list(i, 0)\n\t\tINIT_LIST_HEAD(&pool->unbuddied[i]);\n\tINIT_LIST_HEAD(&pool->buddied);\n\tINIT_LIST_HEAD(&pool->lru);\n\tpool->pages_nr = 0;\n\tpool->ops = ops;\n\treturn pool;\n}"
  },
  {
    "function_name": "num_free_chunks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "285-292",
    "snippet": "static int num_free_chunks(struct zbud_header *zhdr)\n{\n\t/*\n\t * Rather than branch for different situations, just use the fact that\n\t * free buddies have a length of zero to simplify everything.\n\t */\n\treturn NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n\nstatic int num_free_chunks(struct zbud_header *zhdr)\n{\n\t/*\n\t * Rather than branch for different situations, just use the fact that\n\t * free buddies have a length of zero to simplify everything.\n\t */\n\treturn NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n}"
  },
  {
    "function_name": "handle_to_zbud_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "279-282",
    "snippet": "static struct zbud_header *handle_to_zbud_header(unsigned long handle)\n{\n\treturn (struct zbud_header *)(handle & PAGE_MASK);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic struct zbud_header *handle_to_zbud_header(unsigned long handle)\n{\n\treturn (struct zbud_header *)(handle & PAGE_MASK);\n}"
  },
  {
    "function_name": "encode_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "259-276",
    "snippet": "static unsigned long encode_handle(struct zbud_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\t/*\n\t * For now, the encoded handle is actually just the pointer to the data\n\t * but this might not always be the case.  A little information hiding.\n\t * Add CHUNK_SIZE to the handle if it is the first allocation to jump\n\t * over the zbud header in the first chunk.\n\t */\n\thandle = (unsigned long)zhdr;\n\tif (bud == FIRST)\n\t\t/* skip over zbud header */\n\t\thandle += ZHDR_SIZE_ALIGNED;\n\telse /* bud == LAST */\n\t\thandle += PAGE_SIZE - (zhdr->last_chunks  << CHUNK_SHIFT);\n\treturn handle;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define ZHDR_SIZE_ALIGNED CHUNK_SIZE",
      "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)",
      "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define ZHDR_SIZE_ALIGNED CHUNK_SIZE\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n\nstatic unsigned long encode_handle(struct zbud_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\t/*\n\t * For now, the encoded handle is actually just the pointer to the data\n\t * but this might not always be the case.  A little information hiding.\n\t * Add CHUNK_SIZE to the handle if it is the first allocation to jump\n\t * over the zbud header in the first chunk.\n\t */\n\thandle = (unsigned long)zhdr;\n\tif (bud == FIRST)\n\t\t/* skip over zbud header */\n\t\thandle += ZHDR_SIZE_ALIGNED;\n\telse /* bud == LAST */\n\t\thandle += PAGE_SIZE - (zhdr->last_chunks  << CHUNK_SHIFT);\n\treturn handle;\n}"
  },
  {
    "function_name": "free_zbud_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "250-253",
    "snippet": "static void free_zbud_page(struct zbud_header *zhdr)\n{\n\t__free_page(virt_to_page(zhdr));\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "virt_to_page(zhdr)"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "zhdr"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic void free_zbud_page(struct zbud_header *zhdr)\n{\n\t__free_page(virt_to_page(zhdr));\n}"
  },
  {
    "function_name": "init_zbud_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "238-247",
    "snippet": "static struct zbud_header *init_zbud_page(struct page *page)\n{\n\tstruct zbud_header *zhdr = page_address(page);\n\tzhdr->first_chunks = 0;\n\tzhdr->last_chunks = 0;\n\tINIT_LIST_HEAD(&zhdr->buddy);\n\tINIT_LIST_HEAD(&zhdr->lru);\n\tzhdr->under_reclaim = 0;\n\treturn zhdr;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&zhdr->lru"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic struct zbud_header *init_zbud_page(struct page *page)\n{\n\tstruct zbud_header *zhdr = page_address(page);\n\tzhdr->first_chunks = 0;\n\tzhdr->last_chunks = 0;\n\tINIT_LIST_HEAD(&zhdr->buddy);\n\tINIT_LIST_HEAD(&zhdr->lru);\n\tzhdr->under_reclaim = 0;\n\treturn zhdr;\n}"
  },
  {
    "function_name": "size_to_chunks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "229-232",
    "snippet": "static int size_to_chunks(size_t size)\n{\n\treturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)",
      "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n\nstatic int size_to_chunks(size_t size)\n{\n\treturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;\n}"
  },
  {
    "function_name": "zbud_zpool_total_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "198-201",
    "snippet": "static u64 zbud_zpool_total_size(void *pool)\n{\n\treturn zbud_get_pool_size(pool) * PAGE_SIZE;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zbud_get_pool_size",
          "args": [
            "pool"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "zbud_get_pool_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "604-607",
          "snippet": "u64 zbud_get_pool_size(struct zbud_pool *pool)\n{\n\treturn pool->pages_nr;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nu64 zbud_get_pool_size(struct zbud_pool *pool)\n{\n\treturn pool->pages_nr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic u64 zbud_zpool_total_size(void *pool)\n{\n\treturn zbud_get_pool_size(pool) * PAGE_SIZE;\n}"
  },
  {
    "function_name": "zbud_zpool_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "193-196",
    "snippet": "static void zbud_zpool_unmap(void *pool, unsigned long handle)\n{\n\tzbud_unmap(pool, handle);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zbud_unmap",
          "args": [
            "pool",
            "handle"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "zbud_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "593-595",
          "snippet": "void zbud_unmap(struct zbud_pool *pool, unsigned long handle)\n{\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nvoid zbud_unmap(struct zbud_pool *pool, unsigned long handle)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic void zbud_zpool_unmap(void *pool, unsigned long handle)\n{\n\tzbud_unmap(pool, handle);\n}"
  },
  {
    "function_name": "zbud_zpool_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "188-192",
    "snippet": "static void *zbud_zpool_map(void *pool, unsigned long handle,\n\t\t\tenum zpool_mapmode mm)\n{\n\treturn zbud_map(pool, handle);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zbud_map",
          "args": [
            "pool",
            "handle"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "zbud_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "583-586",
          "snippet": "void *zbud_map(struct zbud_pool *pool, unsigned long handle)\n{\n\treturn (void *)(handle);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nvoid *zbud_map(struct zbud_pool *pool, unsigned long handle)\n{\n\treturn (void *)(handle);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic void *zbud_zpool_map(void *pool, unsigned long handle,\n\t\t\tenum zpool_mapmode mm)\n{\n\treturn zbud_map(pool, handle);\n}"
  },
  {
    "function_name": "zbud_zpool_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "169-186",
    "snippet": "static int zbud_zpool_shrink(void *pool, unsigned int pages,\n\t\t\tunsigned int *reclaimed)\n{\n\tunsigned int total = 0;\n\tint ret = -EINVAL;\n\n\twhile (total < pages) {\n\t\tret = zbud_reclaim_page(pool, 8);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\ttotal++;\n\t}\n\n\tif (reclaimed)\n\t\t*reclaimed = total;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zbud_reclaim_page",
          "args": [
            "pool",
            "8"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "zbud_reclaim_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "501-569",
          "snippet": "int zbud_reclaim_page(struct zbud_pool *pool, unsigned int retries)\n{\n\tint i, ret, freechunks;\n\tstruct zbud_header *zhdr;\n\tunsigned long first_handle = 0, last_handle = 0;\n\n\tspin_lock(&pool->lock);\n\tif (!pool->ops || !pool->ops->evict || list_empty(&pool->lru) ||\n\t\t\tretries == 0) {\n\t\tspin_unlock(&pool->lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < retries; i++) {\n\t\tzhdr = list_last_entry(&pool->lru, struct zbud_header, lru);\n\t\tlist_del(&zhdr->lru);\n\t\tlist_del(&zhdr->buddy);\n\t\t/* Protect zbud page against free */\n\t\tzhdr->under_reclaim = true;\n\t\t/*\n\t\t * We need encode the handles before unlocking, since we can\n\t\t * race with free that will set (first|last)_chunks to 0\n\t\t */\n\t\tfirst_handle = 0;\n\t\tlast_handle = 0;\n\t\tif (zhdr->first_chunks)\n\t\t\tfirst_handle = encode_handle(zhdr, FIRST);\n\t\tif (zhdr->last_chunks)\n\t\t\tlast_handle = encode_handle(zhdr, LAST);\n\t\tspin_unlock(&pool->lock);\n\n\t\t/* Issue the eviction callback(s) */\n\t\tif (first_handle) {\n\t\t\tret = pool->ops->evict(pool, first_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (last_handle) {\n\t\t\tret = pool->ops->evict(pool, last_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\nnext:\n\t\tspin_lock(&pool->lock);\n\t\tzhdr->under_reclaim = false;\n\t\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t\t/*\n\t\t\t * Both buddies are now free, free the zbud page and\n\t\t\t * return success.\n\t\t\t */\n\t\t\tfree_zbud_page(zhdr);\n\t\t\tpool->pages_nr--;\n\t\t\tspin_unlock(&pool->lock);\n\t\t\treturn 0;\n\t\t} else if (zhdr->first_chunks == 0 ||\n\t\t\t\tzhdr->last_chunks == 0) {\n\t\t\t/* add to unbuddied list */\n\t\t\tfreechunks = num_free_chunks(zhdr);\n\t\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t\t} else {\n\t\t\t/* add to buddied list */\n\t\t\tlist_add(&zhdr->buddy, &pool->buddied);\n\t\t}\n\n\t\t/* add to beginning of LRU */\n\t\tlist_add(&zhdr->lru, &pool->lru);\n\t}\n\tspin_unlock(&pool->lock);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nint zbud_reclaim_page(struct zbud_pool *pool, unsigned int retries)\n{\n\tint i, ret, freechunks;\n\tstruct zbud_header *zhdr;\n\tunsigned long first_handle = 0, last_handle = 0;\n\n\tspin_lock(&pool->lock);\n\tif (!pool->ops || !pool->ops->evict || list_empty(&pool->lru) ||\n\t\t\tretries == 0) {\n\t\tspin_unlock(&pool->lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < retries; i++) {\n\t\tzhdr = list_last_entry(&pool->lru, struct zbud_header, lru);\n\t\tlist_del(&zhdr->lru);\n\t\tlist_del(&zhdr->buddy);\n\t\t/* Protect zbud page against free */\n\t\tzhdr->under_reclaim = true;\n\t\t/*\n\t\t * We need encode the handles before unlocking, since we can\n\t\t * race with free that will set (first|last)_chunks to 0\n\t\t */\n\t\tfirst_handle = 0;\n\t\tlast_handle = 0;\n\t\tif (zhdr->first_chunks)\n\t\t\tfirst_handle = encode_handle(zhdr, FIRST);\n\t\tif (zhdr->last_chunks)\n\t\t\tlast_handle = encode_handle(zhdr, LAST);\n\t\tspin_unlock(&pool->lock);\n\n\t\t/* Issue the eviction callback(s) */\n\t\tif (first_handle) {\n\t\t\tret = pool->ops->evict(pool, first_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (last_handle) {\n\t\t\tret = pool->ops->evict(pool, last_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\nnext:\n\t\tspin_lock(&pool->lock);\n\t\tzhdr->under_reclaim = false;\n\t\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t\t/*\n\t\t\t * Both buddies are now free, free the zbud page and\n\t\t\t * return success.\n\t\t\t */\n\t\t\tfree_zbud_page(zhdr);\n\t\t\tpool->pages_nr--;\n\t\t\tspin_unlock(&pool->lock);\n\t\t\treturn 0;\n\t\t} else if (zhdr->first_chunks == 0 ||\n\t\t\t\tzhdr->last_chunks == 0) {\n\t\t\t/* add to unbuddied list */\n\t\t\tfreechunks = num_free_chunks(zhdr);\n\t\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t\t} else {\n\t\t\t/* add to buddied list */\n\t\t\tlist_add(&zhdr->buddy, &pool->buddied);\n\t\t}\n\n\t\t/* add to beginning of LRU */\n\t\tlist_add(&zhdr->lru, &pool->lru);\n\t}\n\tspin_unlock(&pool->lock);\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic int zbud_zpool_shrink(void *pool, unsigned int pages,\n\t\t\tunsigned int *reclaimed)\n{\n\tunsigned int total = 0;\n\tint ret = -EINVAL;\n\n\twhile (total < pages) {\n\t\tret = zbud_reclaim_page(pool, 8);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\ttotal++;\n\t}\n\n\tif (reclaimed)\n\t\t*reclaimed = total;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "zbud_zpool_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "164-167",
    "snippet": "static void zbud_zpool_free(void *pool, unsigned long handle)\n{\n\tzbud_free(pool, handle);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zbud_free",
          "args": [
            "pool",
            "handle"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "zbud_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "429-464",
          "snippet": "void zbud_free(struct zbud_pool *pool, unsigned long handle)\n{\n\tstruct zbud_header *zhdr;\n\tint freechunks;\n\n\tspin_lock(&pool->lock);\n\tzhdr = handle_to_zbud_header(handle);\n\n\t/* If first buddy, handle will be page aligned */\n\tif ((handle - ZHDR_SIZE_ALIGNED) & ~PAGE_MASK)\n\t\tzhdr->last_chunks = 0;\n\telse\n\t\tzhdr->first_chunks = 0;\n\n\tif (zhdr->under_reclaim) {\n\t\t/* zbud page is under reclaim, reclaim will free */\n\t\tspin_unlock(&pool->lock);\n\t\treturn;\n\t}\n\n\t/* Remove from existing buddy list */\n\tlist_del(&zhdr->buddy);\n\n\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t/* zbud page is empty, free */\n\t\tlist_del(&zhdr->lru);\n\t\tfree_zbud_page(zhdr);\n\t\tpool->pages_nr--;\n\t} else {\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t}\n\n\tspin_unlock(&pool->lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define ZHDR_SIZE_ALIGNED CHUNK_SIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define ZHDR_SIZE_ALIGNED CHUNK_SIZE\n\nvoid zbud_free(struct zbud_pool *pool, unsigned long handle)\n{\n\tstruct zbud_header *zhdr;\n\tint freechunks;\n\n\tspin_lock(&pool->lock);\n\tzhdr = handle_to_zbud_header(handle);\n\n\t/* If first buddy, handle will be page aligned */\n\tif ((handle - ZHDR_SIZE_ALIGNED) & ~PAGE_MASK)\n\t\tzhdr->last_chunks = 0;\n\telse\n\t\tzhdr->first_chunks = 0;\n\n\tif (zhdr->under_reclaim) {\n\t\t/* zbud page is under reclaim, reclaim will free */\n\t\tspin_unlock(&pool->lock);\n\t\treturn;\n\t}\n\n\t/* Remove from existing buddy list */\n\tlist_del(&zhdr->buddy);\n\n\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t/* zbud page is empty, free */\n\t\tlist_del(&zhdr->lru);\n\t\tfree_zbud_page(zhdr);\n\t\tpool->pages_nr--;\n\t} else {\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t}\n\n\tspin_unlock(&pool->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic void zbud_zpool_free(void *pool, unsigned long handle)\n{\n\tzbud_free(pool, handle);\n}"
  },
  {
    "function_name": "zbud_zpool_malloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "159-163",
    "snippet": "static int zbud_zpool_malloc(void *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\treturn zbud_alloc(pool, size, gfp, handle);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zbud_alloc",
          "args": [
            "pool",
            "size",
            "gfp",
            "handle"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "zbud_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "353-417",
          "snippet": "int zbud_alloc(struct zbud_pool *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\tint chunks, i, freechunks;\n\tstruct zbud_header *zhdr = NULL;\n\tenum buddy bud;\n\tstruct page *page;\n\n\tif (!size || (gfp & __GFP_HIGHMEM))\n\t\treturn -EINVAL;\n\tif (size > PAGE_SIZE - ZHDR_SIZE_ALIGNED - CHUNK_SIZE)\n\t\treturn -ENOSPC;\n\tchunks = size_to_chunks(size);\n\tspin_lock(&pool->lock);\n\n\t/* First, try to find an unbuddied zbud page. */\n\tzhdr = NULL;\n\tfor_each_unbuddied_list(i, chunks) {\n\t\tif (!list_empty(&pool->unbuddied[i])) {\n\t\t\tzhdr = list_first_entry(&pool->unbuddied[i],\n\t\t\t\t\tstruct zbud_header, buddy);\n\t\t\tlist_del(&zhdr->buddy);\n\t\t\tif (zhdr->first_chunks == 0)\n\t\t\t\tbud = FIRST;\n\t\t\telse\n\t\t\t\tbud = LAST;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* Couldn't find unbuddied zbud page, create new one */\n\tspin_unlock(&pool->lock);\n\tpage = alloc_page(gfp);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tspin_lock(&pool->lock);\n\tpool->pages_nr++;\n\tzhdr = init_zbud_page(page);\n\tbud = FIRST;\n\nfound:\n\tif (bud == FIRST)\n\t\tzhdr->first_chunks = chunks;\n\telse\n\t\tzhdr->last_chunks = chunks;\n\n\tif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0) {\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t} else {\n\t\t/* Add to buddied list */\n\t\tlist_add(&zhdr->buddy, &pool->buddied);\n\t}\n\n\t/* Add/move zbud page to beginning of LRU */\n\tif (!list_empty(&zhdr->lru))\n\t\tlist_del(&zhdr->lru);\n\tlist_add(&zhdr->lru, &pool->lru);\n\n\t*handle = encode_handle(zhdr, bud);\n\tspin_unlock(&pool->lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define ZHDR_SIZE_ALIGNED CHUNK_SIZE",
            "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\n#define ZHDR_SIZE_ALIGNED CHUNK_SIZE\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n\nint zbud_alloc(struct zbud_pool *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\tint chunks, i, freechunks;\n\tstruct zbud_header *zhdr = NULL;\n\tenum buddy bud;\n\tstruct page *page;\n\n\tif (!size || (gfp & __GFP_HIGHMEM))\n\t\treturn -EINVAL;\n\tif (size > PAGE_SIZE - ZHDR_SIZE_ALIGNED - CHUNK_SIZE)\n\t\treturn -ENOSPC;\n\tchunks = size_to_chunks(size);\n\tspin_lock(&pool->lock);\n\n\t/* First, try to find an unbuddied zbud page. */\n\tzhdr = NULL;\n\tfor_each_unbuddied_list(i, chunks) {\n\t\tif (!list_empty(&pool->unbuddied[i])) {\n\t\t\tzhdr = list_first_entry(&pool->unbuddied[i],\n\t\t\t\t\tstruct zbud_header, buddy);\n\t\t\tlist_del(&zhdr->buddy);\n\t\t\tif (zhdr->first_chunks == 0)\n\t\t\t\tbud = FIRST;\n\t\t\telse\n\t\t\t\tbud = LAST;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* Couldn't find unbuddied zbud page, create new one */\n\tspin_unlock(&pool->lock);\n\tpage = alloc_page(gfp);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tspin_lock(&pool->lock);\n\tpool->pages_nr++;\n\tzhdr = init_zbud_page(page);\n\tbud = FIRST;\n\nfound:\n\tif (bud == FIRST)\n\t\tzhdr->first_chunks = chunks;\n\telse\n\t\tzhdr->last_chunks = chunks;\n\n\tif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0) {\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\n\t} else {\n\t\t/* Add to buddied list */\n\t\tlist_add(&zhdr->buddy, &pool->buddied);\n\t}\n\n\t/* Add/move zbud page to beginning of LRU */\n\tif (!list_empty(&zhdr->lru))\n\t\tlist_del(&zhdr->lru);\n\tlist_add(&zhdr->lru, &pool->lru);\n\n\t*handle = encode_handle(zhdr, bud);\n\tspin_unlock(&pool->lock);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic int zbud_zpool_malloc(void *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\treturn zbud_alloc(pool, size, gfp, handle);\n}"
  },
  {
    "function_name": "zbud_zpool_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "154-157",
    "snippet": "static void zbud_zpool_destroy(void *pool)\n{\n\tzbud_destroy_pool(pool);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zbud_destroy_pool",
          "args": [
            "pool"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "zbud_destroy_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "329-332",
          "snippet": "void zbud_destroy_pool(struct zbud_pool *pool)\n{\n\tkfree(pool);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nvoid zbud_destroy_pool(struct zbud_pool *pool)\n{\n\tkfree(pool);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic void zbud_zpool_destroy(void *pool)\n{\n\tzbud_destroy_pool(pool);\n}"
  },
  {
    "function_name": "zbud_zpool_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "140-152",
    "snippet": "static void *zbud_zpool_create(const char *name, gfp_t gfp,\n\t\t\t       const struct zpool_ops *zpool_ops,\n\t\t\t       struct zpool *zpool)\n{\n\tstruct zbud_pool *pool;\n\n\tpool = zbud_create_pool(gfp, zpool_ops ? &zbud_zpool_ops : NULL);\n\tif (pool) {\n\t\tpool->zpool = zpool;\n\t\tpool->zpool_ops = zpool_ops;\n\t}\n\treturn pool;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zbud_create_pool",
          "args": [
            "gfp",
            "zpool_ops ? &zbud_zpool_ops : NULL"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "zbud_create_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
          "lines": "305-321",
          "snippet": "struct zbud_pool *zbud_create_pool(gfp_t gfp, const struct zbud_ops *ops)\n{\n\tstruct zbud_pool *pool;\n\tint i;\n\n\tpool = kzalloc(sizeof(struct zbud_pool), gfp);\n\tif (!pool)\n\t\treturn NULL;\n\tspin_lock_init(&pool->lock);\n\tfor_each_unbuddied_list(i, 0)\n\t\tINIT_LIST_HEAD(&pool->unbuddied[i]);\n\tINIT_LIST_HEAD(&pool->buddied);\n\tINIT_LIST_HEAD(&pool->lru);\n\tpool->pages_nr = 0;\n\tpool->ops = ops;\n\treturn pool;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/zbud.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/preempt.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstruct zbud_pool *zbud_create_pool(gfp_t gfp, const struct zbud_ops *ops)\n{\n\tstruct zbud_pool *pool;\n\tint i;\n\n\tpool = kzalloc(sizeof(struct zbud_pool), gfp);\n\tif (!pool)\n\t\treturn NULL;\n\tspin_lock_init(&pool->lock);\n\tfor_each_unbuddied_list(i, 0)\n\t\tINIT_LIST_HEAD(&pool->unbuddied[i]);\n\tINIT_LIST_HEAD(&pool->buddied);\n\tINIT_LIST_HEAD(&pool->lru);\n\tpool->pages_nr = 0;\n\tpool->ops = ops;\n\treturn pool;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic void *zbud_zpool_create(const char *name, gfp_t gfp,\n\t\t\t       const struct zpool_ops *zpool_ops,\n\t\t\t       struct zpool *zpool)\n{\n\tstruct zbud_pool *pool;\n\n\tpool = zbud_create_pool(gfp, zpool_ops ? &zbud_zpool_ops : NULL);\n\tif (pool) {\n\t\tpool->zpool = zpool;\n\t\tpool->zpool_ops = zpool_ops;\n\t}\n\treturn pool;\n}"
  },
  {
    "function_name": "zbud_zpool_evict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zbud.c",
    "lines": "128-134",
    "snippet": "static int zbud_zpool_evict(struct zbud_pool *pool, unsigned long handle)\n{\n\tif (pool->zpool && pool->zpool_ops && pool->zpool_ops->evict)\n\t\treturn pool->zpool_ops->evict(pool->zpool, handle);\n\telse\n\t\treturn -ENOENT;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/zbud.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/preempt.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pool->zpool_ops->evict",
          "args": [
            "pool->zpool",
            "handle"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/zbud.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/preempt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n\nstatic int zbud_zpool_evict(struct zbud_pool *pool, unsigned long handle)\n{\n\tif (pool->zpool && pool->zpool_ops && pool->zpool_ops->evict)\n\t\treturn pool->zpool_ops->evict(pool->zpool, handle);\n\telse\n\t\treturn -ENOENT;\n}"
  }
]