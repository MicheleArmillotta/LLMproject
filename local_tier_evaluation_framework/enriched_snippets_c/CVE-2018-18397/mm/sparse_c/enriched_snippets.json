[
  {
    "function_name": "sparse_remove_one_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "768-788",
    "snippet": "void sparse_remove_one_section(struct zone *zone, struct mem_section *ms,\n\t\tunsigned long map_offset, struct vmem_altmap *altmap)\n{\n\tstruct page *memmap = NULL;\n\tunsigned long *usemap = NULL, flags;\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\n\tpgdat_resize_lock(pgdat, &flags);\n\tif (ms->section_mem_map) {\n\t\tusemap = ms->pageblock_flags;\n\t\tmemmap = sparse_decode_mem_map(ms->section_mem_map,\n\t\t\t\t\t\t__section_nr(ms));\n\t\tms->section_mem_map = 0;\n\t\tms->pageblock_flags = NULL;\n\t}\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\tclear_hwpoisoned_pages(memmap + map_offset,\n\t\t\tPAGES_PER_SECTION - map_offset);\n\tfree_section_usemap(memmap, usemap, altmap);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_section_usemap",
          "args": [
            "memmap",
            "usemap",
            "altmap"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "free_section_usemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "740-766",
          "snippet": "static void free_section_usemap(struct page *memmap, unsigned long *usemap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tstruct page *usemap_page;\n\n\tif (!usemap)\n\t\treturn;\n\n\tusemap_page = virt_to_page(usemap);\n\t/*\n\t * Check to see if allocation came from hot-plug-add\n\t */\n\tif (PageSlab(usemap_page) || PageCompound(usemap_page)) {\n\t\tkfree(usemap);\n\t\tif (memmap)\n\t\t\t__kfree_section_memmap(memmap, altmap);\n\t\treturn;\n\t}\n\n\t/*\n\t * The usemap came from bootmem. This is packed with other usemaps\n\t * on the section which has pgdat at boot time. Just keep it as is now.\n\t */\n\n\tif (memmap)\n\t\tfree_map_bootmem(memmap);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void free_section_usemap(struct page *memmap, unsigned long *usemap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tstruct page *usemap_page;\n\n\tif (!usemap)\n\t\treturn;\n\n\tusemap_page = virt_to_page(usemap);\n\t/*\n\t * Check to see if allocation came from hot-plug-add\n\t */\n\tif (PageSlab(usemap_page) || PageCompound(usemap_page)) {\n\t\tkfree(usemap);\n\t\tif (memmap)\n\t\t\t__kfree_section_memmap(memmap, altmap);\n\t\treturn;\n\t}\n\n\t/*\n\t * The usemap came from bootmem. This is packed with other usemaps\n\t * on the section which has pgdat at boot time. Just keep it as is now.\n\t */\n\n\tif (memmap)\n\t\tfree_map_bootmem(memmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_hwpoisoned_pages",
          "args": [
            "memmap + map_offset",
            "PAGES_PER_SECTION - map_offset"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "clear_hwpoisoned_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "735-737",
          "snippet": "static inline void clear_hwpoisoned_pages(struct page *memmap, int nr_pages)\n{\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void clear_hwpoisoned_pages(struct page *memmap, int nr_pages)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sparse_decode_mem_map",
          "args": [
            "ms->section_mem_map",
            "__section_nr(ms)"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_decode_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "259-264",
          "snippet": "struct page *sparse_decode_mem_map(unsigned long coded_mem_map, unsigned long pnum)\n{\n\t/* mask off the extra low bits of information */\n\tcoded_mem_map &= SECTION_MAP_MASK;\n\treturn ((struct page *)coded_mem_map) + section_nr_to_pfn(pnum);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct page *sparse_decode_mem_map(unsigned long coded_mem_map, unsigned long pnum)\n{\n\t/* mask off the extra low bits of information */\n\tcoded_mem_map &= SECTION_MAP_MASK;\n\treturn ((struct page *)coded_mem_map) + section_nr_to_pfn(pnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__section_nr",
          "args": [
            "ms"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "__section_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "120-123",
          "snippet": "int __section_nr(struct mem_section* ms)\n{\n\treturn (int)(ms - mem_section[0]);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __section_nr(struct mem_section* ms)\n{\n\treturn (int)(ms - mem_section[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_resize_lock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid sparse_remove_one_section(struct zone *zone, struct mem_section *ms,\n\t\tunsigned long map_offset, struct vmem_altmap *altmap)\n{\n\tstruct page *memmap = NULL;\n\tunsigned long *usemap = NULL, flags;\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\n\tpgdat_resize_lock(pgdat, &flags);\n\tif (ms->section_mem_map) {\n\t\tusemap = ms->pageblock_flags;\n\t\tmemmap = sparse_decode_mem_map(ms->section_mem_map,\n\t\t\t\t\t\t__section_nr(ms));\n\t\tms->section_mem_map = 0;\n\t\tms->pageblock_flags = NULL;\n\t}\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\tclear_hwpoisoned_pages(memmap + map_offset,\n\t\t\tPAGES_PER_SECTION - map_offset);\n\tfree_section_usemap(memmap, usemap, altmap);\n}"
  },
  {
    "function_name": "free_section_usemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "740-766",
    "snippet": "static void free_section_usemap(struct page *memmap, unsigned long *usemap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tstruct page *usemap_page;\n\n\tif (!usemap)\n\t\treturn;\n\n\tusemap_page = virt_to_page(usemap);\n\t/*\n\t * Check to see if allocation came from hot-plug-add\n\t */\n\tif (PageSlab(usemap_page) || PageCompound(usemap_page)) {\n\t\tkfree(usemap);\n\t\tif (memmap)\n\t\t\t__kfree_section_memmap(memmap, altmap);\n\t\treturn;\n\t}\n\n\t/*\n\t * The usemap came from bootmem. This is packed with other usemaps\n\t * on the section which has pgdat at boot time. Just keep it as is now.\n\t */\n\n\tif (memmap)\n\t\tfree_map_bootmem(memmap);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_map_bootmem",
          "args": [
            "memmap"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "free_map_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "628-656",
          "snippet": "static void free_map_bootmem(struct page *memmap)\n{\n\tunsigned long maps_section_nr, removing_section_nr, i;\n\tunsigned long magic, nr_pages;\n\tstruct page *page = virt_to_page(memmap);\n\n\tnr_pages = PAGE_ALIGN(PAGES_PER_SECTION * sizeof(struct page))\n\t\t>> PAGE_SHIFT;\n\n\tfor (i = 0; i < nr_pages; i++, page++) {\n\t\tmagic = (unsigned long) page->freelist;\n\n\t\tBUG_ON(magic == NODE_INFO);\n\n\t\tmaps_section_nr = pfn_to_section_nr(page_to_pfn(page));\n\t\tremoving_section_nr = page_private(page);\n\n\t\t/*\n\t\t * When this function is called, the removing section is\n\t\t * logical offlined state. This means all pages are isolated\n\t\t * from page allocator. If removing section's memmap is placed\n\t\t * on the same section, it must not be freed.\n\t\t * If it is freed, page allocator may allocate it which will\n\t\t * be removed physically soon.\n\t\t */\n\t\tif (maps_section_nr != removing_section_nr)\n\t\t\tput_page_bootmem(page);\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void free_map_bootmem(struct page *memmap)\n{\n\tunsigned long maps_section_nr, removing_section_nr, i;\n\tunsigned long magic, nr_pages;\n\tstruct page *page = virt_to_page(memmap);\n\n\tnr_pages = PAGE_ALIGN(PAGES_PER_SECTION * sizeof(struct page))\n\t\t>> PAGE_SHIFT;\n\n\tfor (i = 0; i < nr_pages; i++, page++) {\n\t\tmagic = (unsigned long) page->freelist;\n\n\t\tBUG_ON(magic == NODE_INFO);\n\n\t\tmaps_section_nr = pfn_to_section_nr(page_to_pfn(page));\n\t\tremoving_section_nr = page_private(page);\n\n\t\t/*\n\t\t * When this function is called, the removing section is\n\t\t * logical offlined state. This means all pages are isolated\n\t\t * from page allocator. If removing section's memmap is placed\n\t\t * on the same section, it must not be freed.\n\t\t * If it is freed, page allocator may allocate it which will\n\t\t * be removed physically soon.\n\t\t */\n\t\tif (maps_section_nr != removing_section_nr)\n\t\t\tput_page_bootmem(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kfree_section_memmap",
          "args": [
            "memmap",
            "altmap"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "__kfree_section_memmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "617-625",
          "snippet": "static void __kfree_section_memmap(struct page *memmap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tif (is_vmalloc_addr(memmap))\n\t\tvfree(memmap);\n\telse\n\t\tfree_pages((unsigned long)memmap,\n\t\t\t   get_order(sizeof(struct page) * PAGES_PER_SECTION));\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __kfree_section_memmap(struct page *memmap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tif (is_vmalloc_addr(memmap))\n\t\tvfree(memmap);\n\telse\n\t\tfree_pages((unsigned long)memmap,\n\t\t\t   get_order(sizeof(struct page) * PAGES_PER_SECTION));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "usemap"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "usemap_page"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "usemap_page"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "usemap"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void free_section_usemap(struct page *memmap, unsigned long *usemap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tstruct page *usemap_page;\n\n\tif (!usemap)\n\t\treturn;\n\n\tusemap_page = virt_to_page(usemap);\n\t/*\n\t * Check to see if allocation came from hot-plug-add\n\t */\n\tif (PageSlab(usemap_page) || PageCompound(usemap_page)) {\n\t\tkfree(usemap);\n\t\tif (memmap)\n\t\t\t__kfree_section_memmap(memmap, altmap);\n\t\treturn;\n\t}\n\n\t/*\n\t * The usemap came from bootmem. This is packed with other usemaps\n\t * on the section which has pgdat at boot time. Just keep it as is now.\n\t */\n\n\tif (memmap)\n\t\tfree_map_bootmem(memmap);\n}"
  },
  {
    "function_name": "clear_hwpoisoned_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "735-737",
    "snippet": "static inline void clear_hwpoisoned_pages(struct page *memmap, int nr_pages)\n{\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void clear_hwpoisoned_pages(struct page *memmap, int nr_pages)\n{\n}"
  },
  {
    "function_name": "clear_hwpoisoned_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "720-733",
    "snippet": "static void clear_hwpoisoned_pages(struct page *memmap, int nr_pages)\n{\n\tint i;\n\n\tif (!memmap)\n\t\treturn;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (PageHWPoison(&memmap[i])) {\n\t\t\tatomic_long_sub(1, &num_poisoned_pages);\n\t\t\tClearPageHWPoison(&memmap[i]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPageHWPoison",
          "args": [
            "&memmap[i]"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_sub",
          "args": [
            "1",
            "&num_poisoned_pages"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "&memmap[i]"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void clear_hwpoisoned_pages(struct page *memmap, int nr_pages)\n{\n\tint i;\n\n\tif (!memmap)\n\t\treturn;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (PageHWPoison(&memmap[i])) {\n\t\t\tatomic_long_sub(1, &num_poisoned_pages);\n\t\t\tClearPageHWPoison(&memmap[i]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "sparse_add_one_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "665-716",
    "snippet": "int __meminit sparse_add_one_section(struct pglist_data *pgdat,\n\t\tunsigned long start_pfn, struct vmem_altmap *altmap)\n{\n\tunsigned long section_nr = pfn_to_section_nr(start_pfn);\n\tstruct mem_section *ms;\n\tstruct page *memmap;\n\tunsigned long *usemap;\n\tunsigned long flags;\n\tint ret;\n\n\t/*\n\t * no locking for this, because it does its own\n\t * plus, it does a kmalloc\n\t */\n\tret = sparse_index_init(section_nr, pgdat->node_id);\n\tif (ret < 0 && ret != -EEXIST)\n\t\treturn ret;\n\tret = 0;\n\tmemmap = kmalloc_section_memmap(section_nr, pgdat->node_id, altmap);\n\tif (!memmap)\n\t\treturn -ENOMEM;\n\tusemap = __kmalloc_section_usemap();\n\tif (!usemap) {\n\t\t__kfree_section_memmap(memmap, altmap);\n\t\treturn -ENOMEM;\n\t}\n\n\tpgdat_resize_lock(pgdat, &flags);\n\n\tms = __pfn_to_section(start_pfn);\n\tif (ms->section_mem_map & SECTION_MARKED_PRESENT) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Poison uninitialized struct pages in order to catch invalid flags\n\t * combinations.\n\t */\n\tpage_init_poison(memmap, sizeof(struct page) * PAGES_PER_SECTION);\n\n\tsection_mark_present(ms);\n\tsparse_init_one_section(ms, section_nr, memmap, usemap);\n\nout:\n\tpgdat_resize_unlock(pgdat, &flags);\n\tif (ret < 0) {\n\t\tkfree(usemap);\n\t\t__kfree_section_memmap(memmap, altmap);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kfree_section_memmap",
          "args": [
            "memmap",
            "altmap"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "__kfree_section_memmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "617-625",
          "snippet": "static void __kfree_section_memmap(struct page *memmap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tif (is_vmalloc_addr(memmap))\n\t\tvfree(memmap);\n\telse\n\t\tfree_pages((unsigned long)memmap,\n\t\t\t   get_order(sizeof(struct page) * PAGES_PER_SECTION));\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __kfree_section_memmap(struct page *memmap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tif (is_vmalloc_addr(memmap))\n\t\tvfree(memmap);\n\telse\n\t\tfree_pages((unsigned long)memmap,\n\t\t\t   get_order(sizeof(struct page) * PAGES_PER_SECTION));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "usemap"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sparse_init_one_section",
          "args": [
            "ms",
            "section_nr",
            "memmap",
            "usemap"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_init_one_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "266-274",
          "snippet": "static void __meminit sparse_init_one_section(struct mem_section *ms,\n\t\tunsigned long pnum, struct page *mem_map,\n\t\tunsigned long *pageblock_bitmap)\n{\n\tms->section_mem_map &= ~SECTION_MAP_MASK;\n\tms->section_mem_map |= sparse_encode_mem_map(mem_map, pnum) |\n\t\t\t\t\t\t\tSECTION_HAS_MEM_MAP;\n \tms->pageblock_flags = pageblock_bitmap;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __meminit sparse_init_one_section(struct mem_section *ms,\n\t\tunsigned long pnum, struct page *mem_map,\n\t\tunsigned long *pageblock_bitmap)\n{\n\tms->section_mem_map &= ~SECTION_MAP_MASK;\n\tms->section_mem_map |= sparse_encode_mem_map(mem_map, pnum) |\n\t\t\t\t\t\t\tSECTION_HAS_MEM_MAP;\n \tms->pageblock_flags = pageblock_bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "section_mark_present",
          "args": [
            "ms"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "section_mark_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "178-186",
          "snippet": "static void section_mark_present(struct mem_section *ms)\n{\n\tint section_nr = __section_nr(ms);\n\n\tif (section_nr > __highest_present_section_nr)\n\t\t__highest_present_section_nr = section_nr;\n\n\tms->section_mem_map |= SECTION_MARKED_PRESENT;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __highest_present_section_nr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __highest_present_section_nr;\n\nstatic void section_mark_present(struct mem_section *ms)\n{\n\tint section_nr = __section_nr(ms);\n\n\tif (section_nr > __highest_present_section_nr)\n\t\t__highest_present_section_nr = section_nr;\n\n\tms->section_mem_map |= SECTION_MARKED_PRESENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_init_poison",
          "args": [
            "memmap",
            "sizeof(struct page) * PAGES_PER_SECTION"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "page_init_poison",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
          "lines": "218-222",
          "snippet": "void page_init_poison(struct page *page, size_t size)\n{\n\tif (page_init_poisoning)\n\t\tmemset(page, PAGE_POISON_PATTERN, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/migrate.h>",
            "#include <trace/events/mmflags.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid page_init_poison(struct page *page, size_t size)\n{\n\tif (page_init_poisoning)\n\t\tmemset(page, PAGE_POISON_PATTERN, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "start_pfn"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_lock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kmalloc_section_usemap",
          "args": [],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_section_usemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "282-285",
          "snippet": "static unsigned long *__kmalloc_section_usemap(void)\n{\n\treturn kmalloc(usemap_size(), GFP_KERNEL);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic unsigned long *__kmalloc_section_usemap(void)\n{\n\treturn kmalloc(usemap_size(), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_section_memmap",
          "args": [
            "section_nr",
            "pgdat->node_id",
            "altmap"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_section_memmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "611-615",
          "snippet": "static inline struct page *kmalloc_section_memmap(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\treturn __kmalloc_section_memmap();\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline struct page *kmalloc_section_memmap(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\treturn __kmalloc_section_memmap();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sparse_index_init",
          "args": [
            "section_nr",
            "pgdat->node_id"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_index_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "94-97",
          "snippet": "static inline int sparse_index_init(unsigned long section_nr, int nid)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int sparse_index_init(unsigned long section_nr, int nid)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "start_pfn"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __meminit sparse_add_one_section(struct pglist_data *pgdat,\n\t\tunsigned long start_pfn, struct vmem_altmap *altmap)\n{\n\tunsigned long section_nr = pfn_to_section_nr(start_pfn);\n\tstruct mem_section *ms;\n\tstruct page *memmap;\n\tunsigned long *usemap;\n\tunsigned long flags;\n\tint ret;\n\n\t/*\n\t * no locking for this, because it does its own\n\t * plus, it does a kmalloc\n\t */\n\tret = sparse_index_init(section_nr, pgdat->node_id);\n\tif (ret < 0 && ret != -EEXIST)\n\t\treturn ret;\n\tret = 0;\n\tmemmap = kmalloc_section_memmap(section_nr, pgdat->node_id, altmap);\n\tif (!memmap)\n\t\treturn -ENOMEM;\n\tusemap = __kmalloc_section_usemap();\n\tif (!usemap) {\n\t\t__kfree_section_memmap(memmap, altmap);\n\t\treturn -ENOMEM;\n\t}\n\n\tpgdat_resize_lock(pgdat, &flags);\n\n\tms = __pfn_to_section(start_pfn);\n\tif (ms->section_mem_map & SECTION_MARKED_PRESENT) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Poison uninitialized struct pages in order to catch invalid flags\n\t * combinations.\n\t */\n\tpage_init_poison(memmap, sizeof(struct page) * PAGES_PER_SECTION);\n\n\tsection_mark_present(ms);\n\tsparse_init_one_section(ms, section_nr, memmap, usemap);\n\nout:\n\tpgdat_resize_unlock(pgdat, &flags);\n\tif (ret < 0) {\n\t\tkfree(usemap);\n\t\t__kfree_section_memmap(memmap, altmap);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "free_map_bootmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "628-656",
    "snippet": "static void free_map_bootmem(struct page *memmap)\n{\n\tunsigned long maps_section_nr, removing_section_nr, i;\n\tunsigned long magic, nr_pages;\n\tstruct page *page = virt_to_page(memmap);\n\n\tnr_pages = PAGE_ALIGN(PAGES_PER_SECTION * sizeof(struct page))\n\t\t>> PAGE_SHIFT;\n\n\tfor (i = 0; i < nr_pages; i++, page++) {\n\t\tmagic = (unsigned long) page->freelist;\n\n\t\tBUG_ON(magic == NODE_INFO);\n\n\t\tmaps_section_nr = pfn_to_section_nr(page_to_pfn(page));\n\t\tremoving_section_nr = page_private(page);\n\n\t\t/*\n\t\t * When this function is called, the removing section is\n\t\t * logical offlined state. This means all pages are isolated\n\t\t * from page allocator. If removing section's memmap is placed\n\t\t * on the same section, it must not be freed.\n\t\t * If it is freed, page allocator may allocate it which will\n\t\t * be removed physically soon.\n\t\t */\n\t\tif (maps_section_nr != removing_section_nr)\n\t\t\tput_page_bootmem(page);\n\t}\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page_bootmem",
          "args": [
            "page"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "page_to_pfn(page)"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "magic == NODE_INFO"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "PAGES_PER_SECTION * sizeof(struct page)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "memmap"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void free_map_bootmem(struct page *memmap)\n{\n\tunsigned long maps_section_nr, removing_section_nr, i;\n\tunsigned long magic, nr_pages;\n\tstruct page *page = virt_to_page(memmap);\n\n\tnr_pages = PAGE_ALIGN(PAGES_PER_SECTION * sizeof(struct page))\n\t\t>> PAGE_SHIFT;\n\n\tfor (i = 0; i < nr_pages; i++, page++) {\n\t\tmagic = (unsigned long) page->freelist;\n\n\t\tBUG_ON(magic == NODE_INFO);\n\n\t\tmaps_section_nr = pfn_to_section_nr(page_to_pfn(page));\n\t\tremoving_section_nr = page_private(page);\n\n\t\t/*\n\t\t * When this function is called, the removing section is\n\t\t * logical offlined state. This means all pages are isolated\n\t\t * from page allocator. If removing section's memmap is placed\n\t\t * on the same section, it must not be freed.\n\t\t * If it is freed, page allocator may allocate it which will\n\t\t * be removed physically soon.\n\t\t */\n\t\tif (maps_section_nr != removing_section_nr)\n\t\t\tput_page_bootmem(page);\n\t}\n}"
  },
  {
    "function_name": "__kfree_section_memmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "617-625",
    "snippet": "static void __kfree_section_memmap(struct page *memmap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tif (is_vmalloc_addr(memmap))\n\t\tvfree(memmap);\n\telse\n\t\tfree_pages((unsigned long)memmap,\n\t\t\t   get_order(sizeof(struct page) * PAGES_PER_SECTION));\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)memmap",
            "get_order(sizeof(struct page) * PAGES_PER_SECTION)"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4630-4639",
          "snippet": "void free_pages_exact(void *virt, size_t size)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\n\twhile (addr < end) {\n\t\tfree_page(addr);\n\t\taddr += PAGE_SIZE;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid free_pages_exact(void *virt, size_t size)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\n\twhile (addr < end) {\n\t\tfree_page(addr);\n\t\taddr += PAGE_SIZE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "sizeof(struct page) * PAGES_PER_SECTION"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "memmap"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "vfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "224-227",
          "snippet": "void vfree(const void *addr)\n{\n\tkfree(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid vfree(const void *addr)\n{\n\tkfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "memmap"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __kfree_section_memmap(struct page *memmap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tif (is_vmalloc_addr(memmap))\n\t\tvfree(memmap);\n\telse\n\t\tfree_pages((unsigned long)memmap,\n\t\t\t   get_order(sizeof(struct page) * PAGES_PER_SECTION));\n}"
  },
  {
    "function_name": "kmalloc_section_memmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "611-615",
    "snippet": "static inline struct page *kmalloc_section_memmap(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\treturn __kmalloc_section_memmap();\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kmalloc_section_memmap",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_section_memmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "590-609",
          "snippet": "static struct page *__kmalloc_section_memmap(void)\n{\n\tstruct page *page, *ret;\n\tunsigned long memmap_size = sizeof(struct page) * PAGES_PER_SECTION;\n\n\tpage = alloc_pages(GFP_KERNEL|__GFP_NOWARN, get_order(memmap_size));\n\tif (page)\n\t\tgoto got_map_page;\n\n\tret = vmalloc(memmap_size);\n\tif (ret)\n\t\tgoto got_map_ptr;\n\n\treturn NULL;\ngot_map_page:\n\tret = (struct page *)pfn_to_kaddr(page_to_pfn(page));\ngot_map_ptr:\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct page *__kmalloc_section_memmap(void)\n{\n\tstruct page *page, *ret;\n\tunsigned long memmap_size = sizeof(struct page) * PAGES_PER_SECTION;\n\n\tpage = alloc_pages(GFP_KERNEL|__GFP_NOWARN, get_order(memmap_size));\n\tif (page)\n\t\tgoto got_map_page;\n\n\tret = vmalloc(memmap_size);\n\tif (ret)\n\t\tgoto got_map_ptr;\n\n\treturn NULL;\ngot_map_page:\n\tret = (struct page *)pfn_to_kaddr(page_to_pfn(page));\ngot_map_ptr:\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline struct page *kmalloc_section_memmap(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\treturn __kmalloc_section_memmap();\n}"
  },
  {
    "function_name": "__kmalloc_section_memmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "590-609",
    "snippet": "static struct page *__kmalloc_section_memmap(void)\n{\n\tstruct page *page, *ret;\n\tunsigned long memmap_size = sizeof(struct page) * PAGES_PER_SECTION;\n\n\tpage = alloc_pages(GFP_KERNEL|__GFP_NOWARN, get_order(memmap_size));\n\tif (page)\n\t\tgoto got_map_page;\n\n\tret = vmalloc(memmap_size);\n\tif (ret)\n\t\tgoto got_map_ptr;\n\n\treturn NULL;\ngot_map_page:\n\tret = (struct page *)pfn_to_kaddr(page_to_pfn(page));\ngot_map_ptr:\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_to_kaddr",
          "args": [
            "page_to_pfn(page)"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "memmap_size"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_32_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "407-414",
          "snippet": "void *vmalloc_32_user(unsigned long size)\n{\n\t/*\n\t * We'll have to sort out the ZONE_DMA bits for 64-bit,\n\t * but for now this can simply use vmalloc_user() directly.\n\t */\n\treturn vmalloc_user(size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid *vmalloc_32_user(unsigned long size)\n{\n\t/*\n\t * We'll have to sort out the ZONE_DMA bits for 64-bit,\n\t * but for now this can simply use vmalloc_user() directly.\n\t */\n\treturn vmalloc_user(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "GFP_KERNEL|__GFP_NOWARN",
            "get_order(memmap_size)"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4594-4601",
          "snippet": "void *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "memmap_size"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct page *__kmalloc_section_memmap(void)\n{\n\tstruct page *page, *ret;\n\tunsigned long memmap_size = sizeof(struct page) * PAGES_PER_SECTION;\n\n\tpage = alloc_pages(GFP_KERNEL|__GFP_NOWARN, get_order(memmap_size));\n\tif (page)\n\t\tgoto got_map_page;\n\n\tret = vmalloc(memmap_size);\n\tif (ret)\n\t\tgoto got_map_ptr;\n\n\treturn NULL;\ngot_map_page:\n\tret = (struct page *)pfn_to_kaddr(page_to_pfn(page));\ngot_map_ptr:\n\n\treturn ret;\n}"
  },
  {
    "function_name": "free_map_bootmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "581-587",
    "snippet": "static void free_map_bootmem(struct page *memmap)\n{\n\tunsigned long start = (unsigned long)memmap;\n\tunsigned long end = (unsigned long)(memmap + PAGES_PER_SECTION);\n\n\tvmemmap_free(start, end, NULL);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmemmap_free",
          "args": [
            "start",
            "end",
            "NULL"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void free_map_bootmem(struct page *memmap)\n{\n\tunsigned long start = (unsigned long)memmap;\n\tunsigned long end = (unsigned long)(memmap + PAGES_PER_SECTION);\n\n\tvmemmap_free(start, end, NULL);\n}"
  },
  {
    "function_name": "__kfree_section_memmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "572-579",
    "snippet": "static void __kfree_section_memmap(struct page *memmap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tunsigned long start = (unsigned long)memmap;\n\tunsigned long end = (unsigned long)(memmap + PAGES_PER_SECTION);\n\n\tvmemmap_free(start, end, altmap);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmemmap_free",
          "args": [
            "start",
            "end",
            "altmap"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __kfree_section_memmap(struct page *memmap,\n\t\tstruct vmem_altmap *altmap)\n{\n\tunsigned long start = (unsigned long)memmap;\n\tunsigned long end = (unsigned long)(memmap + PAGES_PER_SECTION);\n\n\tvmemmap_free(start, end, altmap);\n}"
  },
  {
    "function_name": "kmalloc_section_memmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "566-571",
    "snippet": "static inline struct page *kmalloc_section_memmap(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\t/* This will make the necessary allocations eventually. */\n\treturn sparse_mem_map_populate(pnum, nid, altmap);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sparse_mem_map_populate",
          "args": [
            "pnum",
            "nid",
            "altmap"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_mem_map_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "386-399",
          "snippet": "struct page __init *sparse_mem_map_populate(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\tunsigned long size = section_map_size();\n\tstruct page *map = sparse_buffer_alloc(size);\n\n\tif (map)\n\t\treturn map;\n\n\tmap = memblock_alloc_try_nid(size,\n\t\t\t\t\t  PAGE_SIZE, __pa(MAX_DMA_ADDRESS),\n\t\t\t\t\t  MEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\treturn map;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct page __init *sparse_mem_map_populate(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\tunsigned long size = section_map_size();\n\tstruct page *map = sparse_buffer_alloc(size);\n\n\tif (map)\n\t\treturn map;\n\n\tmap = memblock_alloc_try_nid(size,\n\t\t\t\t\t  PAGE_SIZE, __pa(MAX_DMA_ADDRESS),\n\t\t\t\t\t  MEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\treturn map;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline struct page *kmalloc_section_memmap(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\t/* This will make the necessary allocations eventually. */\n\treturn sparse_mem_map_populate(pnum, nid, altmap);\n}"
  },
  {
    "function_name": "offline_mem_sections",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "544-562",
    "snippet": "void offline_mem_sections(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\t/*\n\t\t * TODO this needs some double checking. Offlining code makes\n\t\t * sure to check pfn_valid but those checks might be just bogus\n\t\t */\n\t\tif (WARN_ON(!valid_section_nr(section_nr)))\n\t\t\tcontinue;\n\n\t\tms = __nr_to_section(section_nr);\n\t\tms->section_mem_map &= ~SECTION_IS_ONLINE;\n\t}\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "section_nr"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!valid_section_nr(section_nr)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_section_nr",
          "args": [
            "section_nr"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "pfn"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid offline_mem_sections(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\t/*\n\t\t * TODO this needs some double checking. Offlining code makes\n\t\t * sure to check pfn_valid but those checks might be just bogus\n\t\t */\n\t\tif (WARN_ON(!valid_section_nr(section_nr)))\n\t\t\tcontinue;\n\n\t\tms = __nr_to_section(section_nr);\n\t\tms->section_mem_map &= ~SECTION_IS_ONLINE;\n\t}\n}"
  },
  {
    "function_name": "online_mem_sections",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "525-540",
    "snippet": "void online_mem_sections(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\t/* onlining code should never touch invalid ranges */\n\t\tif (WARN_ON(!valid_section_nr(section_nr)))\n\t\t\tcontinue;\n\n\t\tms = __nr_to_section(section_nr);\n\t\tms->section_mem_map |= SECTION_IS_ONLINE;\n\t}\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "section_nr"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!valid_section_nr(section_nr)"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_section_nr",
          "args": [
            "section_nr"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "pfn"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid online_mem_sections(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\t/* onlining code should never touch invalid ranges */\n\t\tif (WARN_ON(!valid_section_nr(section_nr)))\n\t\t\tcontinue;\n\n\t\tms = __nr_to_section(section_nr);\n\t\tms->section_mem_map |= SECTION_IS_ONLINE;\n\t}\n}"
  },
  {
    "function_name": "sparse_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "495-520",
    "snippet": "void __init sparse_init(void)\n{\n\tunsigned long pnum_begin = first_present_section_nr();\n\tint nid_begin = sparse_early_nid(__nr_to_section(pnum_begin));\n\tunsigned long pnum_end, map_count = 1;\n\n\t/* Setup pageblock_order for HUGETLB_PAGE_SIZE_VARIABLE */\n\tset_pageblock_order();\n\n\tfor_each_present_section_nr(pnum_begin + 1, pnum_end) {\n\t\tint nid = sparse_early_nid(__nr_to_section(pnum_end));\n\n\t\tif (nid == nid_begin) {\n\t\t\tmap_count++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Init node with sections in range [pnum_begin, pnum_end) */\n\t\tsparse_init_nid(nid_begin, pnum_begin, pnum_end, map_count);\n\t\tnid_begin = nid;\n\t\tpnum_begin = pnum_end;\n\t\tmap_count = 1;\n\t}\n\t/* cover the last node */\n\tsparse_init_nid(nid_begin, pnum_begin, pnum_end, map_count);\n\tvmemmap_populate_print_last();\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmemmap_populate_print_last",
          "args": [],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "vmemmap_populate_print_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "438-440",
          "snippet": "__meminit vmemmap_populate_print_last(void)\n{\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n__meminit vmemmap_populate_print_last(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "sparse_init_nid",
          "args": [
            "nid_begin",
            "pnum_begin",
            "pnum_end",
            "map_count"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_init_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "446-489",
          "snippet": "static void __init sparse_init_nid(int nid, unsigned long pnum_begin,\n\t\t\t\t   unsigned long pnum_end,\n\t\t\t\t   unsigned long map_count)\n{\n\tunsigned long pnum, usemap_longs, *usemap;\n\tstruct page *map;\n\n\tusemap_longs = BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS);\n\tusemap = sparse_early_usemaps_alloc_pgdat_section(NODE_DATA(nid),\n\t\t\t\t\t\t\t  usemap_size() *\n\t\t\t\t\t\t\t  map_count);\n\tif (!usemap) {\n\t\tpr_err(\"%s: node[%d] usemap allocation failed\", __func__, nid);\n\t\tgoto failed;\n\t}\n\tsparse_buffer_init(map_count * section_map_size(), nid);\n\tfor_each_present_section_nr(pnum_begin, pnum) {\n\t\tif (pnum >= pnum_end)\n\t\t\tbreak;\n\n\t\tmap = sparse_mem_map_populate(pnum, nid, NULL);\n\t\tif (!map) {\n\t\t\tpr_err(\"%s: node[%d] memory map backing failed. Some memory will not be available.\",\n\t\t\t       __func__, nid);\n\t\t\tpnum_begin = pnum;\n\t\t\tgoto failed;\n\t\t}\n\t\tcheck_usemap_section_nr(nid, usemap);\n\t\tsparse_init_one_section(__nr_to_section(pnum), pnum, map, usemap);\n\t\tusemap += usemap_longs;\n\t}\n\tsparse_buffer_fini();\n\treturn;\nfailed:\n\t/* We failed to allocate, mark all the following pnums as not present */\n\tfor_each_present_section_nr(pnum_begin, pnum) {\n\t\tstruct mem_section *ms;\n\n\t\tif (pnum >= pnum_end)\n\t\t\tbreak;\n\t\tms = __nr_to_section(pnum);\n\t\tms->section_mem_map = 0;\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __init sparse_init_nid(int nid, unsigned long pnum_begin,\n\t\t\t\t   unsigned long pnum_end,\n\t\t\t\t   unsigned long map_count)\n{\n\tunsigned long pnum, usemap_longs, *usemap;\n\tstruct page *map;\n\n\tusemap_longs = BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS);\n\tusemap = sparse_early_usemaps_alloc_pgdat_section(NODE_DATA(nid),\n\t\t\t\t\t\t\t  usemap_size() *\n\t\t\t\t\t\t\t  map_count);\n\tif (!usemap) {\n\t\tpr_err(\"%s: node[%d] usemap allocation failed\", __func__, nid);\n\t\tgoto failed;\n\t}\n\tsparse_buffer_init(map_count * section_map_size(), nid);\n\tfor_each_present_section_nr(pnum_begin, pnum) {\n\t\tif (pnum >= pnum_end)\n\t\t\tbreak;\n\n\t\tmap = sparse_mem_map_populate(pnum, nid, NULL);\n\t\tif (!map) {\n\t\t\tpr_err(\"%s: node[%d] memory map backing failed. Some memory will not be available.\",\n\t\t\t       __func__, nid);\n\t\t\tpnum_begin = pnum;\n\t\t\tgoto failed;\n\t\t}\n\t\tcheck_usemap_section_nr(nid, usemap);\n\t\tsparse_init_one_section(__nr_to_section(pnum), pnum, map, usemap);\n\t\tusemap += usemap_longs;\n\t}\n\tsparse_buffer_fini();\n\treturn;\nfailed:\n\t/* We failed to allocate, mark all the following pnums as not present */\n\tfor_each_present_section_nr(pnum_begin, pnum) {\n\t\tstruct mem_section *ms;\n\n\t\tif (pnum >= pnum_end)\n\t\t\tbreak;\n\t\tms = __nr_to_section(pnum);\n\t\tms->section_mem_map = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sparse_early_nid",
          "args": [
            "__nr_to_section(pnum_end)"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_early_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "137-140",
          "snippet": "static inline int sparse_early_nid(struct mem_section *section)\n{\n\treturn (section->section_mem_map >> SECTION_NID_SHIFT);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int sparse_early_nid(struct mem_section *section)\n{\n\treturn (section->section_mem_map >> SECTION_NID_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "pnum_end"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_present_section_nr",
          "args": [
            "pnum_begin + 1",
            "pnum_end"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pageblock_order",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "pnum_begin"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_present_section_nr",
          "args": [],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "first_present_section_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "204-207",
          "snippet": "static inline unsigned long first_present_section_nr(void)\n{\n\treturn next_present_section_nr(-1);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long first_present_section_nr(void)\n{\n\treturn next_present_section_nr(-1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __init sparse_init(void)\n{\n\tunsigned long pnum_begin = first_present_section_nr();\n\tint nid_begin = sparse_early_nid(__nr_to_section(pnum_begin));\n\tunsigned long pnum_end, map_count = 1;\n\n\t/* Setup pageblock_order for HUGETLB_PAGE_SIZE_VARIABLE */\n\tset_pageblock_order();\n\n\tfor_each_present_section_nr(pnum_begin + 1, pnum_end) {\n\t\tint nid = sparse_early_nid(__nr_to_section(pnum_end));\n\n\t\tif (nid == nid_begin) {\n\t\t\tmap_count++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Init node with sections in range [pnum_begin, pnum_end) */\n\t\tsparse_init_nid(nid_begin, pnum_begin, pnum_end, map_count);\n\t\tnid_begin = nid;\n\t\tpnum_begin = pnum_end;\n\t\tmap_count = 1;\n\t}\n\t/* cover the last node */\n\tsparse_init_nid(nid_begin, pnum_begin, pnum_end, map_count);\n\tvmemmap_populate_print_last();\n}"
  },
  {
    "function_name": "sparse_init_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "446-489",
    "snippet": "static void __init sparse_init_nid(int nid, unsigned long pnum_begin,\n\t\t\t\t   unsigned long pnum_end,\n\t\t\t\t   unsigned long map_count)\n{\n\tunsigned long pnum, usemap_longs, *usemap;\n\tstruct page *map;\n\n\tusemap_longs = BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS);\n\tusemap = sparse_early_usemaps_alloc_pgdat_section(NODE_DATA(nid),\n\t\t\t\t\t\t\t  usemap_size() *\n\t\t\t\t\t\t\t  map_count);\n\tif (!usemap) {\n\t\tpr_err(\"%s: node[%d] usemap allocation failed\", __func__, nid);\n\t\tgoto failed;\n\t}\n\tsparse_buffer_init(map_count * section_map_size(), nid);\n\tfor_each_present_section_nr(pnum_begin, pnum) {\n\t\tif (pnum >= pnum_end)\n\t\t\tbreak;\n\n\t\tmap = sparse_mem_map_populate(pnum, nid, NULL);\n\t\tif (!map) {\n\t\t\tpr_err(\"%s: node[%d] memory map backing failed. Some memory will not be available.\",\n\t\t\t       __func__, nid);\n\t\t\tpnum_begin = pnum;\n\t\t\tgoto failed;\n\t\t}\n\t\tcheck_usemap_section_nr(nid, usemap);\n\t\tsparse_init_one_section(__nr_to_section(pnum), pnum, map, usemap);\n\t\tusemap += usemap_longs;\n\t}\n\tsparse_buffer_fini();\n\treturn;\nfailed:\n\t/* We failed to allocate, mark all the following pnums as not present */\n\tfor_each_present_section_nr(pnum_begin, pnum) {\n\t\tstruct mem_section *ms;\n\n\t\tif (pnum >= pnum_end)\n\t\t\tbreak;\n\t\tms = __nr_to_section(pnum);\n\t\tms->section_mem_map = 0;\n\t}\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "pnum"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_present_section_nr",
          "args": [
            "pnum_begin",
            "pnum"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sparse_buffer_fini",
          "args": [],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_buffer_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "415-422",
          "snippet": "static void __init sparse_buffer_fini(void)\n{\n\tunsigned long size = sparsemap_buf_end - sparsemap_buf;\n\n\tif (sparsemap_buf && size > 0)\n\t\tmemblock_free_early(__pa(sparsemap_buf), size);\n\tsparsemap_buf = NULL;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *sparsemap_buf",
            "static void *sparsemap_buf_end"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void *sparsemap_buf;\nstatic void *sparsemap_buf_end;\n\nstatic void __init sparse_buffer_fini(void)\n{\n\tunsigned long size = sparsemap_buf_end - sparsemap_buf;\n\n\tif (sparsemap_buf && size > 0)\n\t\tmemblock_free_early(__pa(sparsemap_buf), size);\n\tsparsemap_buf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sparse_init_one_section",
          "args": [
            "__nr_to_section(pnum)",
            "pnum",
            "map",
            "usemap"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_init_one_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "266-274",
          "snippet": "static void __meminit sparse_init_one_section(struct mem_section *ms,\n\t\tunsigned long pnum, struct page *mem_map,\n\t\tunsigned long *pageblock_bitmap)\n{\n\tms->section_mem_map &= ~SECTION_MAP_MASK;\n\tms->section_mem_map |= sparse_encode_mem_map(mem_map, pnum) |\n\t\t\t\t\t\t\tSECTION_HAS_MEM_MAP;\n \tms->pageblock_flags = pageblock_bitmap;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __meminit sparse_init_one_section(struct mem_section *ms,\n\t\tunsigned long pnum, struct page *mem_map,\n\t\tunsigned long *pageblock_bitmap)\n{\n\tms->section_mem_map &= ~SECTION_MAP_MASK;\n\tms->section_mem_map |= sparse_encode_mem_map(mem_map, pnum) |\n\t\t\t\t\t\t\tSECTION_HAS_MEM_MAP;\n \tms->pageblock_flags = pageblock_bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "pnum"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_usemap_section_nr",
          "args": [
            "nid",
            "usemap"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "check_usemap_section_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "369-371",
          "snippet": "static void __init check_usemap_section_nr(int nid, unsigned long *usemap)\n{\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __init check_usemap_section_nr(int nid, unsigned long *usemap)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: node[%d] memory map backing failed. Some memory will not be available.\"",
            "__func__",
            "nid"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sparse_mem_map_populate",
          "args": [
            "pnum",
            "nid",
            "NULL"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_mem_map_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "386-399",
          "snippet": "struct page __init *sparse_mem_map_populate(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\tunsigned long size = section_map_size();\n\tstruct page *map = sparse_buffer_alloc(size);\n\n\tif (map)\n\t\treturn map;\n\n\tmap = memblock_alloc_try_nid(size,\n\t\t\t\t\t  PAGE_SIZE, __pa(MAX_DMA_ADDRESS),\n\t\t\t\t\t  MEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\treturn map;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct page __init *sparse_mem_map_populate(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\tunsigned long size = section_map_size();\n\tstruct page *map = sparse_buffer_alloc(size);\n\n\tif (map)\n\t\treturn map;\n\n\tmap = memblock_alloc_try_nid(size,\n\t\t\t\t\t  PAGE_SIZE, __pa(MAX_DMA_ADDRESS),\n\t\t\t\t\t  MEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_present_section_nr",
          "args": [
            "pnum_begin",
            "pnum"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sparse_buffer_init",
          "args": [
            "map_count * section_map_size()",
            "nid"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_buffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "405-413",
          "snippet": "static void __init sparse_buffer_init(unsigned long size, int nid)\n{\n\tWARN_ON(sparsemap_buf);\t/* forgot to call sparse_buffer_fini()? */\n\tsparsemap_buf =\n\t\tmemblock_alloc_try_nid_raw(size, PAGE_SIZE,\n\t\t\t\t\t\t__pa(MAX_DMA_ADDRESS),\n\t\t\t\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\tsparsemap_buf_end = sparsemap_buf + size;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *sparsemap_buf",
            "static void *sparsemap_buf_end"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void *sparsemap_buf;\nstatic void *sparsemap_buf_end;\n\nstatic void __init sparse_buffer_init(unsigned long size, int nid)\n{\n\tWARN_ON(sparsemap_buf);\t/* forgot to call sparse_buffer_fini()? */\n\tsparsemap_buf =\n\t\tmemblock_alloc_try_nid_raw(size, PAGE_SIZE,\n\t\t\t\t\t\t__pa(MAX_DMA_ADDRESS),\n\t\t\t\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\tsparsemap_buf_end = sparsemap_buf + size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "section_map_size",
          "args": [],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "section_map_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "381-384",
          "snippet": "static unsigned long __init section_map_size(void)\n{\n\treturn PAGE_ALIGN(sizeof(struct page) * PAGES_PER_SECTION);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic unsigned long __init section_map_size(void)\n{\n\treturn PAGE_ALIGN(sizeof(struct page) * PAGES_PER_SECTION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: node[%d] usemap allocation failed\"",
            "__func__",
            "nid"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sparse_early_usemaps_alloc_pgdat_section",
          "args": [
            "NODE_DATA(nid)",
            "usemap_size() *\n\t\t\t\t\t\t\t  map_count"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_early_usemaps_alloc_pgdat_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "362-367",
          "snippet": "static unsigned long * __init\nsparse_early_usemaps_alloc_pgdat_section(struct pglist_data *pgdat,\n\t\t\t\t\t unsigned long size)\n{\n\treturn memblock_alloc_node_nopanic(size, pgdat->node_id);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic unsigned long * __init\nsparse_early_usemaps_alloc_pgdat_section(struct pglist_data *pgdat,\n\t\t\t\t\t unsigned long size)\n{\n\treturn memblock_alloc_node_nopanic(size, pgdat->node_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usemap_size",
          "args": [],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "usemap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "276-279",
          "snippet": "unsigned long usemap_size(void)\n{\n\treturn BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS) * sizeof(unsigned long);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nunsigned long usemap_size(void)\n{\n\treturn BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS) * sizeof(unsigned long);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "SECTION_BLOCKFLAGS_BITS"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __init sparse_init_nid(int nid, unsigned long pnum_begin,\n\t\t\t\t   unsigned long pnum_end,\n\t\t\t\t   unsigned long map_count)\n{\n\tunsigned long pnum, usemap_longs, *usemap;\n\tstruct page *map;\n\n\tusemap_longs = BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS);\n\tusemap = sparse_early_usemaps_alloc_pgdat_section(NODE_DATA(nid),\n\t\t\t\t\t\t\t  usemap_size() *\n\t\t\t\t\t\t\t  map_count);\n\tif (!usemap) {\n\t\tpr_err(\"%s: node[%d] usemap allocation failed\", __func__, nid);\n\t\tgoto failed;\n\t}\n\tsparse_buffer_init(map_count * section_map_size(), nid);\n\tfor_each_present_section_nr(pnum_begin, pnum) {\n\t\tif (pnum >= pnum_end)\n\t\t\tbreak;\n\n\t\tmap = sparse_mem_map_populate(pnum, nid, NULL);\n\t\tif (!map) {\n\t\t\tpr_err(\"%s: node[%d] memory map backing failed. Some memory will not be available.\",\n\t\t\t       __func__, nid);\n\t\t\tpnum_begin = pnum;\n\t\t\tgoto failed;\n\t\t}\n\t\tcheck_usemap_section_nr(nid, usemap);\n\t\tsparse_init_one_section(__nr_to_section(pnum), pnum, map, usemap);\n\t\tusemap += usemap_longs;\n\t}\n\tsparse_buffer_fini();\n\treturn;\nfailed:\n\t/* We failed to allocate, mark all the following pnums as not present */\n\tfor_each_present_section_nr(pnum_begin, pnum) {\n\t\tstruct mem_section *ms;\n\n\t\tif (pnum >= pnum_end)\n\t\t\tbreak;\n\t\tms = __nr_to_section(pnum);\n\t\tms->section_mem_map = 0;\n\t}\n}"
  },
  {
    "function_name": "vmemmap_populate_print_last",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "438-440",
    "snippet": "__meminit vmemmap_populate_print_last(void)\n{\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n__meminit vmemmap_populate_print_last(void)\n{\n}"
  },
  {
    "function_name": "sparse_buffer_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "424-436",
    "snippet": "void * __meminit sparse_buffer_alloc(unsigned long size)\n{\n\tvoid *ptr = NULL;\n\n\tif (sparsemap_buf) {\n\t\tptr = PTR_ALIGN(sparsemap_buf, size);\n\t\tif (ptr + size > sparsemap_buf_end)\n\t\t\tptr = NULL;\n\t\telse\n\t\t\tsparsemap_buf = ptr + size;\n\t}\n\treturn ptr;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *sparsemap_buf",
      "static void *sparsemap_buf_end"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ALIGN",
          "args": [
            "sparsemap_buf",
            "size"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void *sparsemap_buf;\nstatic void *sparsemap_buf_end;\n\nvoid * __meminit sparse_buffer_alloc(unsigned long size)\n{\n\tvoid *ptr = NULL;\n\n\tif (sparsemap_buf) {\n\t\tptr = PTR_ALIGN(sparsemap_buf, size);\n\t\tif (ptr + size > sparsemap_buf_end)\n\t\t\tptr = NULL;\n\t\telse\n\t\t\tsparsemap_buf = ptr + size;\n\t}\n\treturn ptr;\n}"
  },
  {
    "function_name": "sparse_buffer_fini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "415-422",
    "snippet": "static void __init sparse_buffer_fini(void)\n{\n\tunsigned long size = sparsemap_buf_end - sparsemap_buf;\n\n\tif (sparsemap_buf && size > 0)\n\t\tmemblock_free_early(__pa(sparsemap_buf), size);\n\tsparsemap_buf = NULL;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *sparsemap_buf",
      "static void *sparsemap_buf_end"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_free_early",
          "args": [
            "__pa(sparsemap_buf)",
            "size"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "__memblock_free_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1547-1555",
          "snippet": "void __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sparsemap_buf"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void *sparsemap_buf;\nstatic void *sparsemap_buf_end;\n\nstatic void __init sparse_buffer_fini(void)\n{\n\tunsigned long size = sparsemap_buf_end - sparsemap_buf;\n\n\tif (sparsemap_buf && size > 0)\n\t\tmemblock_free_early(__pa(sparsemap_buf), size);\n\tsparsemap_buf = NULL;\n}"
  },
  {
    "function_name": "sparse_buffer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "405-413",
    "snippet": "static void __init sparse_buffer_init(unsigned long size, int nid)\n{\n\tWARN_ON(sparsemap_buf);\t/* forgot to call sparse_buffer_fini()? */\n\tsparsemap_buf =\n\t\tmemblock_alloc_try_nid_raw(size, PAGE_SIZE,\n\t\t\t\t\t\t__pa(MAX_DMA_ADDRESS),\n\t\t\t\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\tsparsemap_buf_end = sparsemap_buf + size;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *sparsemap_buf",
      "static void *sparsemap_buf_end"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_try_nid_raw",
          "args": [
            "size",
            "PAGE_SIZE",
            "__pa(MAX_DMA_ADDRESS)",
            "MEMBLOCK_ALLOC_ACCESSIBLE",
            "nid"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_try_nid_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1445-1462",
          "snippet": "void * __init memblock_alloc_try_nid_raw(\n\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr && size > 0)\n\t\tpage_init_poison(ptr, size);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid * __init memblock_alloc_try_nid_raw(\n\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr && size > 0)\n\t\tpage_init_poison(ptr, size);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "MAX_DMA_ADDRESS"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sparsemap_buf"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void *sparsemap_buf;\nstatic void *sparsemap_buf_end;\n\nstatic void __init sparse_buffer_init(unsigned long size, int nid)\n{\n\tWARN_ON(sparsemap_buf);\t/* forgot to call sparse_buffer_fini()? */\n\tsparsemap_buf =\n\t\tmemblock_alloc_try_nid_raw(size, PAGE_SIZE,\n\t\t\t\t\t\t__pa(MAX_DMA_ADDRESS),\n\t\t\t\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\tsparsemap_buf_end = sparsemap_buf + size;\n}"
  },
  {
    "function_name": "sparse_mem_map_populate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "386-399",
    "snippet": "struct page __init *sparse_mem_map_populate(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\tunsigned long size = section_map_size();\n\tstruct page *map = sparse_buffer_alloc(size);\n\n\tif (map)\n\t\treturn map;\n\n\tmap = memblock_alloc_try_nid(size,\n\t\t\t\t\t  PAGE_SIZE, __pa(MAX_DMA_ADDRESS),\n\t\t\t\t\t  MEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\treturn map;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_try_nid",
          "args": [
            "size",
            "PAGE_SIZE",
            "__pa(MAX_DMA_ADDRESS)",
            "MEMBLOCK_ALLOC_ACCESSIBLE",
            "nid"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_try_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1517-1537",
          "snippet": "void * __init memblock_alloc_try_nid(\n\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr) {\n\t\tmemset(ptr, 0, size);\n\t\treturn ptr;\n\t}\n\n\tpanic(\"%s: Failed to allocate %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa\\n\",\n\t      __func__, (u64)size, (u64)align, nid, &min_addr, &max_addr);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid * __init memblock_alloc_try_nid(\n\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr) {\n\t\tmemset(ptr, 0, size);\n\t\treturn ptr;\n\t}\n\n\tpanic(\"%s: Failed to allocate %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa\\n\",\n\t      __func__, (u64)size, (u64)align, nid, &min_addr, &max_addr);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "MAX_DMA_ADDRESS"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sparse_buffer_alloc",
          "args": [
            "size"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_buffer_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "424-436",
          "snippet": "void * __meminit sparse_buffer_alloc(unsigned long size)\n{\n\tvoid *ptr = NULL;\n\n\tif (sparsemap_buf) {\n\t\tptr = PTR_ALIGN(sparsemap_buf, size);\n\t\tif (ptr + size > sparsemap_buf_end)\n\t\t\tptr = NULL;\n\t\telse\n\t\t\tsparsemap_buf = ptr + size;\n\t}\n\treturn ptr;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *sparsemap_buf",
            "static void *sparsemap_buf_end"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void *sparsemap_buf;\nstatic void *sparsemap_buf_end;\n\nvoid * __meminit sparse_buffer_alloc(unsigned long size)\n{\n\tvoid *ptr = NULL;\n\n\tif (sparsemap_buf) {\n\t\tptr = PTR_ALIGN(sparsemap_buf, size);\n\t\tif (ptr + size > sparsemap_buf_end)\n\t\t\tptr = NULL;\n\t\telse\n\t\t\tsparsemap_buf = ptr + size;\n\t}\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "section_map_size",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "section_map_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "381-384",
          "snippet": "static unsigned long __init section_map_size(void)\n{\n\treturn PAGE_ALIGN(sizeof(struct page) * PAGES_PER_SECTION);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic unsigned long __init section_map_size(void)\n{\n\treturn PAGE_ALIGN(sizeof(struct page) * PAGES_PER_SECTION);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct page __init *sparse_mem_map_populate(unsigned long pnum, int nid,\n\t\tstruct vmem_altmap *altmap)\n{\n\tunsigned long size = section_map_size();\n\tstruct page *map = sparse_buffer_alloc(size);\n\n\tif (map)\n\t\treturn map;\n\n\tmap = memblock_alloc_try_nid(size,\n\t\t\t\t\t  PAGE_SIZE, __pa(MAX_DMA_ADDRESS),\n\t\t\t\t\t  MEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\treturn map;\n}"
  },
  {
    "function_name": "section_map_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "381-384",
    "snippet": "static unsigned long __init section_map_size(void)\n{\n\treturn PAGE_ALIGN(sizeof(struct page) * PAGES_PER_SECTION);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "sizeof(struct page) * PAGES_PER_SECTION"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic unsigned long __init section_map_size(void)\n{\n\treturn PAGE_ALIGN(sizeof(struct page) * PAGES_PER_SECTION);\n}"
  },
  {
    "function_name": "section_map_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "375-378",
    "snippet": "static unsigned long __init section_map_size(void)\n{\n\treturn ALIGN(sizeof(struct page) * PAGES_PER_SECTION, PMD_SIZE);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "sizeof(struct page) * PAGES_PER_SECTION",
            "PMD_SIZE"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic unsigned long __init section_map_size(void)\n{\n\treturn ALIGN(sizeof(struct page) * PAGES_PER_SECTION, PMD_SIZE);\n}"
  },
  {
    "function_name": "check_usemap_section_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "369-371",
    "snippet": "static void __init check_usemap_section_nr(int nid, unsigned long *usemap)\n{\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __init check_usemap_section_nr(int nid, unsigned long *usemap)\n{\n}"
  },
  {
    "function_name": "sparse_early_usemaps_alloc_pgdat_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "362-367",
    "snippet": "static unsigned long * __init\nsparse_early_usemaps_alloc_pgdat_section(struct pglist_data *pgdat,\n\t\t\t\t\t unsigned long size)\n{\n\treturn memblock_alloc_node_nopanic(size, pgdat->node_id);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_node_nopanic",
          "args": [
            "size",
            "pgdat->node_id"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic unsigned long * __init\nsparse_early_usemaps_alloc_pgdat_section(struct pglist_data *pgdat,\n\t\t\t\t\t unsigned long size)\n{\n\treturn memblock_alloc_node_nopanic(size, pgdat->node_id);\n}"
  },
  {
    "function_name": "check_usemap_section_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "320-360",
    "snippet": "static void __init check_usemap_section_nr(int nid, unsigned long *usemap)\n{\n\tunsigned long usemap_snr, pgdat_snr;\n\tstatic unsigned long old_usemap_snr;\n\tstatic unsigned long old_pgdat_snr;\n\tstruct pglist_data *pgdat = NODE_DATA(nid);\n\tint usemap_nid;\n\n\t/* First call */\n\tif (!old_usemap_snr) {\n\t\told_usemap_snr = NR_MEM_SECTIONS;\n\t\told_pgdat_snr = NR_MEM_SECTIONS;\n\t}\n\n\tusemap_snr = pfn_to_section_nr(__pa(usemap) >> PAGE_SHIFT);\n\tpgdat_snr = pfn_to_section_nr(__pa(pgdat) >> PAGE_SHIFT);\n\tif (usemap_snr == pgdat_snr)\n\t\treturn;\n\n\tif (old_usemap_snr == usemap_snr && old_pgdat_snr == pgdat_snr)\n\t\t/* skip redundant message */\n\t\treturn;\n\n\told_usemap_snr = usemap_snr;\n\told_pgdat_snr = pgdat_snr;\n\n\tusemap_nid = sparse_early_nid(__nr_to_section(usemap_snr));\n\tif (usemap_nid != nid) {\n\t\tpr_info(\"node %d must be removed before remove section %ld\\n\",\n\t\t\tnid, usemap_snr);\n\t\treturn;\n\t}\n\t/*\n\t * There is a circular dependency.\n\t * Some platforms allow un-removable section because they will just\n\t * gather other removable sections for dynamic partitioning.\n\t * Just notify un-removable section's number here.\n\t */\n\tpr_info(\"Section %ld and %ld (node %d) have a circular dependency on usemap and pgdat allocations\\n\",\n\t\tusemap_snr, pgdat_snr, nid);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Section %ld and %ld (node %d) have a circular dependency on usemap and pgdat allocations\\n\"",
            "usemap_snr",
            "pgdat_snr",
            "nid"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"node %d must be removed before remove section %ld\\n\"",
            "nid",
            "usemap_snr"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sparse_early_nid",
          "args": [
            "__nr_to_section(usemap_snr)"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_early_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "137-140",
          "snippet": "static inline int sparse_early_nid(struct mem_section *section)\n{\n\treturn (section->section_mem_map >> SECTION_NID_SHIFT);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int sparse_early_nid(struct mem_section *section)\n{\n\treturn (section->section_mem_map >> SECTION_NID_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "usemap_snr"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "__pa(pgdat) >> PAGE_SHIFT"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "pgdat"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "__pa(usemap) >> PAGE_SHIFT"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __init check_usemap_section_nr(int nid, unsigned long *usemap)\n{\n\tunsigned long usemap_snr, pgdat_snr;\n\tstatic unsigned long old_usemap_snr;\n\tstatic unsigned long old_pgdat_snr;\n\tstruct pglist_data *pgdat = NODE_DATA(nid);\n\tint usemap_nid;\n\n\t/* First call */\n\tif (!old_usemap_snr) {\n\t\told_usemap_snr = NR_MEM_SECTIONS;\n\t\told_pgdat_snr = NR_MEM_SECTIONS;\n\t}\n\n\tusemap_snr = pfn_to_section_nr(__pa(usemap) >> PAGE_SHIFT);\n\tpgdat_snr = pfn_to_section_nr(__pa(pgdat) >> PAGE_SHIFT);\n\tif (usemap_snr == pgdat_snr)\n\t\treturn;\n\n\tif (old_usemap_snr == usemap_snr && old_pgdat_snr == pgdat_snr)\n\t\t/* skip redundant message */\n\t\treturn;\n\n\told_usemap_snr = usemap_snr;\n\told_pgdat_snr = pgdat_snr;\n\n\tusemap_nid = sparse_early_nid(__nr_to_section(usemap_snr));\n\tif (usemap_nid != nid) {\n\t\tpr_info(\"node %d must be removed before remove section %ld\\n\",\n\t\t\tnid, usemap_snr);\n\t\treturn;\n\t}\n\t/*\n\t * There is a circular dependency.\n\t * Some platforms allow un-removable section because they will just\n\t * gather other removable sections for dynamic partitioning.\n\t * Just notify un-removable section's number here.\n\t */\n\tpr_info(\"Section %ld and %ld (node %d) have a circular dependency on usemap and pgdat allocations\\n\",\n\t\tusemap_snr, pgdat_snr, nid);\n}"
  },
  {
    "function_name": "sparse_early_usemaps_alloc_pgdat_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "289-318",
    "snippet": "static unsigned long * __init\nsparse_early_usemaps_alloc_pgdat_section(struct pglist_data *pgdat,\n\t\t\t\t\t unsigned long size)\n{\n\tunsigned long goal, limit;\n\tunsigned long *p;\n\tint nid;\n\t/*\n\t * A page may contain usemaps for other sections preventing the\n\t * page being freed and making a section unremovable while\n\t * other sections referencing the usemap remain active. Similarly,\n\t * a pgdat can prevent a section being removed. If section A\n\t * contains a pgdat and section B contains the usemap, both\n\t * sections become inter-dependent. This allocates usemaps\n\t * from the same section as the pgdat where possible to avoid\n\t * this problem.\n\t */\n\tgoal = __pa(pgdat) & (PAGE_SECTION_MASK << PAGE_SHIFT);\n\tlimit = goal + (1UL << PA_SECTION_SHIFT);\n\tnid = early_pfn_to_nid(goal >> PAGE_SHIFT);\nagain:\n\tp = memblock_alloc_try_nid_nopanic(size,\n\t\t\t\t\t\tSMP_CACHE_BYTES, goal, limit,\n\t\t\t\t\t\tnid);\n\tif (!p && limit) {\n\t\tlimit = 0;\n\t\tgoto again;\n\t}\n\treturn p;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_try_nid_nopanic",
          "args": [
            "size",
            "SMP_CACHE_BYTES",
            "goal",
            "limit",
            "nid"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_try_nid_nopanic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1481-1497",
          "snippet": "void * __init memblock_alloc_try_nid_nopanic(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr)\n\t\tmemset(ptr, 0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid * __init memblock_alloc_try_nid_nopanic(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr)\n\t\tmemset(ptr, 0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_pfn_to_nid",
          "args": [
            "goal >> PAGE_SHIFT"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1292-1304",
          "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "pgdat"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic unsigned long * __init\nsparse_early_usemaps_alloc_pgdat_section(struct pglist_data *pgdat,\n\t\t\t\t\t unsigned long size)\n{\n\tunsigned long goal, limit;\n\tunsigned long *p;\n\tint nid;\n\t/*\n\t * A page may contain usemaps for other sections preventing the\n\t * page being freed and making a section unremovable while\n\t * other sections referencing the usemap remain active. Similarly,\n\t * a pgdat can prevent a section being removed. If section A\n\t * contains a pgdat and section B contains the usemap, both\n\t * sections become inter-dependent. This allocates usemaps\n\t * from the same section as the pgdat where possible to avoid\n\t * this problem.\n\t */\n\tgoal = __pa(pgdat) & (PAGE_SECTION_MASK << PAGE_SHIFT);\n\tlimit = goal + (1UL << PA_SECTION_SHIFT);\n\tnid = early_pfn_to_nid(goal >> PAGE_SHIFT);\nagain:\n\tp = memblock_alloc_try_nid_nopanic(size,\n\t\t\t\t\t\tSMP_CACHE_BYTES, goal, limit,\n\t\t\t\t\t\tnid);\n\tif (!p && limit) {\n\t\tlimit = 0;\n\t\tgoto again;\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "__kmalloc_section_usemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "282-285",
    "snippet": "static unsigned long *__kmalloc_section_usemap(void)\n{\n\treturn kmalloc(usemap_size(), GFP_KERNEL);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "usemap_size()",
            "GFP_KERNEL"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usemap_size",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "usemap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "276-279",
          "snippet": "unsigned long usemap_size(void)\n{\n\treturn BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS) * sizeof(unsigned long);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nunsigned long usemap_size(void)\n{\n\treturn BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS) * sizeof(unsigned long);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic unsigned long *__kmalloc_section_usemap(void)\n{\n\treturn kmalloc(usemap_size(), GFP_KERNEL);\n}"
  },
  {
    "function_name": "usemap_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "276-279",
    "snippet": "unsigned long usemap_size(void)\n{\n\treturn BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS) * sizeof(unsigned long);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "SECTION_BLOCKFLAGS_BITS"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nunsigned long usemap_size(void)\n{\n\treturn BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS) * sizeof(unsigned long);\n}"
  },
  {
    "function_name": "sparse_init_one_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "266-274",
    "snippet": "static void __meminit sparse_init_one_section(struct mem_section *ms,\n\t\tunsigned long pnum, struct page *mem_map,\n\t\tunsigned long *pageblock_bitmap)\n{\n\tms->section_mem_map &= ~SECTION_MAP_MASK;\n\tms->section_mem_map |= sparse_encode_mem_map(mem_map, pnum) |\n\t\t\t\t\t\t\tSECTION_HAS_MEM_MAP;\n \tms->pageblock_flags = pageblock_bitmap;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sparse_encode_mem_map",
          "args": [
            "mem_map",
            "pnum"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_encode_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "247-254",
          "snippet": "static unsigned long sparse_encode_mem_map(struct page *mem_map, unsigned long pnum)\n{\n\tunsigned long coded_mem_map =\n\t\t(unsigned long)(mem_map - (section_nr_to_pfn(pnum)));\n\tBUILD_BUG_ON(SECTION_MAP_LAST_BIT > (1UL<<PFN_SECTION_SHIFT));\n\tBUG_ON(coded_mem_map & ~SECTION_MAP_MASK);\n\treturn coded_mem_map;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic unsigned long sparse_encode_mem_map(struct page *mem_map, unsigned long pnum)\n{\n\tunsigned long coded_mem_map =\n\t\t(unsigned long)(mem_map - (section_nr_to_pfn(pnum)));\n\tBUILD_BUG_ON(SECTION_MAP_LAST_BIT > (1UL<<PFN_SECTION_SHIFT));\n\tBUG_ON(coded_mem_map & ~SECTION_MAP_MASK);\n\treturn coded_mem_map;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __meminit sparse_init_one_section(struct mem_section *ms,\n\t\tunsigned long pnum, struct page *mem_map,\n\t\tunsigned long *pageblock_bitmap)\n{\n\tms->section_mem_map &= ~SECTION_MAP_MASK;\n\tms->section_mem_map |= sparse_encode_mem_map(mem_map, pnum) |\n\t\t\t\t\t\t\tSECTION_HAS_MEM_MAP;\n \tms->pageblock_flags = pageblock_bitmap;\n}"
  },
  {
    "function_name": "sparse_decode_mem_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "259-264",
    "snippet": "struct page *sparse_decode_mem_map(unsigned long coded_mem_map, unsigned long pnum)\n{\n\t/* mask off the extra low bits of information */\n\tcoded_mem_map &= SECTION_MAP_MASK;\n\treturn ((struct page *)coded_mem_map) + section_nr_to_pfn(pnum);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "section_nr_to_pfn",
          "args": [
            "pnum"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct page *sparse_decode_mem_map(unsigned long coded_mem_map, unsigned long pnum)\n{\n\t/* mask off the extra low bits of information */\n\tcoded_mem_map &= SECTION_MAP_MASK;\n\treturn ((struct page *)coded_mem_map) + section_nr_to_pfn(pnum);\n}"
  },
  {
    "function_name": "sparse_encode_mem_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "247-254",
    "snippet": "static unsigned long sparse_encode_mem_map(struct page *mem_map, unsigned long pnum)\n{\n\tunsigned long coded_mem_map =\n\t\t(unsigned long)(mem_map - (section_nr_to_pfn(pnum)));\n\tBUILD_BUG_ON(SECTION_MAP_LAST_BIT > (1UL<<PFN_SECTION_SHIFT));\n\tBUG_ON(coded_mem_map & ~SECTION_MAP_MASK);\n\treturn coded_mem_map;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "coded_mem_map & ~SECTION_MAP_MASK"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "SECTION_MAP_LAST_BIT > (1UL<<PFN_SECTION_SHIFT)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "section_nr_to_pfn",
          "args": [
            "pnum"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic unsigned long sparse_encode_mem_map(struct page *mem_map, unsigned long pnum)\n{\n\tunsigned long coded_mem_map =\n\t\t(unsigned long)(mem_map - (section_nr_to_pfn(pnum)));\n\tBUILD_BUG_ON(SECTION_MAP_LAST_BIT > (1UL<<PFN_SECTION_SHIFT));\n\tBUG_ON(coded_mem_map & ~SECTION_MAP_MASK);\n\treturn coded_mem_map;\n}"
  },
  {
    "function_name": "memory_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "210-240",
    "snippet": "void __init memory_present(int nid, unsigned long start, unsigned long end)\n{\n\tunsigned long pfn;\n\n#ifdef CONFIG_SPARSEMEM_EXTREME\n\tif (unlikely(!mem_section)) {\n\t\tunsigned long size, align;\n\n\t\tsize = sizeof(struct mem_section*) * NR_SECTION_ROOTS;\n\t\talign = 1 << (INTERNODE_CACHE_SHIFT);\n\t\tmem_section = memblock_alloc(size, align);\n\t}\n#endif\n\n\tstart &= PAGE_SECTION_MASK;\n\tmminit_validate_memmodel_limits(&start, &end);\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\tsparse_index_init(section, nid);\n\t\tset_section_nid(section, nid);\n\n\t\tms = __nr_to_section(section);\n\t\tif (!ms->section_mem_map) {\n\t\t\tms->section_mem_map = sparse_encode_early_nid(nid) |\n\t\t\t\t\t\t\tSECTION_IS_ONLINE;\n\t\t\tsection_mark_present(ms);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "section_mark_present",
          "args": [
            "ms"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "section_mark_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "178-186",
          "snippet": "static void section_mark_present(struct mem_section *ms)\n{\n\tint section_nr = __section_nr(ms);\n\n\tif (section_nr > __highest_present_section_nr)\n\t\t__highest_present_section_nr = section_nr;\n\n\tms->section_mem_map |= SECTION_MARKED_PRESENT;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __highest_present_section_nr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __highest_present_section_nr;\n\nstatic void section_mark_present(struct mem_section *ms)\n{\n\tint section_nr = __section_nr(ms);\n\n\tif (section_nr > __highest_present_section_nr)\n\t\t__highest_present_section_nr = section_nr;\n\n\tms->section_mem_map |= SECTION_MARKED_PRESENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sparse_encode_early_nid",
          "args": [
            "nid"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_encode_early_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "132-135",
          "snippet": "static inline unsigned long sparse_encode_early_nid(int nid)\n{\n\treturn (nid << SECTION_NID_SHIFT);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long sparse_encode_early_nid(int nid)\n{\n\treturn (nid << SECTION_NID_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "section"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_section_nid",
          "args": [
            "section",
            "nid"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "set_section_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "56-58",
          "snippet": "static inline void set_section_nid(unsigned long section_nr, int nid)\n{\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void set_section_nid(unsigned long section_nr, int nid)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "sparse_index_init",
          "args": [
            "section",
            "nid"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_index_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "94-97",
          "snippet": "static inline int sparse_index_init(unsigned long section_nr, int nid)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int sparse_index_init(unsigned long section_nr, int nid)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "pfn"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mminit_validate_memmodel_limits",
          "args": [
            "&start",
            "&end"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "mminit_validate_memmodel_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "143-166",
          "snippet": "void __meminit mminit_validate_memmodel_limits(unsigned long *start_pfn,\n\t\t\t\t\t\tunsigned long *end_pfn)\n{\n\tunsigned long max_sparsemem_pfn = 1UL << (MAX_PHYSMEM_BITS-PAGE_SHIFT);\n\n\t/*\n\t * Sanity checks - do not allow an architecture to pass\n\t * in larger pfns than the maximum scope of sparsemem:\n\t */\n\tif (*start_pfn > max_sparsemem_pfn) {\n\t\tmminit_dprintk(MMINIT_WARNING, \"pfnvalidation\",\n\t\t\t\"Start of range %lu -> %lu exceeds SPARSEMEM max %lu\\n\",\n\t\t\t*start_pfn, *end_pfn, max_sparsemem_pfn);\n\t\tWARN_ON_ONCE(1);\n\t\t*start_pfn = max_sparsemem_pfn;\n\t\t*end_pfn = max_sparsemem_pfn;\n\t} else if (*end_pfn > max_sparsemem_pfn) {\n\t\tmminit_dprintk(MMINIT_WARNING, \"pfnvalidation\",\n\t\t\t\"End of range %lu -> %lu exceeds SPARSEMEM max %lu\\n\",\n\t\t\t*start_pfn, *end_pfn, max_sparsemem_pfn);\n\t\tWARN_ON_ONCE(1);\n\t\t*end_pfn = max_sparsemem_pfn;\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __meminit mminit_validate_memmodel_limits(unsigned long *start_pfn,\n\t\t\t\t\t\tunsigned long *end_pfn)\n{\n\tunsigned long max_sparsemem_pfn = 1UL << (MAX_PHYSMEM_BITS-PAGE_SHIFT);\n\n\t/*\n\t * Sanity checks - do not allow an architecture to pass\n\t * in larger pfns than the maximum scope of sparsemem:\n\t */\n\tif (*start_pfn > max_sparsemem_pfn) {\n\t\tmminit_dprintk(MMINIT_WARNING, \"pfnvalidation\",\n\t\t\t\"Start of range %lu -> %lu exceeds SPARSEMEM max %lu\\n\",\n\t\t\t*start_pfn, *end_pfn, max_sparsemem_pfn);\n\t\tWARN_ON_ONCE(1);\n\t\t*start_pfn = max_sparsemem_pfn;\n\t\t*end_pfn = max_sparsemem_pfn;\n\t} else if (*end_pfn > max_sparsemem_pfn) {\n\t\tmminit_dprintk(MMINIT_WARNING, \"pfnvalidation\",\n\t\t\t\"End of range %lu -> %lu exceeds SPARSEMEM max %lu\\n\",\n\t\t\t*start_pfn, *end_pfn, max_sparsemem_pfn);\n\t\tWARN_ON_ONCE(1);\n\t\t*end_pfn = max_sparsemem_pfn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "size",
            "align"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mem_section"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __init memory_present(int nid, unsigned long start, unsigned long end)\n{\n\tunsigned long pfn;\n\n#ifdef CONFIG_SPARSEMEM_EXTREME\n\tif (unlikely(!mem_section)) {\n\t\tunsigned long size, align;\n\n\t\tsize = sizeof(struct mem_section*) * NR_SECTION_ROOTS;\n\t\talign = 1 << (INTERNODE_CACHE_SHIFT);\n\t\tmem_section = memblock_alloc(size, align);\n\t}\n#endif\n\n\tstart &= PAGE_SECTION_MASK;\n\tmminit_validate_memmodel_limits(&start, &end);\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\tsparse_index_init(section, nid);\n\t\tset_section_nid(section, nid);\n\n\t\tms = __nr_to_section(section);\n\t\tif (!ms->section_mem_map) {\n\t\t\tms->section_mem_map = sparse_encode_early_nid(nid) |\n\t\t\t\t\t\t\tSECTION_IS_ONLINE;\n\t\t\tsection_mark_present(ms);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "first_present_section_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "204-207",
    "snippet": "static inline unsigned long first_present_section_nr(void)\n{\n\treturn next_present_section_nr(-1);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_present_section_nr",
          "args": [
            "-1"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "next_present_section_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "188-197",
          "snippet": "static inline int next_present_section_nr(int section_nr)\n{\n\tdo {\n\t\tsection_nr++;\n\t\tif (present_section_nr(section_nr))\n\t\t\treturn section_nr;\n\t} while ((section_nr <= __highest_present_section_nr));\n\n\treturn -1;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __highest_present_section_nr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __highest_present_section_nr;\n\nstatic inline int next_present_section_nr(int section_nr)\n{\n\tdo {\n\t\tsection_nr++;\n\t\tif (present_section_nr(section_nr))\n\t\t\treturn section_nr;\n\t} while ((section_nr <= __highest_present_section_nr));\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long first_present_section_nr(void)\n{\n\treturn next_present_section_nr(-1);\n}"
  },
  {
    "function_name": "next_present_section_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "188-197",
    "snippet": "static inline int next_present_section_nr(int section_nr)\n{\n\tdo {\n\t\tsection_nr++;\n\t\tif (present_section_nr(section_nr))\n\t\t\treturn section_nr;\n\t} while ((section_nr <= __highest_present_section_nr));\n\n\treturn -1;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __highest_present_section_nr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "present_section_nr",
          "args": [
            "section_nr"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "next_present_section_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "188-197",
          "snippet": "static inline int next_present_section_nr(int section_nr)\n{\n\tdo {\n\t\tsection_nr++;\n\t\tif (present_section_nr(section_nr))\n\t\t\treturn section_nr;\n\t} while ((section_nr <= __highest_present_section_nr));\n\n\treturn -1;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __highest_present_section_nr;\n\nstatic inline int next_present_section_nr(int section_nr)\n{\n\tdo {\n\t\tsection_nr++;\n\t\tif (present_section_nr(section_nr))\n\t\t\treturn section_nr;\n\t} while ((section_nr <= __highest_present_section_nr));\n\n\treturn -1;\n}"
  },
  {
    "function_name": "section_mark_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "178-186",
    "snippet": "static void section_mark_present(struct mem_section *ms)\n{\n\tint section_nr = __section_nr(ms);\n\n\tif (section_nr > __highest_present_section_nr)\n\t\t__highest_present_section_nr = section_nr;\n\n\tms->section_mem_map |= SECTION_MARKED_PRESENT;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __highest_present_section_nr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__section_nr",
          "args": [
            "ms"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__section_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "120-123",
          "snippet": "int __section_nr(struct mem_section* ms)\n{\n\treturn (int)(ms - mem_section[0]);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __section_nr(struct mem_section* ms)\n{\n\treturn (int)(ms - mem_section[0]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __highest_present_section_nr;\n\nstatic void section_mark_present(struct mem_section *ms)\n{\n\tint section_nr = __section_nr(ms);\n\n\tif (section_nr > __highest_present_section_nr)\n\t\t__highest_present_section_nr = section_nr;\n\n\tms->section_mem_map |= SECTION_MARKED_PRESENT;\n}"
  },
  {
    "function_name": "mminit_validate_memmodel_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "143-166",
    "snippet": "void __meminit mminit_validate_memmodel_limits(unsigned long *start_pfn,\n\t\t\t\t\t\tunsigned long *end_pfn)\n{\n\tunsigned long max_sparsemem_pfn = 1UL << (MAX_PHYSMEM_BITS-PAGE_SHIFT);\n\n\t/*\n\t * Sanity checks - do not allow an architecture to pass\n\t * in larger pfns than the maximum scope of sparsemem:\n\t */\n\tif (*start_pfn > max_sparsemem_pfn) {\n\t\tmminit_dprintk(MMINIT_WARNING, \"pfnvalidation\",\n\t\t\t\"Start of range %lu -> %lu exceeds SPARSEMEM max %lu\\n\",\n\t\t\t*start_pfn, *end_pfn, max_sparsemem_pfn);\n\t\tWARN_ON_ONCE(1);\n\t\t*start_pfn = max_sparsemem_pfn;\n\t\t*end_pfn = max_sparsemem_pfn;\n\t} else if (*end_pfn > max_sparsemem_pfn) {\n\t\tmminit_dprintk(MMINIT_WARNING, \"pfnvalidation\",\n\t\t\t\"End of range %lu -> %lu exceeds SPARSEMEM max %lu\\n\",\n\t\t\t*start_pfn, *end_pfn, max_sparsemem_pfn);\n\t\tWARN_ON_ONCE(1);\n\t\t*end_pfn = max_sparsemem_pfn;\n\t}\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mminit_dprintk",
          "args": [
            "MMINIT_WARNING",
            "\"pfnvalidation\"",
            "\"End of range %lu -> %lu exceeds SPARSEMEM max %lu\\n\"",
            "*start_pfn",
            "*end_pfn",
            "max_sparsemem_pfn"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "mminit_dprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "417-420",
          "snippet": "static inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __meminit mminit_validate_memmodel_limits(unsigned long *start_pfn,\n\t\t\t\t\t\tunsigned long *end_pfn)\n{\n\tunsigned long max_sparsemem_pfn = 1UL << (MAX_PHYSMEM_BITS-PAGE_SHIFT);\n\n\t/*\n\t * Sanity checks - do not allow an architecture to pass\n\t * in larger pfns than the maximum scope of sparsemem:\n\t */\n\tif (*start_pfn > max_sparsemem_pfn) {\n\t\tmminit_dprintk(MMINIT_WARNING, \"pfnvalidation\",\n\t\t\t\"Start of range %lu -> %lu exceeds SPARSEMEM max %lu\\n\",\n\t\t\t*start_pfn, *end_pfn, max_sparsemem_pfn);\n\t\tWARN_ON_ONCE(1);\n\t\t*start_pfn = max_sparsemem_pfn;\n\t\t*end_pfn = max_sparsemem_pfn;\n\t} else if (*end_pfn > max_sparsemem_pfn) {\n\t\tmminit_dprintk(MMINIT_WARNING, \"pfnvalidation\",\n\t\t\t\"End of range %lu -> %lu exceeds SPARSEMEM max %lu\\n\",\n\t\t\t*start_pfn, *end_pfn, max_sparsemem_pfn);\n\t\tWARN_ON_ONCE(1);\n\t\t*end_pfn = max_sparsemem_pfn;\n\t}\n}"
  },
  {
    "function_name": "sparse_early_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "137-140",
    "snippet": "static inline int sparse_early_nid(struct mem_section *section)\n{\n\treturn (section->section_mem_map >> SECTION_NID_SHIFT);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int sparse_early_nid(struct mem_section *section)\n{\n\treturn (section->section_mem_map >> SECTION_NID_SHIFT);\n}"
  },
  {
    "function_name": "sparse_encode_early_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "132-135",
    "snippet": "static inline unsigned long sparse_encode_early_nid(int nid)\n{\n\treturn (nid << SECTION_NID_SHIFT);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long sparse_encode_early_nid(int nid)\n{\n\treturn (nid << SECTION_NID_SHIFT);\n}"
  },
  {
    "function_name": "__section_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "120-123",
    "snippet": "int __section_nr(struct mem_section* ms)\n{\n\treturn (int)(ms - mem_section[0]);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __section_nr(struct mem_section* ms)\n{\n\treturn (int)(ms - mem_section[0]);\n}"
  },
  {
    "function_name": "__section_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "101-118",
    "snippet": "int __section_nr(struct mem_section* ms)\n{\n\tunsigned long root_nr;\n\tstruct mem_section *root = NULL;\n\n\tfor (root_nr = 0; root_nr < NR_SECTION_ROOTS; root_nr++) {\n\t\troot = __nr_to_section(root_nr * SECTIONS_PER_ROOT);\n\t\tif (!root)\n\t\t\tcontinue;\n\n\t\tif ((ms >= root) && (ms < (root + SECTIONS_PER_ROOT)))\n\t\t     break;\n\t}\n\n\tVM_BUG_ON(!root);\n\n\treturn (root_nr * SECTIONS_PER_ROOT) + (ms - root);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!root"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "root_nr * SECTIONS_PER_ROOT"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __section_nr(struct mem_section* ms)\n{\n\tunsigned long root_nr;\n\tstruct mem_section *root = NULL;\n\n\tfor (root_nr = 0; root_nr < NR_SECTION_ROOTS; root_nr++) {\n\t\troot = __nr_to_section(root_nr * SECTIONS_PER_ROOT);\n\t\tif (!root)\n\t\t\tcontinue;\n\n\t\tif ((ms >= root) && (ms < (root + SECTIONS_PER_ROOT)))\n\t\t     break;\n\t}\n\n\tVM_BUG_ON(!root);\n\n\treturn (root_nr * SECTIONS_PER_ROOT) + (ms - root);\n}"
  },
  {
    "function_name": "sparse_index_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "94-97",
    "snippet": "static inline int sparse_index_init(unsigned long section_nr, int nid)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int sparse_index_init(unsigned long section_nr, int nid)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "sparse_index_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "77-92",
    "snippet": "static int __meminit sparse_index_init(unsigned long section_nr, int nid)\n{\n\tunsigned long root = SECTION_NR_TO_ROOT(section_nr);\n\tstruct mem_section *section;\n\n\tif (mem_section[root])\n\t\treturn -EEXIST;\n\n\tsection = sparse_index_alloc(nid);\n\tif (!section)\n\t\treturn -ENOMEM;\n\n\tmem_section[root] = section;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sparse_index_alloc",
          "args": [
            "nid"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_index_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "62-75",
          "snippet": "mem_section __ref *sparse_index_alloc(int nid)\n{\n\tstruct mem_section *section = NULL;\n\tunsigned long array_size = SECTIONS_PER_ROOT *\n\t\t\t\t   sizeof(struct mem_section);\n\n\tif (slab_is_available())\n\t\tsection = kzalloc_node(array_size, GFP_KERNEL, nid);\n\telse\n\t\tsection = memblock_alloc_node(array_size, SMP_CACHE_BYTES,\n\t\t\t\t\t      nid);\n\n\treturn section;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nmem_section __ref *sparse_index_alloc(int nid)\n{\n\tstruct mem_section *section = NULL;\n\tunsigned long array_size = SECTIONS_PER_ROOT *\n\t\t\t\t   sizeof(struct mem_section);\n\n\tif (slab_is_available())\n\t\tsection = kzalloc_node(array_size, GFP_KERNEL, nid);\n\telse\n\t\tsection = memblock_alloc_node(array_size, SMP_CACHE_BYTES,\n\t\t\t\t\t      nid);\n\n\treturn section;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SECTION_NR_TO_ROOT",
          "args": [
            "section_nr"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int __meminit sparse_index_init(unsigned long section_nr, int nid)\n{\n\tunsigned long root = SECTION_NR_TO_ROOT(section_nr);\n\tstruct mem_section *section;\n\n\tif (mem_section[root])\n\t\treturn -EEXIST;\n\n\tsection = sparse_index_alloc(nid);\n\tif (!section)\n\t\treturn -ENOMEM;\n\n\tmem_section[root] = section;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sparse_index_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "62-75",
    "snippet": "mem_section __ref *sparse_index_alloc(int nid)\n{\n\tstruct mem_section *section = NULL;\n\tunsigned long array_size = SECTIONS_PER_ROOT *\n\t\t\t\t   sizeof(struct mem_section);\n\n\tif (slab_is_available())\n\t\tsection = kzalloc_node(array_size, GFP_KERNEL, nid);\n\telse\n\t\tsection = memblock_alloc_node(array_size, SMP_CACHE_BYTES,\n\t\t\t\t\t      nid);\n\n\treturn section;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_node",
          "args": [
            "array_size",
            "SMP_CACHE_BYTES",
            "nid"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "array_size",
            "GFP_KERNEL",
            "nid"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "slab_is_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "930-933",
          "snippet": "bool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum slab_state slab_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nenum slab_state slab_state;\n\nbool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nmem_section __ref *sparse_index_alloc(int nid)\n{\n\tstruct mem_section *section = NULL;\n\tunsigned long array_size = SECTIONS_PER_ROOT *\n\t\t\t\t   sizeof(struct mem_section);\n\n\tif (slab_is_available())\n\t\tsection = kzalloc_node(array_size, GFP_KERNEL, nid);\n\telse\n\t\tsection = memblock_alloc_node(array_size, SMP_CACHE_BYTES,\n\t\t\t\t\t      nid);\n\n\treturn section;\n}"
  },
  {
    "function_name": "set_section_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "56-58",
    "snippet": "static inline void set_section_nid(unsigned long section_nr, int nid)\n{\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void set_section_nid(unsigned long section_nr, int nid)\n{\n}"
  },
  {
    "function_name": "set_section_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "51-54",
    "snippet": "static void set_section_nid(unsigned long section_nr, int nid)\n{\n\tsection_to_node_table[section_nr] = nid;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void set_section_nid(unsigned long section_nr, int nid)\n{\n\tsection_to_node_table[section_nr] = nid;\n}"
  },
  {
    "function_name": "page_to_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
    "lines": "45-48",
    "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/dma.h>",
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_section",
          "args": [
            "page"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
  }
]