[
  {
    "function_name": "dmam_pool_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "527-532",
    "snippet": "void dmam_pool_destroy(struct dma_pool *pool)\n{\n\tstruct device *dev = pool->dev;\n\n\tWARN_ON(devres_release(dev, dmam_pool_release, dmam_pool_match, pool));\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "devres_release(dev, dmam_pool_release, dmam_pool_match, pool)"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_release",
          "args": [
            "dev",
            "dmam_pool_release",
            "dmam_pool_match",
            "pool"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nvoid dmam_pool_destroy(struct dma_pool *pool)\n{\n\tstruct device *dev = pool->dev;\n\n\tWARN_ON(devres_release(dev, dmam_pool_release, dmam_pool_match, pool));\n}"
  },
  {
    "function_name": "dmam_pool_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "502-518",
    "snippet": "struct dma_pool *dmam_pool_create(const char *name, struct device *dev,\n\t\t\t\t  size_t size, size_t align, size_t allocation)\n{\n\tstruct dma_pool **ptr, *pool;\n\n\tptr = devres_alloc(dmam_pool_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn NULL;\n\n\tpool = *ptr = dma_pool_create(name, dev, size, align, allocation);\n\tif (pool)\n\t\tdevres_add(dev, ptr);\n\telse\n\t\tdevres_free(ptr);\n\n\treturn pool;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEVICE_ATTR(pools, 0444, show_pools, NULL);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "ptr"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "ptr"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_pool_create",
          "args": [
            "name",
            "dev",
            "size",
            "align",
            "allocation"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "dma_pool_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
          "lines": "131-203",
          "snippet": "struct dma_pool *dma_pool_create(const char *name, struct device *dev,\n\t\t\t\t size_t size, size_t align, size_t boundary)\n{\n\tstruct dma_pool *retval;\n\tsize_t allocation;\n\tbool empty = false;\n\n\tif (align == 0)\n\t\talign = 1;\n\telse if (align & (align - 1))\n\t\treturn NULL;\n\n\tif (size == 0)\n\t\treturn NULL;\n\telse if (size < 4)\n\t\tsize = 4;\n\n\tif ((size % align) != 0)\n\t\tsize = ALIGN(size, align);\n\n\tallocation = max_t(size_t, size, PAGE_SIZE);\n\n\tif (!boundary)\n\t\tboundary = allocation;\n\telse if ((boundary < size) || (boundary & (boundary - 1)))\n\t\treturn NULL;\n\n\tretval = kmalloc_node(sizeof(*retval), GFP_KERNEL, dev_to_node(dev));\n\tif (!retval)\n\t\treturn retval;\n\n\tstrlcpy(retval->name, name, sizeof(retval->name));\n\n\tretval->dev = dev;\n\n\tINIT_LIST_HEAD(&retval->page_list);\n\tspin_lock_init(&retval->lock);\n\tretval->size = size;\n\tretval->boundary = boundary;\n\tretval->allocation = allocation;\n\n\tINIT_LIST_HEAD(&retval->pools);\n\n\t/*\n\t * pools_lock ensures that the ->dma_pools list does not get corrupted.\n\t * pools_reg_lock ensures that there is not a race between\n\t * dma_pool_create() and dma_pool_destroy() or within dma_pool_create()\n\t * when the first invocation of dma_pool_create() failed on\n\t * device_create_file() and the second assumes that it has been done (I\n\t * know it is a short window).\n\t */\n\tmutex_lock(&pools_reg_lock);\n\tmutex_lock(&pools_lock);\n\tif (list_empty(&dev->dma_pools))\n\t\tempty = true;\n\tlist_add(&retval->pools, &dev->dma_pools);\n\tmutex_unlock(&pools_lock);\n\tif (empty) {\n\t\tint err;\n\n\t\terr = device_create_file(dev, &dev_attr_pools);\n\t\tif (err) {\n\t\t\tmutex_lock(&pools_lock);\n\t\t\tlist_del(&retval->pools);\n\t\t\tmutex_unlock(&pools_lock);\n\t\t\tmutex_unlock(&pools_reg_lock);\n\t\t\tkfree(retval);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tmutex_unlock(&pools_reg_lock);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dmapool.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(pools_lock);",
            "static DEFINE_MUTEX(pools_reg_lock);",
            "static DEVICE_ATTR(pools, 0444, show_pools, NULL);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(pools_lock);\nstatic DEFINE_MUTEX(pools_reg_lock);\nstatic DEVICE_ATTR(pools, 0444, show_pools, NULL);\n\nstruct dma_pool *dma_pool_create(const char *name, struct device *dev,\n\t\t\t\t size_t size, size_t align, size_t boundary)\n{\n\tstruct dma_pool *retval;\n\tsize_t allocation;\n\tbool empty = false;\n\n\tif (align == 0)\n\t\talign = 1;\n\telse if (align & (align - 1))\n\t\treturn NULL;\n\n\tif (size == 0)\n\t\treturn NULL;\n\telse if (size < 4)\n\t\tsize = 4;\n\n\tif ((size % align) != 0)\n\t\tsize = ALIGN(size, align);\n\n\tallocation = max_t(size_t, size, PAGE_SIZE);\n\n\tif (!boundary)\n\t\tboundary = allocation;\n\telse if ((boundary < size) || (boundary & (boundary - 1)))\n\t\treturn NULL;\n\n\tretval = kmalloc_node(sizeof(*retval), GFP_KERNEL, dev_to_node(dev));\n\tif (!retval)\n\t\treturn retval;\n\n\tstrlcpy(retval->name, name, sizeof(retval->name));\n\n\tretval->dev = dev;\n\n\tINIT_LIST_HEAD(&retval->page_list);\n\tspin_lock_init(&retval->lock);\n\tretval->size = size;\n\tretval->boundary = boundary;\n\tretval->allocation = allocation;\n\n\tINIT_LIST_HEAD(&retval->pools);\n\n\t/*\n\t * pools_lock ensures that the ->dma_pools list does not get corrupted.\n\t * pools_reg_lock ensures that there is not a race between\n\t * dma_pool_create() and dma_pool_destroy() or within dma_pool_create()\n\t * when the first invocation of dma_pool_create() failed on\n\t * device_create_file() and the second assumes that it has been done (I\n\t * know it is a short window).\n\t */\n\tmutex_lock(&pools_reg_lock);\n\tmutex_lock(&pools_lock);\n\tif (list_empty(&dev->dma_pools))\n\t\tempty = true;\n\tlist_add(&retval->pools, &dev->dma_pools);\n\tmutex_unlock(&pools_lock);\n\tif (empty) {\n\t\tint err;\n\n\t\terr = device_create_file(dev, &dev_attr_pools);\n\t\tif (err) {\n\t\t\tmutex_lock(&pools_lock);\n\t\t\tlist_del(&retval->pools);\n\t\t\tmutex_unlock(&pools_lock);\n\t\t\tmutex_unlock(&pools_reg_lock);\n\t\t\tkfree(retval);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tmutex_unlock(&pools_reg_lock);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "dmam_pool_release",
            "sizeof(*ptr)",
            "GFP_KERNEL"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic DEVICE_ATTR(pools, 0444, show_pools, NULL);\n\nstruct dma_pool *dmam_pool_create(const char *name, struct device *dev,\n\t\t\t\t  size_t size, size_t align, size_t allocation)\n{\n\tstruct dma_pool **ptr, *pool;\n\n\tptr = devres_alloc(dmam_pool_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn NULL;\n\n\tpool = *ptr = dma_pool_create(name, dev, size, align, allocation);\n\tif (pool)\n\t\tdevres_add(dev, ptr);\n\telse\n\t\tdevres_free(ptr);\n\n\treturn pool;\n}"
  },
  {
    "function_name": "dmam_pool_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "486-489",
    "snippet": "static int dmam_pool_match(struct device *dev, void *res, void *match_data)\n{\n\treturn *(struct dma_pool **)res == match_data;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic int dmam_pool_match(struct device *dev, void *res, void *match_data)\n{\n\treturn *(struct dma_pool **)res == match_data;\n}"
  },
  {
    "function_name": "dmam_pool_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "479-484",
    "snippet": "static void dmam_pool_release(struct device *dev, void *res)\n{\n\tstruct dma_pool *pool = *(struct dma_pool **)res;\n\n\tdma_pool_destroy(pool);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_pool_destroy",
          "args": [
            "pool"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "dma_pool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
          "lines": "270-307",
          "snippet": "void dma_pool_destroy(struct dma_pool *pool)\n{\n\tbool empty = false;\n\n\tif (unlikely(!pool))\n\t\treturn;\n\n\tmutex_lock(&pools_reg_lock);\n\tmutex_lock(&pools_lock);\n\tlist_del(&pool->pools);\n\tif (pool->dev && list_empty(&pool->dev->dma_pools))\n\t\tempty = true;\n\tmutex_unlock(&pools_lock);\n\tif (empty)\n\t\tdevice_remove_file(pool->dev, &dev_attr_pools);\n\tmutex_unlock(&pools_reg_lock);\n\n\twhile (!list_empty(&pool->page_list)) {\n\t\tstruct dma_page *page;\n\t\tpage = list_entry(pool->page_list.next,\n\t\t\t\t  struct dma_page, page_list);\n\t\tif (is_page_busy(page)) {\n\t\t\tif (pool->dev)\n\t\t\t\tdev_err(pool->dev,\n\t\t\t\t\t\"dma_pool_destroy %s, %p busy\\n\",\n\t\t\t\t\tpool->name, page->vaddr);\n\t\t\telse\n\t\t\t\tpr_err(\"dma_pool_destroy %s, %p busy\\n\",\n\t\t\t\t       pool->name, page->vaddr);\n\t\t\t/* leak the still-in-use consistent memory */\n\t\t\tlist_del(&page->page_list);\n\t\t\tkfree(page);\n\t\t} else\n\t\t\tpool_free_page(pool, page);\n\t}\n\n\tkfree(pool);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dmapool.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(pools_lock);",
            "static DEFINE_MUTEX(pools_reg_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(pools_lock);\nstatic DEFINE_MUTEX(pools_reg_lock);\n\nvoid dma_pool_destroy(struct dma_pool *pool)\n{\n\tbool empty = false;\n\n\tif (unlikely(!pool))\n\t\treturn;\n\n\tmutex_lock(&pools_reg_lock);\n\tmutex_lock(&pools_lock);\n\tlist_del(&pool->pools);\n\tif (pool->dev && list_empty(&pool->dev->dma_pools))\n\t\tempty = true;\n\tmutex_unlock(&pools_lock);\n\tif (empty)\n\t\tdevice_remove_file(pool->dev, &dev_attr_pools);\n\tmutex_unlock(&pools_reg_lock);\n\n\twhile (!list_empty(&pool->page_list)) {\n\t\tstruct dma_page *page;\n\t\tpage = list_entry(pool->page_list.next,\n\t\t\t\t  struct dma_page, page_list);\n\t\tif (is_page_busy(page)) {\n\t\t\tif (pool->dev)\n\t\t\t\tdev_err(pool->dev,\n\t\t\t\t\t\"dma_pool_destroy %s, %p busy\\n\",\n\t\t\t\t\tpool->name, page->vaddr);\n\t\t\telse\n\t\t\t\tpr_err(\"dma_pool_destroy %s, %p busy\\n\",\n\t\t\t\t       pool->name, page->vaddr);\n\t\t\t/* leak the still-in-use consistent memory */\n\t\t\tlist_del(&page->page_list);\n\t\t\tkfree(page);\n\t\t} else\n\t\t\tpool_free_page(pool, page);\n\t}\n\n\tkfree(pool);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic void dmam_pool_release(struct device *dev, void *res)\n{\n\tstruct dma_pool *pool = *(struct dma_pool **)res;\n\n\tdma_pool_destroy(pool);\n}"
  },
  {
    "function_name": "dma_pool_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "411-473",
    "snippet": "void dma_pool_free(struct dma_pool *pool, void *vaddr, dma_addr_t dma)\n{\n\tstruct dma_page *page;\n\tunsigned long flags;\n\tunsigned int offset;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tpage = pool_find_page(pool, dma);\n\tif (!page) {\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\tif (pool->dev)\n\t\t\tdev_err(pool->dev,\n\t\t\t\t\"dma_pool_free %s, %p/%lx (bad dma)\\n\",\n\t\t\t\tpool->name, vaddr, (unsigned long)dma);\n\t\telse\n\t\t\tpr_err(\"dma_pool_free %s, %p/%lx (bad dma)\\n\",\n\t\t\t       pool->name, vaddr, (unsigned long)dma);\n\t\treturn;\n\t}\n\n\toffset = vaddr - page->vaddr;\n#ifdef\tDMAPOOL_DEBUG\n\tif ((dma - page->dma) != offset) {\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\tif (pool->dev)\n\t\t\tdev_err(pool->dev,\n\t\t\t\t\"dma_pool_free %s, %p (bad vaddr)/%pad\\n\",\n\t\t\t\tpool->name, vaddr, &dma);\n\t\telse\n\t\t\tpr_err(\"dma_pool_free %s, %p (bad vaddr)/%pad\\n\",\n\t\t\t       pool->name, vaddr, &dma);\n\t\treturn;\n\t}\n\t{\n\t\tunsigned int chain = page->offset;\n\t\twhile (chain < pool->allocation) {\n\t\t\tif (chain != offset) {\n\t\t\t\tchain = *(int *)(page->vaddr + chain);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t\tif (pool->dev)\n\t\t\t\tdev_err(pool->dev, \"dma_pool_free %s, dma %pad already free\\n\",\n\t\t\t\t\tpool->name, &dma);\n\t\t\telse\n\t\t\t\tpr_err(\"dma_pool_free %s, dma %pad already free\\n\",\n\t\t\t\t       pool->name, &dma);\n\t\t\treturn;\n\t\t}\n\t}\n\tmemset(vaddr, POOL_POISON_FREED, pool->size);\n#endif\n\n\tpage->in_use--;\n\t*(int *)vaddr = page->offset;\n\tpage->offset = offset;\n\t/*\n\t * Resist a temptation to do\n\t *    if (!is_page_busy(page)) pool_free_page(pool, page);\n\t * Better have a few empty pages hang around.\n\t */\n\tspin_unlock_irqrestore(&pool->lock, flags);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define DMAPOOL_DEBUG 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vaddr",
            "POOL_POISON_FREED",
            "pool->size"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"dma_pool_free %s, dma %pad already free\\n\"",
            "pool->name",
            "&dma"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "pool->dev",
            "\"dma_pool_free %s, dma %pad already free\\n\"",
            "pool->name",
            "&dma"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"dma_pool_free %s, %p (bad vaddr)/%pad\\n\"",
            "pool->name",
            "vaddr",
            "&dma"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "pool->dev",
            "\"dma_pool_free %s, %p (bad vaddr)/%pad\\n\"",
            "pool->name",
            "vaddr",
            "&dma"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"dma_pool_free %s, %p/%lx (bad dma)\\n\"",
            "pool->name",
            "vaddr",
            "(unsigned long)dma"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "pool->dev",
            "\"dma_pool_free %s, %p/%lx (bad dma)\\n\"",
            "pool->name",
            "vaddr",
            "(unsigned long)dma"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool_find_page",
          "args": [
            "pool",
            "dma"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "pool_find_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
          "lines": "389-400",
          "snippet": "static struct dma_page *pool_find_page(struct dma_pool *pool, dma_addr_t dma)\n{\n\tstruct dma_page *page;\n\n\tlist_for_each_entry(page, &pool->page_list, page_list) {\n\t\tif (dma < page->dma)\n\t\t\tcontinue;\n\t\tif ((dma - page->dma) < pool->allocation)\n\t\t\treturn page;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dmapool.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEVICE_ATTR(pools, 0444, show_pools, NULL);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic DEVICE_ATTR(pools, 0444, show_pools, NULL);\n\nstatic struct dma_page *pool_find_page(struct dma_pool *pool, dma_addr_t dma)\n{\n\tstruct dma_page *page;\n\n\tlist_for_each_entry(page, &pool->page_list, page_list) {\n\t\tif (dma < page->dma)\n\t\t\tcontinue;\n\t\tif ((dma - page->dma) < pool->allocation)\n\t\t\treturn page;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\n#define DMAPOOL_DEBUG 1\n\nvoid dma_pool_free(struct dma_pool *pool, void *vaddr, dma_addr_t dma)\n{\n\tstruct dma_page *page;\n\tunsigned long flags;\n\tunsigned int offset;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tpage = pool_find_page(pool, dma);\n\tif (!page) {\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\tif (pool->dev)\n\t\t\tdev_err(pool->dev,\n\t\t\t\t\"dma_pool_free %s, %p/%lx (bad dma)\\n\",\n\t\t\t\tpool->name, vaddr, (unsigned long)dma);\n\t\telse\n\t\t\tpr_err(\"dma_pool_free %s, %p/%lx (bad dma)\\n\",\n\t\t\t       pool->name, vaddr, (unsigned long)dma);\n\t\treturn;\n\t}\n\n\toffset = vaddr - page->vaddr;\n#ifdef\tDMAPOOL_DEBUG\n\tif ((dma - page->dma) != offset) {\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\tif (pool->dev)\n\t\t\tdev_err(pool->dev,\n\t\t\t\t\"dma_pool_free %s, %p (bad vaddr)/%pad\\n\",\n\t\t\t\tpool->name, vaddr, &dma);\n\t\telse\n\t\t\tpr_err(\"dma_pool_free %s, %p (bad vaddr)/%pad\\n\",\n\t\t\t       pool->name, vaddr, &dma);\n\t\treturn;\n\t}\n\t{\n\t\tunsigned int chain = page->offset;\n\t\twhile (chain < pool->allocation) {\n\t\t\tif (chain != offset) {\n\t\t\t\tchain = *(int *)(page->vaddr + chain);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t\tif (pool->dev)\n\t\t\t\tdev_err(pool->dev, \"dma_pool_free %s, dma %pad already free\\n\",\n\t\t\t\t\tpool->name, &dma);\n\t\t\telse\n\t\t\t\tpr_err(\"dma_pool_free %s, dma %pad already free\\n\",\n\t\t\t\t       pool->name, &dma);\n\t\t\treturn;\n\t\t}\n\t}\n\tmemset(vaddr, POOL_POISON_FREED, pool->size);\n#endif\n\n\tpage->in_use--;\n\t*(int *)vaddr = page->offset;\n\tpage->offset = offset;\n\t/*\n\t * Resist a temptation to do\n\t *    if (!is_page_busy(page)) pool_free_page(pool, page);\n\t * Better have a few empty pages hang around.\n\t */\n\tspin_unlock_irqrestore(&pool->lock, flags);\n}"
  },
  {
    "function_name": "pool_find_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "389-400",
    "snippet": "static struct dma_page *pool_find_page(struct dma_pool *pool, dma_addr_t dma)\n{\n\tstruct dma_page *page;\n\n\tlist_for_each_entry(page, &pool->page_list, page_list) {\n\t\tif (dma < page->dma)\n\t\t\tcontinue;\n\t\tif ((dma - page->dma) < pool->allocation)\n\t\t\treturn page;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEVICE_ATTR(pools, 0444, show_pools, NULL);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&pool->page_list",
            "page_list"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic DEVICE_ATTR(pools, 0444, show_pools, NULL);\n\nstatic struct dma_page *pool_find_page(struct dma_pool *pool, dma_addr_t dma)\n{\n\tstruct dma_page *page;\n\n\tlist_for_each_entry(page, &pool->page_list, page_list) {\n\t\tif (dma < page->dma)\n\t\t\tcontinue;\n\t\tif ((dma - page->dma) < pool->allocation)\n\t\t\treturn page;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "dma_pool_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "320-386",
    "snippet": "void *dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,\n\t\t     dma_addr_t *handle)\n{\n\tunsigned long flags;\n\tstruct dma_page *page;\n\tsize_t offset;\n\tvoid *retval;\n\n\tmight_sleep_if(gfpflags_allow_blocking(mem_flags));\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tlist_for_each_entry(page, &pool->page_list, page_list) {\n\t\tif (page->offset < pool->allocation)\n\t\t\tgoto ready;\n\t}\n\n\t/* pool_alloc_page() might sleep, so temporarily drop &pool->lock */\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\tpage = pool_alloc_page(pool, mem_flags & (~__GFP_ZERO));\n\tif (!page)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\n\tlist_add(&page->page_list, &pool->page_list);\n ready:\n\tpage->in_use++;\n\toffset = page->offset;\n\tpage->offset = *(int *)(page->vaddr + offset);\n\tretval = offset + page->vaddr;\n\t*handle = offset + page->dma;\n#ifdef\tDMAPOOL_DEBUG\n\t{\n\t\tint i;\n\t\tu8 *data = retval;\n\t\t/* page->offset is stored in first 4 bytes */\n\t\tfor (i = sizeof(page->offset); i < pool->size; i++) {\n\t\t\tif (data[i] == POOL_POISON_FREED)\n\t\t\t\tcontinue;\n\t\t\tif (pool->dev)\n\t\t\t\tdev_err(pool->dev,\n\t\t\t\t\t\"dma_pool_alloc %s, %p (corrupted)\\n\",\n\t\t\t\t\tpool->name, retval);\n\t\t\telse\n\t\t\t\tpr_err(\"dma_pool_alloc %s, %p (corrupted)\\n\",\n\t\t\t\t\tpool->name, retval);\n\n\t\t\t/*\n\t\t\t * Dump the first 4 bytes even if they are not\n\t\t\t * POOL_POISON_FREED\n\t\t\t */\n\t\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t\tdata, pool->size, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!(mem_flags & __GFP_ZERO))\n\t\tmemset(retval, POOL_POISON_ALLOCATED, pool->size);\n#endif\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\tif (mem_flags & __GFP_ZERO)\n\t\tmemset(retval, 0, pool->size);\n\n\treturn retval;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define DMAPOOL_DEBUG 1"
    ],
    "globals_used": [
      "static DEVICE_ATTR(pools, 0444, show_pools, NULL);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "retval",
            "0",
            "pool->size"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"\"",
            "DUMP_PREFIX_OFFSET",
            "16",
            "1",
            "data",
            "pool->size",
            "1"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"dma_pool_alloc %s, %p (corrupted)\\n\"",
            "pool->name",
            "retval"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "pool->dev",
            "\"dma_pool_alloc %s, %p (corrupted)\\n\"",
            "pool->name",
            "retval"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->page_list",
            "&pool->page_list"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool_alloc_page",
          "args": [
            "pool",
            "mem_flags & (~__GFP_ZERO)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "pool_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
          "lines": "222-243",
          "snippet": "static struct dma_page *pool_alloc_page(struct dma_pool *pool, gfp_t mem_flags)\n{\n\tstruct dma_page *page;\n\n\tpage = kmalloc(sizeof(*page), mem_flags);\n\tif (!page)\n\t\treturn NULL;\n\tpage->vaddr = dma_alloc_coherent(pool->dev, pool->allocation,\n\t\t\t\t\t &page->dma, mem_flags);\n\tif (page->vaddr) {\n#ifdef\tDMAPOOL_DEBUG\n\t\tmemset(page->vaddr, POOL_POISON_FREED, pool->allocation);\n#endif\n\t\tpool_initialise_page(pool, page);\n\t\tpage->in_use = 0;\n\t\tpage->offset = 0;\n\t} else {\n\t\tkfree(page);\n\t\tpage = NULL;\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dmapool.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [
            "#define DMAPOOL_DEBUG 1"
          ],
          "globals_used": [
            "static DEVICE_ATTR(pools, 0444, show_pools, NULL);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\n#define DMAPOOL_DEBUG 1\n\nstatic DEVICE_ATTR(pools, 0444, show_pools, NULL);\n\nstatic struct dma_page *pool_alloc_page(struct dma_pool *pool, gfp_t mem_flags)\n{\n\tstruct dma_page *page;\n\n\tpage = kmalloc(sizeof(*page), mem_flags);\n\tif (!page)\n\t\treturn NULL;\n\tpage->vaddr = dma_alloc_coherent(pool->dev, pool->allocation,\n\t\t\t\t\t &page->dma, mem_flags);\n\tif (page->vaddr) {\n#ifdef\tDMAPOOL_DEBUG\n\t\tmemset(page->vaddr, POOL_POISON_FREED, pool->allocation);\n#endif\n\t\tpool_initialise_page(pool, page);\n\t\tpage->in_use = 0;\n\t\tpage->offset = 0;\n\t} else {\n\t\tkfree(page);\n\t\tpage = NULL;\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&pool->page_list",
            "page_list"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep_if",
          "args": [
            "gfpflags_allow_blocking(mem_flags)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "mem_flags"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\n#define DMAPOOL_DEBUG 1\n\nstatic DEVICE_ATTR(pools, 0444, show_pools, NULL);\n\nvoid *dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,\n\t\t     dma_addr_t *handle)\n{\n\tunsigned long flags;\n\tstruct dma_page *page;\n\tsize_t offset;\n\tvoid *retval;\n\n\tmight_sleep_if(gfpflags_allow_blocking(mem_flags));\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tlist_for_each_entry(page, &pool->page_list, page_list) {\n\t\tif (page->offset < pool->allocation)\n\t\t\tgoto ready;\n\t}\n\n\t/* pool_alloc_page() might sleep, so temporarily drop &pool->lock */\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\tpage = pool_alloc_page(pool, mem_flags & (~__GFP_ZERO));\n\tif (!page)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\n\tlist_add(&page->page_list, &pool->page_list);\n ready:\n\tpage->in_use++;\n\toffset = page->offset;\n\tpage->offset = *(int *)(page->vaddr + offset);\n\tretval = offset + page->vaddr;\n\t*handle = offset + page->dma;\n#ifdef\tDMAPOOL_DEBUG\n\t{\n\t\tint i;\n\t\tu8 *data = retval;\n\t\t/* page->offset is stored in first 4 bytes */\n\t\tfor (i = sizeof(page->offset); i < pool->size; i++) {\n\t\t\tif (data[i] == POOL_POISON_FREED)\n\t\t\t\tcontinue;\n\t\t\tif (pool->dev)\n\t\t\t\tdev_err(pool->dev,\n\t\t\t\t\t\"dma_pool_alloc %s, %p (corrupted)\\n\",\n\t\t\t\t\tpool->name, retval);\n\t\t\telse\n\t\t\t\tpr_err(\"dma_pool_alloc %s, %p (corrupted)\\n\",\n\t\t\t\t\tpool->name, retval);\n\n\t\t\t/*\n\t\t\t * Dump the first 4 bytes even if they are not\n\t\t\t * POOL_POISON_FREED\n\t\t\t */\n\t\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t\tdata, pool->size, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!(mem_flags & __GFP_ZERO))\n\t\tmemset(retval, POOL_POISON_ALLOCATED, pool->size);\n#endif\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\tif (mem_flags & __GFP_ZERO)\n\t\tmemset(retval, 0, pool->size);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "dma_pool_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "270-307",
    "snippet": "void dma_pool_destroy(struct dma_pool *pool)\n{\n\tbool empty = false;\n\n\tif (unlikely(!pool))\n\t\treturn;\n\n\tmutex_lock(&pools_reg_lock);\n\tmutex_lock(&pools_lock);\n\tlist_del(&pool->pools);\n\tif (pool->dev && list_empty(&pool->dev->dma_pools))\n\t\tempty = true;\n\tmutex_unlock(&pools_lock);\n\tif (empty)\n\t\tdevice_remove_file(pool->dev, &dev_attr_pools);\n\tmutex_unlock(&pools_reg_lock);\n\n\twhile (!list_empty(&pool->page_list)) {\n\t\tstruct dma_page *page;\n\t\tpage = list_entry(pool->page_list.next,\n\t\t\t\t  struct dma_page, page_list);\n\t\tif (is_page_busy(page)) {\n\t\t\tif (pool->dev)\n\t\t\t\tdev_err(pool->dev,\n\t\t\t\t\t\"dma_pool_destroy %s, %p busy\\n\",\n\t\t\t\t\tpool->name, page->vaddr);\n\t\t\telse\n\t\t\t\tpr_err(\"dma_pool_destroy %s, %p busy\\n\",\n\t\t\t\t       pool->name, page->vaddr);\n\t\t\t/* leak the still-in-use consistent memory */\n\t\t\tlist_del(&page->page_list);\n\t\t\tkfree(page);\n\t\t} else\n\t\t\tpool_free_page(pool, page);\n\t}\n\n\tkfree(pool);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(pools_lock);",
      "static DEFINE_MUTEX(pools_reg_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pool"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pool_free_page",
          "args": [
            "pool",
            "page"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "pool_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
          "lines": "250-260",
          "snippet": "static void pool_free_page(struct dma_pool *pool, struct dma_page *page)\n{\n\tdma_addr_t dma = page->dma;\n\n#ifdef\tDMAPOOL_DEBUG\n\tmemset(page->vaddr, POOL_POISON_FREED, pool->allocation);\n#endif\n\tdma_free_coherent(pool->dev, pool->allocation, page->vaddr, dma);\n\tlist_del(&page->page_list);\n\tkfree(page);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dmapool.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [
            "#define DMAPOOL_DEBUG 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\n#define DMAPOOL_DEBUG 1\n\nstatic void pool_free_page(struct dma_pool *pool, struct dma_page *page)\n{\n\tdma_addr_t dma = page->dma;\n\n#ifdef\tDMAPOOL_DEBUG\n\tmemset(page->vaddr, POOL_POISON_FREED, pool->allocation);\n#endif\n\tdma_free_coherent(pool->dev, pool->allocation, page->vaddr, dma);\n\tlist_del(&page->page_list);\n\tkfree(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->page_list"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"dma_pool_destroy %s, %p busy\\n\"",
            "pool->name",
            "page->vaddr"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "pool->dev",
            "\"dma_pool_destroy %s, %p busy\\n\"",
            "pool->name",
            "page->vaddr"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_page_busy",
          "args": [
            "page"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "is_page_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
          "lines": "245-248",
          "snippet": "static inline bool is_page_busy(struct dma_page *page)\n{\n\treturn page->in_use != 0;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dmapool.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic inline bool is_page_busy(struct dma_page *page)\n{\n\treturn page->in_use != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pool->page_list.next",
            "structdma_page",
            "page_list"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->page_list"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pools_reg_lock"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_remove_file",
          "args": [
            "pool->dev",
            "&dev_attr_pools"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pools_lock"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pool->pools"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pools_lock"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pools_reg_lock"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pool"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(pools_lock);\nstatic DEFINE_MUTEX(pools_reg_lock);\n\nvoid dma_pool_destroy(struct dma_pool *pool)\n{\n\tbool empty = false;\n\n\tif (unlikely(!pool))\n\t\treturn;\n\n\tmutex_lock(&pools_reg_lock);\n\tmutex_lock(&pools_lock);\n\tlist_del(&pool->pools);\n\tif (pool->dev && list_empty(&pool->dev->dma_pools))\n\t\tempty = true;\n\tmutex_unlock(&pools_lock);\n\tif (empty)\n\t\tdevice_remove_file(pool->dev, &dev_attr_pools);\n\tmutex_unlock(&pools_reg_lock);\n\n\twhile (!list_empty(&pool->page_list)) {\n\t\tstruct dma_page *page;\n\t\tpage = list_entry(pool->page_list.next,\n\t\t\t\t  struct dma_page, page_list);\n\t\tif (is_page_busy(page)) {\n\t\t\tif (pool->dev)\n\t\t\t\tdev_err(pool->dev,\n\t\t\t\t\t\"dma_pool_destroy %s, %p busy\\n\",\n\t\t\t\t\tpool->name, page->vaddr);\n\t\t\telse\n\t\t\t\tpr_err(\"dma_pool_destroy %s, %p busy\\n\",\n\t\t\t\t       pool->name, page->vaddr);\n\t\t\t/* leak the still-in-use consistent memory */\n\t\t\tlist_del(&page->page_list);\n\t\t\tkfree(page);\n\t\t} else\n\t\t\tpool_free_page(pool, page);\n\t}\n\n\tkfree(pool);\n}"
  },
  {
    "function_name": "pool_free_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "250-260",
    "snippet": "static void pool_free_page(struct dma_pool *pool, struct dma_page *page)\n{\n\tdma_addr_t dma = page->dma;\n\n#ifdef\tDMAPOOL_DEBUG\n\tmemset(page->vaddr, POOL_POISON_FREED, pool->allocation);\n#endif\n\tdma_free_coherent(pool->dev, pool->allocation, page->vaddr, dma);\n\tlist_del(&page->page_list);\n\tkfree(page);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define DMAPOOL_DEBUG 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->page_list"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_free_coherent",
          "args": [
            "pool->dev",
            "pool->allocation",
            "page->vaddr",
            "dma"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page->vaddr",
            "POOL_POISON_FREED",
            "pool->allocation"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\n#define DMAPOOL_DEBUG 1\n\nstatic void pool_free_page(struct dma_pool *pool, struct dma_page *page)\n{\n\tdma_addr_t dma = page->dma;\n\n#ifdef\tDMAPOOL_DEBUG\n\tmemset(page->vaddr, POOL_POISON_FREED, pool->allocation);\n#endif\n\tdma_free_coherent(pool->dev, pool->allocation, page->vaddr, dma);\n\tlist_del(&page->page_list);\n\tkfree(page);\n}"
  },
  {
    "function_name": "is_page_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "245-248",
    "snippet": "static inline bool is_page_busy(struct dma_page *page)\n{\n\treturn page->in_use != 0;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic inline bool is_page_busy(struct dma_page *page)\n{\n\treturn page->in_use != 0;\n}"
  },
  {
    "function_name": "pool_alloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "222-243",
    "snippet": "static struct dma_page *pool_alloc_page(struct dma_pool *pool, gfp_t mem_flags)\n{\n\tstruct dma_page *page;\n\n\tpage = kmalloc(sizeof(*page), mem_flags);\n\tif (!page)\n\t\treturn NULL;\n\tpage->vaddr = dma_alloc_coherent(pool->dev, pool->allocation,\n\t\t\t\t\t &page->dma, mem_flags);\n\tif (page->vaddr) {\n#ifdef\tDMAPOOL_DEBUG\n\t\tmemset(page->vaddr, POOL_POISON_FREED, pool->allocation);\n#endif\n\t\tpool_initialise_page(pool, page);\n\t\tpage->in_use = 0;\n\t\tpage->offset = 0;\n\t} else {\n\t\tkfree(page);\n\t\tpage = NULL;\n\t}\n\treturn page;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define DMAPOOL_DEBUG 1"
    ],
    "globals_used": [
      "static DEVICE_ATTR(pools, 0444, show_pools, NULL);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pool_initialise_page",
          "args": [
            "pool",
            "page"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "pool_initialise_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
          "lines": "206-220",
          "snippet": "static void pool_initialise_page(struct dma_pool *pool, struct dma_page *page)\n{\n\tunsigned int offset = 0;\n\tunsigned int next_boundary = pool->boundary;\n\n\tdo {\n\t\tunsigned int next = offset + pool->size;\n\t\tif (unlikely((next + pool->size) >= next_boundary)) {\n\t\t\tnext = next_boundary;\n\t\t\tnext_boundary += pool->boundary;\n\t\t}\n\t\t*(int *)(page->vaddr + offset) = next;\n\t\toffset = next;\n\t} while (offset < pool->allocation);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dmapool.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic void pool_initialise_page(struct dma_pool *pool, struct dma_page *page)\n{\n\tunsigned int offset = 0;\n\tunsigned int next_boundary = pool->boundary;\n\n\tdo {\n\t\tunsigned int next = offset + pool->size;\n\t\tif (unlikely((next + pool->size) >= next_boundary)) {\n\t\t\tnext = next_boundary;\n\t\t\tnext_boundary += pool->boundary;\n\t\t}\n\t\t*(int *)(page->vaddr + offset) = next;\n\t\toffset = next;\n\t} while (offset < pool->allocation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page->vaddr",
            "POOL_POISON_FREED",
            "pool->allocation"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_alloc_coherent",
          "args": [
            "pool->dev",
            "pool->allocation",
            "&page->dma",
            "mem_flags"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*page)",
            "mem_flags"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\n#define DMAPOOL_DEBUG 1\n\nstatic DEVICE_ATTR(pools, 0444, show_pools, NULL);\n\nstatic struct dma_page *pool_alloc_page(struct dma_pool *pool, gfp_t mem_flags)\n{\n\tstruct dma_page *page;\n\n\tpage = kmalloc(sizeof(*page), mem_flags);\n\tif (!page)\n\t\treturn NULL;\n\tpage->vaddr = dma_alloc_coherent(pool->dev, pool->allocation,\n\t\t\t\t\t &page->dma, mem_flags);\n\tif (page->vaddr) {\n#ifdef\tDMAPOOL_DEBUG\n\t\tmemset(page->vaddr, POOL_POISON_FREED, pool->allocation);\n#endif\n\t\tpool_initialise_page(pool, page);\n\t\tpage->in_use = 0;\n\t\tpage->offset = 0;\n\t} else {\n\t\tkfree(page);\n\t\tpage = NULL;\n\t}\n\treturn page;\n}"
  },
  {
    "function_name": "pool_initialise_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "206-220",
    "snippet": "static void pool_initialise_page(struct dma_pool *pool, struct dma_page *page)\n{\n\tunsigned int offset = 0;\n\tunsigned int next_boundary = pool->boundary;\n\n\tdo {\n\t\tunsigned int next = offset + pool->size;\n\t\tif (unlikely((next + pool->size) >= next_boundary)) {\n\t\t\tnext = next_boundary;\n\t\t\tnext_boundary += pool->boundary;\n\t\t}\n\t\t*(int *)(page->vaddr + offset) = next;\n\t\toffset = next;\n\t} while (offset < pool->allocation);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(next + pool->size) >= next_boundary"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic void pool_initialise_page(struct dma_pool *pool, struct dma_page *page)\n{\n\tunsigned int offset = 0;\n\tunsigned int next_boundary = pool->boundary;\n\n\tdo {\n\t\tunsigned int next = offset + pool->size;\n\t\tif (unlikely((next + pool->size) >= next_boundary)) {\n\t\t\tnext = next_boundary;\n\t\t\tnext_boundary += pool->boundary;\n\t\t}\n\t\t*(int *)(page->vaddr + offset) = next;\n\t\toffset = next;\n\t} while (offset < pool->allocation);\n}"
  },
  {
    "function_name": "dma_pool_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "131-203",
    "snippet": "struct dma_pool *dma_pool_create(const char *name, struct device *dev,\n\t\t\t\t size_t size, size_t align, size_t boundary)\n{\n\tstruct dma_pool *retval;\n\tsize_t allocation;\n\tbool empty = false;\n\n\tif (align == 0)\n\t\talign = 1;\n\telse if (align & (align - 1))\n\t\treturn NULL;\n\n\tif (size == 0)\n\t\treturn NULL;\n\telse if (size < 4)\n\t\tsize = 4;\n\n\tif ((size % align) != 0)\n\t\tsize = ALIGN(size, align);\n\n\tallocation = max_t(size_t, size, PAGE_SIZE);\n\n\tif (!boundary)\n\t\tboundary = allocation;\n\telse if ((boundary < size) || (boundary & (boundary - 1)))\n\t\treturn NULL;\n\n\tretval = kmalloc_node(sizeof(*retval), GFP_KERNEL, dev_to_node(dev));\n\tif (!retval)\n\t\treturn retval;\n\n\tstrlcpy(retval->name, name, sizeof(retval->name));\n\n\tretval->dev = dev;\n\n\tINIT_LIST_HEAD(&retval->page_list);\n\tspin_lock_init(&retval->lock);\n\tretval->size = size;\n\tretval->boundary = boundary;\n\tretval->allocation = allocation;\n\n\tINIT_LIST_HEAD(&retval->pools);\n\n\t/*\n\t * pools_lock ensures that the ->dma_pools list does not get corrupted.\n\t * pools_reg_lock ensures that there is not a race between\n\t * dma_pool_create() and dma_pool_destroy() or within dma_pool_create()\n\t * when the first invocation of dma_pool_create() failed on\n\t * device_create_file() and the second assumes that it has been done (I\n\t * know it is a short window).\n\t */\n\tmutex_lock(&pools_reg_lock);\n\tmutex_lock(&pools_lock);\n\tif (list_empty(&dev->dma_pools))\n\t\tempty = true;\n\tlist_add(&retval->pools, &dev->dma_pools);\n\tmutex_unlock(&pools_lock);\n\tif (empty) {\n\t\tint err;\n\n\t\terr = device_create_file(dev, &dev_attr_pools);\n\t\tif (err) {\n\t\t\tmutex_lock(&pools_lock);\n\t\t\tlist_del(&retval->pools);\n\t\t\tmutex_unlock(&pools_lock);\n\t\t\tmutex_unlock(&pools_reg_lock);\n\t\t\tkfree(retval);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tmutex_unlock(&pools_reg_lock);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(pools_lock);",
      "static DEFINE_MUTEX(pools_reg_lock);",
      "static DEVICE_ATTR(pools, 0444, show_pools, NULL);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pools_reg_lock"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "retval"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pools_reg_lock"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pools_lock"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&retval->pools"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pools_lock"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "dev",
            "&dev_attr_pools"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pools_lock"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&retval->pools",
            "&dev->dma_pools"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dev->dma_pools"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pools_lock"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pools_reg_lock"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&retval->pools"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&retval->lock"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&retval->page_list"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "retval->name",
            "name",
            "sizeof(retval->name)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "sizeof(*retval)",
            "GFP_KERNEL",
            "dev_to_node(dev)"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3689-3692",
          "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "dev"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "size",
            "PAGE_SIZE"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "align"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(pools_lock);\nstatic DEFINE_MUTEX(pools_reg_lock);\nstatic DEVICE_ATTR(pools, 0444, show_pools, NULL);\n\nstruct dma_pool *dma_pool_create(const char *name, struct device *dev,\n\t\t\t\t size_t size, size_t align, size_t boundary)\n{\n\tstruct dma_pool *retval;\n\tsize_t allocation;\n\tbool empty = false;\n\n\tif (align == 0)\n\t\talign = 1;\n\telse if (align & (align - 1))\n\t\treturn NULL;\n\n\tif (size == 0)\n\t\treturn NULL;\n\telse if (size < 4)\n\t\tsize = 4;\n\n\tif ((size % align) != 0)\n\t\tsize = ALIGN(size, align);\n\n\tallocation = max_t(size_t, size, PAGE_SIZE);\n\n\tif (!boundary)\n\t\tboundary = allocation;\n\telse if ((boundary < size) || (boundary & (boundary - 1)))\n\t\treturn NULL;\n\n\tretval = kmalloc_node(sizeof(*retval), GFP_KERNEL, dev_to_node(dev));\n\tif (!retval)\n\t\treturn retval;\n\n\tstrlcpy(retval->name, name, sizeof(retval->name));\n\n\tretval->dev = dev;\n\n\tINIT_LIST_HEAD(&retval->page_list);\n\tspin_lock_init(&retval->lock);\n\tretval->size = size;\n\tretval->boundary = boundary;\n\tretval->allocation = allocation;\n\n\tINIT_LIST_HEAD(&retval->pools);\n\n\t/*\n\t * pools_lock ensures that the ->dma_pools list does not get corrupted.\n\t * pools_reg_lock ensures that there is not a race between\n\t * dma_pool_create() and dma_pool_destroy() or within dma_pool_create()\n\t * when the first invocation of dma_pool_create() failed on\n\t * device_create_file() and the second assumes that it has been done (I\n\t * know it is a short window).\n\t */\n\tmutex_lock(&pools_reg_lock);\n\tmutex_lock(&pools_lock);\n\tif (list_empty(&dev->dma_pools))\n\t\tempty = true;\n\tlist_add(&retval->pools, &dev->dma_pools);\n\tmutex_unlock(&pools_lock);\n\tif (empty) {\n\t\tint err;\n\n\t\terr = device_create_file(dev, &dev_attr_pools);\n\t\tif (err) {\n\t\t\tmutex_lock(&pools_lock);\n\t\t\tlist_del(&retval->pools);\n\t\t\tmutex_unlock(&pools_lock);\n\t\t\tmutex_unlock(&pools_reg_lock);\n\t\t\tkfree(retval);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tmutex_unlock(&pools_reg_lock);\n\treturn retval;\n}"
  },
  {
    "function_name": "show_pools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/dmapool.c",
    "lines": "67-106",
    "snippet": "static ssize_t\nshow_pools(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tunsigned temp;\n\tunsigned size;\n\tchar *next;\n\tstruct dma_page *page;\n\tstruct dma_pool *pool;\n\n\tnext = buf;\n\tsize = PAGE_SIZE;\n\n\ttemp = scnprintf(next, size, \"poolinfo - 0.1\\n\");\n\tsize -= temp;\n\tnext += temp;\n\n\tmutex_lock(&pools_lock);\n\tlist_for_each_entry(pool, &dev->dma_pools, pools) {\n\t\tunsigned pages = 0;\n\t\tunsigned blocks = 0;\n\n\t\tspin_lock_irq(&pool->lock);\n\t\tlist_for_each_entry(page, &pool->page_list, page_list) {\n\t\t\tpages++;\n\t\t\tblocks += page->in_use;\n\t\t}\n\t\tspin_unlock_irq(&pool->lock);\n\n\t\t/* per-pool info, no real statistics yet */\n\t\ttemp = scnprintf(next, size, \"%-16s %4u %4zu %4zu %2u\\n\",\n\t\t\t\t pool->name, blocks,\n\t\t\t\t pages * (pool->allocation / pool->size),\n\t\t\t\t pool->size, pages);\n\t\tsize -= temp;\n\t\tnext += temp;\n\t}\n\tmutex_unlock(&pools_lock);\n\n\treturn PAGE_SIZE - size;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dmapool.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(pools_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pools_lock"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "next",
            "size",
            "\"%-16s %4u %4zu %4zu %2u\\n\"",
            "pool->name",
            "blocks",
            "pages * (pool->allocation / pool->size)",
            "pool->size",
            "pages"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&pool->page_list",
            "page_list"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pool",
            "&dev->dma_pools",
            "pools"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pools_lock"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "next",
            "size",
            "\"poolinfo - 0.1\\n\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(pools_lock);\n\nstatic ssize_t\nshow_pools(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tunsigned temp;\n\tunsigned size;\n\tchar *next;\n\tstruct dma_page *page;\n\tstruct dma_pool *pool;\n\n\tnext = buf;\n\tsize = PAGE_SIZE;\n\n\ttemp = scnprintf(next, size, \"poolinfo - 0.1\\n\");\n\tsize -= temp;\n\tnext += temp;\n\n\tmutex_lock(&pools_lock);\n\tlist_for_each_entry(pool, &dev->dma_pools, pools) {\n\t\tunsigned pages = 0;\n\t\tunsigned blocks = 0;\n\n\t\tspin_lock_irq(&pool->lock);\n\t\tlist_for_each_entry(page, &pool->page_list, page_list) {\n\t\t\tpages++;\n\t\t\tblocks += page->in_use;\n\t\t}\n\t\tspin_unlock_irq(&pool->lock);\n\n\t\t/* per-pool info, no real statistics yet */\n\t\ttemp = scnprintf(next, size, \"%-16s %4u %4zu %4zu %2u\\n\",\n\t\t\t\t pool->name, blocks,\n\t\t\t\t pages * (pool->allocation / pool->size),\n\t\t\t\t pool->size, pages);\n\t\tsize -= temp;\n\t\tnext += temp;\n\t}\n\tmutex_unlock(&pools_lock);\n\n\treturn PAGE_SIZE - size;\n}"
  }
]