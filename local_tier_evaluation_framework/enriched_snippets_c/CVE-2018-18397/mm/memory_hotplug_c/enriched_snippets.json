[
  {
    "function_name": "remove_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1868-1873",
    "snippet": "void remove_memory(int nid, u64 start, u64 size)\n{\n\tlock_device_hotplug();\n\t__remove_memory(nid, start, size);\n\tunlock_device_hotplug();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_memory",
          "args": [
            "nid",
            "start",
            "size"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1838-1866",
          "snippet": "void __ref __remove_memory(int nid, u64 start, u64 size)\n{\n\tint ret;\n\n\tBUG_ON(check_hotplug_memory_range(start, size));\n\n\tmem_hotplug_begin();\n\n\t/*\n\t * All memory blocks must be offlined before removing memory.  Check\n\t * whether all memory blocks in question are offline and trigger a BUG()\n\t * if this is not the case.\n\t */\n\tret = walk_memory_range(PFN_DOWN(start), PFN_UP(start + size - 1), NULL,\n\t\t\t\tcheck_memblock_offlined_cb);\n\tif (ret)\n\t\tBUG();\n\n\t/* remove memmap entry */\n\tfirmware_map_remove(start, start + size, \"System RAM\");\n\tmemblock_free(start, size);\n\tmemblock_remove(start, size);\n\n\tarch_remove_memory(start, size, NULL);\n\n\ttry_offline_node(nid);\n\n\tmem_hotplug_done();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid __ref __remove_memory(int nid, u64 start, u64 size)\n{\n\tint ret;\n\n\tBUG_ON(check_hotplug_memory_range(start, size));\n\n\tmem_hotplug_begin();\n\n\t/*\n\t * All memory blocks must be offlined before removing memory.  Check\n\t * whether all memory blocks in question are offline and trigger a BUG()\n\t * if this is not the case.\n\t */\n\tret = walk_memory_range(PFN_DOWN(start), PFN_UP(start + size - 1), NULL,\n\t\t\t\tcheck_memblock_offlined_cb);\n\tif (ret)\n\t\tBUG();\n\n\t/* remove memmap entry */\n\tfirmware_map_remove(start, start + size, \"System RAM\");\n\tmemblock_free(start, size);\n\tmemblock_remove(start, size);\n\n\tarch_remove_memory(start, size, NULL);\n\n\ttry_offline_node(nid);\n\n\tmem_hotplug_done();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid remove_memory(int nid, u64 start, u64 size)\n{\n\tlock_device_hotplug();\n\t__remove_memory(nid, start, size);\n\tunlock_device_hotplug();\n}"
  },
  {
    "function_name": "__remove_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1838-1866",
    "snippet": "void __ref __remove_memory(int nid, u64 start, u64 size)\n{\n\tint ret;\n\n\tBUG_ON(check_hotplug_memory_range(start, size));\n\n\tmem_hotplug_begin();\n\n\t/*\n\t * All memory blocks must be offlined before removing memory.  Check\n\t * whether all memory blocks in question are offline and trigger a BUG()\n\t * if this is not the case.\n\t */\n\tret = walk_memory_range(PFN_DOWN(start), PFN_UP(start + size - 1), NULL,\n\t\t\t\tcheck_memblock_offlined_cb);\n\tif (ret)\n\t\tBUG();\n\n\t/* remove memmap entry */\n\tfirmware_map_remove(start, start + size, \"System RAM\");\n\tmemblock_free(start, size);\n\tmemblock_remove(start, size);\n\n\tarch_remove_memory(start, size, NULL);\n\n\ttry_offline_node(nid);\n\n\tmem_hotplug_done();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_hotplug_done",
          "args": [],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "92-96",
          "snippet": "void mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_offline_node",
          "args": [
            "nid"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "try_offline_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1793-1825",
          "snippet": "void try_offline_node(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tunsigned long start_pfn = pgdat->node_start_pfn;\n\tunsigned long end_pfn = start_pfn + pgdat->node_spanned_pages;\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\n\t\tif (!present_section_nr(section_nr))\n\t\t\tcontinue;\n\n\t\tif (pfn_to_nid(pfn) != nid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * some memory sections of this node are not removed, and we\n\t\t * can't offline node now.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (check_and_unmap_cpu_on_node(pgdat))\n\t\treturn;\n\n\t/*\n\t * all memory/cpu of this node are removed, we can offline this\n\t * node now.\n\t */\n\tnode_set_offline(nid);\n\tunregister_one_node(nid);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid try_offline_node(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tunsigned long start_pfn = pgdat->node_start_pfn;\n\tunsigned long end_pfn = start_pfn + pgdat->node_spanned_pages;\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\n\t\tif (!present_section_nr(section_nr))\n\t\t\tcontinue;\n\n\t\tif (pfn_to_nid(pfn) != nid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * some memory sections of this node are not removed, and we\n\t\t * can't offline node now.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (check_and_unmap_cpu_on_node(pgdat))\n\t\treturn;\n\n\t/*\n\t * all memory/cpu of this node are removed, we can offline this\n\t * node now.\n\t */\n\tnode_set_offline(nid);\n\tunregister_one_node(nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_remove_memory",
          "args": [
            "start",
            "size",
            "NULL"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_remove",
          "args": [
            "start",
            "size"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "793-801",
          "snippet": "int __init_memblock memblock_remove(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_remove: [%pa-%pa] %pS\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_remove_range(&memblock.memory, base, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_remove(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_remove: [%pa-%pa] %pS\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_remove_range(&memblock.memory, base, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_free",
          "args": [
            "start",
            "size"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "__memblock_free_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1566-1581",
          "snippet": "void __init __memblock_free_late(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t cursor, end;\n\n\tend = base + size - 1;\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tcursor = PFN_UP(base);\n\tend = PFN_DOWN(base + size);\n\n\tfor (; cursor < end; cursor++) {\n\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);\n\t\ttotalram_pages++;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init __memblock_free_late(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t cursor, end;\n\n\tend = base + size - 1;\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tcursor = PFN_UP(base);\n\tend = PFN_DOWN(base + size);\n\n\tfor (; cursor < end; cursor++) {\n\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);\n\t\ttotalram_pages++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "firmware_map_remove",
          "args": [
            "start",
            "start + size",
            "\"System RAM\""
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_memory_range",
          "args": [
            "PFN_DOWN(start)",
            "PFN_UP(start + size - 1)",
            "NULL",
            "check_memblock_offlined_cb"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "walk_memory_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1686-1721",
          "snippet": "int walk_memory_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\tvoid *arg, int (*func)(struct memory_block *, void *))\n{\n\tstruct memory_block *mem = NULL;\n\tstruct mem_section *section;\n\tunsigned long pfn, section_nr;\n\tint ret;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tsection_nr = pfn_to_section_nr(pfn);\n\t\tif (!present_section_nr(section_nr))\n\t\t\tcontinue;\n\n\t\tsection = __nr_to_section(section_nr);\n\t\t/* same memblock? */\n\t\tif (mem)\n\t\t\tif ((section_nr >= mem->start_section_nr) &&\n\t\t\t    (section_nr <= mem->end_section_nr))\n\t\t\t\tcontinue;\n\n\t\tmem = find_memory_block_hinted(section, mem);\n\t\tif (!mem)\n\t\t\tcontinue;\n\n\t\tret = func(mem, arg);\n\t\tif (ret) {\n\t\t\tkobject_put(&mem->dev.kobj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (mem)\n\t\tkobject_put(&mem->dev.kobj);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint walk_memory_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\tvoid *arg, int (*func)(struct memory_block *, void *))\n{\n\tstruct memory_block *mem = NULL;\n\tstruct mem_section *section;\n\tunsigned long pfn, section_nr;\n\tint ret;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tsection_nr = pfn_to_section_nr(pfn);\n\t\tif (!present_section_nr(section_nr))\n\t\t\tcontinue;\n\n\t\tsection = __nr_to_section(section_nr);\n\t\t/* same memblock? */\n\t\tif (mem)\n\t\t\tif ((section_nr >= mem->start_section_nr) &&\n\t\t\t    (section_nr <= mem->end_section_nr))\n\t\t\t\tcontinue;\n\n\t\tmem = find_memory_block_hinted(section, mem);\n\t\tif (!mem)\n\t\t\tcontinue;\n\n\t\tret = func(mem, arg);\n\t\tif (ret) {\n\t\t\tkobject_put(&mem->dev.kobj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (mem)\n\t\tkobject_put(&mem->dev.kobj);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "start + size - 1"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "start"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_hotplug_begin",
          "args": [],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "86-90",
          "snippet": "void mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "check_hotplug_memory_range(start, size)"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_hotplug_memory_range",
          "args": [
            "start",
            "size"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "check_hotplug_memory_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1052-1068",
          "snippet": "static int check_hotplug_memory_range(u64 start, u64 size)\n{\n\tunsigned long block_sz = memory_block_size_bytes();\n\tu64 block_nr_pages = block_sz >> PAGE_SHIFT;\n\tu64 nr_pages = size >> PAGE_SHIFT;\n\tu64 start_pfn = PFN_DOWN(start);\n\n\t/* memory range must be block size aligned */\n\tif (!nr_pages || !IS_ALIGNED(start_pfn, block_nr_pages) ||\n\t    !IS_ALIGNED(nr_pages, block_nr_pages)) {\n\t\tpr_err(\"Block size [%#lx] unaligned hotplug range: start %#llx, size %#llx\",\n\t\t       block_sz, start, size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int check_hotplug_memory_range(u64 start, u64 size)\n{\n\tunsigned long block_sz = memory_block_size_bytes();\n\tu64 block_nr_pages = block_sz >> PAGE_SHIFT;\n\tu64 nr_pages = size >> PAGE_SHIFT;\n\tu64 start_pfn = PFN_DOWN(start);\n\n\t/* memory range must be block size aligned */\n\tif (!nr_pages || !IS_ALIGNED(start_pfn, block_nr_pages) ||\n\t    !IS_ALIGNED(nr_pages, block_nr_pages)) {\n\t\tpr_err(\"Block size [%#lx] unaligned hotplug range: start %#llx, size %#llx\",\n\t\t       block_sz, start, size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid __ref __remove_memory(int nid, u64 start, u64 size)\n{\n\tint ret;\n\n\tBUG_ON(check_hotplug_memory_range(start, size));\n\n\tmem_hotplug_begin();\n\n\t/*\n\t * All memory blocks must be offlined before removing memory.  Check\n\t * whether all memory blocks in question are offline and trigger a BUG()\n\t * if this is not the case.\n\t */\n\tret = walk_memory_range(PFN_DOWN(start), PFN_UP(start + size - 1), NULL,\n\t\t\t\tcheck_memblock_offlined_cb);\n\tif (ret)\n\t\tBUG();\n\n\t/* remove memmap entry */\n\tfirmware_map_remove(start, start + size, \"System RAM\");\n\tmemblock_free(start, size);\n\tmemblock_remove(start, size);\n\n\tarch_remove_memory(start, size, NULL);\n\n\ttry_offline_node(nid);\n\n\tmem_hotplug_done();\n}"
  },
  {
    "function_name": "try_offline_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1793-1825",
    "snippet": "void try_offline_node(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tunsigned long start_pfn = pgdat->node_start_pfn;\n\tunsigned long end_pfn = start_pfn + pgdat->node_spanned_pages;\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\n\t\tif (!present_section_nr(section_nr))\n\t\t\tcontinue;\n\n\t\tif (pfn_to_nid(pfn) != nid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * some memory sections of this node are not removed, and we\n\t\t * can't offline node now.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (check_and_unmap_cpu_on_node(pgdat))\n\t\treturn;\n\n\t/*\n\t * all memory/cpu of this node are removed, we can offline this\n\t * node now.\n\t */\n\tnode_set_offline(nid);\n\tunregister_one_node(nid);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_one_node",
          "args": [
            "nid"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set_offline",
          "args": [
            "nid"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_and_unmap_cpu_on_node",
          "args": [
            "pgdat"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_unmap_cpu_on_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1767-1782",
          "snippet": "static int check_and_unmap_cpu_on_node(pg_data_t *pgdat)\n{\n\tint ret;\n\n\tret = check_cpu_on_node(pgdat);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * the node will be offlined when we come here, so we can clear\n\t * the cpu_to_node() now.\n\t */\n\n\tunmap_cpu_on_node(pgdat);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int check_and_unmap_cpu_on_node(pg_data_t *pgdat)\n{\n\tint ret;\n\n\tret = check_cpu_on_node(pgdat);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * the node will be offlined when we come here, so we can clear\n\t * the cpu_to_node() now.\n\t */\n\n\tunmap_cpu_on_node(pgdat);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_nid",
          "args": [
            "pfn"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1292-1304",
          "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "present_section_nr",
          "args": [
            "section_nr"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "next_present_section_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "188-197",
          "snippet": "static inline int next_present_section_nr(int section_nr)\n{\n\tdo {\n\t\tsection_nr++;\n\t\tif (present_section_nr(section_nr))\n\t\t\treturn section_nr;\n\t} while ((section_nr <= __highest_present_section_nr));\n\n\treturn -1;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __highest_present_section_nr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __highest_present_section_nr;\n\nstatic inline int next_present_section_nr(int section_nr)\n{\n\tdo {\n\t\tsection_nr++;\n\t\tif (present_section_nr(section_nr))\n\t\t\treturn section_nr;\n\t} while ((section_nr <= __highest_present_section_nr));\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "pfn"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid try_offline_node(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tunsigned long start_pfn = pgdat->node_start_pfn;\n\tunsigned long end_pfn = start_pfn + pgdat->node_spanned_pages;\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\n\t\tif (!present_section_nr(section_nr))\n\t\t\tcontinue;\n\n\t\tif (pfn_to_nid(pfn) != nid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * some memory sections of this node are not removed, and we\n\t\t * can't offline node now.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (check_and_unmap_cpu_on_node(pgdat))\n\t\treturn;\n\n\t/*\n\t * all memory/cpu of this node are removed, we can offline this\n\t * node now.\n\t */\n\tnode_set_offline(nid);\n\tunregister_one_node(nid);\n}"
  },
  {
    "function_name": "check_and_unmap_cpu_on_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1767-1782",
    "snippet": "static int check_and_unmap_cpu_on_node(pg_data_t *pgdat)\n{\n\tint ret;\n\n\tret = check_cpu_on_node(pgdat);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * the node will be offlined when we come here, so we can clear\n\t * the cpu_to_node() now.\n\t */\n\n\tunmap_cpu_on_node(pgdat);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_cpu_on_node",
          "args": [
            "pgdat"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_unmap_cpu_on_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1767-1782",
          "snippet": "static int check_and_unmap_cpu_on_node(pg_data_t *pgdat)\n{\n\tint ret;\n\n\tret = check_cpu_on_node(pgdat);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * the node will be offlined when we come here, so we can clear\n\t * the cpu_to_node() now.\n\t */\n\n\tunmap_cpu_on_node(pgdat);\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_cpu_on_node",
          "args": [
            "pgdat"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "check_cpu_on_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1740-1754",
          "snippet": "static int check_cpu_on_node(pg_data_t *pgdat)\n{\n\tint cpu;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (cpu_to_node(cpu) == pgdat->node_id)\n\t\t\t/*\n\t\t\t * the cpu on this node isn't removed, and we can't\n\t\t\t * offline this node.\n\t\t\t */\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int check_cpu_on_node(pg_data_t *pgdat)\n{\n\tint cpu;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (cpu_to_node(cpu) == pgdat->node_id)\n\t\t\t/*\n\t\t\t * the cpu on this node isn't removed, and we can't\n\t\t\t * offline this node.\n\t\t\t */\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int check_and_unmap_cpu_on_node(pg_data_t *pgdat)\n{\n\tint ret;\n\n\tret = check_cpu_on_node(pgdat);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * the node will be offlined when we come here, so we can clear\n\t * the cpu_to_node() now.\n\t */\n\n\tunmap_cpu_on_node(pgdat);\n\treturn 0;\n}"
  },
  {
    "function_name": "unmap_cpu_on_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1756-1765",
    "snippet": "static void unmap_cpu_on_node(pg_data_t *pgdat)\n{\n#ifdef CONFIG_ACPI_NUMA\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tif (cpu_to_node(cpu) == pgdat->node_id)\n\t\t\tnuma_clear_node(cpu);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "numa_clear_node",
          "args": [
            "cpu"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void unmap_cpu_on_node(pg_data_t *pgdat)\n{\n#ifdef CONFIG_ACPI_NUMA\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tif (cpu_to_node(cpu) == pgdat->node_id)\n\t\t\tnuma_clear_node(cpu);\n#endif\n}"
  },
  {
    "function_name": "check_cpu_on_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1740-1754",
    "snippet": "static int check_cpu_on_node(pg_data_t *pgdat)\n{\n\tint cpu;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (cpu_to_node(cpu) == pgdat->node_id)\n\t\t\t/*\n\t\t\t * the cpu on this node isn't removed, and we can't\n\t\t\t * offline this node.\n\t\t\t */\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int check_cpu_on_node(pg_data_t *pgdat)\n{\n\tint cpu;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (cpu_to_node(cpu) == pgdat->node_id)\n\t\t\t/*\n\t\t\t * the cpu on this node isn't removed, and we can't\n\t\t\t * offline this node.\n\t\t\t */\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_memblock_offlined_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1724-1738",
    "snippet": "static int check_memblock_offlined_cb(struct memory_block *mem, void *arg)\n{\n\tint ret = !is_memblock_offlined(mem);\n\n\tif (unlikely(ret)) {\n\t\tphys_addr_t beginpa, endpa;\n\n\t\tbeginpa = PFN_PHYS(section_nr_to_pfn(mem->start_section_nr));\n\t\tendpa = PFN_PHYS(section_nr_to_pfn(mem->end_section_nr + 1))-1;\n\t\tpr_warn(\"removing memory fails, because memory [%pa-%pa] is onlined\\n\",\n\t\t\t&beginpa, &endpa);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"removing memory fails, because memory [%pa-%pa] is onlined\\n\"",
            "&beginpa",
            "&endpa"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_PHYS",
          "args": [
            "section_nr_to_pfn(mem->end_section_nr + 1)"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "section_nr_to_pfn",
          "args": [
            "mem->end_section_nr + 1"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_PHYS",
          "args": [
            "section_nr_to_pfn(mem->start_section_nr)"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "section_nr_to_pfn",
          "args": [
            "mem->start_section_nr"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_memblock_offlined",
          "args": [
            "mem"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int check_memblock_offlined_cb(struct memory_block *mem, void *arg)\n{\n\tint ret = !is_memblock_offlined(mem);\n\n\tif (unlikely(ret)) {\n\t\tphys_addr_t beginpa, endpa;\n\n\t\tbeginpa = PFN_PHYS(section_nr_to_pfn(mem->start_section_nr));\n\t\tendpa = PFN_PHYS(section_nr_to_pfn(mem->end_section_nr + 1))-1;\n\t\tpr_warn(\"removing memory fails, because memory [%pa-%pa] is onlined\\n\",\n\t\t\t&beginpa, &endpa);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "walk_memory_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1686-1721",
    "snippet": "int walk_memory_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\tvoid *arg, int (*func)(struct memory_block *, void *))\n{\n\tstruct memory_block *mem = NULL;\n\tstruct mem_section *section;\n\tunsigned long pfn, section_nr;\n\tint ret;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tsection_nr = pfn_to_section_nr(pfn);\n\t\tif (!present_section_nr(section_nr))\n\t\t\tcontinue;\n\n\t\tsection = __nr_to_section(section_nr);\n\t\t/* same memblock? */\n\t\tif (mem)\n\t\t\tif ((section_nr >= mem->start_section_nr) &&\n\t\t\t    (section_nr <= mem->end_section_nr))\n\t\t\t\tcontinue;\n\n\t\tmem = find_memory_block_hinted(section, mem);\n\t\tif (!mem)\n\t\t\tcontinue;\n\n\t\tret = func(mem, arg);\n\t\tif (ret) {\n\t\t\tkobject_put(&mem->dev.kobj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (mem)\n\t\tkobject_put(&mem->dev.kobj);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&mem->dev.kobj"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&mem->dev.kobj"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "mem",
            "arg"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_memory_block_hinted",
          "args": [
            "section",
            "mem"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "section_nr"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "present_section_nr",
          "args": [
            "section_nr"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "next_present_section_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "188-197",
          "snippet": "static inline int next_present_section_nr(int section_nr)\n{\n\tdo {\n\t\tsection_nr++;\n\t\tif (present_section_nr(section_nr))\n\t\t\treturn section_nr;\n\t} while ((section_nr <= __highest_present_section_nr));\n\n\treturn -1;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __highest_present_section_nr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __highest_present_section_nr;\n\nstatic inline int next_present_section_nr(int section_nr)\n{\n\tdo {\n\t\tsection_nr++;\n\t\tif (present_section_nr(section_nr))\n\t\t\treturn section_nr;\n\t} while ((section_nr <= __highest_present_section_nr));\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "pfn"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint walk_memory_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\tvoid *arg, int (*func)(struct memory_block *, void *))\n{\n\tstruct memory_block *mem = NULL;\n\tstruct mem_section *section;\n\tunsigned long pfn, section_nr;\n\tint ret;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tsection_nr = pfn_to_section_nr(pfn);\n\t\tif (!present_section_nr(section_nr))\n\t\t\tcontinue;\n\n\t\tsection = __nr_to_section(section_nr);\n\t\t/* same memblock? */\n\t\tif (mem)\n\t\t\tif ((section_nr >= mem->start_section_nr) &&\n\t\t\t    (section_nr <= mem->end_section_nr))\n\t\t\t\tcontinue;\n\n\t\tmem = find_memory_block_hinted(section, mem);\n\t\tif (!mem)\n\t\t\tcontinue;\n\n\t\tret = func(mem, arg);\n\t\tif (ret) {\n\t\t\tkobject_put(&mem->dev.kobj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (mem)\n\t\tkobject_put(&mem->dev.kobj);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "offline_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1668-1671",
    "snippet": "int offline_pages(unsigned long start_pfn, unsigned long nr_pages)\n{\n\treturn __offline_pages(start_pfn, start_pfn + nr_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__offline_pages",
          "args": [
            "start_pfn",
            "start_pfn + nr_pages"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "__offline_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1546-1666",
          "snippet": "static int __ref __offline_pages(unsigned long start_pfn,\n\t\t  unsigned long end_pfn)\n{\n\tunsigned long pfn, nr_pages;\n\tlong offlined_pages;\n\tint ret, node;\n\tunsigned long flags;\n\tunsigned long valid_start, valid_end;\n\tstruct zone *zone;\n\tstruct memory_notify arg;\n\n\t/* at least, alignment against pageblock is necessary */\n\tif (!IS_ALIGNED(start_pfn, pageblock_nr_pages))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(end_pfn, pageblock_nr_pages))\n\t\treturn -EINVAL;\n\n\tmem_hotplug_begin();\n\n\t/* This makes hotplug much easier...and readable.\n\t   we assume this for now. .*/\n\tif (!test_pages_in_a_zone(start_pfn, end_pfn, &valid_start,\n\t\t\t\t  &valid_end)) {\n\t\tmem_hotplug_done();\n\t\treturn -EINVAL;\n\t}\n\n\tzone = page_zone(pfn_to_page(valid_start));\n\tnode = zone_to_nid(zone);\n\tnr_pages = end_pfn - start_pfn;\n\n\t/* set above range as isolated */\n\tret = start_isolate_page_range(start_pfn, end_pfn,\n\t\t\t\t       MIGRATE_MOVABLE, true);\n\tif (ret) {\n\t\tmem_hotplug_done();\n\t\treturn ret;\n\t}\n\n\targ.start_pfn = start_pfn;\n\targ.nr_pages = nr_pages;\n\tnode_states_check_changes_offline(nr_pages, zone, &arg);\n\n\tret = memory_notify(MEM_GOING_OFFLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret)\n\t\tgoto failed_removal;\n\n\tpfn = start_pfn;\nrepeat:\n\t/* start memory hot removal */\n\tret = -EINTR;\n\tif (signal_pending(current))\n\t\tgoto failed_removal;\n\n\tcond_resched();\n\tlru_add_drain_all();\n\tdrain_all_pages(zone);\n\n\tpfn = scan_movable_pages(start_pfn, end_pfn);\n\tif (pfn) { /* We have movable pages */\n\t\tret = do_migrate_range(pfn, end_pfn);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * dissolve free hugepages in the memory block before doing offlining\n\t * actually in order to make hugetlbfs's object counting consistent.\n\t */\n\tret = dissolve_free_huge_pages(start_pfn, end_pfn);\n\tif (ret)\n\t\tgoto failed_removal;\n\t/* check again */\n\tofflined_pages = check_pages_isolated(start_pfn, end_pfn);\n\tif (offlined_pages < 0)\n\t\tgoto repeat;\n\tpr_info(\"Offlined Pages %ld\\n\", offlined_pages);\n\t/* Ok, all of our target is isolated.\n\t   We cannot do rollback at this point. */\n\toffline_isolated_pages(start_pfn, end_pfn);\n\t/* reset pagetype flags and makes migrate type to be MOVABLE */\n\tundo_isolate_page_range(start_pfn, end_pfn, MIGRATE_MOVABLE);\n\t/* removal success */\n\tadjust_managed_page_count(pfn_to_page(start_pfn), -offlined_pages);\n\tzone->present_pages -= offlined_pages;\n\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tzone->zone_pgdat->node_present_pages -= offlined_pages;\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n\n\tinit_per_zone_wmark_min();\n\n\tif (!populated_zone(zone)) {\n\t\tzone_pcp_reset(zone);\n\t\tbuild_all_zonelists(NULL);\n\t} else\n\t\tzone_pcp_update(zone);\n\n\tnode_states_clear_node(node, &arg);\n\tif (arg.status_change_nid >= 0) {\n\t\tkswapd_stop(node);\n\t\tkcompactd_stop(node);\n\t}\n\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\n\tmemory_notify(MEM_OFFLINE, &arg);\n\tmem_hotplug_done();\n\treturn 0;\n\nfailed_removal:\n\tpr_debug(\"memory offlining [mem %#010llx-%#010llx] failed\\n\",\n\t\t (unsigned long long) start_pfn << PAGE_SHIFT,\n\t\t ((unsigned long long) end_pfn << PAGE_SHIFT) - 1);\n\tmemory_notify(MEM_CANCEL_OFFLINE, &arg);\n\t/* pushback to free area */\n\tundo_isolate_page_range(start_pfn, end_pfn, MIGRATE_MOVABLE);\n\tmem_hotplug_done();\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __ref __offline_pages(unsigned long start_pfn,\n\t\t  unsigned long end_pfn)\n{\n\tunsigned long pfn, nr_pages;\n\tlong offlined_pages;\n\tint ret, node;\n\tunsigned long flags;\n\tunsigned long valid_start, valid_end;\n\tstruct zone *zone;\n\tstruct memory_notify arg;\n\n\t/* at least, alignment against pageblock is necessary */\n\tif (!IS_ALIGNED(start_pfn, pageblock_nr_pages))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(end_pfn, pageblock_nr_pages))\n\t\treturn -EINVAL;\n\n\tmem_hotplug_begin();\n\n\t/* This makes hotplug much easier...and readable.\n\t   we assume this for now. .*/\n\tif (!test_pages_in_a_zone(start_pfn, end_pfn, &valid_start,\n\t\t\t\t  &valid_end)) {\n\t\tmem_hotplug_done();\n\t\treturn -EINVAL;\n\t}\n\n\tzone = page_zone(pfn_to_page(valid_start));\n\tnode = zone_to_nid(zone);\n\tnr_pages = end_pfn - start_pfn;\n\n\t/* set above range as isolated */\n\tret = start_isolate_page_range(start_pfn, end_pfn,\n\t\t\t\t       MIGRATE_MOVABLE, true);\n\tif (ret) {\n\t\tmem_hotplug_done();\n\t\treturn ret;\n\t}\n\n\targ.start_pfn = start_pfn;\n\targ.nr_pages = nr_pages;\n\tnode_states_check_changes_offline(nr_pages, zone, &arg);\n\n\tret = memory_notify(MEM_GOING_OFFLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret)\n\t\tgoto failed_removal;\n\n\tpfn = start_pfn;\nrepeat:\n\t/* start memory hot removal */\n\tret = -EINTR;\n\tif (signal_pending(current))\n\t\tgoto failed_removal;\n\n\tcond_resched();\n\tlru_add_drain_all();\n\tdrain_all_pages(zone);\n\n\tpfn = scan_movable_pages(start_pfn, end_pfn);\n\tif (pfn) { /* We have movable pages */\n\t\tret = do_migrate_range(pfn, end_pfn);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * dissolve free hugepages in the memory block before doing offlining\n\t * actually in order to make hugetlbfs's object counting consistent.\n\t */\n\tret = dissolve_free_huge_pages(start_pfn, end_pfn);\n\tif (ret)\n\t\tgoto failed_removal;\n\t/* check again */\n\tofflined_pages = check_pages_isolated(start_pfn, end_pfn);\n\tif (offlined_pages < 0)\n\t\tgoto repeat;\n\tpr_info(\"Offlined Pages %ld\\n\", offlined_pages);\n\t/* Ok, all of our target is isolated.\n\t   We cannot do rollback at this point. */\n\toffline_isolated_pages(start_pfn, end_pfn);\n\t/* reset pagetype flags and makes migrate type to be MOVABLE */\n\tundo_isolate_page_range(start_pfn, end_pfn, MIGRATE_MOVABLE);\n\t/* removal success */\n\tadjust_managed_page_count(pfn_to_page(start_pfn), -offlined_pages);\n\tzone->present_pages -= offlined_pages;\n\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tzone->zone_pgdat->node_present_pages -= offlined_pages;\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n\n\tinit_per_zone_wmark_min();\n\n\tif (!populated_zone(zone)) {\n\t\tzone_pcp_reset(zone);\n\t\tbuild_all_zonelists(NULL);\n\t} else\n\t\tzone_pcp_update(zone);\n\n\tnode_states_clear_node(node, &arg);\n\tif (arg.status_change_nid >= 0) {\n\t\tkswapd_stop(node);\n\t\tkcompactd_stop(node);\n\t}\n\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\n\tmemory_notify(MEM_OFFLINE, &arg);\n\tmem_hotplug_done();\n\treturn 0;\n\nfailed_removal:\n\tpr_debug(\"memory offlining [mem %#010llx-%#010llx] failed\\n\",\n\t\t (unsigned long long) start_pfn << PAGE_SHIFT,\n\t\t ((unsigned long long) end_pfn << PAGE_SHIFT) - 1);\n\tmemory_notify(MEM_CANCEL_OFFLINE, &arg);\n\t/* pushback to free area */\n\tundo_isolate_page_range(start_pfn, end_pfn, MIGRATE_MOVABLE);\n\tmem_hotplug_done();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint offline_pages(unsigned long start_pfn, unsigned long nr_pages)\n{\n\treturn __offline_pages(start_pfn, start_pfn + nr_pages);\n}"
  },
  {
    "function_name": "__offline_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1546-1666",
    "snippet": "static int __ref __offline_pages(unsigned long start_pfn,\n\t\t  unsigned long end_pfn)\n{\n\tunsigned long pfn, nr_pages;\n\tlong offlined_pages;\n\tint ret, node;\n\tunsigned long flags;\n\tunsigned long valid_start, valid_end;\n\tstruct zone *zone;\n\tstruct memory_notify arg;\n\n\t/* at least, alignment against pageblock is necessary */\n\tif (!IS_ALIGNED(start_pfn, pageblock_nr_pages))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(end_pfn, pageblock_nr_pages))\n\t\treturn -EINVAL;\n\n\tmem_hotplug_begin();\n\n\t/* This makes hotplug much easier...and readable.\n\t   we assume this for now. .*/\n\tif (!test_pages_in_a_zone(start_pfn, end_pfn, &valid_start,\n\t\t\t\t  &valid_end)) {\n\t\tmem_hotplug_done();\n\t\treturn -EINVAL;\n\t}\n\n\tzone = page_zone(pfn_to_page(valid_start));\n\tnode = zone_to_nid(zone);\n\tnr_pages = end_pfn - start_pfn;\n\n\t/* set above range as isolated */\n\tret = start_isolate_page_range(start_pfn, end_pfn,\n\t\t\t\t       MIGRATE_MOVABLE, true);\n\tif (ret) {\n\t\tmem_hotplug_done();\n\t\treturn ret;\n\t}\n\n\targ.start_pfn = start_pfn;\n\targ.nr_pages = nr_pages;\n\tnode_states_check_changes_offline(nr_pages, zone, &arg);\n\n\tret = memory_notify(MEM_GOING_OFFLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret)\n\t\tgoto failed_removal;\n\n\tpfn = start_pfn;\nrepeat:\n\t/* start memory hot removal */\n\tret = -EINTR;\n\tif (signal_pending(current))\n\t\tgoto failed_removal;\n\n\tcond_resched();\n\tlru_add_drain_all();\n\tdrain_all_pages(zone);\n\n\tpfn = scan_movable_pages(start_pfn, end_pfn);\n\tif (pfn) { /* We have movable pages */\n\t\tret = do_migrate_range(pfn, end_pfn);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * dissolve free hugepages in the memory block before doing offlining\n\t * actually in order to make hugetlbfs's object counting consistent.\n\t */\n\tret = dissolve_free_huge_pages(start_pfn, end_pfn);\n\tif (ret)\n\t\tgoto failed_removal;\n\t/* check again */\n\tofflined_pages = check_pages_isolated(start_pfn, end_pfn);\n\tif (offlined_pages < 0)\n\t\tgoto repeat;\n\tpr_info(\"Offlined Pages %ld\\n\", offlined_pages);\n\t/* Ok, all of our target is isolated.\n\t   We cannot do rollback at this point. */\n\toffline_isolated_pages(start_pfn, end_pfn);\n\t/* reset pagetype flags and makes migrate type to be MOVABLE */\n\tundo_isolate_page_range(start_pfn, end_pfn, MIGRATE_MOVABLE);\n\t/* removal success */\n\tadjust_managed_page_count(pfn_to_page(start_pfn), -offlined_pages);\n\tzone->present_pages -= offlined_pages;\n\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tzone->zone_pgdat->node_present_pages -= offlined_pages;\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n\n\tinit_per_zone_wmark_min();\n\n\tif (!populated_zone(zone)) {\n\t\tzone_pcp_reset(zone);\n\t\tbuild_all_zonelists(NULL);\n\t} else\n\t\tzone_pcp_update(zone);\n\n\tnode_states_clear_node(node, &arg);\n\tif (arg.status_change_nid >= 0) {\n\t\tkswapd_stop(node);\n\t\tkcompactd_stop(node);\n\t}\n\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\n\tmemory_notify(MEM_OFFLINE, &arg);\n\tmem_hotplug_done();\n\treturn 0;\n\nfailed_removal:\n\tpr_debug(\"memory offlining [mem %#010llx-%#010llx] failed\\n\",\n\t\t (unsigned long long) start_pfn << PAGE_SHIFT,\n\t\t ((unsigned long long) end_pfn << PAGE_SHIFT) - 1);\n\tmemory_notify(MEM_CANCEL_OFFLINE, &arg);\n\t/* pushback to free area */\n\tundo_isolate_page_range(start_pfn, end_pfn, MIGRATE_MOVABLE);\n\tmem_hotplug_done();\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_hotplug_done",
          "args": [],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "92-96",
          "snippet": "void mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "undo_isolate_page_range",
          "args": [
            "start_pfn",
            "end_pfn",
            "MIGRATE_MOVABLE"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "undo_isolate_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "224-242",
          "snippet": "int undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t    unsigned migratetype)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (!page || !is_migrate_isolate_page(page))\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nint undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t    unsigned migratetype)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (!page || !is_migrate_isolate_page(page))\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memory_notify",
          "args": [
            "MEM_CANCEL_OFFLINE",
            "&arg"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"memory offlining [mem %#010llx-%#010llx] failed\\n\"",
            "(unsigned long long) start_pfn << PAGE_SHIFT",
            "((unsigned long long) end_pfn << PAGE_SHIFT) - 1"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_notify",
          "args": [
            "MEM_OFFLINE",
            "&arg"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_set_ratelimit",
          "args": [],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_set_ratelimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2039-2050",
          "snippet": "void writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long ratelimit_pages = 32;",
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long ratelimit_pages = 32;\nstruct wb_domain global_wb_domain;\n\nvoid writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_free_pagecache_pages",
          "args": [],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "nr_free_pagecache_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4690-4693",
          "snippet": "unsigned long nr_free_pagecache_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_HIGHUSER_MOVABLE));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nunsigned long nr_free_pagecache_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_HIGHUSER_MOVABLE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcompactd_stop",
          "args": [
            "node"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "kcompactd_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "2111-2119",
          "snippet": "void kcompactd_stop(int nid)\n{\n\tstruct task_struct *kcompactd = NODE_DATA(nid)->kcompactd;\n\n\tif (kcompactd) {\n\t\tkthread_stop(kcompactd);\n\t\tNODE_DATA(nid)->kcompactd = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid kcompactd_stop(int nid)\n{\n\tstruct task_struct *kcompactd = NODE_DATA(nid)->kcompactd;\n\n\tif (kcompactd) {\n\t\tkthread_stop(kcompactd);\n\t\tNODE_DATA(nid)->kcompactd = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kswapd_stop",
          "args": [
            "node"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "kswapd_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3965-3973",
          "snippet": "void kswapd_stop(int nid)\n{\n\tstruct task_struct *kswapd = NODE_DATA(nid)->kswapd;\n\n\tif (kswapd) {\n\t\tkthread_stop(kswapd);\n\t\tNODE_DATA(nid)->kswapd = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid kswapd_stop(int nid)\n{\n\tstruct task_struct *kswapd = NODE_DATA(nid)->kswapd;\n\n\tif (kswapd) {\n\t\tkthread_stop(kswapd);\n\t\tNODE_DATA(nid)->kswapd = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_states_clear_node",
          "args": [
            "node",
            "&arg"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "node_states_clear_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1534-1544",
          "snippet": "static void node_states_clear_node(int node, struct memory_notify *arg)\n{\n\tif (arg->status_change_nid_normal >= 0)\n\t\tnode_clear_state(node, N_NORMAL_MEMORY);\n\n\tif (arg->status_change_nid_high >= 0)\n\t\tnode_clear_state(node, N_HIGH_MEMORY);\n\n\tif (arg->status_change_nid >= 0)\n\t\tnode_clear_state(node, N_MEMORY);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void node_states_clear_node(int node, struct memory_notify *arg)\n{\n\tif (arg->status_change_nid_normal >= 0)\n\t\tnode_clear_state(node, N_NORMAL_MEMORY);\n\n\tif (arg->status_change_nid_high >= 0)\n\t\tnode_clear_state(node, N_HIGH_MEMORY);\n\n\tif (arg->status_change_nid >= 0)\n\t\tnode_clear_state(node, N_MEMORY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_pcp_update",
          "args": [
            "zone"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_all_zonelists",
          "args": [
            "NULL"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_pcp_reset",
          "args": [
            "zone"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_per_zone_wmark_min",
          "args": [],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "zone->zone_pgdat",
            "&flags"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_lock",
          "args": [
            "zone->zone_pgdat",
            "&flags"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_managed_page_count",
          "args": [
            "pfn_to_page(start_pfn)",
            "-offlined_pages"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "start_pfn"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offline_isolated_pages",
          "args": [
            "start_pfn",
            "end_pfn"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "offline_isolated_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1432-1437",
          "snippet": "static void\noffline_isolated_pages(unsigned long start_pfn, unsigned long end_pfn)\n{\n\twalk_system_ram_range(start_pfn, end_pfn - start_pfn, NULL,\n\t\t\t\toffline_isolated_pages_cb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void\noffline_isolated_pages(unsigned long start_pfn, unsigned long end_pfn)\n{\n\twalk_system_ram_range(start_pfn, end_pfn - start_pfn, NULL,\n\t\t\t\toffline_isolated_pages_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Offlined Pages %ld\\n\"",
            "offlined_pages"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_pages_isolated",
          "args": [
            "start_pfn",
            "end_pfn"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "check_pages_isolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1455-1466",
          "snippet": "static long\ncheck_pages_isolated(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tlong offlined = 0;\n\tint ret;\n\n\tret = walk_system_ram_range(start_pfn, end_pfn - start_pfn, &offlined,\n\t\t\tcheck_pages_isolated_cb);\n\tif (ret < 0)\n\t\tofflined = (long)ret;\n\treturn offlined;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic long\ncheck_pages_isolated(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tlong offlined = 0;\n\tint ret;\n\n\tret = walk_system_ram_range(start_pfn, end_pfn - start_pfn, &offlined,\n\t\t\tcheck_pages_isolated_cb);\n\tif (ret < 0)\n\t\tofflined = (long)ret;\n\treturn offlined;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dissolve_free_huge_pages",
          "args": [
            "start_pfn",
            "end_pfn"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "dissolve_free_huge_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1524-1543",
          "snippet": "int dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tint rc = 0;\n\n\tif (!hugepages_supported())\n\t\treturn rc;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += 1 << minimum_order) {\n\t\tpage = pfn_to_page(pfn);\n\t\tif (PageHuge(page) && !page_count(page)) {\n\t\t\trc = dissolve_free_huge_page(page);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int minimum_order"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic unsigned int minimum_order;\n\nint dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tint rc = 0;\n\n\tif (!hugepages_supported())\n\t\treturn rc;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += 1 << minimum_order) {\n\t\tpage = pfn_to_page(pfn);\n\t\tif (PageHuge(page) && !page_count(page)) {\n\t\t\trc = dissolve_free_huge_page(page);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_migrate_range",
          "args": [
            "pfn",
            "end_pfn"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "do_migrate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1343-1419",
          "snippet": "static int\ndo_migrate_range(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tint move_pages = NR_OFFLINE_AT_ONCE_PAGES;\n\tint not_managed = 0;\n\tint ret = 0;\n\tLIST_HEAD(source);\n\n\tfor (pfn = start_pfn; pfn < end_pfn && move_pages > 0; pfn++) {\n\t\tif (!pfn_valid(pfn))\n\t\t\tcontinue;\n\t\tpage = pfn_to_page(pfn);\n\n\t\tif (PageHuge(page)) {\n\t\t\tstruct page *head = compound_head(page);\n\t\t\tpfn = page_to_pfn(head) + (1<<compound_order(head)) - 1;\n\t\t\tif (compound_order(head) > PFN_SECTION_SHIFT) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isolate_huge_page(page, &source))\n\t\t\t\tmove_pages -= 1 << compound_order(head);\n\t\t\tcontinue;\n\t\t} else if (PageTransHuge(page))\n\t\t\tpfn = page_to_pfn(compound_head(page))\n\t\t\t\t+ hpage_nr_pages(page) - 1;\n\n\t\tif (!get_page_unless_zero(page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can skip free pages. And we can deal with pages on\n\t\t * LRU and non-lru movable pages.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tret = isolate_lru_page(page);\n\t\telse\n\t\t\tret = isolate_movable_page(page, ISOLATE_UNEVICTABLE);\n\t\tif (!ret) { /* Success */\n\t\t\tput_page(page);\n\t\t\tlist_add_tail(&page->lru, &source);\n\t\t\tmove_pages--;\n\t\t\tif (!__PageMovable(page))\n\t\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t\t    page_is_file_cache(page));\n\n\t\t} else {\n#ifdef CONFIG_DEBUG_VM\n\t\t\tpr_alert(\"failed to isolate pfn %lx\\n\", pfn);\n\t\t\tdump_page(page, \"isolation failed\");\n#endif\n\t\t\tput_page(page);\n\t\t\t/* Because we don't have big zone->lock. we should\n\t\t\t   check this again here. */\n\t\t\tif (page_count(page)) {\n\t\t\t\tnot_managed++;\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!list_empty(&source)) {\n\t\tif (not_managed) {\n\t\t\tputback_movable_pages(&source);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Allocate a new page from the nearest neighbor node */\n\t\tret = migrate_pages(&source, new_node_page, NULL, 0,\n\t\t\t\t\tMIGRATE_SYNC, MR_MEMORY_HOTPLUG);\n\t\tif (ret)\n\t\t\tputback_movable_pages(&source);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [
            "#define NR_OFFLINE_AT_ONCE_PAGES\t(256)"
          ],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\n#define NR_OFFLINE_AT_ONCE_PAGES\t(256)\n\nstatic void generic_online_page(struct page *page);\n\nstatic int\ndo_migrate_range(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tint move_pages = NR_OFFLINE_AT_ONCE_PAGES;\n\tint not_managed = 0;\n\tint ret = 0;\n\tLIST_HEAD(source);\n\n\tfor (pfn = start_pfn; pfn < end_pfn && move_pages > 0; pfn++) {\n\t\tif (!pfn_valid(pfn))\n\t\t\tcontinue;\n\t\tpage = pfn_to_page(pfn);\n\n\t\tif (PageHuge(page)) {\n\t\t\tstruct page *head = compound_head(page);\n\t\t\tpfn = page_to_pfn(head) + (1<<compound_order(head)) - 1;\n\t\t\tif (compound_order(head) > PFN_SECTION_SHIFT) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isolate_huge_page(page, &source))\n\t\t\t\tmove_pages -= 1 << compound_order(head);\n\t\t\tcontinue;\n\t\t} else if (PageTransHuge(page))\n\t\t\tpfn = page_to_pfn(compound_head(page))\n\t\t\t\t+ hpage_nr_pages(page) - 1;\n\n\t\tif (!get_page_unless_zero(page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can skip free pages. And we can deal with pages on\n\t\t * LRU and non-lru movable pages.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tret = isolate_lru_page(page);\n\t\telse\n\t\t\tret = isolate_movable_page(page, ISOLATE_UNEVICTABLE);\n\t\tif (!ret) { /* Success */\n\t\t\tput_page(page);\n\t\t\tlist_add_tail(&page->lru, &source);\n\t\t\tmove_pages--;\n\t\t\tif (!__PageMovable(page))\n\t\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t\t    page_is_file_cache(page));\n\n\t\t} else {\n#ifdef CONFIG_DEBUG_VM\n\t\t\tpr_alert(\"failed to isolate pfn %lx\\n\", pfn);\n\t\t\tdump_page(page, \"isolation failed\");\n#endif\n\t\t\tput_page(page);\n\t\t\t/* Because we don't have big zone->lock. we should\n\t\t\t   check this again here. */\n\t\t\tif (page_count(page)) {\n\t\t\t\tnot_managed++;\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!list_empty(&source)) {\n\t\tif (not_managed) {\n\t\t\tputback_movable_pages(&source);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Allocate a new page from the nearest neighbor node */\n\t\tret = migrate_pages(&source, new_node_page, NULL, 0,\n\t\t\t\t\tMIGRATE_SYNC, MR_MEMORY_HOTPLUG);\n\t\tif (ret)\n\t\t\tputback_movable_pages(&source);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_movable_pages",
          "args": [
            "start_pfn",
            "end_pfn"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "scan_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1301-1323",
          "snippet": "static unsigned long scan_movable_pages(unsigned long start, unsigned long end)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tfor (pfn = start; pfn < end; pfn++) {\n\t\tif (pfn_valid(pfn)) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\tif (PageLRU(page))\n\t\t\t\treturn pfn;\n\t\t\tif (__PageMovable(page))\n\t\t\t\treturn pfn;\n\t\t\tif (PageHuge(page)) {\n\t\t\t\tif (hugepage_migration_supported(page_hstate(page)) &&\n\t\t\t\t    page_huge_active(page))\n\t\t\t\t\treturn pfn;\n\t\t\t\telse\n\t\t\t\t\tpfn = round_up(pfn + 1,\n\t\t\t\t\t\t1 << compound_order(page)) - 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic unsigned long scan_movable_pages(unsigned long start, unsigned long end)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tfor (pfn = start; pfn < end; pfn++) {\n\t\tif (pfn_valid(pfn)) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\tif (PageLRU(page))\n\t\t\t\treturn pfn;\n\t\t\tif (__PageMovable(page))\n\t\t\t\treturn pfn;\n\t\t\tif (PageHuge(page)) {\n\t\t\t\tif (hugepage_migration_supported(page_hstate(page)) &&\n\t\t\t\t    page_huge_active(page))\n\t\t\t\t\treturn pfn;\n\t\t\t\telse\n\t\t\t\t\tpfn = round_up(pfn + 1,\n\t\t\t\t\t\t1 << compound_order(page)) - 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_all_pages",
          "args": [
            "zone"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2614-2682",
          "snippet": "void drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notifier_to_errno",
          "args": [
            "ret"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_notify",
          "args": [
            "MEM_GOING_OFFLINE",
            "&arg"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_states_check_changes_offline",
          "args": [
            "nr_pages",
            "zone",
            "&arg"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "node_states_check_changes_offline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1480-1532",
          "snippet": "static void node_states_check_changes_offline(unsigned long nr_pages,\n\t\tstruct zone *zone, struct memory_notify *arg)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tunsigned long present_pages = 0;\n\tenum zone_type zt;\n\n\targ->status_change_nid = -1;\n\targ->status_change_nid_normal = -1;\n\targ->status_change_nid_high = -1;\n\n\t/*\n\t * Check whether node_states[N_NORMAL_MEMORY] will be changed.\n\t * If the memory to be offline is within the range\n\t * [0..ZONE_NORMAL], and it is the last present memory there,\n\t * the zones in that range will become empty after the offlining,\n\t * thus we can determine that we need to clear the node from\n\t * node_states[N_NORMAL_MEMORY].\n\t */\n\tfor (zt = 0; zt <= ZONE_NORMAL; zt++)\n\t\tpresent_pages += pgdat->node_zones[zt].present_pages;\n\tif (zone_idx(zone) <= ZONE_NORMAL && nr_pages >= present_pages)\n\t\targ->status_change_nid_normal = zone_to_nid(zone);\n\n#ifdef CONFIG_HIGHMEM\n\t/*\n\t * node_states[N_HIGH_MEMORY] contains nodes which\n\t * have normal memory or high memory.\n\t * Here we add the present_pages belonging to ZONE_HIGHMEM.\n\t * If the zone is within the range of [0..ZONE_HIGHMEM), and\n\t * we determine that the zones in that range become empty,\n\t * we need to clear the node for N_HIGH_MEMORY.\n\t */\n\tpresent_pages += pgdat->node_zones[ZONE_HIGHMEM].present_pages;\n\tif (zone_idx(zone) <= ZONE_HIGHMEM && nr_pages >= present_pages)\n\t\targ->status_change_nid_high = zone_to_nid(zone);\n#endif\n\n\t/*\n\t * We have accounted the pages from [0..ZONE_NORMAL), and\n\t * in case of CONFIG_HIGHMEM the pages from ZONE_HIGHMEM\n\t * as well.\n\t * Here we count the possible pages from ZONE_MOVABLE.\n\t * If after having accounted all the pages, we see that the nr_pages\n\t * to be offlined is over or equal to the accounted pages,\n\t * we know that the node will become empty, and so, we can clear\n\t * it for N_MEMORY as well.\n\t */\n\tpresent_pages += pgdat->node_zones[ZONE_MOVABLE].present_pages;\n\n\tif (nr_pages >= present_pages)\n\t\targ->status_change_nid = zone_to_nid(zone);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void node_states_check_changes_offline(unsigned long nr_pages,\n\t\tstruct zone *zone, struct memory_notify *arg)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tunsigned long present_pages = 0;\n\tenum zone_type zt;\n\n\targ->status_change_nid = -1;\n\targ->status_change_nid_normal = -1;\n\targ->status_change_nid_high = -1;\n\n\t/*\n\t * Check whether node_states[N_NORMAL_MEMORY] will be changed.\n\t * If the memory to be offline is within the range\n\t * [0..ZONE_NORMAL], and it is the last present memory there,\n\t * the zones in that range will become empty after the offlining,\n\t * thus we can determine that we need to clear the node from\n\t * node_states[N_NORMAL_MEMORY].\n\t */\n\tfor (zt = 0; zt <= ZONE_NORMAL; zt++)\n\t\tpresent_pages += pgdat->node_zones[zt].present_pages;\n\tif (zone_idx(zone) <= ZONE_NORMAL && nr_pages >= present_pages)\n\t\targ->status_change_nid_normal = zone_to_nid(zone);\n\n#ifdef CONFIG_HIGHMEM\n\t/*\n\t * node_states[N_HIGH_MEMORY] contains nodes which\n\t * have normal memory or high memory.\n\t * Here we add the present_pages belonging to ZONE_HIGHMEM.\n\t * If the zone is within the range of [0..ZONE_HIGHMEM), and\n\t * we determine that the zones in that range become empty,\n\t * we need to clear the node for N_HIGH_MEMORY.\n\t */\n\tpresent_pages += pgdat->node_zones[ZONE_HIGHMEM].present_pages;\n\tif (zone_idx(zone) <= ZONE_HIGHMEM && nr_pages >= present_pages)\n\t\targ->status_change_nid_high = zone_to_nid(zone);\n#endif\n\n\t/*\n\t * We have accounted the pages from [0..ZONE_NORMAL), and\n\t * in case of CONFIG_HIGHMEM the pages from ZONE_HIGHMEM\n\t * as well.\n\t * Here we count the possible pages from ZONE_MOVABLE.\n\t * If after having accounted all the pages, we see that the nr_pages\n\t * to be offlined is over or equal to the accounted pages,\n\t * we know that the node will become empty, and so, we can clear\n\t * it for N_MEMORY as well.\n\t */\n\tpresent_pages += pgdat->node_zones[ZONE_MOVABLE].present_pages;\n\n\tif (nr_pages >= present_pages)\n\t\targ->status_change_nid = zone_to_nid(zone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_isolate_page_range",
          "args": [
            "start_pfn",
            "end_pfn",
            "MIGRATE_MOVABLE",
            "true"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "start_isolate_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "187-219",
          "snippet": "int start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t     unsigned migratetype, bool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn;\n\tunsigned long undo_pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page &&\n\t\t    set_migratetype_isolate(page, migratetype, skip_hwpoisoned_pages)) {\n\t\t\tundo_pfn = pfn;\n\t\t\tgoto undo;\n\t\t}\n\t}\n\treturn 0;\nundo:\n\tfor (pfn = start_pfn;\n\t     pfn < undo_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tstruct page *page = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\n\treturn -EBUSY;\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nint start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t     unsigned migratetype, bool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn;\n\tunsigned long undo_pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page &&\n\t\t    set_migratetype_isolate(page, migratetype, skip_hwpoisoned_pages)) {\n\t\t\tundo_pfn = pfn;\n\t\t\tgoto undo;\n\t\t}\n\t}\n\treturn 0;\nundo:\n\tfor (pfn = start_pfn;\n\t     pfn < undo_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tstruct page *page = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "pfn_to_page(valid_start)"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "valid_start"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_pages_in_a_zone",
          "args": [
            "start_pfn",
            "end_pfn",
            "&valid_start",
            "&valid_end"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "test_pages_in_a_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1253-1293",
          "snippet": "int test_pages_in_a_zone(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t unsigned long *valid_start, unsigned long *valid_end)\n{\n\tunsigned long pfn, sec_end_pfn;\n\tunsigned long start, end;\n\tstruct zone *zone = NULL;\n\tstruct page *page;\n\tint i;\n\tfor (pfn = start_pfn, sec_end_pfn = SECTION_ALIGN_UP(start_pfn + 1);\n\t     pfn < end_pfn;\n\t     pfn = sec_end_pfn, sec_end_pfn += PAGES_PER_SECTION) {\n\t\t/* Make sure the memory section is present first */\n\t\tif (!present_section_nr(pfn_to_section_nr(pfn)))\n\t\t\tcontinue;\n\t\tfor (; pfn < sec_end_pfn && pfn < end_pfn;\n\t\t     pfn += MAX_ORDER_NR_PAGES) {\n\t\t\ti = 0;\n\t\t\t/* This is just a CONFIG_HOLES_IN_ZONE check.*/\n\t\t\twhile ((i < MAX_ORDER_NR_PAGES) &&\n\t\t\t\t!pfn_valid_within(pfn + i))\n\t\t\t\ti++;\n\t\t\tif (i == MAX_ORDER_NR_PAGES || pfn + i >= end_pfn)\n\t\t\t\tcontinue;\n\t\t\tpage = pfn_to_page(pfn + i);\n\t\t\tif (zone && page_zone(page) != zone)\n\t\t\t\treturn 0;\n\t\t\tif (!zone)\n\t\t\t\tstart = pfn + i;\n\t\t\tzone = page_zone(page);\n\t\t\tend = pfn + MAX_ORDER_NR_PAGES;\n\t\t}\n\t}\n\n\tif (zone) {\n\t\t*valid_start = start;\n\t\t*valid_end = min(end, end_pfn);\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nint test_pages_in_a_zone(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t unsigned long *valid_start, unsigned long *valid_end)\n{\n\tunsigned long pfn, sec_end_pfn;\n\tunsigned long start, end;\n\tstruct zone *zone = NULL;\n\tstruct page *page;\n\tint i;\n\tfor (pfn = start_pfn, sec_end_pfn = SECTION_ALIGN_UP(start_pfn + 1);\n\t     pfn < end_pfn;\n\t     pfn = sec_end_pfn, sec_end_pfn += PAGES_PER_SECTION) {\n\t\t/* Make sure the memory section is present first */\n\t\tif (!present_section_nr(pfn_to_section_nr(pfn)))\n\t\t\tcontinue;\n\t\tfor (; pfn < sec_end_pfn && pfn < end_pfn;\n\t\t     pfn += MAX_ORDER_NR_PAGES) {\n\t\t\ti = 0;\n\t\t\t/* This is just a CONFIG_HOLES_IN_ZONE check.*/\n\t\t\twhile ((i < MAX_ORDER_NR_PAGES) &&\n\t\t\t\t!pfn_valid_within(pfn + i))\n\t\t\t\ti++;\n\t\t\tif (i == MAX_ORDER_NR_PAGES || pfn + i >= end_pfn)\n\t\t\t\tcontinue;\n\t\t\tpage = pfn_to_page(pfn + i);\n\t\t\tif (zone && page_zone(page) != zone)\n\t\t\t\treturn 0;\n\t\t\tif (!zone)\n\t\t\t\tstart = pfn + i;\n\t\t\tzone = page_zone(page);\n\t\t\tend = pfn + MAX_ORDER_NR_PAGES;\n\t\t}\n\t}\n\n\tif (zone) {\n\t\t*valid_start = start;\n\t\t*valid_end = min(end, end_pfn);\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_hotplug_begin",
          "args": [],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "86-90",
          "snippet": "void mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "end_pfn",
            "pageblock_nr_pages"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "start_pfn",
            "pageblock_nr_pages"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __ref __offline_pages(unsigned long start_pfn,\n\t\t  unsigned long end_pfn)\n{\n\tunsigned long pfn, nr_pages;\n\tlong offlined_pages;\n\tint ret, node;\n\tunsigned long flags;\n\tunsigned long valid_start, valid_end;\n\tstruct zone *zone;\n\tstruct memory_notify arg;\n\n\t/* at least, alignment against pageblock is necessary */\n\tif (!IS_ALIGNED(start_pfn, pageblock_nr_pages))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(end_pfn, pageblock_nr_pages))\n\t\treturn -EINVAL;\n\n\tmem_hotplug_begin();\n\n\t/* This makes hotplug much easier...and readable.\n\t   we assume this for now. .*/\n\tif (!test_pages_in_a_zone(start_pfn, end_pfn, &valid_start,\n\t\t\t\t  &valid_end)) {\n\t\tmem_hotplug_done();\n\t\treturn -EINVAL;\n\t}\n\n\tzone = page_zone(pfn_to_page(valid_start));\n\tnode = zone_to_nid(zone);\n\tnr_pages = end_pfn - start_pfn;\n\n\t/* set above range as isolated */\n\tret = start_isolate_page_range(start_pfn, end_pfn,\n\t\t\t\t       MIGRATE_MOVABLE, true);\n\tif (ret) {\n\t\tmem_hotplug_done();\n\t\treturn ret;\n\t}\n\n\targ.start_pfn = start_pfn;\n\targ.nr_pages = nr_pages;\n\tnode_states_check_changes_offline(nr_pages, zone, &arg);\n\n\tret = memory_notify(MEM_GOING_OFFLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret)\n\t\tgoto failed_removal;\n\n\tpfn = start_pfn;\nrepeat:\n\t/* start memory hot removal */\n\tret = -EINTR;\n\tif (signal_pending(current))\n\t\tgoto failed_removal;\n\n\tcond_resched();\n\tlru_add_drain_all();\n\tdrain_all_pages(zone);\n\n\tpfn = scan_movable_pages(start_pfn, end_pfn);\n\tif (pfn) { /* We have movable pages */\n\t\tret = do_migrate_range(pfn, end_pfn);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * dissolve free hugepages in the memory block before doing offlining\n\t * actually in order to make hugetlbfs's object counting consistent.\n\t */\n\tret = dissolve_free_huge_pages(start_pfn, end_pfn);\n\tif (ret)\n\t\tgoto failed_removal;\n\t/* check again */\n\tofflined_pages = check_pages_isolated(start_pfn, end_pfn);\n\tif (offlined_pages < 0)\n\t\tgoto repeat;\n\tpr_info(\"Offlined Pages %ld\\n\", offlined_pages);\n\t/* Ok, all of our target is isolated.\n\t   We cannot do rollback at this point. */\n\toffline_isolated_pages(start_pfn, end_pfn);\n\t/* reset pagetype flags and makes migrate type to be MOVABLE */\n\tundo_isolate_page_range(start_pfn, end_pfn, MIGRATE_MOVABLE);\n\t/* removal success */\n\tadjust_managed_page_count(pfn_to_page(start_pfn), -offlined_pages);\n\tzone->present_pages -= offlined_pages;\n\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tzone->zone_pgdat->node_present_pages -= offlined_pages;\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n\n\tinit_per_zone_wmark_min();\n\n\tif (!populated_zone(zone)) {\n\t\tzone_pcp_reset(zone);\n\t\tbuild_all_zonelists(NULL);\n\t} else\n\t\tzone_pcp_update(zone);\n\n\tnode_states_clear_node(node, &arg);\n\tif (arg.status_change_nid >= 0) {\n\t\tkswapd_stop(node);\n\t\tkcompactd_stop(node);\n\t}\n\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\n\tmemory_notify(MEM_OFFLINE, &arg);\n\tmem_hotplug_done();\n\treturn 0;\n\nfailed_removal:\n\tpr_debug(\"memory offlining [mem %#010llx-%#010llx] failed\\n\",\n\t\t (unsigned long long) start_pfn << PAGE_SHIFT,\n\t\t ((unsigned long long) end_pfn << PAGE_SHIFT) - 1);\n\tmemory_notify(MEM_CANCEL_OFFLINE, &arg);\n\t/* pushback to free area */\n\tundo_isolate_page_range(start_pfn, end_pfn, MIGRATE_MOVABLE);\n\tmem_hotplug_done();\n\treturn ret;\n}"
  },
  {
    "function_name": "node_states_clear_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1534-1544",
    "snippet": "static void node_states_clear_node(int node, struct memory_notify *arg)\n{\n\tif (arg->status_change_nid_normal >= 0)\n\t\tnode_clear_state(node, N_NORMAL_MEMORY);\n\n\tif (arg->status_change_nid_high >= 0)\n\t\tnode_clear_state(node, N_HIGH_MEMORY);\n\n\tif (arg->status_change_nid >= 0)\n\t\tnode_clear_state(node, N_MEMORY);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_clear_state",
          "args": [
            "node",
            "N_MEMORY"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_clear_state",
          "args": [
            "node",
            "N_HIGH_MEMORY"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_clear_state",
          "args": [
            "node",
            "N_NORMAL_MEMORY"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void node_states_clear_node(int node, struct memory_notify *arg)\n{\n\tif (arg->status_change_nid_normal >= 0)\n\t\tnode_clear_state(node, N_NORMAL_MEMORY);\n\n\tif (arg->status_change_nid_high >= 0)\n\t\tnode_clear_state(node, N_HIGH_MEMORY);\n\n\tif (arg->status_change_nid >= 0)\n\t\tnode_clear_state(node, N_MEMORY);\n}"
  },
  {
    "function_name": "node_states_check_changes_offline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1480-1532",
    "snippet": "static void node_states_check_changes_offline(unsigned long nr_pages,\n\t\tstruct zone *zone, struct memory_notify *arg)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tunsigned long present_pages = 0;\n\tenum zone_type zt;\n\n\targ->status_change_nid = -1;\n\targ->status_change_nid_normal = -1;\n\targ->status_change_nid_high = -1;\n\n\t/*\n\t * Check whether node_states[N_NORMAL_MEMORY] will be changed.\n\t * If the memory to be offline is within the range\n\t * [0..ZONE_NORMAL], and it is the last present memory there,\n\t * the zones in that range will become empty after the offlining,\n\t * thus we can determine that we need to clear the node from\n\t * node_states[N_NORMAL_MEMORY].\n\t */\n\tfor (zt = 0; zt <= ZONE_NORMAL; zt++)\n\t\tpresent_pages += pgdat->node_zones[zt].present_pages;\n\tif (zone_idx(zone) <= ZONE_NORMAL && nr_pages >= present_pages)\n\t\targ->status_change_nid_normal = zone_to_nid(zone);\n\n#ifdef CONFIG_HIGHMEM\n\t/*\n\t * node_states[N_HIGH_MEMORY] contains nodes which\n\t * have normal memory or high memory.\n\t * Here we add the present_pages belonging to ZONE_HIGHMEM.\n\t * If the zone is within the range of [0..ZONE_HIGHMEM), and\n\t * we determine that the zones in that range become empty,\n\t * we need to clear the node for N_HIGH_MEMORY.\n\t */\n\tpresent_pages += pgdat->node_zones[ZONE_HIGHMEM].present_pages;\n\tif (zone_idx(zone) <= ZONE_HIGHMEM && nr_pages >= present_pages)\n\t\targ->status_change_nid_high = zone_to_nid(zone);\n#endif\n\n\t/*\n\t * We have accounted the pages from [0..ZONE_NORMAL), and\n\t * in case of CONFIG_HIGHMEM the pages from ZONE_HIGHMEM\n\t * as well.\n\t * Here we count the possible pages from ZONE_MOVABLE.\n\t * If after having accounted all the pages, we see that the nr_pages\n\t * to be offlined is over or equal to the accounted pages,\n\t * we know that the node will become empty, and so, we can clear\n\t * it for N_MEMORY as well.\n\t */\n\tpresent_pages += pgdat->node_zones[ZONE_MOVABLE].present_pages;\n\n\tif (nr_pages >= present_pages)\n\t\targ->status_change_nid = zone_to_nid(zone);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void node_states_check_changes_offline(unsigned long nr_pages,\n\t\tstruct zone *zone, struct memory_notify *arg)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tunsigned long present_pages = 0;\n\tenum zone_type zt;\n\n\targ->status_change_nid = -1;\n\targ->status_change_nid_normal = -1;\n\targ->status_change_nid_high = -1;\n\n\t/*\n\t * Check whether node_states[N_NORMAL_MEMORY] will be changed.\n\t * If the memory to be offline is within the range\n\t * [0..ZONE_NORMAL], and it is the last present memory there,\n\t * the zones in that range will become empty after the offlining,\n\t * thus we can determine that we need to clear the node from\n\t * node_states[N_NORMAL_MEMORY].\n\t */\n\tfor (zt = 0; zt <= ZONE_NORMAL; zt++)\n\t\tpresent_pages += pgdat->node_zones[zt].present_pages;\n\tif (zone_idx(zone) <= ZONE_NORMAL && nr_pages >= present_pages)\n\t\targ->status_change_nid_normal = zone_to_nid(zone);\n\n#ifdef CONFIG_HIGHMEM\n\t/*\n\t * node_states[N_HIGH_MEMORY] contains nodes which\n\t * have normal memory or high memory.\n\t * Here we add the present_pages belonging to ZONE_HIGHMEM.\n\t * If the zone is within the range of [0..ZONE_HIGHMEM), and\n\t * we determine that the zones in that range become empty,\n\t * we need to clear the node for N_HIGH_MEMORY.\n\t */\n\tpresent_pages += pgdat->node_zones[ZONE_HIGHMEM].present_pages;\n\tif (zone_idx(zone) <= ZONE_HIGHMEM && nr_pages >= present_pages)\n\t\targ->status_change_nid_high = zone_to_nid(zone);\n#endif\n\n\t/*\n\t * We have accounted the pages from [0..ZONE_NORMAL), and\n\t * in case of CONFIG_HIGHMEM the pages from ZONE_HIGHMEM\n\t * as well.\n\t * Here we count the possible pages from ZONE_MOVABLE.\n\t * If after having accounted all the pages, we see that the nr_pages\n\t * to be offlined is over or equal to the accounted pages,\n\t * we know that the node will become empty, and so, we can clear\n\t * it for N_MEMORY as well.\n\t */\n\tpresent_pages += pgdat->node_zones[ZONE_MOVABLE].present_pages;\n\n\tif (nr_pages >= present_pages)\n\t\targ->status_change_nid = zone_to_nid(zone);\n}"
  },
  {
    "function_name": "cmdline_parse_movable_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1468-1476",
    "snippet": "static int __init cmdline_parse_movable_node(char *p)\n{\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\tmovable_node_enabled = true;\n#else\n\tpr_warn(\"movable_node parameter depends on CONFIG_HAVE_MEMBLOCK_NODE_MAP to work properly\\n\");\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool movable_node_enabled = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"movable_node parameter depends on CONFIG_HAVE_MEMBLOCK_NODE_MAP to work properly\\n\""
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nbool movable_node_enabled = false;\n\nstatic int __init cmdline_parse_movable_node(char *p)\n{\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\tmovable_node_enabled = true;\n#else\n\tpr_warn(\"movable_node parameter depends on CONFIG_HAVE_MEMBLOCK_NODE_MAP to work properly\\n\");\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "check_pages_isolated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1455-1466",
    "snippet": "static long\ncheck_pages_isolated(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tlong offlined = 0;\n\tint ret;\n\n\tret = walk_system_ram_range(start_pfn, end_pfn - start_pfn, &offlined,\n\t\t\tcheck_pages_isolated_cb);\n\tif (ret < 0)\n\t\tofflined = (long)ret;\n\treturn offlined;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_system_ram_range",
          "args": [
            "start_pfn",
            "end_pfn - start_pfn",
            "&offlined",
            "check_pages_isolated_cb"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic long\ncheck_pages_isolated(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tlong offlined = 0;\n\tint ret;\n\n\tret = walk_system_ram_range(start_pfn, end_pfn - start_pfn, &offlined,\n\t\t\tcheck_pages_isolated_cb);\n\tif (ret < 0)\n\t\tofflined = (long)ret;\n\treturn offlined;\n}"
  },
  {
    "function_name": "check_pages_isolated_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1442-1453",
    "snippet": "static int\ncheck_pages_isolated_cb(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\tvoid *data)\n{\n\tint ret;\n\tlong offlined = *(long *)data;\n\tret = test_pages_isolated(start_pfn, start_pfn + nr_pages, true);\n\tofflined = nr_pages;\n\tif (!ret)\n\t\t*(long *)data += offlined;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_pages_isolated",
          "args": [
            "start_pfn",
            "start_pfn + nr_pages",
            "true"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "test_pages_isolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "280-310",
          "snippet": "int test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\tbool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn, flags;\n\tstruct page *page;\n\tstruct zone *zone;\n\n\t/*\n\t * Note: pageblock_nr_pages != MAX_ORDER. Then, chunks of free pages\n\t * are not aligned to pageblock_nr_pages.\n\t * Then we just check migratetype first.\n\t */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page && !is_migrate_isolate_page(page))\n\t\t\tbreak;\n\t}\n\tpage = __first_valid_page(start_pfn, end_pfn - start_pfn);\n\tif ((pfn < end_pfn) || !page)\n\t\treturn -EBUSY;\n\t/* Check all pages are free or marked as ISOLATED */\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tpfn = __test_page_isolated_in_pageblock(start_pfn, end_pfn,\n\t\t\t\t\t\tskip_hwpoisoned_pages);\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\n\ttrace_test_pages_isolated(start_pfn, end_pfn, pfn);\n\n\treturn pfn < end_pfn ? -EBUSY : 0;\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nint test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\tbool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn, flags;\n\tstruct page *page;\n\tstruct zone *zone;\n\n\t/*\n\t * Note: pageblock_nr_pages != MAX_ORDER. Then, chunks of free pages\n\t * are not aligned to pageblock_nr_pages.\n\t * Then we just check migratetype first.\n\t */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page && !is_migrate_isolate_page(page))\n\t\t\tbreak;\n\t}\n\tpage = __first_valid_page(start_pfn, end_pfn - start_pfn);\n\tif ((pfn < end_pfn) || !page)\n\t\treturn -EBUSY;\n\t/* Check all pages are free or marked as ISOLATED */\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tpfn = __test_page_isolated_in_pageblock(start_pfn, end_pfn,\n\t\t\t\t\t\tskip_hwpoisoned_pages);\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\n\ttrace_test_pages_isolated(start_pfn, end_pfn, pfn);\n\n\treturn pfn < end_pfn ? -EBUSY : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int\ncheck_pages_isolated_cb(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\tvoid *data)\n{\n\tint ret;\n\tlong offlined = *(long *)data;\n\tret = test_pages_isolated(start_pfn, start_pfn + nr_pages, true);\n\tofflined = nr_pages;\n\tif (!ret)\n\t\t*(long *)data += offlined;\n\treturn ret;\n}"
  },
  {
    "function_name": "offline_isolated_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1432-1437",
    "snippet": "static void\noffline_isolated_pages(unsigned long start_pfn, unsigned long end_pfn)\n{\n\twalk_system_ram_range(start_pfn, end_pfn - start_pfn, NULL,\n\t\t\t\toffline_isolated_pages_cb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_system_ram_range",
          "args": [
            "start_pfn",
            "end_pfn - start_pfn",
            "NULL",
            "offline_isolated_pages_cb"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void\noffline_isolated_pages(unsigned long start_pfn, unsigned long end_pfn)\n{\n\twalk_system_ram_range(start_pfn, end_pfn - start_pfn, NULL,\n\t\t\t\toffline_isolated_pages_cb);\n}"
  },
  {
    "function_name": "offline_isolated_pages_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1424-1430",
    "snippet": "static int\noffline_isolated_pages_cb(unsigned long start, unsigned long nr_pages,\n\t\t\tvoid *data)\n{\n\t__offline_isolated_pages(start, start + nr_pages);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__offline_isolated_pages",
          "args": [
            "start",
            "start + nr_pages"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int\noffline_isolated_pages_cb(unsigned long start, unsigned long nr_pages,\n\t\t\tvoid *data)\n{\n\t__offline_isolated_pages(start, start + nr_pages);\n\treturn 0;\n}"
  },
  {
    "function_name": "do_migrate_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1343-1419",
    "snippet": "static int\ndo_migrate_range(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tint move_pages = NR_OFFLINE_AT_ONCE_PAGES;\n\tint not_managed = 0;\n\tint ret = 0;\n\tLIST_HEAD(source);\n\n\tfor (pfn = start_pfn; pfn < end_pfn && move_pages > 0; pfn++) {\n\t\tif (!pfn_valid(pfn))\n\t\t\tcontinue;\n\t\tpage = pfn_to_page(pfn);\n\n\t\tif (PageHuge(page)) {\n\t\t\tstruct page *head = compound_head(page);\n\t\t\tpfn = page_to_pfn(head) + (1<<compound_order(head)) - 1;\n\t\t\tif (compound_order(head) > PFN_SECTION_SHIFT) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isolate_huge_page(page, &source))\n\t\t\t\tmove_pages -= 1 << compound_order(head);\n\t\t\tcontinue;\n\t\t} else if (PageTransHuge(page))\n\t\t\tpfn = page_to_pfn(compound_head(page))\n\t\t\t\t+ hpage_nr_pages(page) - 1;\n\n\t\tif (!get_page_unless_zero(page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can skip free pages. And we can deal with pages on\n\t\t * LRU and non-lru movable pages.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tret = isolate_lru_page(page);\n\t\telse\n\t\t\tret = isolate_movable_page(page, ISOLATE_UNEVICTABLE);\n\t\tif (!ret) { /* Success */\n\t\t\tput_page(page);\n\t\t\tlist_add_tail(&page->lru, &source);\n\t\t\tmove_pages--;\n\t\t\tif (!__PageMovable(page))\n\t\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t\t    page_is_file_cache(page));\n\n\t\t} else {\n#ifdef CONFIG_DEBUG_VM\n\t\t\tpr_alert(\"failed to isolate pfn %lx\\n\", pfn);\n\t\t\tdump_page(page, \"isolation failed\");\n#endif\n\t\t\tput_page(page);\n\t\t\t/* Because we don't have big zone->lock. we should\n\t\t\t   check this again here. */\n\t\t\tif (page_count(page)) {\n\t\t\t\tnot_managed++;\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!list_empty(&source)) {\n\t\tif (not_managed) {\n\t\t\tputback_movable_pages(&source);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Allocate a new page from the nearest neighbor node */\n\t\tret = migrate_pages(&source, new_node_page, NULL, 0,\n\t\t\t\t\tMIGRATE_SYNC, MR_MEMORY_HOTPLUG);\n\t\tif (ret)\n\t\t\tputback_movable_pages(&source);\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [
      "#define NR_OFFLINE_AT_ONCE_PAGES\t(256)"
    ],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "putback_movable_pages",
          "args": [
            "&source"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "putback_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "167-198",
          "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_pages",
          "args": [
            "&source",
            "new_node_page",
            "NULL",
            "0",
            "MIGRATE_SYNC",
            "MR_MEMORY_HOTPLUG"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1362-1449",
          "snippet": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&source"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_page",
          "args": [
            "page",
            "\"isolation failed\""
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "dump_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
          "lines": "91-95",
          "snippet": "void dump_page(struct page *page, const char *reason)\n{\n\t__dump_page(page, reason);\n\tdump_page_owner(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/migrate.h>",
            "#include <trace/events/mmflags.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid dump_page(struct page *page, const char *reason)\n{\n\t__dump_page(page, reason);\n\tdump_page_owner(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"failed to isolate pfn %lx\\n\"",
            "pfn"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_node_page_state",
          "args": [
            "page",
            "NR_ISOLATED_ANON +\n\t\t\t\t\t\t    page_is_file_cache(page)"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "655-664",
          "snippet": "void inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "&source"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_movable_page",
          "args": [
            "page",
            "ISOLATE_UNEVICTABLE"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_movable_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "84-143",
          "snippet": "int isolate_movable_page(struct page *page, isolate_mode_t mode)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Avoid burning cycles with pages that are yet under __free_pages(),\n\t * or just got freed under us.\n\t *\n\t * In case we 'win' a race for a movable page being freed under us and\n\t * raise its refcount preventing __free_pages() from doing its job\n\t * the put_page() at the end of this block will take care of\n\t * release this page, thus avoiding a nasty leakage.\n\t */\n\tif (unlikely(!get_page_unless_zero(page)))\n\t\tgoto out;\n\n\t/*\n\t * Check PageMovable before holding a PG_lock because page's owner\n\t * assumes anybody doesn't touch PG_lock of newly allocated page\n\t * so unconditionally grapping the lock ruins page's owner side.\n\t */\n\tif (unlikely(!__PageMovable(page)))\n\t\tgoto out_putpage;\n\t/*\n\t * As movable pages are not isolated from LRU lists, concurrent\n\t * compaction threads can race against page migration functions\n\t * as well as race against the releasing a page.\n\t *\n\t * In order to avoid having an already isolated movable page\n\t * being (wrongly) re-isolated while it is under migration,\n\t * or to avoid attempting to isolate pages being released,\n\t * lets be sure we have the page lock\n\t * before proceeding with the movable page isolation steps.\n\t */\n\tif (unlikely(!trylock_page(page)))\n\t\tgoto out_putpage;\n\n\tif (!PageMovable(page) || PageIsolated(page))\n\t\tgoto out_no_isolated;\n\n\tmapping = page_mapping(page);\n\tVM_BUG_ON_PAGE(!mapping, page);\n\n\tif (!mapping->a_ops->isolate_page(page, mode))\n\t\tgoto out_no_isolated;\n\n\t/* Driver shouldn't use PG_isolated bit of page->flags */\n\tWARN_ON_ONCE(PageIsolated(page));\n\t__SetPageIsolated(page);\n\tunlock_page(page);\n\n\treturn 0;\n\nout_no_isolated:\n\tunlock_page(page);\nout_putpage:\n\tput_page(page);\nout:\n\treturn -EBUSY;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint isolate_movable_page(struct page *page, isolate_mode_t mode)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Avoid burning cycles with pages that are yet under __free_pages(),\n\t * or just got freed under us.\n\t *\n\t * In case we 'win' a race for a movable page being freed under us and\n\t * raise its refcount preventing __free_pages() from doing its job\n\t * the put_page() at the end of this block will take care of\n\t * release this page, thus avoiding a nasty leakage.\n\t */\n\tif (unlikely(!get_page_unless_zero(page)))\n\t\tgoto out;\n\n\t/*\n\t * Check PageMovable before holding a PG_lock because page's owner\n\t * assumes anybody doesn't touch PG_lock of newly allocated page\n\t * so unconditionally grapping the lock ruins page's owner side.\n\t */\n\tif (unlikely(!__PageMovable(page)))\n\t\tgoto out_putpage;\n\t/*\n\t * As movable pages are not isolated from LRU lists, concurrent\n\t * compaction threads can race against page migration functions\n\t * as well as race against the releasing a page.\n\t *\n\t * In order to avoid having an already isolated movable page\n\t * being (wrongly) re-isolated while it is under migration,\n\t * or to avoid attempting to isolate pages being released,\n\t * lets be sure we have the page lock\n\t * before proceeding with the movable page isolation steps.\n\t */\n\tif (unlikely(!trylock_page(page)))\n\t\tgoto out_putpage;\n\n\tif (!PageMovable(page) || PageIsolated(page))\n\t\tgoto out_no_isolated;\n\n\tmapping = page_mapping(page);\n\tVM_BUG_ON_PAGE(!mapping, page);\n\n\tif (!mapping->a_ops->isolate_page(page, mode))\n\t\tgoto out_no_isolated;\n\n\t/* Driver shouldn't use PG_isolated bit of page->flags */\n\tWARN_ON_ONCE(PageIsolated(page));\n\t__SetPageIsolated(page);\n\tunlock_page(page);\n\n\treturn 0;\n\nout_no_isolated:\n\tunlock_page(page);\nout_putpage:\n\tput_page(page);\nout:\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "page"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "compound_head(page)"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "head"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_huge_page",
          "args": [
            "page",
            "&source"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4891-4906",
          "snippet": "bool isolate_huge_page(struct page *page, struct list_head *list)\n{\n\tbool ret = true;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tif (!page_huge_active(page) || !get_page_unless_zero(page)) {\n\t\tret = false;\n\t\tgoto unlock;\n\t}\n\tclear_page_huge_active(page);\n\tlist_move_tail(&page->lru, list);\nunlock:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nbool isolate_huge_page(struct page *page, struct list_head *list)\n{\n\tbool ret = true;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tif (!page_huge_active(page) || !get_page_unless_zero(page)) {\n\t\tret = false;\n\t\tgoto unlock;\n\t}\n\tclear_page_huge_active(page);\n\tlist_move_tail(&page->lru, list);\nunlock:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "head"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "head"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "head"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "source"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\n#define NR_OFFLINE_AT_ONCE_PAGES\t(256)\n\nstatic void generic_online_page(struct page *page);\n\nstatic int\ndo_migrate_range(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tint move_pages = NR_OFFLINE_AT_ONCE_PAGES;\n\tint not_managed = 0;\n\tint ret = 0;\n\tLIST_HEAD(source);\n\n\tfor (pfn = start_pfn; pfn < end_pfn && move_pages > 0; pfn++) {\n\t\tif (!pfn_valid(pfn))\n\t\t\tcontinue;\n\t\tpage = pfn_to_page(pfn);\n\n\t\tif (PageHuge(page)) {\n\t\t\tstruct page *head = compound_head(page);\n\t\t\tpfn = page_to_pfn(head) + (1<<compound_order(head)) - 1;\n\t\t\tif (compound_order(head) > PFN_SECTION_SHIFT) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isolate_huge_page(page, &source))\n\t\t\t\tmove_pages -= 1 << compound_order(head);\n\t\t\tcontinue;\n\t\t} else if (PageTransHuge(page))\n\t\t\tpfn = page_to_pfn(compound_head(page))\n\t\t\t\t+ hpage_nr_pages(page) - 1;\n\n\t\tif (!get_page_unless_zero(page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can skip free pages. And we can deal with pages on\n\t\t * LRU and non-lru movable pages.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tret = isolate_lru_page(page);\n\t\telse\n\t\t\tret = isolate_movable_page(page, ISOLATE_UNEVICTABLE);\n\t\tif (!ret) { /* Success */\n\t\t\tput_page(page);\n\t\t\tlist_add_tail(&page->lru, &source);\n\t\t\tmove_pages--;\n\t\t\tif (!__PageMovable(page))\n\t\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t\t    page_is_file_cache(page));\n\n\t\t} else {\n#ifdef CONFIG_DEBUG_VM\n\t\t\tpr_alert(\"failed to isolate pfn %lx\\n\", pfn);\n\t\t\tdump_page(page, \"isolation failed\");\n#endif\n\t\t\tput_page(page);\n\t\t\t/* Because we don't have big zone->lock. we should\n\t\t\t   check this again here. */\n\t\t\tif (page_count(page)) {\n\t\t\t\tnot_managed++;\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!list_empty(&source)) {\n\t\tif (not_managed) {\n\t\t\tputback_movable_pages(&source);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Allocate a new page from the nearest neighbor node */\n\t\tret = migrate_pages(&source, new_node_page, NULL, 0,\n\t\t\t\t\tMIGRATE_SYNC, MR_MEMORY_HOTPLUG);\n\t\tif (ret)\n\t\t\tputback_movable_pages(&source);\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "new_node_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1325-1340",
    "snippet": "static struct page *new_node_page(struct page *page, unsigned long private)\n{\n\tint nid = page_to_nid(page);\n\tnodemask_t nmask = node_states[N_MEMORY];\n\n\t/*\n\t * try to allocate from a different node but reuse this node if there\n\t * are no other online nodes to be used (e.g. we are offlining a part\n\t * of the only existing node)\n\t */\n\tnode_clear(nid, nmask);\n\tif (nodes_empty(nmask))\n\t\tnode_set(nid, nmask);\n\n\treturn new_page_nodemask(page, nid, &nmask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_page_nodemask",
          "args": [
            "page",
            "nid",
            "&nmask"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set",
          "args": [
            "nid",
            "nmask"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "nmask"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_clear",
          "args": [
            "nid",
            "nmask"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic struct page *new_node_page(struct page *page, unsigned long private)\n{\n\tint nid = page_to_nid(page);\n\tnodemask_t nmask = node_states[N_MEMORY];\n\n\t/*\n\t * try to allocate from a different node but reuse this node if there\n\t * are no other online nodes to be used (e.g. we are offlining a part\n\t * of the only existing node)\n\t */\n\tnode_clear(nid, nmask);\n\tif (nodes_empty(nmask))\n\t\tnode_set(nid, nmask);\n\n\treturn new_page_nodemask(page, nid, &nmask);\n}"
  },
  {
    "function_name": "scan_movable_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1301-1323",
    "snippet": "static unsigned long scan_movable_pages(unsigned long start, unsigned long end)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tfor (pfn = start; pfn < end; pfn++) {\n\t\tif (pfn_valid(pfn)) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\tif (PageLRU(page))\n\t\t\t\treturn pfn;\n\t\t\tif (__PageMovable(page))\n\t\t\t\treturn pfn;\n\t\t\tif (PageHuge(page)) {\n\t\t\t\tif (hugepage_migration_supported(page_hstate(page)) &&\n\t\t\t\t    page_huge_active(page))\n\t\t\t\t\treturn pfn;\n\t\t\t\telse\n\t\t\t\t\tpfn = round_up(pfn + 1,\n\t\t\t\t\t\t1 << compound_order(page)) - 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "pfn + 1",
            "1 << compound_order(page)"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_huge_active",
          "args": [
            "page"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_huge_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1211-1215",
          "snippet": "static void clear_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tClearPagePrivate(&page[1]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void clear_page_huge_active(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHeadHuge(page), page);\n\tClearPagePrivate(&page[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugepage_migration_supported",
          "args": [
            "page_hstate(page)"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "page"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic unsigned long scan_movable_pages(unsigned long start, unsigned long end)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tfor (pfn = start; pfn < end; pfn++) {\n\t\tif (pfn_valid(pfn)) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\tif (PageLRU(page))\n\t\t\t\treturn pfn;\n\t\t\tif (__PageMovable(page))\n\t\t\t\treturn pfn;\n\t\t\tif (PageHuge(page)) {\n\t\t\t\tif (hugepage_migration_supported(page_hstate(page)) &&\n\t\t\t\t    page_huge_active(page))\n\t\t\t\t\treturn pfn;\n\t\t\t\telse\n\t\t\t\t\tpfn = round_up(pfn + 1,\n\t\t\t\t\t\t1 << compound_order(page)) - 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "test_pages_in_a_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1253-1293",
    "snippet": "int test_pages_in_a_zone(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t unsigned long *valid_start, unsigned long *valid_end)\n{\n\tunsigned long pfn, sec_end_pfn;\n\tunsigned long start, end;\n\tstruct zone *zone = NULL;\n\tstruct page *page;\n\tint i;\n\tfor (pfn = start_pfn, sec_end_pfn = SECTION_ALIGN_UP(start_pfn + 1);\n\t     pfn < end_pfn;\n\t     pfn = sec_end_pfn, sec_end_pfn += PAGES_PER_SECTION) {\n\t\t/* Make sure the memory section is present first */\n\t\tif (!present_section_nr(pfn_to_section_nr(pfn)))\n\t\t\tcontinue;\n\t\tfor (; pfn < sec_end_pfn && pfn < end_pfn;\n\t\t     pfn += MAX_ORDER_NR_PAGES) {\n\t\t\ti = 0;\n\t\t\t/* This is just a CONFIG_HOLES_IN_ZONE check.*/\n\t\t\twhile ((i < MAX_ORDER_NR_PAGES) &&\n\t\t\t\t!pfn_valid_within(pfn + i))\n\t\t\t\ti++;\n\t\t\tif (i == MAX_ORDER_NR_PAGES || pfn + i >= end_pfn)\n\t\t\t\tcontinue;\n\t\t\tpage = pfn_to_page(pfn + i);\n\t\t\tif (zone && page_zone(page) != zone)\n\t\t\t\treturn 0;\n\t\t\tif (!zone)\n\t\t\t\tstart = pfn + i;\n\t\t\tzone = page_zone(page);\n\t\t\tend = pfn + MAX_ORDER_NR_PAGES;\n\t\t}\n\t}\n\n\tif (zone) {\n\t\t*valid_start = start;\n\t\t*valid_end = min(end, end_pfn);\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "end_pfn"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn + i"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "pfn + i"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "present_section_nr",
          "args": [
            "pfn_to_section_nr(pfn)"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "next_present_section_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "188-197",
          "snippet": "static inline int next_present_section_nr(int section_nr)\n{\n\tdo {\n\t\tsection_nr++;\n\t\tif (present_section_nr(section_nr))\n\t\t\treturn section_nr;\n\t} while ((section_nr <= __highest_present_section_nr));\n\n\treturn -1;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __highest_present_section_nr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __highest_present_section_nr;\n\nstatic inline int next_present_section_nr(int section_nr)\n{\n\tdo {\n\t\tsection_nr++;\n\t\tif (present_section_nr(section_nr))\n\t\t\treturn section_nr;\n\t} while ((section_nr <= __highest_present_section_nr));\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "pfn"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SECTION_ALIGN_UP",
          "args": [
            "start_pfn + 1"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nint test_pages_in_a_zone(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t unsigned long *valid_start, unsigned long *valid_end)\n{\n\tunsigned long pfn, sec_end_pfn;\n\tunsigned long start, end;\n\tstruct zone *zone = NULL;\n\tstruct page *page;\n\tint i;\n\tfor (pfn = start_pfn, sec_end_pfn = SECTION_ALIGN_UP(start_pfn + 1);\n\t     pfn < end_pfn;\n\t     pfn = sec_end_pfn, sec_end_pfn += PAGES_PER_SECTION) {\n\t\t/* Make sure the memory section is present first */\n\t\tif (!present_section_nr(pfn_to_section_nr(pfn)))\n\t\t\tcontinue;\n\t\tfor (; pfn < sec_end_pfn && pfn < end_pfn;\n\t\t     pfn += MAX_ORDER_NR_PAGES) {\n\t\t\ti = 0;\n\t\t\t/* This is just a CONFIG_HOLES_IN_ZONE check.*/\n\t\t\twhile ((i < MAX_ORDER_NR_PAGES) &&\n\t\t\t\t!pfn_valid_within(pfn + i))\n\t\t\t\ti++;\n\t\t\tif (i == MAX_ORDER_NR_PAGES || pfn + i >= end_pfn)\n\t\t\t\tcontinue;\n\t\t\tpage = pfn_to_page(pfn + i);\n\t\t\tif (zone && page_zone(page) != zone)\n\t\t\t\treturn 0;\n\t\t\tif (!zone)\n\t\t\t\tstart = pfn + i;\n\t\t\tzone = page_zone(page);\n\t\t\tend = pfn + MAX_ORDER_NR_PAGES;\n\t\t}\n\t}\n\n\tif (zone) {\n\t\t*valid_start = start;\n\t\t*valid_end = min(end, end_pfn);\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "is_mem_section_removable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1233-1247",
    "snippet": "bool is_mem_section_removable(unsigned long start_pfn, unsigned long nr_pages)\n{\n\tstruct page *page = pfn_to_page(start_pfn);\n\tstruct page *end_page = page + nr_pages;\n\n\t/* Check the starting page of each pageblock within the range */\n\tfor (; page < end_page; page = next_active_pageblock(page)) {\n\t\tif (!is_pageblock_removable_nolock(page))\n\t\t\treturn false;\n\t\tcond_resched();\n\t}\n\n\t/* All pageblocks in the memory block are likely to be hot-removable */\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pageblock_removable_nolock",
          "args": [
            "page"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "is_pageblock_removable_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1209-1230",
          "snippet": "static bool is_pageblock_removable_nolock(struct page *page)\n{\n\tstruct zone *zone;\n\tunsigned long pfn;\n\n\t/*\n\t * We have to be careful here because we are iterating over memory\n\t * sections which are not zone aware so we might end up outside of\n\t * the zone but still within the section.\n\t * We have to take care about the node as well. If the node is offline\n\t * its NODE_DATA will be NULL - see page_zone.\n\t */\n\tif (!node_online(page_to_nid(page)))\n\t\treturn false;\n\n\tzone = page_zone(page);\n\tpfn = page_to_pfn(page);\n\tif (!zone_spans_pfn(zone, pfn))\n\t\treturn false;\n\n\treturn !has_unmovable_pages(zone, page, 0, MIGRATE_MOVABLE, true);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic bool is_pageblock_removable_nolock(struct page *page)\n{\n\tstruct zone *zone;\n\tunsigned long pfn;\n\n\t/*\n\t * We have to be careful here because we are iterating over memory\n\t * sections which are not zone aware so we might end up outside of\n\t * the zone but still within the section.\n\t * We have to take care about the node as well. If the node is offline\n\t * its NODE_DATA will be NULL - see page_zone.\n\t */\n\tif (!node_online(page_to_nid(page)))\n\t\treturn false;\n\n\tzone = page_zone(page);\n\tpfn = page_to_pfn(page);\n\tif (!zone_spans_pfn(zone, pfn))\n\t\treturn false;\n\n\treturn !has_unmovable_pages(zone, page, 0, MIGRATE_MOVABLE, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_active_pageblock",
          "args": [
            "page"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "next_active_pageblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1192-1207",
          "snippet": "static struct page *next_active_pageblock(struct page *page)\n{\n\t/* Ensure the starting page is pageblock-aligned */\n\tBUG_ON(page_to_pfn(page) & (pageblock_nr_pages - 1));\n\n\t/* If the entire pageblock is free, move to the end of free page */\n\tif (pageblock_free(page)) {\n\t\tint order;\n\t\t/* be careful. we don't have locks, page_order can be changed.*/\n\t\torder = page_order(page);\n\t\tif ((order < MAX_ORDER) && (order >= pageblock_order))\n\t\t\treturn page + (1 << order);\n\t}\n\n\treturn page + pageblock_nr_pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic struct page *next_active_pageblock(struct page *page)\n{\n\t/* Ensure the starting page is pageblock-aligned */\n\tBUG_ON(page_to_pfn(page) & (pageblock_nr_pages - 1));\n\n\t/* If the entire pageblock is free, move to the end of free page */\n\tif (pageblock_free(page)) {\n\t\tint order;\n\t\t/* be careful. we don't have locks, page_order can be changed.*/\n\t\torder = page_order(page);\n\t\tif ((order < MAX_ORDER) && (order >= pageblock_order))\n\t\t\treturn page + (1 << order);\n\t}\n\n\treturn page + pageblock_nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "start_pfn"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nbool is_mem_section_removable(unsigned long start_pfn, unsigned long nr_pages)\n{\n\tstruct page *page = pfn_to_page(start_pfn);\n\tstruct page *end_page = page + nr_pages;\n\n\t/* Check the starting page of each pageblock within the range */\n\tfor (; page < end_page; page = next_active_pageblock(page)) {\n\t\tif (!is_pageblock_removable_nolock(page))\n\t\t\treturn false;\n\t\tcond_resched();\n\t}\n\n\t/* All pageblocks in the memory block are likely to be hot-removable */\n\treturn true;\n}"
  },
  {
    "function_name": "is_pageblock_removable_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1209-1230",
    "snippet": "static bool is_pageblock_removable_nolock(struct page *page)\n{\n\tstruct zone *zone;\n\tunsigned long pfn;\n\n\t/*\n\t * We have to be careful here because we are iterating over memory\n\t * sections which are not zone aware so we might end up outside of\n\t * the zone but still within the section.\n\t * We have to take care about the node as well. If the node is offline\n\t * its NODE_DATA will be NULL - see page_zone.\n\t */\n\tif (!node_online(page_to_nid(page)))\n\t\treturn false;\n\n\tzone = page_zone(page);\n\tpfn = page_to_pfn(page);\n\tif (!zone_spans_pfn(zone, pfn))\n\t\treturn false;\n\n\treturn !has_unmovable_pages(zone, page, 0, MIGRATE_MOVABLE, true);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "has_unmovable_pages",
          "args": [
            "zone",
            "page",
            "0",
            "MIGRATE_MOVABLE",
            "true"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_spans_pfn",
          "args": [
            "zone",
            "pfn"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "page_to_nid(page)"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic bool is_pageblock_removable_nolock(struct page *page)\n{\n\tstruct zone *zone;\n\tunsigned long pfn;\n\n\t/*\n\t * We have to be careful here because we are iterating over memory\n\t * sections which are not zone aware so we might end up outside of\n\t * the zone but still within the section.\n\t * We have to take care about the node as well. If the node is offline\n\t * its NODE_DATA will be NULL - see page_zone.\n\t */\n\tif (!node_online(page_to_nid(page)))\n\t\treturn false;\n\n\tzone = page_zone(page);\n\tpfn = page_to_pfn(page);\n\tif (!zone_spans_pfn(zone, pfn))\n\t\treturn false;\n\n\treturn !has_unmovable_pages(zone, page, 0, MIGRATE_MOVABLE, true);\n}"
  },
  {
    "function_name": "next_active_pageblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1192-1207",
    "snippet": "static struct page *next_active_pageblock(struct page *page)\n{\n\t/* Ensure the starting page is pageblock-aligned */\n\tBUG_ON(page_to_pfn(page) & (pageblock_nr_pages - 1));\n\n\t/* If the entire pageblock is free, move to the end of free page */\n\tif (pageblock_free(page)) {\n\t\tint order;\n\t\t/* be careful. we don't have locks, page_order can be changed.*/\n\t\torder = page_order(page);\n\t\tif ((order < MAX_ORDER) && (order >= pageblock_order))\n\t\t\treturn page + (1 << order);\n\t}\n\n\treturn page + pageblock_nr_pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "page"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pageblock_free",
          "args": [
            "page"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "pageblock_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1186-1189",
          "snippet": "static inline int pageblock_free(struct page *page)\n{\n\treturn PageBuddy(page) && page_order(page) >= pageblock_order;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic inline int pageblock_free(struct page *page)\n{\n\treturn PageBuddy(page) && page_order(page) >= pageblock_order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_to_pfn(page) & (pageblock_nr_pages - 1)"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic struct page *next_active_pageblock(struct page *page)\n{\n\t/* Ensure the starting page is pageblock-aligned */\n\tBUG_ON(page_to_pfn(page) & (pageblock_nr_pages - 1));\n\n\t/* If the entire pageblock is free, move to the end of free page */\n\tif (pageblock_free(page)) {\n\t\tint order;\n\t\t/* be careful. we don't have locks, page_order can be changed.*/\n\t\torder = page_order(page);\n\t\tif ((order < MAX_ORDER) && (order >= pageblock_order))\n\t\t\treturn page + (1 << order);\n\t}\n\n\treturn page + pageblock_nr_pages;\n}"
  },
  {
    "function_name": "pageblock_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1186-1189",
    "snippet": "static inline int pageblock_free(struct page *page)\n{\n\treturn PageBuddy(page) && page_order(page) >= pageblock_order;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "page"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic inline int pageblock_free(struct page *page)\n{\n\treturn PageBuddy(page) && page_order(page) >= pageblock_order;\n}"
  },
  {
    "function_name": "add_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1166-1175",
    "snippet": "int add_memory(int nid, u64 start, u64 size)\n{\n\tint rc;\n\n\tlock_device_hotplug();\n\trc = __add_memory(nid, start, size);\n\tunlock_device_hotplug();\n\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_memory",
          "args": [
            "nid",
            "start",
            "size"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "__add_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1151-1164",
          "snippet": "int __ref __add_memory(int nid, u64 start, u64 size)\n{\n\tstruct resource *res;\n\tint ret;\n\n\tres = register_memory_resource(start, size);\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\n\tret = add_memory_resource(nid, res, memhp_auto_online);\n\tif (ret < 0)\n\t\trelease_memory_resource(res);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __ref __add_memory(int nid, u64 start, u64 size)\n{\n\tstruct resource *res;\n\tint ret;\n\n\tres = register_memory_resource(start, size);\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\n\tret = add_memory_resource(nid, res, memhp_auto_online);\n\tif (ret < 0)\n\t\trelease_memory_resource(res);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint add_memory(int nid, u64 start, u64 size)\n{\n\tint rc;\n\n\tlock_device_hotplug();\n\trc = __add_memory(nid, start, size);\n\tunlock_device_hotplug();\n\n\treturn rc;\n}"
  },
  {
    "function_name": "__add_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1151-1164",
    "snippet": "int __ref __add_memory(int nid, u64 start, u64 size)\n{\n\tstruct resource *res;\n\tint ret;\n\n\tres = register_memory_resource(start, size);\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\n\tret = add_memory_resource(nid, res, memhp_auto_online);\n\tif (ret < 0)\n\t\trelease_memory_resource(res);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_memory_resource",
          "args": [
            "res"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "release_memory_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "124-131",
          "snippet": "static void release_memory_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\trelease_resource(res);\n\tkfree(res);\n\treturn;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void release_memory_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\trelease_resource(res);\n\tkfree(res);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_memory_resource",
          "args": [
            "nid",
            "res",
            "memhp_auto_online"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "add_memory_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1081-1148",
          "snippet": "int __ref add_memory_resource(int nid, struct resource *res, bool online)\n{\n\tu64 start, size;\n\tbool new_node = false;\n\tint ret;\n\n\tstart = res->start;\n\tsize = resource_size(res);\n\n\tret = check_hotplug_memory_range(start, size);\n\tif (ret)\n\t\treturn ret;\n\n\tmem_hotplug_begin();\n\n\t/*\n\t * Add new range to memblock so that when hotadd_new_pgdat() is called\n\t * to allocate new pgdat, get_pfn_range_for_nid() will be able to find\n\t * this new range and calculate total pages correctly.  The range will\n\t * be removed at hot-remove time.\n\t */\n\tmemblock_add_node(start, size, nid);\n\n\tret = __try_online_node(nid, start, false);\n\tif (ret < 0)\n\t\tgoto error;\n\tnew_node = ret;\n\n\t/* call arch's memory hotadd */\n\tret = arch_add_memory(nid, start, size, NULL, true);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (new_node) {\n\t\t/* If sysfs file of new node can't be created, cpu on the node\n\t\t * can't be hot-added. There is no rollback way now.\n\t\t * So, check by BUG_ON() to catch it reluctantly..\n\t\t * We online node here. We can't roll back from here.\n\t\t */\n\t\tnode_set_online(nid);\n\t\tret = __register_one_node(nid);\n\t\tBUG_ON(ret);\n\t}\n\n\t/* link memory sections under this node.*/\n\tret = link_mem_sections(nid, PFN_DOWN(start), PFN_UP(start + size - 1));\n\tBUG_ON(ret);\n\n\t/* create new memmap entry */\n\tfirmware_map_add_hotplug(start, start + size, \"System RAM\");\n\n\t/* device_online() will take the lock when calling online_pages() */\n\tmem_hotplug_done();\n\n\t/* online pages if requested */\n\tif (online)\n\t\twalk_memory_range(PFN_DOWN(start), PFN_UP(start + size - 1),\n\t\t\t\t  NULL, online_memory_block);\n\n\treturn ret;\nerror:\n\t/* rollback pgdat allocation and others */\n\tif (new_node)\n\t\trollback_node_hotadd(nid);\n\tmemblock_remove(start, size);\n\tmem_hotplug_done();\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __ref add_memory_resource(int nid, struct resource *res, bool online)\n{\n\tu64 start, size;\n\tbool new_node = false;\n\tint ret;\n\n\tstart = res->start;\n\tsize = resource_size(res);\n\n\tret = check_hotplug_memory_range(start, size);\n\tif (ret)\n\t\treturn ret;\n\n\tmem_hotplug_begin();\n\n\t/*\n\t * Add new range to memblock so that when hotadd_new_pgdat() is called\n\t * to allocate new pgdat, get_pfn_range_for_nid() will be able to find\n\t * this new range and calculate total pages correctly.  The range will\n\t * be removed at hot-remove time.\n\t */\n\tmemblock_add_node(start, size, nid);\n\n\tret = __try_online_node(nid, start, false);\n\tif (ret < 0)\n\t\tgoto error;\n\tnew_node = ret;\n\n\t/* call arch's memory hotadd */\n\tret = arch_add_memory(nid, start, size, NULL, true);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (new_node) {\n\t\t/* If sysfs file of new node can't be created, cpu on the node\n\t\t * can't be hot-added. There is no rollback way now.\n\t\t * So, check by BUG_ON() to catch it reluctantly..\n\t\t * We online node here. We can't roll back from here.\n\t\t */\n\t\tnode_set_online(nid);\n\t\tret = __register_one_node(nid);\n\t\tBUG_ON(ret);\n\t}\n\n\t/* link memory sections under this node.*/\n\tret = link_mem_sections(nid, PFN_DOWN(start), PFN_UP(start + size - 1));\n\tBUG_ON(ret);\n\n\t/* create new memmap entry */\n\tfirmware_map_add_hotplug(start, start + size, \"System RAM\");\n\n\t/* device_online() will take the lock when calling online_pages() */\n\tmem_hotplug_done();\n\n\t/* online pages if requested */\n\tif (online)\n\t\twalk_memory_range(PFN_DOWN(start), PFN_UP(start + size - 1),\n\t\t\t\t  NULL, online_memory_block);\n\n\treturn ret;\nerror:\n\t/* rollback pgdat allocation and others */\n\tif (new_node)\n\t\trollback_node_hotadd(nid);\n\tmemblock_remove(start, size);\n\tmem_hotplug_done();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "res"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_memory_resource",
          "args": [
            "start",
            "size"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "register_memory_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "99-122",
          "snippet": "static struct resource *register_memory_resource(u64 start, u64 size)\n{\n\tstruct resource *res, *conflict;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tres->name = \"System RAM\";\n\tres->start = start;\n\tres->end = start + size - 1;\n\tres->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\tconflict =  request_resource_conflict(&iomem_resource, res);\n\tif (conflict) {\n\t\tif (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {\n\t\t\tpr_debug(\"Device unaddressable memory block \"\n\t\t\t\t \"memory hotplug at %#010llx !\\n\",\n\t\t\t\t (unsigned long long)start);\n\t\t}\n\t\tpr_debug(\"System RAM resource %pR cannot be added\\n\", res);\n\t\tkfree(res);\n\t\treturn ERR_PTR(-EEXIST);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic struct resource *register_memory_resource(u64 start, u64 size)\n{\n\tstruct resource *res, *conflict;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tres->name = \"System RAM\";\n\tres->start = start;\n\tres->end = start + size - 1;\n\tres->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\tconflict =  request_resource_conflict(&iomem_resource, res);\n\tif (conflict) {\n\t\tif (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {\n\t\t\tpr_debug(\"Device unaddressable memory block \"\n\t\t\t\t \"memory hotplug at %#010llx !\\n\",\n\t\t\t\t (unsigned long long)start);\n\t\t}\n\t\tpr_debug(\"System RAM resource %pR cannot be added\\n\", res);\n\t\tkfree(res);\n\t\treturn ERR_PTR(-EEXIST);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __ref __add_memory(int nid, u64 start, u64 size)\n{\n\tstruct resource *res;\n\tint ret;\n\n\tres = register_memory_resource(start, size);\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\n\tret = add_memory_resource(nid, res, memhp_auto_online);\n\tif (ret < 0)\n\t\trelease_memory_resource(res);\n\treturn ret;\n}"
  },
  {
    "function_name": "add_memory_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1081-1148",
    "snippet": "int __ref add_memory_resource(int nid, struct resource *res, bool online)\n{\n\tu64 start, size;\n\tbool new_node = false;\n\tint ret;\n\n\tstart = res->start;\n\tsize = resource_size(res);\n\n\tret = check_hotplug_memory_range(start, size);\n\tif (ret)\n\t\treturn ret;\n\n\tmem_hotplug_begin();\n\n\t/*\n\t * Add new range to memblock so that when hotadd_new_pgdat() is called\n\t * to allocate new pgdat, get_pfn_range_for_nid() will be able to find\n\t * this new range and calculate total pages correctly.  The range will\n\t * be removed at hot-remove time.\n\t */\n\tmemblock_add_node(start, size, nid);\n\n\tret = __try_online_node(nid, start, false);\n\tif (ret < 0)\n\t\tgoto error;\n\tnew_node = ret;\n\n\t/* call arch's memory hotadd */\n\tret = arch_add_memory(nid, start, size, NULL, true);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (new_node) {\n\t\t/* If sysfs file of new node can't be created, cpu on the node\n\t\t * can't be hot-added. There is no rollback way now.\n\t\t * So, check by BUG_ON() to catch it reluctantly..\n\t\t * We online node here. We can't roll back from here.\n\t\t */\n\t\tnode_set_online(nid);\n\t\tret = __register_one_node(nid);\n\t\tBUG_ON(ret);\n\t}\n\n\t/* link memory sections under this node.*/\n\tret = link_mem_sections(nid, PFN_DOWN(start), PFN_UP(start + size - 1));\n\tBUG_ON(ret);\n\n\t/* create new memmap entry */\n\tfirmware_map_add_hotplug(start, start + size, \"System RAM\");\n\n\t/* device_online() will take the lock when calling online_pages() */\n\tmem_hotplug_done();\n\n\t/* online pages if requested */\n\tif (online)\n\t\twalk_memory_range(PFN_DOWN(start), PFN_UP(start + size - 1),\n\t\t\t\t  NULL, online_memory_block);\n\n\treturn ret;\nerror:\n\t/* rollback pgdat allocation and others */\n\tif (new_node)\n\t\trollback_node_hotadd(nid);\n\tmemblock_remove(start, size);\n\tmem_hotplug_done();\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_hotplug_done",
          "args": [],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "92-96",
          "snippet": "void mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_remove",
          "args": [
            "start",
            "size"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "793-801",
          "snippet": "int __init_memblock memblock_remove(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_remove: [%pa-%pa] %pS\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_remove_range(&memblock.memory, base, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_remove(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_remove: [%pa-%pa] %pS\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_remove_range(&memblock.memory, base, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rollback_node_hotadd",
          "args": [
            "nid"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "rollback_node_hotadd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "992-1000",
          "snippet": "static void rollback_node_hotadd(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tarch_refresh_nodedata(nid, NULL);\n\tfree_percpu(pgdat->per_cpu_nodestats);\n\tarch_free_nodedata(pgdat);\n\treturn;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void rollback_node_hotadd(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tarch_refresh_nodedata(nid, NULL);\n\tfree_percpu(pgdat->per_cpu_nodestats);\n\tarch_free_nodedata(pgdat);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_memory_range",
          "args": [
            "PFN_DOWN(start)",
            "PFN_UP(start + size - 1)",
            "NULL",
            "online_memory_block"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "walk_memory_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1686-1721",
          "snippet": "int walk_memory_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\tvoid *arg, int (*func)(struct memory_block *, void *))\n{\n\tstruct memory_block *mem = NULL;\n\tstruct mem_section *section;\n\tunsigned long pfn, section_nr;\n\tint ret;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tsection_nr = pfn_to_section_nr(pfn);\n\t\tif (!present_section_nr(section_nr))\n\t\t\tcontinue;\n\n\t\tsection = __nr_to_section(section_nr);\n\t\t/* same memblock? */\n\t\tif (mem)\n\t\t\tif ((section_nr >= mem->start_section_nr) &&\n\t\t\t    (section_nr <= mem->end_section_nr))\n\t\t\t\tcontinue;\n\n\t\tmem = find_memory_block_hinted(section, mem);\n\t\tif (!mem)\n\t\t\tcontinue;\n\n\t\tret = func(mem, arg);\n\t\tif (ret) {\n\t\t\tkobject_put(&mem->dev.kobj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (mem)\n\t\tkobject_put(&mem->dev.kobj);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint walk_memory_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\tvoid *arg, int (*func)(struct memory_block *, void *))\n{\n\tstruct memory_block *mem = NULL;\n\tstruct mem_section *section;\n\tunsigned long pfn, section_nr;\n\tint ret;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tsection_nr = pfn_to_section_nr(pfn);\n\t\tif (!present_section_nr(section_nr))\n\t\t\tcontinue;\n\n\t\tsection = __nr_to_section(section_nr);\n\t\t/* same memblock? */\n\t\tif (mem)\n\t\t\tif ((section_nr >= mem->start_section_nr) &&\n\t\t\t    (section_nr <= mem->end_section_nr))\n\t\t\t\tcontinue;\n\n\t\tmem = find_memory_block_hinted(section, mem);\n\t\tif (!mem)\n\t\t\tcontinue;\n\n\t\tret = func(mem, arg);\n\t\tif (ret) {\n\t\t\tkobject_put(&mem->dev.kobj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (mem)\n\t\tkobject_put(&mem->dev.kobj);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "start + size - 1"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "start"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firmware_map_add_hotplug",
          "args": [
            "start",
            "start + size",
            "\"System RAM\""
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_mem_sections",
          "args": [
            "nid",
            "PFN_DOWN(start)",
            "PFN_UP(start + size - 1)"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "start + size - 1"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "start"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__register_one_node",
          "args": [
            "nid"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set_online",
          "args": [
            "nid"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_add_memory",
          "args": [
            "nid",
            "start",
            "size",
            "NULL",
            "true"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__try_online_node",
          "args": [
            "nid",
            "start",
            "false"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "__try_online_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1015-1037",
          "snippet": "static int __try_online_node(int nid, u64 start, bool set_node_online)\n{\n\tpg_data_t *pgdat;\n\tint ret = 1;\n\n\tif (node_online(nid))\n\t\treturn 0;\n\n\tpgdat = hotadd_new_pgdat(nid, start);\n\tif (!pgdat) {\n\t\tpr_err(\"Cannot online node %d due to NULL pgdat\\n\", nid);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (set_node_online) {\n\t\tnode_set_online(nid);\n\t\tret = register_one_node(nid);\n\t\tBUG_ON(ret);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __try_online_node(int nid, u64 start, bool set_node_online)\n{\n\tpg_data_t *pgdat;\n\tint ret = 1;\n\n\tif (node_online(nid))\n\t\treturn 0;\n\n\tpgdat = hotadd_new_pgdat(nid, start);\n\tif (!pgdat) {\n\t\tpr_err(\"Cannot online node %d due to NULL pgdat\\n\", nid);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (set_node_online) {\n\t\tnode_set_online(nid);\n\t\tret = register_one_node(nid);\n\t\tBUG_ON(ret);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_add_node",
          "args": [
            "start",
            "size",
            "nid"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_add_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "675-679",
          "snippet": "int __init_memblock memblock_add_node(phys_addr_t base, phys_addr_t size,\n\t\t\t\t       int nid)\n{\n\treturn memblock_add_range(&memblock.memory, base, size, nid, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_add_node(phys_addr_t base, phys_addr_t size,\n\t\t\t\t       int nid)\n{\n\treturn memblock_add_range(&memblock.memory, base, size, nid, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_hotplug_begin",
          "args": [],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "86-90",
          "snippet": "void mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_hotplug_memory_range",
          "args": [
            "start",
            "size"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "check_hotplug_memory_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1052-1068",
          "snippet": "static int check_hotplug_memory_range(u64 start, u64 size)\n{\n\tunsigned long block_sz = memory_block_size_bytes();\n\tu64 block_nr_pages = block_sz >> PAGE_SHIFT;\n\tu64 nr_pages = size >> PAGE_SHIFT;\n\tu64 start_pfn = PFN_DOWN(start);\n\n\t/* memory range must be block size aligned */\n\tif (!nr_pages || !IS_ALIGNED(start_pfn, block_nr_pages) ||\n\t    !IS_ALIGNED(nr_pages, block_nr_pages)) {\n\t\tpr_err(\"Block size [%#lx] unaligned hotplug range: start %#llx, size %#llx\",\n\t\t       block_sz, start, size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int check_hotplug_memory_range(u64 start, u64 size)\n{\n\tunsigned long block_sz = memory_block_size_bytes();\n\tu64 block_nr_pages = block_sz >> PAGE_SHIFT;\n\tu64 nr_pages = size >> PAGE_SHIFT;\n\tu64 start_pfn = PFN_DOWN(start);\n\n\t/* memory range must be block size aligned */\n\tif (!nr_pages || !IS_ALIGNED(start_pfn, block_nr_pages) ||\n\t    !IS_ALIGNED(nr_pages, block_nr_pages)) {\n\t\tpr_err(\"Block size [%#lx] unaligned hotplug range: start %#llx, size %#llx\",\n\t\t       block_sz, start, size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "res"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __ref add_memory_resource(int nid, struct resource *res, bool online)\n{\n\tu64 start, size;\n\tbool new_node = false;\n\tint ret;\n\n\tstart = res->start;\n\tsize = resource_size(res);\n\n\tret = check_hotplug_memory_range(start, size);\n\tif (ret)\n\t\treturn ret;\n\n\tmem_hotplug_begin();\n\n\t/*\n\t * Add new range to memblock so that when hotadd_new_pgdat() is called\n\t * to allocate new pgdat, get_pfn_range_for_nid() will be able to find\n\t * this new range and calculate total pages correctly.  The range will\n\t * be removed at hot-remove time.\n\t */\n\tmemblock_add_node(start, size, nid);\n\n\tret = __try_online_node(nid, start, false);\n\tif (ret < 0)\n\t\tgoto error;\n\tnew_node = ret;\n\n\t/* call arch's memory hotadd */\n\tret = arch_add_memory(nid, start, size, NULL, true);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (new_node) {\n\t\t/* If sysfs file of new node can't be created, cpu on the node\n\t\t * can't be hot-added. There is no rollback way now.\n\t\t * So, check by BUG_ON() to catch it reluctantly..\n\t\t * We online node here. We can't roll back from here.\n\t\t */\n\t\tnode_set_online(nid);\n\t\tret = __register_one_node(nid);\n\t\tBUG_ON(ret);\n\t}\n\n\t/* link memory sections under this node.*/\n\tret = link_mem_sections(nid, PFN_DOWN(start), PFN_UP(start + size - 1));\n\tBUG_ON(ret);\n\n\t/* create new memmap entry */\n\tfirmware_map_add_hotplug(start, start + size, \"System RAM\");\n\n\t/* device_online() will take the lock when calling online_pages() */\n\tmem_hotplug_done();\n\n\t/* online pages if requested */\n\tif (online)\n\t\twalk_memory_range(PFN_DOWN(start), PFN_UP(start + size - 1),\n\t\t\t\t  NULL, online_memory_block);\n\n\treturn ret;\nerror:\n\t/* rollback pgdat allocation and others */\n\tif (new_node)\n\t\trollback_node_hotadd(nid);\n\tmemblock_remove(start, size);\n\tmem_hotplug_done();\n\treturn ret;\n}"
  },
  {
    "function_name": "online_memory_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1070-1073",
    "snippet": "static int online_memory_block(struct memory_block *mem, void *arg)\n{\n\treturn device_online(&mem->dev);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_online",
          "args": [
            "&mem->dev"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int online_memory_block(struct memory_block *mem, void *arg)\n{\n\treturn device_online(&mem->dev);\n}"
  },
  {
    "function_name": "check_hotplug_memory_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1052-1068",
    "snippet": "static int check_hotplug_memory_range(u64 start, u64 size)\n{\n\tunsigned long block_sz = memory_block_size_bytes();\n\tu64 block_nr_pages = block_sz >> PAGE_SHIFT;\n\tu64 nr_pages = size >> PAGE_SHIFT;\n\tu64 start_pfn = PFN_DOWN(start);\n\n\t/* memory range must be block size aligned */\n\tif (!nr_pages || !IS_ALIGNED(start_pfn, block_nr_pages) ||\n\t    !IS_ALIGNED(nr_pages, block_nr_pages)) {\n\t\tpr_err(\"Block size [%#lx] unaligned hotplug range: start %#llx, size %#llx\",\n\t\t       block_sz, start, size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Block size [%#lx] unaligned hotplug range: start %#llx, size %#llx\"",
            "block_sz",
            "start",
            "size"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "nr_pages",
            "block_nr_pages"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "start_pfn",
            "block_nr_pages"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "start"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_block_size_bytes",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int check_hotplug_memory_range(u64 start, u64 size)\n{\n\tunsigned long block_sz = memory_block_size_bytes();\n\tu64 block_nr_pages = block_sz >> PAGE_SHIFT;\n\tu64 nr_pages = size >> PAGE_SHIFT;\n\tu64 start_pfn = PFN_DOWN(start);\n\n\t/* memory range must be block size aligned */\n\tif (!nr_pages || !IS_ALIGNED(start_pfn, block_nr_pages) ||\n\t    !IS_ALIGNED(nr_pages, block_nr_pages)) {\n\t\tpr_err(\"Block size [%#lx] unaligned hotplug range: start %#llx, size %#llx\",\n\t\t       block_sz, start, size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "try_online_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1042-1050",
    "snippet": "int try_online_node(int nid)\n{\n\tint ret;\n\n\tmem_hotplug_begin();\n\tret =  __try_online_node(nid, 0, true);\n\tmem_hotplug_done();\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_hotplug_done",
          "args": [],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "92-96",
          "snippet": "void mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__try_online_node",
          "args": [
            "nid",
            "0",
            "true"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "__try_online_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1015-1037",
          "snippet": "static int __try_online_node(int nid, u64 start, bool set_node_online)\n{\n\tpg_data_t *pgdat;\n\tint ret = 1;\n\n\tif (node_online(nid))\n\t\treturn 0;\n\n\tpgdat = hotadd_new_pgdat(nid, start);\n\tif (!pgdat) {\n\t\tpr_err(\"Cannot online node %d due to NULL pgdat\\n\", nid);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (set_node_online) {\n\t\tnode_set_online(nid);\n\t\tret = register_one_node(nid);\n\t\tBUG_ON(ret);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __try_online_node(int nid, u64 start, bool set_node_online)\n{\n\tpg_data_t *pgdat;\n\tint ret = 1;\n\n\tif (node_online(nid))\n\t\treturn 0;\n\n\tpgdat = hotadd_new_pgdat(nid, start);\n\tif (!pgdat) {\n\t\tpr_err(\"Cannot online node %d due to NULL pgdat\\n\", nid);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (set_node_online) {\n\t\tnode_set_online(nid);\n\t\tret = register_one_node(nid);\n\t\tBUG_ON(ret);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_hotplug_begin",
          "args": [],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "86-90",
          "snippet": "void mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint try_online_node(int nid)\n{\n\tint ret;\n\n\tmem_hotplug_begin();\n\tret =  __try_online_node(nid, 0, true);\n\tmem_hotplug_done();\n\treturn ret;\n}"
  },
  {
    "function_name": "__try_online_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "1015-1037",
    "snippet": "static int __try_online_node(int nid, u64 start, bool set_node_online)\n{\n\tpg_data_t *pgdat;\n\tint ret = 1;\n\n\tif (node_online(nid))\n\t\treturn 0;\n\n\tpgdat = hotadd_new_pgdat(nid, start);\n\tif (!pgdat) {\n\t\tpr_err(\"Cannot online node %d due to NULL pgdat\\n\", nid);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (set_node_online) {\n\t\tnode_set_online(nid);\n\t\tret = register_one_node(nid);\n\t\tBUG_ON(ret);\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_one_node",
          "args": [
            "nid"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set_online",
          "args": [
            "nid"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot online node %d due to NULL pgdat\\n\"",
            "nid"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hotadd_new_pgdat",
          "args": [
            "nid",
            "start"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "hotadd_new_pgdat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "943-990",
          "snippet": "static pg_data_t __ref *hotadd_new_pgdat(int nid, u64 start)\n{\n\tstruct pglist_data *pgdat;\n\tunsigned long start_pfn = PFN_DOWN(start);\n\n\tpgdat = NODE_DATA(nid);\n\tif (!pgdat) {\n\t\tpgdat = arch_alloc_nodedata(nid);\n\t\tif (!pgdat)\n\t\t\treturn NULL;\n\n\t\tarch_refresh_nodedata(nid, pgdat);\n\t} else {\n\t\t/*\n\t\t * Reset the nr_zones, order and classzone_idx before reuse.\n\t\t * Note that kswapd will init kswapd_classzone_idx properly\n\t\t * when it starts in the near future.\n\t\t */\n\t\tpgdat->nr_zones = 0;\n\t\tpgdat->kswapd_order = 0;\n\t\tpgdat->kswapd_classzone_idx = 0;\n\t}\n\n\t/* we can use NODE_DATA(nid) from here */\n\n\tpgdat->node_id = nid;\n\tpgdat->node_start_pfn = start_pfn;\n\n\t/* init node's zones as empty zones, we don't have any present pages.*/\n\tfree_area_init_core_hotplug(nid);\n\tpgdat->per_cpu_nodestats = alloc_percpu(struct per_cpu_nodestat);\n\n\t/*\n\t * The node we allocated has no zone fallback lists. For avoiding\n\t * to access not-initialized zonelist, build here.\n\t */\n\tbuild_all_zonelists(pgdat);\n\n\t/*\n\t * When memory is hot-added, all the memory is in offline state. So\n\t * clear all zones' present_pages because they will be updated in\n\t * online_pages() and offline_pages().\n\t */\n\treset_node_managed_pages(pgdat);\n\treset_node_present_pages(pgdat);\n\n\treturn pgdat;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic pg_data_t __ref *hotadd_new_pgdat(int nid, u64 start)\n{\n\tstruct pglist_data *pgdat;\n\tunsigned long start_pfn = PFN_DOWN(start);\n\n\tpgdat = NODE_DATA(nid);\n\tif (!pgdat) {\n\t\tpgdat = arch_alloc_nodedata(nid);\n\t\tif (!pgdat)\n\t\t\treturn NULL;\n\n\t\tarch_refresh_nodedata(nid, pgdat);\n\t} else {\n\t\t/*\n\t\t * Reset the nr_zones, order and classzone_idx before reuse.\n\t\t * Note that kswapd will init kswapd_classzone_idx properly\n\t\t * when it starts in the near future.\n\t\t */\n\t\tpgdat->nr_zones = 0;\n\t\tpgdat->kswapd_order = 0;\n\t\tpgdat->kswapd_classzone_idx = 0;\n\t}\n\n\t/* we can use NODE_DATA(nid) from here */\n\n\tpgdat->node_id = nid;\n\tpgdat->node_start_pfn = start_pfn;\n\n\t/* init node's zones as empty zones, we don't have any present pages.*/\n\tfree_area_init_core_hotplug(nid);\n\tpgdat->per_cpu_nodestats = alloc_percpu(struct per_cpu_nodestat);\n\n\t/*\n\t * The node we allocated has no zone fallback lists. For avoiding\n\t * to access not-initialized zonelist, build here.\n\t */\n\tbuild_all_zonelists(pgdat);\n\n\t/*\n\t * When memory is hot-added, all the memory is in offline state. So\n\t * clear all zones' present_pages because they will be updated in\n\t * online_pages() and offline_pages().\n\t */\n\treset_node_managed_pages(pgdat);\n\treset_node_present_pages(pgdat);\n\n\treturn pgdat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "nid"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __try_online_node(int nid, u64 start, bool set_node_online)\n{\n\tpg_data_t *pgdat;\n\tint ret = 1;\n\n\tif (node_online(nid))\n\t\treturn 0;\n\n\tpgdat = hotadd_new_pgdat(nid, start);\n\tif (!pgdat) {\n\t\tpr_err(\"Cannot online node %d due to NULL pgdat\\n\", nid);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (set_node_online) {\n\t\tnode_set_online(nid);\n\t\tret = register_one_node(nid);\n\t\tBUG_ON(ret);\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "rollback_node_hotadd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "992-1000",
    "snippet": "static void rollback_node_hotadd(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tarch_refresh_nodedata(nid, NULL);\n\tfree_percpu(pgdat->per_cpu_nodestats);\n\tarch_free_nodedata(pgdat);\n\treturn;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_free_nodedata",
          "args": [
            "pgdat"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "pgdat->per_cpu_nodestats"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1718-1753",
          "snippet": "void free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_size",
            "int pcpu_nr_slots",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static struct page *pcpu_addr_to_page(void *addr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nvoid free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_refresh_nodedata",
          "args": [
            "nid",
            "NULL"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void rollback_node_hotadd(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tarch_refresh_nodedata(nid, NULL);\n\tfree_percpu(pgdat->per_cpu_nodestats);\n\tarch_free_nodedata(pgdat);\n\treturn;\n}"
  },
  {
    "function_name": "hotadd_new_pgdat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "943-990",
    "snippet": "static pg_data_t __ref *hotadd_new_pgdat(int nid, u64 start)\n{\n\tstruct pglist_data *pgdat;\n\tunsigned long start_pfn = PFN_DOWN(start);\n\n\tpgdat = NODE_DATA(nid);\n\tif (!pgdat) {\n\t\tpgdat = arch_alloc_nodedata(nid);\n\t\tif (!pgdat)\n\t\t\treturn NULL;\n\n\t\tarch_refresh_nodedata(nid, pgdat);\n\t} else {\n\t\t/*\n\t\t * Reset the nr_zones, order and classzone_idx before reuse.\n\t\t * Note that kswapd will init kswapd_classzone_idx properly\n\t\t * when it starts in the near future.\n\t\t */\n\t\tpgdat->nr_zones = 0;\n\t\tpgdat->kswapd_order = 0;\n\t\tpgdat->kswapd_classzone_idx = 0;\n\t}\n\n\t/* we can use NODE_DATA(nid) from here */\n\n\tpgdat->node_id = nid;\n\tpgdat->node_start_pfn = start_pfn;\n\n\t/* init node's zones as empty zones, we don't have any present pages.*/\n\tfree_area_init_core_hotplug(nid);\n\tpgdat->per_cpu_nodestats = alloc_percpu(struct per_cpu_nodestat);\n\n\t/*\n\t * The node we allocated has no zone fallback lists. For avoiding\n\t * to access not-initialized zonelist, build here.\n\t */\n\tbuild_all_zonelists(pgdat);\n\n\t/*\n\t * When memory is hot-added, all the memory is in offline state. So\n\t * clear all zones' present_pages because they will be updated in\n\t * online_pages() and offline_pages().\n\t */\n\treset_node_managed_pages(pgdat);\n\treset_node_present_pages(pgdat);\n\n\treturn pgdat;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_node_present_pages",
          "args": [
            "pgdat"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "reset_node_present_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "932-940",
          "snippet": "static void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_node_managed_pages",
          "args": [
            "pgdat"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "reset_node_managed_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1948-1954",
          "snippet": "void reset_node_managed_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->managed_pages = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid reset_node_managed_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->managed_pages = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_all_zonelists",
          "args": [
            "pgdat"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structper_cpu_nodestat"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "early_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "941-950",
          "snippet": "static void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\n\nstatic void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_area_init_core_hotplug",
          "args": [
            "nid"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_refresh_nodedata",
          "args": [
            "nid",
            "pgdat"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_alloc_nodedata",
          "args": [
            "nid"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "start"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic pg_data_t __ref *hotadd_new_pgdat(int nid, u64 start)\n{\n\tstruct pglist_data *pgdat;\n\tunsigned long start_pfn = PFN_DOWN(start);\n\n\tpgdat = NODE_DATA(nid);\n\tif (!pgdat) {\n\t\tpgdat = arch_alloc_nodedata(nid);\n\t\tif (!pgdat)\n\t\t\treturn NULL;\n\n\t\tarch_refresh_nodedata(nid, pgdat);\n\t} else {\n\t\t/*\n\t\t * Reset the nr_zones, order and classzone_idx before reuse.\n\t\t * Note that kswapd will init kswapd_classzone_idx properly\n\t\t * when it starts in the near future.\n\t\t */\n\t\tpgdat->nr_zones = 0;\n\t\tpgdat->kswapd_order = 0;\n\t\tpgdat->kswapd_classzone_idx = 0;\n\t}\n\n\t/* we can use NODE_DATA(nid) from here */\n\n\tpgdat->node_id = nid;\n\tpgdat->node_start_pfn = start_pfn;\n\n\t/* init node's zones as empty zones, we don't have any present pages.*/\n\tfree_area_init_core_hotplug(nid);\n\tpgdat->per_cpu_nodestats = alloc_percpu(struct per_cpu_nodestat);\n\n\t/*\n\t * The node we allocated has no zone fallback lists. For avoiding\n\t * to access not-initialized zonelist, build here.\n\t */\n\tbuild_all_zonelists(pgdat);\n\n\t/*\n\t * When memory is hot-added, all the memory is in offline state. So\n\t * clear all zones' present_pages because they will be updated in\n\t * online_pages() and offline_pages().\n\t */\n\treset_node_managed_pages(pgdat);\n\treset_node_present_pages(pgdat);\n\n\treturn pgdat;\n}"
  },
  {
    "function_name": "reset_node_present_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "932-940",
    "snippet": "static void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}"
  },
  {
    "function_name": "online_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "842-929",
    "snippet": "int __ref online_pages(unsigned long pfn, unsigned long nr_pages, int online_type)\n{\n\tunsigned long flags;\n\tunsigned long onlined_pages = 0;\n\tstruct zone *zone;\n\tint need_zonelists_rebuild = 0;\n\tint nid;\n\tint ret;\n\tstruct memory_notify arg;\n\tstruct memory_block *mem;\n\n\tmem_hotplug_begin();\n\n\t/*\n\t * We can't use pfn_to_nid() because nid might be stored in struct page\n\t * which is not yet initialized. Instead, we find nid from memory block.\n\t */\n\tmem = find_memory_block(__pfn_to_section(pfn));\n\tnid = mem->nid;\n\n\t/* associate pfn range with the zone */\n\tzone = move_pfn_range(online_type, nid, pfn, nr_pages);\n\n\targ.start_pfn = pfn;\n\targ.nr_pages = nr_pages;\n\tnode_states_check_changes_online(nr_pages, zone, &arg);\n\n\tret = memory_notify(MEM_GOING_ONLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret)\n\t\tgoto failed_addition;\n\n\t/*\n\t * If this zone is not populated, then it is not in zonelist.\n\t * This means the page allocator ignores this zone.\n\t * So, zonelist must be updated after online.\n\t */\n\tif (!populated_zone(zone)) {\n\t\tneed_zonelists_rebuild = 1;\n\t\tsetup_zone_pageset(zone);\n\t}\n\n\tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\n\t\tonline_pages_range);\n\tif (ret) {\n\t\tif (need_zonelists_rebuild)\n\t\t\tzone_pcp_reset(zone);\n\t\tgoto failed_addition;\n\t}\n\n\tzone->present_pages += onlined_pages;\n\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tzone->zone_pgdat->node_present_pages += onlined_pages;\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n\n\tif (onlined_pages) {\n\t\tnode_states_set_node(nid, &arg);\n\t\tif (need_zonelists_rebuild)\n\t\t\tbuild_all_zonelists(NULL);\n\t\telse\n\t\t\tzone_pcp_update(zone);\n\t}\n\n\tinit_per_zone_wmark_min();\n\n\tif (onlined_pages) {\n\t\tkswapd_run(nid);\n\t\tkcompactd_run(nid);\n\t}\n\n\tvm_total_pages = nr_free_pagecache_pages();\n\n\twriteback_set_ratelimit();\n\n\tif (onlined_pages)\n\t\tmemory_notify(MEM_ONLINE, &arg);\n\tmem_hotplug_done();\n\treturn 0;\n\nfailed_addition:\n\tpr_debug(\"online_pages [mem %#010llx-%#010llx] failed\\n\",\n\t\t (unsigned long long) pfn << PAGE_SHIFT,\n\t\t (((unsigned long long) pfn + nr_pages) << PAGE_SHIFT) - 1);\n\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\tmem_hotplug_done();\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_hotplug_done",
          "args": [],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "92-96",
          "snippet": "void mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memory_notify",
          "args": [
            "MEM_CANCEL_ONLINE",
            "&arg"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"online_pages [mem %#010llx-%#010llx] failed\\n\"",
            "(unsigned long long) pfn << PAGE_SHIFT",
            "(((unsigned long long) pfn + nr_pages) << PAGE_SHIFT) - 1"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_notify",
          "args": [
            "MEM_ONLINE",
            "&arg"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_set_ratelimit",
          "args": [],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_set_ratelimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2039-2050",
          "snippet": "void writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long ratelimit_pages = 32;",
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long ratelimit_pages = 32;\nstruct wb_domain global_wb_domain;\n\nvoid writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_free_pagecache_pages",
          "args": [],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "nr_free_pagecache_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4690-4693",
          "snippet": "unsigned long nr_free_pagecache_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_HIGHUSER_MOVABLE));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nunsigned long nr_free_pagecache_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_HIGHUSER_MOVABLE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcompactd_run",
          "args": [
            "nid"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "kcompactd_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "2090-2105",
          "snippet": "int kcompactd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kcompactd)\n\t\treturn 0;\n\n\tpgdat->kcompactd = kthread_run(kcompactd, pgdat, \"kcompactd%d\", nid);\n\tif (IS_ERR(pgdat->kcompactd)) {\n\t\tpr_err(\"Failed to start kcompactd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kcompactd);\n\t\tpgdat->kcompactd = NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nint kcompactd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kcompactd)\n\t\treturn 0;\n\n\tpgdat->kcompactd = kthread_run(kcompactd, pgdat, \"kcompactd%d\", nid);\n\tif (IS_ERR(pgdat->kcompactd)) {\n\t\tpr_err(\"Failed to start kcompactd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kcompactd);\n\t\tpgdat->kcompactd = NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kswapd_run",
          "args": [
            "nid"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "kswapd_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3942-3959",
          "snippet": "int kswapd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kswapd)\n\t\treturn 0;\n\n\tpgdat->kswapd = kthread_run(kswapd, pgdat, \"kswapd%d\", nid);\n\tif (IS_ERR(pgdat->kswapd)) {\n\t\t/* failure at boot is fatal */\n\t\tBUG_ON(system_state < SYSTEM_RUNNING);\n\t\tpr_err(\"Failed to start kswapd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kswapd);\n\t\tpgdat->kswapd = NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint kswapd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kswapd)\n\t\treturn 0;\n\n\tpgdat->kswapd = kthread_run(kswapd, pgdat, \"kswapd%d\", nid);\n\tif (IS_ERR(pgdat->kswapd)) {\n\t\t/* failure at boot is fatal */\n\t\tBUG_ON(system_state < SYSTEM_RUNNING);\n\t\tpr_err(\"Failed to start kswapd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kswapd);\n\t\tpgdat->kswapd = NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_per_zone_wmark_min",
          "args": [],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_pcp_update",
          "args": [
            "zone"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_all_zonelists",
          "args": [
            "NULL"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_states_set_node",
          "args": [
            "nid",
            "&arg"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "node_states_set_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "705-715",
          "snippet": "static void node_states_set_node(int node, struct memory_notify *arg)\n{\n\tif (arg->status_change_nid_normal >= 0)\n\t\tnode_set_state(node, N_NORMAL_MEMORY);\n\n\tif (arg->status_change_nid_high >= 0)\n\t\tnode_set_state(node, N_HIGH_MEMORY);\n\n\tif (arg->status_change_nid >= 0)\n\t\tnode_set_state(node, N_MEMORY);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void node_states_set_node(int node, struct memory_notify *arg)\n{\n\tif (arg->status_change_nid_normal >= 0)\n\t\tnode_set_state(node, N_NORMAL_MEMORY);\n\n\tif (arg->status_change_nid_high >= 0)\n\t\tnode_set_state(node, N_HIGH_MEMORY);\n\n\tif (arg->status_change_nid >= 0)\n\t\tnode_set_state(node, N_MEMORY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "zone->zone_pgdat",
            "&flags"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_lock",
          "args": [
            "zone->zone_pgdat",
            "&flags"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_pcp_reset",
          "args": [
            "zone"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_system_ram_range",
          "args": [
            "pfn",
            "nr_pages",
            "&onlined_pages",
            "online_pages_range"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_zone_pageset",
          "args": [
            "zone"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notifier_to_errno",
          "args": [
            "ret"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_notify",
          "args": [
            "MEM_GOING_ONLINE",
            "&arg"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_states_check_changes_online",
          "args": [
            "nr_pages",
            "zone",
            "&arg"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "node_states_check_changes_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "686-703",
          "snippet": "static void node_states_check_changes_online(unsigned long nr_pages,\n\tstruct zone *zone, struct memory_notify *arg)\n{\n\tint nid = zone_to_nid(zone);\n\n\targ->status_change_nid = -1;\n\targ->status_change_nid_normal = -1;\n\targ->status_change_nid_high = -1;\n\n\tif (!node_state(nid, N_MEMORY))\n\t\targ->status_change_nid = nid;\n\tif (zone_idx(zone) <= ZONE_NORMAL && !node_state(nid, N_NORMAL_MEMORY))\n\t\targ->status_change_nid_normal = nid;\n#ifdef CONFIG_HIGHMEM\n\tif (zone_idx(zone) <= N_HIGH_MEMORY && !node_state(nid, N_HIGH_MEMORY))\n\t\targ->status_change_nid_high = nid;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void node_states_check_changes_online(unsigned long nr_pages,\n\tstruct zone *zone, struct memory_notify *arg)\n{\n\tint nid = zone_to_nid(zone);\n\n\targ->status_change_nid = -1;\n\targ->status_change_nid_normal = -1;\n\targ->status_change_nid_high = -1;\n\n\tif (!node_state(nid, N_MEMORY))\n\t\targ->status_change_nid = nid;\n\tif (zone_idx(zone) <= ZONE_NORMAL && !node_state(nid, N_NORMAL_MEMORY))\n\t\targ->status_change_nid_normal = nid;\n#ifdef CONFIG_HIGHMEM\n\tif (zone_idx(zone) <= N_HIGH_MEMORY && !node_state(nid, N_HIGH_MEMORY))\n\t\targ->status_change_nid_high = nid;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_pfn_range",
          "args": [
            "online_type",
            "nid",
            "pfn",
            "nr_pages"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "move_pfn_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "832-840",
          "snippet": "static struct zone * __meminit move_pfn_range(int online_type, int nid,\n\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tstruct zone *zone;\n\n\tzone = zone_for_pfn_range(online_type, nid, start_pfn, nr_pages);\n\tmove_pfn_range_to_zone(zone, start_pfn, nr_pages, NULL);\n\treturn zone;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic struct zone * __meminit move_pfn_range(int online_type, int nid,\n\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tstruct zone *zone;\n\n\tzone = zone_for_pfn_range(online_type, nid, start_pfn, nr_pages);\n\tmove_pfn_range_to_zone(zone, start_pfn, nr_pages, NULL);\n\treturn zone;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_memory_block",
          "args": [
            "__pfn_to_section(pfn)"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "pfn"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_hotplug_begin",
          "args": [],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "86-90",
          "snippet": "void mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nint __ref online_pages(unsigned long pfn, unsigned long nr_pages, int online_type)\n{\n\tunsigned long flags;\n\tunsigned long onlined_pages = 0;\n\tstruct zone *zone;\n\tint need_zonelists_rebuild = 0;\n\tint nid;\n\tint ret;\n\tstruct memory_notify arg;\n\tstruct memory_block *mem;\n\n\tmem_hotplug_begin();\n\n\t/*\n\t * We can't use pfn_to_nid() because nid might be stored in struct page\n\t * which is not yet initialized. Instead, we find nid from memory block.\n\t */\n\tmem = find_memory_block(__pfn_to_section(pfn));\n\tnid = mem->nid;\n\n\t/* associate pfn range with the zone */\n\tzone = move_pfn_range(online_type, nid, pfn, nr_pages);\n\n\targ.start_pfn = pfn;\n\targ.nr_pages = nr_pages;\n\tnode_states_check_changes_online(nr_pages, zone, &arg);\n\n\tret = memory_notify(MEM_GOING_ONLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret)\n\t\tgoto failed_addition;\n\n\t/*\n\t * If this zone is not populated, then it is not in zonelist.\n\t * This means the page allocator ignores this zone.\n\t * So, zonelist must be updated after online.\n\t */\n\tif (!populated_zone(zone)) {\n\t\tneed_zonelists_rebuild = 1;\n\t\tsetup_zone_pageset(zone);\n\t}\n\n\tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\n\t\tonline_pages_range);\n\tif (ret) {\n\t\tif (need_zonelists_rebuild)\n\t\t\tzone_pcp_reset(zone);\n\t\tgoto failed_addition;\n\t}\n\n\tzone->present_pages += onlined_pages;\n\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tzone->zone_pgdat->node_present_pages += onlined_pages;\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n\n\tif (onlined_pages) {\n\t\tnode_states_set_node(nid, &arg);\n\t\tif (need_zonelists_rebuild)\n\t\t\tbuild_all_zonelists(NULL);\n\t\telse\n\t\t\tzone_pcp_update(zone);\n\t}\n\n\tinit_per_zone_wmark_min();\n\n\tif (onlined_pages) {\n\t\tkswapd_run(nid);\n\t\tkcompactd_run(nid);\n\t}\n\n\tvm_total_pages = nr_free_pagecache_pages();\n\n\twriteback_set_ratelimit();\n\n\tif (onlined_pages)\n\t\tmemory_notify(MEM_ONLINE, &arg);\n\tmem_hotplug_done();\n\treturn 0;\n\nfailed_addition:\n\tpr_debug(\"online_pages [mem %#010llx-%#010llx] failed\\n\",\n\t\t (unsigned long long) pfn << PAGE_SHIFT,\n\t\t (((unsigned long long) pfn + nr_pages) << PAGE_SHIFT) - 1);\n\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\tmem_hotplug_done();\n\treturn ret;\n}"
  },
  {
    "function_name": "move_pfn_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "832-840",
    "snippet": "static struct zone * __meminit move_pfn_range(int online_type, int nid,\n\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tstruct zone *zone;\n\n\tzone = zone_for_pfn_range(online_type, nid, start_pfn, nr_pages);\n\tmove_pfn_range_to_zone(zone, start_pfn, nr_pages, NULL);\n\treturn zone;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_pfn_range_to_zone",
          "args": [
            "zone",
            "start_pfn",
            "nr_pages",
            "NULL"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "move_pfn_range_to_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "739-769",
          "snippet": "void __ref move_pfn_range_to_zone(struct zone *zone, unsigned long start_pfn,\n\t\tunsigned long nr_pages, struct vmem_altmap *altmap)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nid = pgdat->node_id;\n\tunsigned long flags;\n\n\tif (zone_is_empty(zone))\n\t\tinit_currently_empty_zone(zone, start_pfn, nr_pages);\n\n\tclear_zone_contiguous(zone);\n\n\t/* TODO Huh pgdat is irqsave while zone is not. It used to be like that before */\n\tpgdat_resize_lock(pgdat, &flags);\n\tzone_span_writelock(zone);\n\tresize_zone_range(zone, start_pfn, nr_pages);\n\tzone_span_writeunlock(zone);\n\tresize_pgdat_range(pgdat, start_pfn, nr_pages);\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\t/*\n\t * TODO now we have a visible range of pages which are not associated\n\t * with their zone properly. Not nice but set_pfnblock_flags_mask\n\t * expects the zone spans the pfn range. All the pages in the range\n\t * are reserved so nobody should be touching them so we should be safe\n\t */\n\tmemmap_init_zone(nr_pages, nid, zone_idx(zone), start_pfn,\n\t\t\tMEMMAP_HOTPLUG, altmap);\n\n\tset_zone_contiguous(zone);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid __ref move_pfn_range_to_zone(struct zone *zone, unsigned long start_pfn,\n\t\tunsigned long nr_pages, struct vmem_altmap *altmap)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nid = pgdat->node_id;\n\tunsigned long flags;\n\n\tif (zone_is_empty(zone))\n\t\tinit_currently_empty_zone(zone, start_pfn, nr_pages);\n\n\tclear_zone_contiguous(zone);\n\n\t/* TODO Huh pgdat is irqsave while zone is not. It used to be like that before */\n\tpgdat_resize_lock(pgdat, &flags);\n\tzone_span_writelock(zone);\n\tresize_zone_range(zone, start_pfn, nr_pages);\n\tzone_span_writeunlock(zone);\n\tresize_pgdat_range(pgdat, start_pfn, nr_pages);\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\t/*\n\t * TODO now we have a visible range of pages which are not associated\n\t * with their zone properly. Not nice but set_pfnblock_flags_mask\n\t * expects the zone spans the pfn range. All the pages in the range\n\t * are reserved so nobody should be touching them so we should be safe\n\t */\n\tmemmap_init_zone(nr_pages, nid, zone_idx(zone), start_pfn,\n\t\t\tMEMMAP_HOTPLUG, altmap);\n\n\tset_zone_contiguous(zone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_for_pfn_range",
          "args": [
            "online_type",
            "nid",
            "start_pfn",
            "nr_pages"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "zone_for_pfn_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "816-826",
          "snippet": "struct zone * zone_for_pfn_range(int online_type, int nid, unsigned start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tif (online_type == MMOP_ONLINE_KERNEL)\n\t\treturn default_kernel_zone_for_pfn(nid, start_pfn, nr_pages);\n\n\tif (online_type == MMOP_ONLINE_MOVABLE)\n\t\treturn &NODE_DATA(nid)->node_zones[ZONE_MOVABLE];\n\n\treturn default_zone_for_pfn(nid, start_pfn, nr_pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstruct zone * zone_for_pfn_range(int online_type, int nid, unsigned start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tif (online_type == MMOP_ONLINE_KERNEL)\n\t\treturn default_kernel_zone_for_pfn(nid, start_pfn, nr_pages);\n\n\tif (online_type == MMOP_ONLINE_MOVABLE)\n\t\treturn &NODE_DATA(nid)->node_zones[ZONE_MOVABLE];\n\n\treturn default_zone_for_pfn(nid, start_pfn, nr_pages);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic struct zone * __meminit move_pfn_range(int online_type, int nid,\n\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tstruct zone *zone;\n\n\tzone = zone_for_pfn_range(online_type, nid, start_pfn, nr_pages);\n\tmove_pfn_range_to_zone(zone, start_pfn, nr_pages, NULL);\n\treturn zone;\n}"
  },
  {
    "function_name": "zone_for_pfn_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "816-826",
    "snippet": "struct zone * zone_for_pfn_range(int online_type, int nid, unsigned start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tif (online_type == MMOP_ONLINE_KERNEL)\n\t\treturn default_kernel_zone_for_pfn(nid, start_pfn, nr_pages);\n\n\tif (online_type == MMOP_ONLINE_MOVABLE)\n\t\treturn &NODE_DATA(nid)->node_zones[ZONE_MOVABLE];\n\n\treturn default_zone_for_pfn(nid, start_pfn, nr_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "default_zone_for_pfn",
          "args": [
            "nid",
            "start_pfn",
            "nr_pages"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "default_zone_for_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "792-814",
          "snippet": "static inline struct zone *default_zone_for_pfn(int nid, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tstruct zone *kernel_zone = default_kernel_zone_for_pfn(nid, start_pfn,\n\t\t\tnr_pages);\n\tstruct zone *movable_zone = &NODE_DATA(nid)->node_zones[ZONE_MOVABLE];\n\tbool in_kernel = zone_intersects(kernel_zone, start_pfn, nr_pages);\n\tbool in_movable = zone_intersects(movable_zone, start_pfn, nr_pages);\n\n\t/*\n\t * We inherit the existing zone in a simple case where zones do not\n\t * overlap in the given range\n\t */\n\tif (in_kernel ^ in_movable)\n\t\treturn (in_kernel) ? kernel_zone : movable_zone;\n\n\t/*\n\t * If the range doesn't belong to any zone or two zones overlap in the\n\t * given range then we use movable zone only if movable_node is\n\t * enabled because we always online to a kernel zone by default.\n\t */\n\treturn movable_node_enabled ? movable_zone : kernel_zone;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool movable_node_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nbool movable_node_enabled = false;\n\nstatic inline struct zone *default_zone_for_pfn(int nid, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tstruct zone *kernel_zone = default_kernel_zone_for_pfn(nid, start_pfn,\n\t\t\tnr_pages);\n\tstruct zone *movable_zone = &NODE_DATA(nid)->node_zones[ZONE_MOVABLE];\n\tbool in_kernel = zone_intersects(kernel_zone, start_pfn, nr_pages);\n\tbool in_movable = zone_intersects(movable_zone, start_pfn, nr_pages);\n\n\t/*\n\t * We inherit the existing zone in a simple case where zones do not\n\t * overlap in the given range\n\t */\n\tif (in_kernel ^ in_movable)\n\t\treturn (in_kernel) ? kernel_zone : movable_zone;\n\n\t/*\n\t * If the range doesn't belong to any zone or two zones overlap in the\n\t * given range then we use movable zone only if movable_node is\n\t * enabled because we always online to a kernel zone by default.\n\t */\n\treturn movable_node_enabled ? movable_zone : kernel_zone;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_kernel_zone_for_pfn",
          "args": [
            "nid",
            "start_pfn",
            "nr_pages"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "default_kernel_zone_for_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "776-790",
          "snippet": "static struct zone *default_kernel_zone_for_pfn(int nid, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tstruct pglist_data *pgdat = NODE_DATA(nid);\n\tint zid;\n\n\tfor (zid = 0; zid <= ZONE_NORMAL; zid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zid];\n\n\t\tif (zone_intersects(zone, start_pfn, nr_pages))\n\t\t\treturn zone;\n\t}\n\n\treturn &pgdat->node_zones[ZONE_NORMAL];\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic struct zone *default_kernel_zone_for_pfn(int nid, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tstruct pglist_data *pgdat = NODE_DATA(nid);\n\tint zid;\n\n\tfor (zid = 0; zid <= ZONE_NORMAL; zid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zid];\n\n\t\tif (zone_intersects(zone, start_pfn, nr_pages))\n\t\t\treturn zone;\n\t}\n\n\treturn &pgdat->node_zones[ZONE_NORMAL];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstruct zone * zone_for_pfn_range(int online_type, int nid, unsigned start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tif (online_type == MMOP_ONLINE_KERNEL)\n\t\treturn default_kernel_zone_for_pfn(nid, start_pfn, nr_pages);\n\n\tif (online_type == MMOP_ONLINE_MOVABLE)\n\t\treturn &NODE_DATA(nid)->node_zones[ZONE_MOVABLE];\n\n\treturn default_zone_for_pfn(nid, start_pfn, nr_pages);\n}"
  },
  {
    "function_name": "default_zone_for_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "792-814",
    "snippet": "static inline struct zone *default_zone_for_pfn(int nid, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tstruct zone *kernel_zone = default_kernel_zone_for_pfn(nid, start_pfn,\n\t\t\tnr_pages);\n\tstruct zone *movable_zone = &NODE_DATA(nid)->node_zones[ZONE_MOVABLE];\n\tbool in_kernel = zone_intersects(kernel_zone, start_pfn, nr_pages);\n\tbool in_movable = zone_intersects(movable_zone, start_pfn, nr_pages);\n\n\t/*\n\t * We inherit the existing zone in a simple case where zones do not\n\t * overlap in the given range\n\t */\n\tif (in_kernel ^ in_movable)\n\t\treturn (in_kernel) ? kernel_zone : movable_zone;\n\n\t/*\n\t * If the range doesn't belong to any zone or two zones overlap in the\n\t * given range then we use movable zone only if movable_node is\n\t * enabled because we always online to a kernel zone by default.\n\t */\n\treturn movable_node_enabled ? movable_zone : kernel_zone;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool movable_node_enabled = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_intersects",
          "args": [
            "movable_zone",
            "start_pfn",
            "nr_pages"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_intersects",
          "args": [
            "kernel_zone",
            "start_pfn",
            "nr_pages"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_kernel_zone_for_pfn",
          "args": [
            "nid",
            "start_pfn",
            "nr_pages"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "default_kernel_zone_for_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "776-790",
          "snippet": "static struct zone *default_kernel_zone_for_pfn(int nid, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tstruct pglist_data *pgdat = NODE_DATA(nid);\n\tint zid;\n\n\tfor (zid = 0; zid <= ZONE_NORMAL; zid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zid];\n\n\t\tif (zone_intersects(zone, start_pfn, nr_pages))\n\t\t\treturn zone;\n\t}\n\n\treturn &pgdat->node_zones[ZONE_NORMAL];\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic struct zone *default_kernel_zone_for_pfn(int nid, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tstruct pglist_data *pgdat = NODE_DATA(nid);\n\tint zid;\n\n\tfor (zid = 0; zid <= ZONE_NORMAL; zid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zid];\n\n\t\tif (zone_intersects(zone, start_pfn, nr_pages))\n\t\t\treturn zone;\n\t}\n\n\treturn &pgdat->node_zones[ZONE_NORMAL];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nbool movable_node_enabled = false;\n\nstatic inline struct zone *default_zone_for_pfn(int nid, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tstruct zone *kernel_zone = default_kernel_zone_for_pfn(nid, start_pfn,\n\t\t\tnr_pages);\n\tstruct zone *movable_zone = &NODE_DATA(nid)->node_zones[ZONE_MOVABLE];\n\tbool in_kernel = zone_intersects(kernel_zone, start_pfn, nr_pages);\n\tbool in_movable = zone_intersects(movable_zone, start_pfn, nr_pages);\n\n\t/*\n\t * We inherit the existing zone in a simple case where zones do not\n\t * overlap in the given range\n\t */\n\tif (in_kernel ^ in_movable)\n\t\treturn (in_kernel) ? kernel_zone : movable_zone;\n\n\t/*\n\t * If the range doesn't belong to any zone or two zones overlap in the\n\t * given range then we use movable zone only if movable_node is\n\t * enabled because we always online to a kernel zone by default.\n\t */\n\treturn movable_node_enabled ? movable_zone : kernel_zone;\n}"
  },
  {
    "function_name": "default_kernel_zone_for_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "776-790",
    "snippet": "static struct zone *default_kernel_zone_for_pfn(int nid, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tstruct pglist_data *pgdat = NODE_DATA(nid);\n\tint zid;\n\n\tfor (zid = 0; zid <= ZONE_NORMAL; zid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zid];\n\n\t\tif (zone_intersects(zone, start_pfn, nr_pages))\n\t\t\treturn zone;\n\t}\n\n\treturn &pgdat->node_zones[ZONE_NORMAL];\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_intersects",
          "args": [
            "zone",
            "start_pfn",
            "nr_pages"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic struct zone *default_kernel_zone_for_pfn(int nid, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tstruct pglist_data *pgdat = NODE_DATA(nid);\n\tint zid;\n\n\tfor (zid = 0; zid <= ZONE_NORMAL; zid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zid];\n\n\t\tif (zone_intersects(zone, start_pfn, nr_pages))\n\t\t\treturn zone;\n\t}\n\n\treturn &pgdat->node_zones[ZONE_NORMAL];\n}"
  },
  {
    "function_name": "move_pfn_range_to_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "739-769",
    "snippet": "void __ref move_pfn_range_to_zone(struct zone *zone, unsigned long start_pfn,\n\t\tunsigned long nr_pages, struct vmem_altmap *altmap)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nid = pgdat->node_id;\n\tunsigned long flags;\n\n\tif (zone_is_empty(zone))\n\t\tinit_currently_empty_zone(zone, start_pfn, nr_pages);\n\n\tclear_zone_contiguous(zone);\n\n\t/* TODO Huh pgdat is irqsave while zone is not. It used to be like that before */\n\tpgdat_resize_lock(pgdat, &flags);\n\tzone_span_writelock(zone);\n\tresize_zone_range(zone, start_pfn, nr_pages);\n\tzone_span_writeunlock(zone);\n\tresize_pgdat_range(pgdat, start_pfn, nr_pages);\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\t/*\n\t * TODO now we have a visible range of pages which are not associated\n\t * with their zone properly. Not nice but set_pfnblock_flags_mask\n\t * expects the zone spans the pfn range. All the pages in the range\n\t * are reserved so nobody should be touching them so we should be safe\n\t */\n\tmemmap_init_zone(nr_pages, nid, zone_idx(zone), start_pfn,\n\t\t\tMEMMAP_HOTPLUG, altmap);\n\n\tset_zone_contiguous(zone);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_zone_contiguous",
          "args": [
            "zone"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "set_zone_contiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1394-1413",
          "snippet": "void set_zone_contiguous(struct zone *zone)\n{\n\tunsigned long block_start_pfn = zone->zone_start_pfn;\n\tunsigned long block_end_pfn;\n\n\tblock_end_pfn = ALIGN(block_start_pfn + 1, pageblock_nr_pages);\n\tfor (; block_start_pfn < zone_end_pfn(zone);\n\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t block_end_pfn += pageblock_nr_pages) {\n\n\t\tblock_end_pfn = min(block_end_pfn, zone_end_pfn(zone));\n\n\t\tif (!__pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\t     block_end_pfn, zone))\n\t\t\treturn;\n\t}\n\n\t/* We confirm that there is no hole */\n\tzone->contiguous = true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_zone_contiguous(struct zone *zone)\n{\n\tunsigned long block_start_pfn = zone->zone_start_pfn;\n\tunsigned long block_end_pfn;\n\n\tblock_end_pfn = ALIGN(block_start_pfn + 1, pageblock_nr_pages);\n\tfor (; block_start_pfn < zone_end_pfn(zone);\n\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t block_end_pfn += pageblock_nr_pages) {\n\n\t\tblock_end_pfn = min(block_end_pfn, zone_end_pfn(zone));\n\n\t\tif (!__pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\t     block_end_pfn, zone))\n\t\t\treturn;\n\t}\n\n\t/* We confirm that there is no hole */\n\tzone->contiguous = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmap_init_zone",
          "args": [
            "nr_pages",
            "nid",
            "zone_idx(zone)",
            "start_pfn",
            "MEMMAP_HOTPLUG",
            "altmap"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resize_pgdat_range",
          "args": [
            "pgdat",
            "start_pfn",
            "nr_pages"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "resize_pgdat_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "728-737",
          "snippet": "static void __meminit resize_pgdat_range(struct pglist_data *pgdat, unsigned long start_pfn,\n                                     unsigned long nr_pages)\n{\n\tunsigned long old_end_pfn = pgdat_end_pfn(pgdat);\n\n\tif (!pgdat->node_spanned_pages || start_pfn < pgdat->node_start_pfn)\n\t\tpgdat->node_start_pfn = start_pfn;\n\n\tpgdat->node_spanned_pages = max(start_pfn + nr_pages, old_end_pfn) - pgdat->node_start_pfn;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __meminit resize_pgdat_range(struct pglist_data *pgdat, unsigned long start_pfn,\n                                     unsigned long nr_pages)\n{\n\tunsigned long old_end_pfn = pgdat_end_pfn(pgdat);\n\n\tif (!pgdat->node_spanned_pages || start_pfn < pgdat->node_start_pfn)\n\t\tpgdat->node_start_pfn = start_pfn;\n\n\tpgdat->node_spanned_pages = max(start_pfn + nr_pages, old_end_pfn) - pgdat->node_start_pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_span_writeunlock",
          "args": [
            "zone"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resize_zone_range",
          "args": [
            "zone",
            "start_pfn",
            "nr_pages"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "resize_zone_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "717-726",
          "snippet": "static void __meminit resize_zone_range(struct zone *zone, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tunsigned long old_end_pfn = zone_end_pfn(zone);\n\n\tif (zone_is_empty(zone) || start_pfn < zone->zone_start_pfn)\n\t\tzone->zone_start_pfn = start_pfn;\n\n\tzone->spanned_pages = max(start_pfn + nr_pages, old_end_pfn) - zone->zone_start_pfn;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __meminit resize_zone_range(struct zone *zone, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tunsigned long old_end_pfn = zone_end_pfn(zone);\n\n\tif (zone_is_empty(zone) || start_pfn < zone->zone_start_pfn)\n\t\tzone->zone_start_pfn = start_pfn;\n\n\tzone->spanned_pages = max(start_pfn + nr_pages, old_end_pfn) - zone->zone_start_pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_span_writelock",
          "args": [
            "zone"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_lock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_zone_contiguous",
          "args": [
            "zone"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "clear_zone_contiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1415-1418",
          "snippet": "void clear_zone_contiguous(struct zone *zone)\n{\n\tzone->contiguous = false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid clear_zone_contiguous(struct zone *zone)\n{\n\tzone->contiguous = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_currently_empty_zone",
          "args": [
            "zone",
            "start_pfn",
            "nr_pages"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_is_empty",
          "args": [
            "zone"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid __ref move_pfn_range_to_zone(struct zone *zone, unsigned long start_pfn,\n\t\tunsigned long nr_pages, struct vmem_altmap *altmap)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nid = pgdat->node_id;\n\tunsigned long flags;\n\n\tif (zone_is_empty(zone))\n\t\tinit_currently_empty_zone(zone, start_pfn, nr_pages);\n\n\tclear_zone_contiguous(zone);\n\n\t/* TODO Huh pgdat is irqsave while zone is not. It used to be like that before */\n\tpgdat_resize_lock(pgdat, &flags);\n\tzone_span_writelock(zone);\n\tresize_zone_range(zone, start_pfn, nr_pages);\n\tzone_span_writeunlock(zone);\n\tresize_pgdat_range(pgdat, start_pfn, nr_pages);\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\t/*\n\t * TODO now we have a visible range of pages which are not associated\n\t * with their zone properly. Not nice but set_pfnblock_flags_mask\n\t * expects the zone spans the pfn range. All the pages in the range\n\t * are reserved so nobody should be touching them so we should be safe\n\t */\n\tmemmap_init_zone(nr_pages, nid, zone_idx(zone), start_pfn,\n\t\t\tMEMMAP_HOTPLUG, altmap);\n\n\tset_zone_contiguous(zone);\n}"
  },
  {
    "function_name": "resize_pgdat_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "728-737",
    "snippet": "static void __meminit resize_pgdat_range(struct pglist_data *pgdat, unsigned long start_pfn,\n                                     unsigned long nr_pages)\n{\n\tunsigned long old_end_pfn = pgdat_end_pfn(pgdat);\n\n\tif (!pgdat->node_spanned_pages || start_pfn < pgdat->node_start_pfn)\n\t\tpgdat->node_start_pfn = start_pfn;\n\n\tpgdat->node_spanned_pages = max(start_pfn + nr_pages, old_end_pfn) - pgdat->node_start_pfn;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start_pfn + nr_pages",
            "old_end_pfn"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_end_pfn",
          "args": [
            "pgdat"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __meminit resize_pgdat_range(struct pglist_data *pgdat, unsigned long start_pfn,\n                                     unsigned long nr_pages)\n{\n\tunsigned long old_end_pfn = pgdat_end_pfn(pgdat);\n\n\tif (!pgdat->node_spanned_pages || start_pfn < pgdat->node_start_pfn)\n\t\tpgdat->node_start_pfn = start_pfn;\n\n\tpgdat->node_spanned_pages = max(start_pfn + nr_pages, old_end_pfn) - pgdat->node_start_pfn;\n}"
  },
  {
    "function_name": "resize_zone_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "717-726",
    "snippet": "static void __meminit resize_zone_range(struct zone *zone, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tunsigned long old_end_pfn = zone_end_pfn(zone);\n\n\tif (zone_is_empty(zone) || start_pfn < zone->zone_start_pfn)\n\t\tzone->zone_start_pfn = start_pfn;\n\n\tzone->spanned_pages = max(start_pfn + nr_pages, old_end_pfn) - zone->zone_start_pfn;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start_pfn + nr_pages",
            "old_end_pfn"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_is_empty",
          "args": [
            "zone"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __meminit resize_zone_range(struct zone *zone, unsigned long start_pfn,\n\t\tunsigned long nr_pages)\n{\n\tunsigned long old_end_pfn = zone_end_pfn(zone);\n\n\tif (zone_is_empty(zone) || start_pfn < zone->zone_start_pfn)\n\t\tzone->zone_start_pfn = start_pfn;\n\n\tzone->spanned_pages = max(start_pfn + nr_pages, old_end_pfn) - zone->zone_start_pfn;\n}"
  },
  {
    "function_name": "node_states_set_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "705-715",
    "snippet": "static void node_states_set_node(int node, struct memory_notify *arg)\n{\n\tif (arg->status_change_nid_normal >= 0)\n\t\tnode_set_state(node, N_NORMAL_MEMORY);\n\n\tif (arg->status_change_nid_high >= 0)\n\t\tnode_set_state(node, N_HIGH_MEMORY);\n\n\tif (arg->status_change_nid >= 0)\n\t\tnode_set_state(node, N_MEMORY);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_set_state",
          "args": [
            "node",
            "N_MEMORY"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set_state",
          "args": [
            "node",
            "N_HIGH_MEMORY"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set_state",
          "args": [
            "node",
            "N_NORMAL_MEMORY"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void node_states_set_node(int node, struct memory_notify *arg)\n{\n\tif (arg->status_change_nid_normal >= 0)\n\t\tnode_set_state(node, N_NORMAL_MEMORY);\n\n\tif (arg->status_change_nid_high >= 0)\n\t\tnode_set_state(node, N_HIGH_MEMORY);\n\n\tif (arg->status_change_nid >= 0)\n\t\tnode_set_state(node, N_MEMORY);\n}"
  },
  {
    "function_name": "node_states_check_changes_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "686-703",
    "snippet": "static void node_states_check_changes_online(unsigned long nr_pages,\n\tstruct zone *zone, struct memory_notify *arg)\n{\n\tint nid = zone_to_nid(zone);\n\n\targ->status_change_nid = -1;\n\targ->status_change_nid_normal = -1;\n\targ->status_change_nid_high = -1;\n\n\tif (!node_state(nid, N_MEMORY))\n\t\targ->status_change_nid = nid;\n\tif (zone_idx(zone) <= ZONE_NORMAL && !node_state(nid, N_NORMAL_MEMORY))\n\t\targ->status_change_nid_normal = nid;\n#ifdef CONFIG_HIGHMEM\n\tif (zone_idx(zone) <= N_HIGH_MEMORY && !node_state(nid, N_HIGH_MEMORY))\n\t\targ->status_change_nid_high = nid;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_state",
          "args": [
            "nid",
            "N_HIGH_MEMORY"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "node_states_clear_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "1534-1544",
          "snippet": "static void node_states_clear_node(int node, struct memory_notify *arg)\n{\n\tif (arg->status_change_nid_normal >= 0)\n\t\tnode_clear_state(node, N_NORMAL_MEMORY);\n\n\tif (arg->status_change_nid_high >= 0)\n\t\tnode_clear_state(node, N_HIGH_MEMORY);\n\n\tif (arg->status_change_nid >= 0)\n\t\tnode_clear_state(node, N_MEMORY);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void node_states_clear_node(int node, struct memory_notify *arg)\n{\n\tif (arg->status_change_nid_normal >= 0)\n\t\tnode_clear_state(node, N_NORMAL_MEMORY);\n\n\tif (arg->status_change_nid_high >= 0)\n\t\tnode_clear_state(node, N_HIGH_MEMORY);\n\n\tif (arg->status_change_nid >= 0)\n\t\tnode_clear_state(node, N_MEMORY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void node_states_check_changes_online(unsigned long nr_pages,\n\tstruct zone *zone, struct memory_notify *arg)\n{\n\tint nid = zone_to_nid(zone);\n\n\targ->status_change_nid = -1;\n\targ->status_change_nid_normal = -1;\n\targ->status_change_nid_high = -1;\n\n\tif (!node_state(nid, N_MEMORY))\n\t\targ->status_change_nid = nid;\n\tif (zone_idx(zone) <= ZONE_NORMAL && !node_state(nid, N_NORMAL_MEMORY))\n\t\targ->status_change_nid_normal = nid;\n#ifdef CONFIG_HIGHMEM\n\tif (zone_idx(zone) <= N_HIGH_MEMORY && !node_state(nid, N_HIGH_MEMORY))\n\t\targ->status_change_nid_high = nid;\n#endif\n}"
  },
  {
    "function_name": "online_pages_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "665-683",
    "snippet": "static int online_pages_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\tvoid *arg)\n{\n\tunsigned long i;\n\tunsigned long onlined_pages = *(unsigned long *)arg;\n\tstruct page *page;\n\n\tif (PageReserved(pfn_to_page(start_pfn)))\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tpage = pfn_to_page(start_pfn + i);\n\t\t\t(*online_page_callback)(page);\n\t\t\tonlined_pages++;\n\t\t}\n\n\tonline_mem_sections(start_pfn, start_pfn + nr_pages);\n\n\t*(unsigned long *)arg = onlined_pages;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);",
      "static online_page_callback_t online_page_callback = generic_online_page;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "online_mem_sections",
          "args": [
            "start_pfn",
            "start_pfn + nr_pages"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "online_mem_sections",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "525-540",
          "snippet": "void online_mem_sections(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\t/* onlining code should never touch invalid ranges */\n\t\tif (WARN_ON(!valid_section_nr(section_nr)))\n\t\t\tcontinue;\n\n\t\tms = __nr_to_section(section_nr);\n\t\tms->section_mem_map |= SECTION_IS_ONLINE;\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid online_mem_sections(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\t/* onlining code should never touch invalid ranges */\n\t\tif (WARN_ON(!valid_section_nr(section_nr)))\n\t\t\tcontinue;\n\n\t\tms = __nr_to_section(section_nr);\n\t\tms->section_mem_map |= SECTION_IS_ONLINE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "page"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "start_pfn + i"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "pfn_to_page(start_pfn)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "start_pfn"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\nstatic online_page_callback_t online_page_callback = generic_online_page;\n\nstatic int online_pages_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\tvoid *arg)\n{\n\tunsigned long i;\n\tunsigned long onlined_pages = *(unsigned long *)arg;\n\tstruct page *page;\n\n\tif (PageReserved(pfn_to_page(start_pfn)))\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tpage = pfn_to_page(start_pfn + i);\n\t\t\t(*online_page_callback)(page);\n\t\t\tonlined_pages++;\n\t\t}\n\n\tonline_mem_sections(start_pfn, start_pfn + nr_pages);\n\n\t*(unsigned long *)arg = onlined_pages;\n\treturn 0;\n}"
  },
  {
    "function_name": "generic_online_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "658-663",
    "snippet": "static void generic_online_page(struct page *page)\n{\n\t__online_page_set_limits(page);\n\t__online_page_increment_counters(page);\n\t__online_page_free(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__online_page_free",
          "args": [
            "page"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "__online_page_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "652-655",
          "snippet": "void __online_page_free(struct page *page)\n{\n\t__free_reserved_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid __online_page_free(struct page *page)\n{\n\t__free_reserved_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__online_page_increment_counters",
          "args": [
            "page"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "__online_page_increment_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "646-649",
          "snippet": "void __online_page_increment_counters(struct page *page)\n{\n\tadjust_managed_page_count(page, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid __online_page_increment_counters(struct page *page)\n{\n\tadjust_managed_page_count(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__online_page_set_limits",
          "args": [
            "page"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "__online_page_set_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "641-643",
          "snippet": "void __online_page_set_limits(struct page *page)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid __online_page_set_limits(struct page *page)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic void generic_online_page(struct page *page)\n{\n\t__online_page_set_limits(page);\n\t__online_page_increment_counters(page);\n\t__online_page_free(page);\n}"
  },
  {
    "function_name": "__online_page_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "652-655",
    "snippet": "void __online_page_free(struct page *page)\n{\n\t__free_reserved_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_reserved_page",
          "args": [
            "page"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid __online_page_free(struct page *page)\n{\n\t__free_reserved_page(page);\n}"
  },
  {
    "function_name": "__online_page_increment_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "646-649",
    "snippet": "void __online_page_increment_counters(struct page *page)\n{\n\tadjust_managed_page_count(page, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adjust_managed_page_count",
          "args": [
            "page",
            "1"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid __online_page_increment_counters(struct page *page)\n{\n\tadjust_managed_page_count(page, 1);\n}"
  },
  {
    "function_name": "__online_page_set_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "641-643",
    "snippet": "void __online_page_set_limits(struct page *page)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid __online_page_set_limits(struct page *page)\n{\n}"
  },
  {
    "function_name": "restore_online_page_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "622-638",
    "snippet": "int restore_online_page_callback(online_page_callback_t callback)\n{\n\tint rc = -EINVAL;\n\n\tget_online_mems();\n\tmutex_lock(&online_page_callback_lock);\n\n\tif (online_page_callback == callback) {\n\t\tonline_page_callback = generic_online_page;\n\t\trc = 0;\n\t}\n\n\tmutex_unlock(&online_page_callback_lock);\n\tput_online_mems();\n\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static online_page_callback_t online_page_callback = generic_online_page;",
      "static DEFINE_MUTEX(online_page_callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&online_page_callback_lock"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&online_page_callback_lock"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic online_page_callback_t online_page_callback = generic_online_page;\nstatic DEFINE_MUTEX(online_page_callback_lock);\n\nint restore_online_page_callback(online_page_callback_t callback)\n{\n\tint rc = -EINVAL;\n\n\tget_online_mems();\n\tmutex_lock(&online_page_callback_lock);\n\n\tif (online_page_callback == callback) {\n\t\tonline_page_callback = generic_online_page;\n\t\trc = 0;\n\t}\n\n\tmutex_unlock(&online_page_callback_lock);\n\tput_online_mems();\n\n\treturn rc;\n}"
  },
  {
    "function_name": "set_online_page_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "603-619",
    "snippet": "int set_online_page_callback(online_page_callback_t callback)\n{\n\tint rc = -EINVAL;\n\n\tget_online_mems();\n\tmutex_lock(&online_page_callback_lock);\n\n\tif (online_page_callback == generic_online_page) {\n\t\tonline_page_callback = callback;\n\t\trc = 0;\n\t}\n\n\tmutex_unlock(&online_page_callback_lock);\n\tput_online_mems();\n\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static online_page_callback_t online_page_callback = generic_online_page;",
      "static DEFINE_MUTEX(online_page_callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&online_page_callback_lock"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&online_page_callback_lock"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic online_page_callback_t online_page_callback = generic_online_page;\nstatic DEFINE_MUTEX(online_page_callback_lock);\n\nint set_online_page_callback(online_page_callback_t callback)\n{\n\tint rc = -EINVAL;\n\n\tget_online_mems();\n\tmutex_lock(&online_page_callback_lock);\n\n\tif (online_page_callback == generic_online_page) {\n\t\tonline_page_callback = callback;\n\t\trc = 0;\n\t}\n\n\tmutex_unlock(&online_page_callback_lock);\n\tput_online_mems();\n\n\treturn rc;\n}"
  },
  {
    "function_name": "__remove_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "550-600",
    "snippet": "int __remove_pages(struct zone *zone, unsigned long phys_start_pfn,\n\t\t unsigned long nr_pages, struct vmem_altmap *altmap)\n{\n\tunsigned long i;\n\tunsigned long map_offset = 0;\n\tint sections_to_remove, ret = 0;\n\n\t/* In the ZONE_DEVICE case device driver owns the memory region */\n\tif (is_dev_zone(zone)) {\n\t\tif (altmap)\n\t\t\tmap_offset = vmem_altmap_offset(altmap);\n\t} else {\n\t\tresource_size_t start, size;\n\n\t\tstart = phys_start_pfn << PAGE_SHIFT;\n\t\tsize = nr_pages * PAGE_SIZE;\n\n\t\tret = release_mem_region_adjustable(&iomem_resource, start,\n\t\t\t\t\tsize);\n\t\tif (ret) {\n\t\t\tresource_size_t endres = start + size - 1;\n\n\t\t\tpr_warn(\"Unable to release resource <%pa-%pa> (%d)\\n\",\n\t\t\t\t\t&start, &endres, ret);\n\t\t}\n\t}\n\n\tclear_zone_contiguous(zone);\n\n\t/*\n\t * We can only remove entire sections\n\t */\n\tBUG_ON(phys_start_pfn & ~PAGE_SECTION_MASK);\n\tBUG_ON(nr_pages % PAGES_PER_SECTION);\n\n\tsections_to_remove = nr_pages / PAGES_PER_SECTION;\n\tfor (i = 0; i < sections_to_remove; i++) {\n\t\tunsigned long pfn = phys_start_pfn + i*PAGES_PER_SECTION;\n\n\t\tcond_resched();\n\t\tret = __remove_section(zone, __pfn_to_section(pfn), map_offset,\n\t\t\t\taltmap);\n\t\tmap_offset = 0;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tset_zone_contiguous(zone);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_zone_contiguous",
          "args": [
            "zone"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "set_zone_contiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1394-1413",
          "snippet": "void set_zone_contiguous(struct zone *zone)\n{\n\tunsigned long block_start_pfn = zone->zone_start_pfn;\n\tunsigned long block_end_pfn;\n\n\tblock_end_pfn = ALIGN(block_start_pfn + 1, pageblock_nr_pages);\n\tfor (; block_start_pfn < zone_end_pfn(zone);\n\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t block_end_pfn += pageblock_nr_pages) {\n\n\t\tblock_end_pfn = min(block_end_pfn, zone_end_pfn(zone));\n\n\t\tif (!__pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\t     block_end_pfn, zone))\n\t\t\treturn;\n\t}\n\n\t/* We confirm that there is no hole */\n\tzone->contiguous = true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_zone_contiguous(struct zone *zone)\n{\n\tunsigned long block_start_pfn = zone->zone_start_pfn;\n\tunsigned long block_end_pfn;\n\n\tblock_end_pfn = ALIGN(block_start_pfn + 1, pageblock_nr_pages);\n\tfor (; block_start_pfn < zone_end_pfn(zone);\n\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t block_end_pfn += pageblock_nr_pages) {\n\n\t\tblock_end_pfn = min(block_end_pfn, zone_end_pfn(zone));\n\n\t\tif (!__pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\t     block_end_pfn, zone))\n\t\t\treturn;\n\t}\n\n\t/* We confirm that there is no hole */\n\tzone->contiguous = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_section",
          "args": [
            "zone",
            "__pfn_to_section(pfn)",
            "map_offset",
            "altmap"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "516-536",
          "snippet": "static int __remove_section(struct zone *zone, struct mem_section *ms,\n\t\tunsigned long map_offset, struct vmem_altmap *altmap)\n{\n\tunsigned long start_pfn;\n\tint scn_nr;\n\tint ret = -EINVAL;\n\n\tif (!valid_section(ms))\n\t\treturn ret;\n\n\tret = unregister_memory_section(ms);\n\tif (ret)\n\t\treturn ret;\n\n\tscn_nr = __section_nr(ms);\n\tstart_pfn = section_nr_to_pfn((unsigned long)scn_nr);\n\t__remove_zone(zone, start_pfn);\n\n\tsparse_remove_one_section(zone, ms, map_offset, altmap);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __remove_section(struct zone *zone, struct mem_section *ms,\n\t\tunsigned long map_offset, struct vmem_altmap *altmap)\n{\n\tunsigned long start_pfn;\n\tint scn_nr;\n\tint ret = -EINVAL;\n\n\tif (!valid_section(ms))\n\t\treturn ret;\n\n\tret = unregister_memory_section(ms);\n\tif (ret)\n\t\treturn ret;\n\n\tscn_nr = __section_nr(ms);\n\tstart_pfn = section_nr_to_pfn((unsigned long)scn_nr);\n\t__remove_zone(zone, start_pfn);\n\n\tsparse_remove_one_section(zone, ms, map_offset, altmap);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "pfn"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr_pages % PAGES_PER_SECTION"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "phys_start_pfn & ~PAGE_SECTION_MASK"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_zone_contiguous",
          "args": [
            "zone"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "clear_zone_contiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1415-1418",
          "snippet": "void clear_zone_contiguous(struct zone *zone)\n{\n\tzone->contiguous = false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid clear_zone_contiguous(struct zone *zone)\n{\n\tzone->contiguous = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unable to release resource <%pa-%pa> (%d)\\n\"",
            "&start",
            "&endres",
            "ret"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_mem_region_adjustable",
          "args": [
            "&iomem_resource",
            "start",
            "size"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmem_altmap_offset",
          "args": [
            "altmap"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dev_zone",
          "args": [
            "zone"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __remove_pages(struct zone *zone, unsigned long phys_start_pfn,\n\t\t unsigned long nr_pages, struct vmem_altmap *altmap)\n{\n\tunsigned long i;\n\tunsigned long map_offset = 0;\n\tint sections_to_remove, ret = 0;\n\n\t/* In the ZONE_DEVICE case device driver owns the memory region */\n\tif (is_dev_zone(zone)) {\n\t\tif (altmap)\n\t\t\tmap_offset = vmem_altmap_offset(altmap);\n\t} else {\n\t\tresource_size_t start, size;\n\n\t\tstart = phys_start_pfn << PAGE_SHIFT;\n\t\tsize = nr_pages * PAGE_SIZE;\n\n\t\tret = release_mem_region_adjustable(&iomem_resource, start,\n\t\t\t\t\tsize);\n\t\tif (ret) {\n\t\t\tresource_size_t endres = start + size - 1;\n\n\t\t\tpr_warn(\"Unable to release resource <%pa-%pa> (%d)\\n\",\n\t\t\t\t\t&start, &endres, ret);\n\t\t}\n\t}\n\n\tclear_zone_contiguous(zone);\n\n\t/*\n\t * We can only remove entire sections\n\t */\n\tBUG_ON(phys_start_pfn & ~PAGE_SECTION_MASK);\n\tBUG_ON(nr_pages % PAGES_PER_SECTION);\n\n\tsections_to_remove = nr_pages / PAGES_PER_SECTION;\n\tfor (i = 0; i < sections_to_remove; i++) {\n\t\tunsigned long pfn = phys_start_pfn + i*PAGES_PER_SECTION;\n\n\t\tcond_resched();\n\t\tret = __remove_section(zone, __pfn_to_section(pfn), map_offset,\n\t\t\t\taltmap);\n\t\tmap_offset = 0;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tset_zone_contiguous(zone);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__remove_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "516-536",
    "snippet": "static int __remove_section(struct zone *zone, struct mem_section *ms,\n\t\tunsigned long map_offset, struct vmem_altmap *altmap)\n{\n\tunsigned long start_pfn;\n\tint scn_nr;\n\tint ret = -EINVAL;\n\n\tif (!valid_section(ms))\n\t\treturn ret;\n\n\tret = unregister_memory_section(ms);\n\tif (ret)\n\t\treturn ret;\n\n\tscn_nr = __section_nr(ms);\n\tstart_pfn = section_nr_to_pfn((unsigned long)scn_nr);\n\t__remove_zone(zone, start_pfn);\n\n\tsparse_remove_one_section(zone, ms, map_offset, altmap);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sparse_remove_one_section",
          "args": [
            "zone",
            "ms",
            "map_offset",
            "altmap"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_remove_one_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "768-788",
          "snippet": "void sparse_remove_one_section(struct zone *zone, struct mem_section *ms,\n\t\tunsigned long map_offset, struct vmem_altmap *altmap)\n{\n\tstruct page *memmap = NULL;\n\tunsigned long *usemap = NULL, flags;\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\n\tpgdat_resize_lock(pgdat, &flags);\n\tif (ms->section_mem_map) {\n\t\tusemap = ms->pageblock_flags;\n\t\tmemmap = sparse_decode_mem_map(ms->section_mem_map,\n\t\t\t\t\t\t__section_nr(ms));\n\t\tms->section_mem_map = 0;\n\t\tms->pageblock_flags = NULL;\n\t}\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\tclear_hwpoisoned_pages(memmap + map_offset,\n\t\t\tPAGES_PER_SECTION - map_offset);\n\tfree_section_usemap(memmap, usemap, altmap);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid sparse_remove_one_section(struct zone *zone, struct mem_section *ms,\n\t\tunsigned long map_offset, struct vmem_altmap *altmap)\n{\n\tstruct page *memmap = NULL;\n\tunsigned long *usemap = NULL, flags;\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\n\tpgdat_resize_lock(pgdat, &flags);\n\tif (ms->section_mem_map) {\n\t\tusemap = ms->pageblock_flags;\n\t\tmemmap = sparse_decode_mem_map(ms->section_mem_map,\n\t\t\t\t\t\t__section_nr(ms));\n\t\tms->section_mem_map = 0;\n\t\tms->pageblock_flags = NULL;\n\t}\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\tclear_hwpoisoned_pages(memmap + map_offset,\n\t\t\tPAGES_PER_SECTION - map_offset);\n\tfree_section_usemap(memmap, usemap, altmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_zone",
          "args": [
            "zone",
            "start_pfn"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "504-514",
          "snippet": "static void __remove_zone(struct zone *zone, unsigned long start_pfn)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nr_pages = PAGES_PER_SECTION;\n\tunsigned long flags;\n\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tshrink_zone_span(zone, start_pfn, start_pfn + nr_pages);\n\tshrink_pgdat_span(pgdat, start_pfn, start_pfn + nr_pages);\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __remove_zone(struct zone *zone, unsigned long start_pfn)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nr_pages = PAGES_PER_SECTION;\n\tunsigned long flags;\n\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tshrink_zone_span(zone, start_pfn, start_pfn + nr_pages);\n\tshrink_pgdat_span(pgdat, start_pfn, start_pfn + nr_pages);\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "section_nr_to_pfn",
          "args": [
            "(unsigned long)scn_nr"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__section_nr",
          "args": [
            "ms"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "__section_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "120-123",
          "snippet": "int __section_nr(struct mem_section* ms)\n{\n\treturn (int)(ms - mem_section[0]);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __section_nr(struct mem_section* ms)\n{\n\treturn (int)(ms - mem_section[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_memory_section",
          "args": [
            "ms"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_section",
          "args": [
            "ms"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __remove_section(struct zone *zone, struct mem_section *ms,\n\t\tunsigned long map_offset, struct vmem_altmap *altmap)\n{\n\tunsigned long start_pfn;\n\tint scn_nr;\n\tint ret = -EINVAL;\n\n\tif (!valid_section(ms))\n\t\treturn ret;\n\n\tret = unregister_memory_section(ms);\n\tif (ret)\n\t\treturn ret;\n\n\tscn_nr = __section_nr(ms);\n\tstart_pfn = section_nr_to_pfn((unsigned long)scn_nr);\n\t__remove_zone(zone, start_pfn);\n\n\tsparse_remove_one_section(zone, ms, map_offset, altmap);\n\treturn 0;\n}"
  },
  {
    "function_name": "__remove_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "504-514",
    "snippet": "static void __remove_zone(struct zone *zone, unsigned long start_pfn)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nr_pages = PAGES_PER_SECTION;\n\tunsigned long flags;\n\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tshrink_zone_span(zone, start_pfn, start_pfn + nr_pages);\n\tshrink_pgdat_span(pgdat, start_pfn, start_pfn + nr_pages);\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "zone->zone_pgdat",
            "&flags"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_pgdat_span",
          "args": [
            "pgdat",
            "start_pfn",
            "start_pfn + nr_pages"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_pgdat_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "438-502",
          "snippet": "static void shrink_pgdat_span(struct pglist_data *pgdat,\n\t\t\t      unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pgdat_start_pfn = pgdat->node_start_pfn;\n\tunsigned long p = pgdat_end_pfn(pgdat); /* pgdat_end_pfn namespace clash */\n\tunsigned long pgdat_end_pfn = p;\n\tunsigned long pfn;\n\tstruct mem_section *ms;\n\tint nid = pgdat->node_id;\n\n\tif (pgdat_start_pfn == start_pfn) {\n\t\t/*\n\t\t * If the section is smallest section in the pgdat, it need\n\t\t * shrink pgdat->node_start_pfn and pgdat->node_spanned_pages.\n\t\t * In this case, we find second smallest valid mem_section\n\t\t * for shrinking zone.\n\t\t */\n\t\tpfn = find_smallest_section_pfn(nid, NULL, end_pfn,\n\t\t\t\t\t\tpgdat_end_pfn);\n\t\tif (pfn) {\n\t\t\tpgdat->node_start_pfn = pfn;\n\t\t\tpgdat->node_spanned_pages = pgdat_end_pfn - pfn;\n\t\t}\n\t} else if (pgdat_end_pfn == end_pfn) {\n\t\t/*\n\t\t * If the section is biggest section in the pgdat, it need\n\t\t * shrink pgdat->node_spanned_pages.\n\t\t * In this case, we find second biggest valid mem_section for\n\t\t * shrinking zone.\n\t\t */\n\t\tpfn = find_biggest_section_pfn(nid, NULL, pgdat_start_pfn,\n\t\t\t\t\t       start_pfn);\n\t\tif (pfn)\n\t\t\tpgdat->node_spanned_pages = pfn - pgdat_start_pfn + 1;\n\t}\n\n\t/*\n\t * If the section is not biggest or smallest mem_section in the pgdat,\n\t * it only creates a hole in the pgdat. So in this case, we need not\n\t * change the pgdat.\n\t * But perhaps, the pgdat has only hole data. Thus it check the pgdat\n\t * has only hole or not.\n\t */\n\tpfn = pgdat_start_pfn;\n\tfor (; pfn < pgdat_end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (pfn_to_nid(pfn) != nid)\n\t\t\tcontinue;\n\n\t\t /* If the section is current section, it continues the loop */\n\t\tif (start_pfn == pfn)\n\t\t\tcontinue;\n\n\t\t/* If we find valid section, we have nothing to do */\n\t\treturn;\n\t}\n\n\t/* The pgdat has no valid section */\n\tpgdat->node_start_pfn = 0;\n\tpgdat->node_spanned_pages = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void shrink_pgdat_span(struct pglist_data *pgdat,\n\t\t\t      unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pgdat_start_pfn = pgdat->node_start_pfn;\n\tunsigned long p = pgdat_end_pfn(pgdat); /* pgdat_end_pfn namespace clash */\n\tunsigned long pgdat_end_pfn = p;\n\tunsigned long pfn;\n\tstruct mem_section *ms;\n\tint nid = pgdat->node_id;\n\n\tif (pgdat_start_pfn == start_pfn) {\n\t\t/*\n\t\t * If the section is smallest section in the pgdat, it need\n\t\t * shrink pgdat->node_start_pfn and pgdat->node_spanned_pages.\n\t\t * In this case, we find second smallest valid mem_section\n\t\t * for shrinking zone.\n\t\t */\n\t\tpfn = find_smallest_section_pfn(nid, NULL, end_pfn,\n\t\t\t\t\t\tpgdat_end_pfn);\n\t\tif (pfn) {\n\t\t\tpgdat->node_start_pfn = pfn;\n\t\t\tpgdat->node_spanned_pages = pgdat_end_pfn - pfn;\n\t\t}\n\t} else if (pgdat_end_pfn == end_pfn) {\n\t\t/*\n\t\t * If the section is biggest section in the pgdat, it need\n\t\t * shrink pgdat->node_spanned_pages.\n\t\t * In this case, we find second biggest valid mem_section for\n\t\t * shrinking zone.\n\t\t */\n\t\tpfn = find_biggest_section_pfn(nid, NULL, pgdat_start_pfn,\n\t\t\t\t\t       start_pfn);\n\t\tif (pfn)\n\t\t\tpgdat->node_spanned_pages = pfn - pgdat_start_pfn + 1;\n\t}\n\n\t/*\n\t * If the section is not biggest or smallest mem_section in the pgdat,\n\t * it only creates a hole in the pgdat. So in this case, we need not\n\t * change the pgdat.\n\t * But perhaps, the pgdat has only hole data. Thus it check the pgdat\n\t * has only hole or not.\n\t */\n\tpfn = pgdat_start_pfn;\n\tfor (; pfn < pgdat_end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (pfn_to_nid(pfn) != nid)\n\t\t\tcontinue;\n\n\t\t /* If the section is current section, it continues the loop */\n\t\tif (start_pfn == pfn)\n\t\t\tcontinue;\n\n\t\t/* If we find valid section, we have nothing to do */\n\t\treturn;\n\t}\n\n\t/* The pgdat has no valid section */\n\tpgdat->node_start_pfn = 0;\n\tpgdat->node_spanned_pages = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_zone_span",
          "args": [
            "zone",
            "start_pfn",
            "start_pfn + nr_pages"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_zone_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "370-436",
          "snippet": "static void shrink_zone_span(struct zone *zone, unsigned long start_pfn,\n\t\t\t     unsigned long end_pfn)\n{\n\tunsigned long zone_start_pfn = zone->zone_start_pfn;\n\tunsigned long z = zone_end_pfn(zone); /* zone_end_pfn namespace clash */\n\tunsigned long zone_end_pfn = z;\n\tunsigned long pfn;\n\tstruct mem_section *ms;\n\tint nid = zone_to_nid(zone);\n\n\tzone_span_writelock(zone);\n\tif (zone_start_pfn == start_pfn) {\n\t\t/*\n\t\t * If the section is smallest section in the zone, it need\n\t\t * shrink zone->zone_start_pfn and zone->zone_spanned_pages.\n\t\t * In this case, we find second smallest valid mem_section\n\t\t * for shrinking zone.\n\t\t */\n\t\tpfn = find_smallest_section_pfn(nid, zone, end_pfn,\n\t\t\t\t\t\tzone_end_pfn);\n\t\tif (pfn) {\n\t\t\tzone->zone_start_pfn = pfn;\n\t\t\tzone->spanned_pages = zone_end_pfn - pfn;\n\t\t}\n\t} else if (zone_end_pfn == end_pfn) {\n\t\t/*\n\t\t * If the section is biggest section in the zone, it need\n\t\t * shrink zone->spanned_pages.\n\t\t * In this case, we find second biggest valid mem_section for\n\t\t * shrinking zone.\n\t\t */\n\t\tpfn = find_biggest_section_pfn(nid, zone, zone_start_pfn,\n\t\t\t\t\t       start_pfn);\n\t\tif (pfn)\n\t\t\tzone->spanned_pages = pfn - zone_start_pfn + 1;\n\t}\n\n\t/*\n\t * The section is not biggest or smallest mem_section in the zone, it\n\t * only creates a hole in the zone. So in this case, we need not\n\t * change the zone. But perhaps, the zone has only hole data. Thus\n\t * it check the zone has only hole or not.\n\t */\n\tpfn = zone_start_pfn;\n\tfor (; pfn < zone_end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (page_zone(pfn_to_page(pfn)) != zone)\n\t\t\tcontinue;\n\n\t\t /* If the section is current section, it continues the loop */\n\t\tif (start_pfn == pfn)\n\t\t\tcontinue;\n\n\t\t/* If we find valid section, we have nothing to do */\n\t\tzone_span_writeunlock(zone);\n\t\treturn;\n\t}\n\n\t/* The zone has no valid section */\n\tzone->zone_start_pfn = 0;\n\tzone->spanned_pages = 0;\n\tzone_span_writeunlock(zone);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void shrink_zone_span(struct zone *zone, unsigned long start_pfn,\n\t\t\t     unsigned long end_pfn)\n{\n\tunsigned long zone_start_pfn = zone->zone_start_pfn;\n\tunsigned long z = zone_end_pfn(zone); /* zone_end_pfn namespace clash */\n\tunsigned long zone_end_pfn = z;\n\tunsigned long pfn;\n\tstruct mem_section *ms;\n\tint nid = zone_to_nid(zone);\n\n\tzone_span_writelock(zone);\n\tif (zone_start_pfn == start_pfn) {\n\t\t/*\n\t\t * If the section is smallest section in the zone, it need\n\t\t * shrink zone->zone_start_pfn and zone->zone_spanned_pages.\n\t\t * In this case, we find second smallest valid mem_section\n\t\t * for shrinking zone.\n\t\t */\n\t\tpfn = find_smallest_section_pfn(nid, zone, end_pfn,\n\t\t\t\t\t\tzone_end_pfn);\n\t\tif (pfn) {\n\t\t\tzone->zone_start_pfn = pfn;\n\t\t\tzone->spanned_pages = zone_end_pfn - pfn;\n\t\t}\n\t} else if (zone_end_pfn == end_pfn) {\n\t\t/*\n\t\t * If the section is biggest section in the zone, it need\n\t\t * shrink zone->spanned_pages.\n\t\t * In this case, we find second biggest valid mem_section for\n\t\t * shrinking zone.\n\t\t */\n\t\tpfn = find_biggest_section_pfn(nid, zone, zone_start_pfn,\n\t\t\t\t\t       start_pfn);\n\t\tif (pfn)\n\t\t\tzone->spanned_pages = pfn - zone_start_pfn + 1;\n\t}\n\n\t/*\n\t * The section is not biggest or smallest mem_section in the zone, it\n\t * only creates a hole in the zone. So in this case, we need not\n\t * change the zone. But perhaps, the zone has only hole data. Thus\n\t * it check the zone has only hole or not.\n\t */\n\tpfn = zone_start_pfn;\n\tfor (; pfn < zone_end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (page_zone(pfn_to_page(pfn)) != zone)\n\t\t\tcontinue;\n\n\t\t /* If the section is current section, it continues the loop */\n\t\tif (start_pfn == pfn)\n\t\t\tcontinue;\n\n\t\t/* If we find valid section, we have nothing to do */\n\t\tzone_span_writeunlock(zone);\n\t\treturn;\n\t}\n\n\t/* The zone has no valid section */\n\tzone->zone_start_pfn = 0;\n\tzone->spanned_pages = 0;\n\tzone_span_writeunlock(zone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_resize_lock",
          "args": [
            "zone->zone_pgdat",
            "&flags"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __remove_zone(struct zone *zone, unsigned long start_pfn)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nr_pages = PAGES_PER_SECTION;\n\tunsigned long flags;\n\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tshrink_zone_span(zone, start_pfn, start_pfn + nr_pages);\n\tshrink_pgdat_span(pgdat, start_pfn, start_pfn + nr_pages);\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n}"
  },
  {
    "function_name": "shrink_pgdat_span",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "438-502",
    "snippet": "static void shrink_pgdat_span(struct pglist_data *pgdat,\n\t\t\t      unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pgdat_start_pfn = pgdat->node_start_pfn;\n\tunsigned long p = pgdat_end_pfn(pgdat); /* pgdat_end_pfn namespace clash */\n\tunsigned long pgdat_end_pfn = p;\n\tunsigned long pfn;\n\tstruct mem_section *ms;\n\tint nid = pgdat->node_id;\n\n\tif (pgdat_start_pfn == start_pfn) {\n\t\t/*\n\t\t * If the section is smallest section in the pgdat, it need\n\t\t * shrink pgdat->node_start_pfn and pgdat->node_spanned_pages.\n\t\t * In this case, we find second smallest valid mem_section\n\t\t * for shrinking zone.\n\t\t */\n\t\tpfn = find_smallest_section_pfn(nid, NULL, end_pfn,\n\t\t\t\t\t\tpgdat_end_pfn);\n\t\tif (pfn) {\n\t\t\tpgdat->node_start_pfn = pfn;\n\t\t\tpgdat->node_spanned_pages = pgdat_end_pfn - pfn;\n\t\t}\n\t} else if (pgdat_end_pfn == end_pfn) {\n\t\t/*\n\t\t * If the section is biggest section in the pgdat, it need\n\t\t * shrink pgdat->node_spanned_pages.\n\t\t * In this case, we find second biggest valid mem_section for\n\t\t * shrinking zone.\n\t\t */\n\t\tpfn = find_biggest_section_pfn(nid, NULL, pgdat_start_pfn,\n\t\t\t\t\t       start_pfn);\n\t\tif (pfn)\n\t\t\tpgdat->node_spanned_pages = pfn - pgdat_start_pfn + 1;\n\t}\n\n\t/*\n\t * If the section is not biggest or smallest mem_section in the pgdat,\n\t * it only creates a hole in the pgdat. So in this case, we need not\n\t * change the pgdat.\n\t * But perhaps, the pgdat has only hole data. Thus it check the pgdat\n\t * has only hole or not.\n\t */\n\tpfn = pgdat_start_pfn;\n\tfor (; pfn < pgdat_end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (pfn_to_nid(pfn) != nid)\n\t\t\tcontinue;\n\n\t\t /* If the section is current section, it continues the loop */\n\t\tif (start_pfn == pfn)\n\t\t\tcontinue;\n\n\t\t/* If we find valid section, we have nothing to do */\n\t\treturn;\n\t}\n\n\t/* The pgdat has no valid section */\n\tpgdat->node_start_pfn = 0;\n\tpgdat->node_spanned_pages = 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_to_nid",
          "args": [
            "pfn"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1292-1304",
          "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!valid_section(ms)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_section",
          "args": [
            "ms"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "pfn"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_biggest_section_pfn",
          "args": [
            "nid",
            "NULL",
            "pgdat_start_pfn",
            "start_pfn"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "find_biggest_section_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "343-368",
          "snippet": "static unsigned long find_biggest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t    unsigned long start_pfn,\n\t\t\t\t    unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\tunsigned long pfn;\n\n\t/* pfn is the end pfn of a memory section. */\n\tpfn = end_pfn - 1;\n\tfor (; pfn >= start_pfn; pfn -= PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(pfn)))\n\t\t\tcontinue;\n\n\t\treturn pfn;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic unsigned long find_biggest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t    unsigned long start_pfn,\n\t\t\t\t    unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\tunsigned long pfn;\n\n\t/* pfn is the end pfn of a memory section. */\n\tpfn = end_pfn - 1;\n\tfor (; pfn >= start_pfn; pfn -= PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(pfn)))\n\t\t\tcontinue;\n\n\t\treturn pfn;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_smallest_section_pfn",
          "args": [
            "nid",
            "NULL",
            "end_pfn",
            "pgdat_end_pfn"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "find_smallest_section_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "318-340",
          "snippet": "static unsigned long find_smallest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t     unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\n\tfor (; start_pfn < end_pfn; start_pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(start_pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(start_pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(start_pfn)))\n\t\t\tcontinue;\n\n\t\treturn start_pfn;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic unsigned long find_smallest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t     unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\n\tfor (; start_pfn < end_pfn; start_pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(start_pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(start_pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(start_pfn)))\n\t\t\tcontinue;\n\n\t\treturn start_pfn;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_end_pfn",
          "args": [
            "pgdat"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void shrink_pgdat_span(struct pglist_data *pgdat,\n\t\t\t      unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pgdat_start_pfn = pgdat->node_start_pfn;\n\tunsigned long p = pgdat_end_pfn(pgdat); /* pgdat_end_pfn namespace clash */\n\tunsigned long pgdat_end_pfn = p;\n\tunsigned long pfn;\n\tstruct mem_section *ms;\n\tint nid = pgdat->node_id;\n\n\tif (pgdat_start_pfn == start_pfn) {\n\t\t/*\n\t\t * If the section is smallest section in the pgdat, it need\n\t\t * shrink pgdat->node_start_pfn and pgdat->node_spanned_pages.\n\t\t * In this case, we find second smallest valid mem_section\n\t\t * for shrinking zone.\n\t\t */\n\t\tpfn = find_smallest_section_pfn(nid, NULL, end_pfn,\n\t\t\t\t\t\tpgdat_end_pfn);\n\t\tif (pfn) {\n\t\t\tpgdat->node_start_pfn = pfn;\n\t\t\tpgdat->node_spanned_pages = pgdat_end_pfn - pfn;\n\t\t}\n\t} else if (pgdat_end_pfn == end_pfn) {\n\t\t/*\n\t\t * If the section is biggest section in the pgdat, it need\n\t\t * shrink pgdat->node_spanned_pages.\n\t\t * In this case, we find second biggest valid mem_section for\n\t\t * shrinking zone.\n\t\t */\n\t\tpfn = find_biggest_section_pfn(nid, NULL, pgdat_start_pfn,\n\t\t\t\t\t       start_pfn);\n\t\tif (pfn)\n\t\t\tpgdat->node_spanned_pages = pfn - pgdat_start_pfn + 1;\n\t}\n\n\t/*\n\t * If the section is not biggest or smallest mem_section in the pgdat,\n\t * it only creates a hole in the pgdat. So in this case, we need not\n\t * change the pgdat.\n\t * But perhaps, the pgdat has only hole data. Thus it check the pgdat\n\t * has only hole or not.\n\t */\n\tpfn = pgdat_start_pfn;\n\tfor (; pfn < pgdat_end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (pfn_to_nid(pfn) != nid)\n\t\t\tcontinue;\n\n\t\t /* If the section is current section, it continues the loop */\n\t\tif (start_pfn == pfn)\n\t\t\tcontinue;\n\n\t\t/* If we find valid section, we have nothing to do */\n\t\treturn;\n\t}\n\n\t/* The pgdat has no valid section */\n\tpgdat->node_start_pfn = 0;\n\tpgdat->node_spanned_pages = 0;\n}"
  },
  {
    "function_name": "shrink_zone_span",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "370-436",
    "snippet": "static void shrink_zone_span(struct zone *zone, unsigned long start_pfn,\n\t\t\t     unsigned long end_pfn)\n{\n\tunsigned long zone_start_pfn = zone->zone_start_pfn;\n\tunsigned long z = zone_end_pfn(zone); /* zone_end_pfn namespace clash */\n\tunsigned long zone_end_pfn = z;\n\tunsigned long pfn;\n\tstruct mem_section *ms;\n\tint nid = zone_to_nid(zone);\n\n\tzone_span_writelock(zone);\n\tif (zone_start_pfn == start_pfn) {\n\t\t/*\n\t\t * If the section is smallest section in the zone, it need\n\t\t * shrink zone->zone_start_pfn and zone->zone_spanned_pages.\n\t\t * In this case, we find second smallest valid mem_section\n\t\t * for shrinking zone.\n\t\t */\n\t\tpfn = find_smallest_section_pfn(nid, zone, end_pfn,\n\t\t\t\t\t\tzone_end_pfn);\n\t\tif (pfn) {\n\t\t\tzone->zone_start_pfn = pfn;\n\t\t\tzone->spanned_pages = zone_end_pfn - pfn;\n\t\t}\n\t} else if (zone_end_pfn == end_pfn) {\n\t\t/*\n\t\t * If the section is biggest section in the zone, it need\n\t\t * shrink zone->spanned_pages.\n\t\t * In this case, we find second biggest valid mem_section for\n\t\t * shrinking zone.\n\t\t */\n\t\tpfn = find_biggest_section_pfn(nid, zone, zone_start_pfn,\n\t\t\t\t\t       start_pfn);\n\t\tif (pfn)\n\t\t\tzone->spanned_pages = pfn - zone_start_pfn + 1;\n\t}\n\n\t/*\n\t * The section is not biggest or smallest mem_section in the zone, it\n\t * only creates a hole in the zone. So in this case, we need not\n\t * change the zone. But perhaps, the zone has only hole data. Thus\n\t * it check the zone has only hole or not.\n\t */\n\tpfn = zone_start_pfn;\n\tfor (; pfn < zone_end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (page_zone(pfn_to_page(pfn)) != zone)\n\t\t\tcontinue;\n\n\t\t /* If the section is current section, it continues the loop */\n\t\tif (start_pfn == pfn)\n\t\t\tcontinue;\n\n\t\t/* If we find valid section, we have nothing to do */\n\t\tzone_span_writeunlock(zone);\n\t\treturn;\n\t}\n\n\t/* The zone has no valid section */\n\tzone->zone_start_pfn = 0;\n\tzone->spanned_pages = 0;\n\tzone_span_writeunlock(zone);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_span_writeunlock",
          "args": [
            "zone"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_span_writeunlock",
          "args": [
            "zone"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!valid_section(ms)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_section",
          "args": [
            "ms"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "pfn"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_biggest_section_pfn",
          "args": [
            "nid",
            "zone",
            "zone_start_pfn",
            "start_pfn"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "find_biggest_section_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "343-368",
          "snippet": "static unsigned long find_biggest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t    unsigned long start_pfn,\n\t\t\t\t    unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\tunsigned long pfn;\n\n\t/* pfn is the end pfn of a memory section. */\n\tpfn = end_pfn - 1;\n\tfor (; pfn >= start_pfn; pfn -= PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(pfn)))\n\t\t\tcontinue;\n\n\t\treturn pfn;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic unsigned long find_biggest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t    unsigned long start_pfn,\n\t\t\t\t    unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\tunsigned long pfn;\n\n\t/* pfn is the end pfn of a memory section. */\n\tpfn = end_pfn - 1;\n\tfor (; pfn >= start_pfn; pfn -= PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(pfn)))\n\t\t\tcontinue;\n\n\t\treturn pfn;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_smallest_section_pfn",
          "args": [
            "nid",
            "zone",
            "end_pfn",
            "zone_end_pfn"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "find_smallest_section_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "318-340",
          "snippet": "static unsigned long find_smallest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t     unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\n\tfor (; start_pfn < end_pfn; start_pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(start_pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(start_pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(start_pfn)))\n\t\t\tcontinue;\n\n\t\treturn start_pfn;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic unsigned long find_smallest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t     unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\n\tfor (; start_pfn < end_pfn; start_pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(start_pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(start_pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(start_pfn)))\n\t\t\tcontinue;\n\n\t\treturn start_pfn;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_span_writelock",
          "args": [
            "zone"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void shrink_zone_span(struct zone *zone, unsigned long start_pfn,\n\t\t\t     unsigned long end_pfn)\n{\n\tunsigned long zone_start_pfn = zone->zone_start_pfn;\n\tunsigned long z = zone_end_pfn(zone); /* zone_end_pfn namespace clash */\n\tunsigned long zone_end_pfn = z;\n\tunsigned long pfn;\n\tstruct mem_section *ms;\n\tint nid = zone_to_nid(zone);\n\n\tzone_span_writelock(zone);\n\tif (zone_start_pfn == start_pfn) {\n\t\t/*\n\t\t * If the section is smallest section in the zone, it need\n\t\t * shrink zone->zone_start_pfn and zone->zone_spanned_pages.\n\t\t * In this case, we find second smallest valid mem_section\n\t\t * for shrinking zone.\n\t\t */\n\t\tpfn = find_smallest_section_pfn(nid, zone, end_pfn,\n\t\t\t\t\t\tzone_end_pfn);\n\t\tif (pfn) {\n\t\t\tzone->zone_start_pfn = pfn;\n\t\t\tzone->spanned_pages = zone_end_pfn - pfn;\n\t\t}\n\t} else if (zone_end_pfn == end_pfn) {\n\t\t/*\n\t\t * If the section is biggest section in the zone, it need\n\t\t * shrink zone->spanned_pages.\n\t\t * In this case, we find second biggest valid mem_section for\n\t\t * shrinking zone.\n\t\t */\n\t\tpfn = find_biggest_section_pfn(nid, zone, zone_start_pfn,\n\t\t\t\t\t       start_pfn);\n\t\tif (pfn)\n\t\t\tzone->spanned_pages = pfn - zone_start_pfn + 1;\n\t}\n\n\t/*\n\t * The section is not biggest or smallest mem_section in the zone, it\n\t * only creates a hole in the zone. So in this case, we need not\n\t * change the zone. But perhaps, the zone has only hole data. Thus\n\t * it check the zone has only hole or not.\n\t */\n\tpfn = zone_start_pfn;\n\tfor (; pfn < zone_end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (page_zone(pfn_to_page(pfn)) != zone)\n\t\t\tcontinue;\n\n\t\t /* If the section is current section, it continues the loop */\n\t\tif (start_pfn == pfn)\n\t\t\tcontinue;\n\n\t\t/* If we find valid section, we have nothing to do */\n\t\tzone_span_writeunlock(zone);\n\t\treturn;\n\t}\n\n\t/* The zone has no valid section */\n\tzone->zone_start_pfn = 0;\n\tzone->spanned_pages = 0;\n\tzone_span_writeunlock(zone);\n}"
  },
  {
    "function_name": "find_biggest_section_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "343-368",
    "snippet": "static unsigned long find_biggest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t    unsigned long start_pfn,\n\t\t\t\t    unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\tunsigned long pfn;\n\n\t/* pfn is the end pfn of a memory section. */\n\tpfn = end_pfn - 1;\n\tfor (; pfn >= start_pfn; pfn -= PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(pfn)))\n\t\t\tcontinue;\n\n\t\treturn pfn;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pfn_to_nid(pfn) != nid"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_nid",
          "args": [
            "pfn"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1292-1304",
          "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!valid_section(ms)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_section",
          "args": [
            "ms"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "pfn"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic unsigned long find_biggest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t    unsigned long start_pfn,\n\t\t\t\t    unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\tunsigned long pfn;\n\n\t/* pfn is the end pfn of a memory section. */\n\tpfn = end_pfn - 1;\n\tfor (; pfn >= start_pfn; pfn -= PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(pfn)))\n\t\t\tcontinue;\n\n\t\treturn pfn;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_smallest_section_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "318-340",
    "snippet": "static unsigned long find_smallest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t     unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\n\tfor (; start_pfn < end_pfn; start_pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(start_pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(start_pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(start_pfn)))\n\t\t\tcontinue;\n\n\t\treturn start_pfn;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "pfn_to_page(start_pfn)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "start_pfn"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pfn_to_nid(start_pfn) != nid"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_nid",
          "args": [
            "start_pfn"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1292-1304",
          "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!valid_section(ms)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_section",
          "args": [
            "ms"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "start_pfn"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic unsigned long find_smallest_section_pfn(int nid, struct zone *zone,\n\t\t\t\t     unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn)\n{\n\tstruct mem_section *ms;\n\n\tfor (; start_pfn < end_pfn; start_pfn += PAGES_PER_SECTION) {\n\t\tms = __pfn_to_section(start_pfn);\n\n\t\tif (unlikely(!valid_section(ms)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(pfn_to_nid(start_pfn) != nid))\n\t\t\tcontinue;\n\n\t\tif (zone && zone != page_zone(pfn_to_page(start_pfn)))\n\t\t\tcontinue;\n\n\t\treturn start_pfn;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__add_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "272-314",
    "snippet": "int __ref __add_pages(int nid, unsigned long phys_start_pfn,\n\t\tunsigned long nr_pages, struct vmem_altmap *altmap,\n\t\tbool want_memblock)\n{\n\tunsigned long i;\n\tint err = 0;\n\tint start_sec, end_sec;\n\n\t/* during initialize mem_map, align hot-added range to section */\n\tstart_sec = pfn_to_section_nr(phys_start_pfn);\n\tend_sec = pfn_to_section_nr(phys_start_pfn + nr_pages - 1);\n\n\tif (altmap) {\n\t\t/*\n\t\t * Validate altmap is within bounds of the total request\n\t\t */\n\t\tif (altmap->base_pfn != phys_start_pfn\n\t\t\t\t|| vmem_altmap_offset(altmap) > nr_pages) {\n\t\t\tpr_warn_once(\"memory add fail, invalid altmap\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\taltmap->alloc = 0;\n\t}\n\n\tfor (i = start_sec; i <= end_sec; i++) {\n\t\terr = __add_section(nid, section_nr_to_pfn(i), altmap,\n\t\t\t\twant_memblock);\n\n\t\t/*\n\t\t * EEXIST is finally dealt with by ioresource collision\n\t\t * check. see add_memory() => register_memory_resource()\n\t\t * Warning will be printed if there is collision.\n\t\t */\n\t\tif (err && (err != -EEXIST))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tcond_resched();\n\t}\n\tvmemmap_populate_print_last();\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmemmap_populate_print_last",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "vmemmap_populate_print_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "438-440",
          "snippet": "__meminit vmemmap_populate_print_last(void)\n{\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n__meminit vmemmap_populate_print_last(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_section",
          "args": [
            "nid",
            "section_nr_to_pfn(i)",
            "altmap",
            "want_memblock"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "__add_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "248-264",
          "snippet": "static int __meminit __add_section(int nid, unsigned long phys_start_pfn,\n\t\tstruct vmem_altmap *altmap, bool want_memblock)\n{\n\tint ret;\n\n\tif (pfn_valid(phys_start_pfn))\n\t\treturn -EEXIST;\n\n\tret = sparse_add_one_section(NODE_DATA(nid), phys_start_pfn, altmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!want_memblock)\n\t\treturn 0;\n\n\treturn hotplug_memory_register(nid, __pfn_to_section(phys_start_pfn));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __meminit __add_section(int nid, unsigned long phys_start_pfn,\n\t\tstruct vmem_altmap *altmap, bool want_memblock)\n{\n\tint ret;\n\n\tif (pfn_valid(phys_start_pfn))\n\t\treturn -EEXIST;\n\n\tret = sparse_add_one_section(NODE_DATA(nid), phys_start_pfn, altmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!want_memblock)\n\t\treturn 0;\n\n\treturn hotplug_memory_register(nid, __pfn_to_section(phys_start_pfn));\n}"
        }
      },
      {
        "call_info": {
          "callee": "section_nr_to_pfn",
          "args": [
            "i"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"memory add fail, invalid altmap\\n\""
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmem_altmap_offset",
          "args": [
            "altmap"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "phys_start_pfn + nr_pages - 1"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "phys_start_pfn"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __ref __add_pages(int nid, unsigned long phys_start_pfn,\n\t\tunsigned long nr_pages, struct vmem_altmap *altmap,\n\t\tbool want_memblock)\n{\n\tunsigned long i;\n\tint err = 0;\n\tint start_sec, end_sec;\n\n\t/* during initialize mem_map, align hot-added range to section */\n\tstart_sec = pfn_to_section_nr(phys_start_pfn);\n\tend_sec = pfn_to_section_nr(phys_start_pfn + nr_pages - 1);\n\n\tif (altmap) {\n\t\t/*\n\t\t * Validate altmap is within bounds of the total request\n\t\t */\n\t\tif (altmap->base_pfn != phys_start_pfn\n\t\t\t\t|| vmem_altmap_offset(altmap) > nr_pages) {\n\t\t\tpr_warn_once(\"memory add fail, invalid altmap\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\taltmap->alloc = 0;\n\t}\n\n\tfor (i = start_sec; i <= end_sec; i++) {\n\t\terr = __add_section(nid, section_nr_to_pfn(i), altmap,\n\t\t\t\twant_memblock);\n\n\t\t/*\n\t\t * EEXIST is finally dealt with by ioresource collision\n\t\t * check. see add_memory() => register_memory_resource()\n\t\t * Warning will be printed if there is collision.\n\t\t */\n\t\tif (err && (err != -EEXIST))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tcond_resched();\n\t}\n\tvmemmap_populate_print_last();\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "__add_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "248-264",
    "snippet": "static int __meminit __add_section(int nid, unsigned long phys_start_pfn,\n\t\tstruct vmem_altmap *altmap, bool want_memblock)\n{\n\tint ret;\n\n\tif (pfn_valid(phys_start_pfn))\n\t\treturn -EEXIST;\n\n\tret = sparse_add_one_section(NODE_DATA(nid), phys_start_pfn, altmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!want_memblock)\n\t\treturn 0;\n\n\treturn hotplug_memory_register(nid, __pfn_to_section(phys_start_pfn));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hotplug_memory_register",
          "args": [
            "nid",
            "__pfn_to_section(phys_start_pfn)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "phys_start_pfn"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sparse_add_one_section",
          "args": [
            "NODE_DATA(nid)",
            "phys_start_pfn",
            "altmap"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_add_one_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "665-716",
          "snippet": "int __meminit sparse_add_one_section(struct pglist_data *pgdat,\n\t\tunsigned long start_pfn, struct vmem_altmap *altmap)\n{\n\tunsigned long section_nr = pfn_to_section_nr(start_pfn);\n\tstruct mem_section *ms;\n\tstruct page *memmap;\n\tunsigned long *usemap;\n\tunsigned long flags;\n\tint ret;\n\n\t/*\n\t * no locking for this, because it does its own\n\t * plus, it does a kmalloc\n\t */\n\tret = sparse_index_init(section_nr, pgdat->node_id);\n\tif (ret < 0 && ret != -EEXIST)\n\t\treturn ret;\n\tret = 0;\n\tmemmap = kmalloc_section_memmap(section_nr, pgdat->node_id, altmap);\n\tif (!memmap)\n\t\treturn -ENOMEM;\n\tusemap = __kmalloc_section_usemap();\n\tif (!usemap) {\n\t\t__kfree_section_memmap(memmap, altmap);\n\t\treturn -ENOMEM;\n\t}\n\n\tpgdat_resize_lock(pgdat, &flags);\n\n\tms = __pfn_to_section(start_pfn);\n\tif (ms->section_mem_map & SECTION_MARKED_PRESENT) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Poison uninitialized struct pages in order to catch invalid flags\n\t * combinations.\n\t */\n\tpage_init_poison(memmap, sizeof(struct page) * PAGES_PER_SECTION);\n\n\tsection_mark_present(ms);\n\tsparse_init_one_section(ms, section_nr, memmap, usemap);\n\nout:\n\tpgdat_resize_unlock(pgdat, &flags);\n\tif (ret < 0) {\n\t\tkfree(usemap);\n\t\t__kfree_section_memmap(memmap, altmap);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __meminit sparse_add_one_section(struct pglist_data *pgdat,\n\t\tunsigned long start_pfn, struct vmem_altmap *altmap)\n{\n\tunsigned long section_nr = pfn_to_section_nr(start_pfn);\n\tstruct mem_section *ms;\n\tstruct page *memmap;\n\tunsigned long *usemap;\n\tunsigned long flags;\n\tint ret;\n\n\t/*\n\t * no locking for this, because it does its own\n\t * plus, it does a kmalloc\n\t */\n\tret = sparse_index_init(section_nr, pgdat->node_id);\n\tif (ret < 0 && ret != -EEXIST)\n\t\treturn ret;\n\tret = 0;\n\tmemmap = kmalloc_section_memmap(section_nr, pgdat->node_id, altmap);\n\tif (!memmap)\n\t\treturn -ENOMEM;\n\tusemap = __kmalloc_section_usemap();\n\tif (!usemap) {\n\t\t__kfree_section_memmap(memmap, altmap);\n\t\treturn -ENOMEM;\n\t}\n\n\tpgdat_resize_lock(pgdat, &flags);\n\n\tms = __pfn_to_section(start_pfn);\n\tif (ms->section_mem_map & SECTION_MARKED_PRESENT) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Poison uninitialized struct pages in order to catch invalid flags\n\t * combinations.\n\t */\n\tpage_init_poison(memmap, sizeof(struct page) * PAGES_PER_SECTION);\n\n\tsection_mark_present(ms);\n\tsparse_init_one_section(ms, section_nr, memmap, usemap);\n\nout:\n\tpgdat_resize_unlock(pgdat, &flags);\n\tif (ret < 0) {\n\t\tkfree(usemap);\n\t\t__kfree_section_memmap(memmap, altmap);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "phys_start_pfn"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __meminit __add_section(int nid, unsigned long phys_start_pfn,\n\t\tstruct vmem_altmap *altmap, bool want_memblock)\n{\n\tint ret;\n\n\tif (pfn_valid(phys_start_pfn))\n\t\treturn -EEXIST;\n\n\tret = sparse_add_one_section(NODE_DATA(nid), phys_start_pfn, altmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!want_memblock)\n\t\treturn 0;\n\n\treturn hotplug_memory_register(nid, __pfn_to_section(phys_start_pfn));\n}"
  },
  {
    "function_name": "register_page_bootmem_info_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "219-245",
    "snippet": "void __init register_page_bootmem_info_node(struct pglist_data *pgdat)\n{\n\tunsigned long i, pfn, end_pfn, nr_pages;\n\tint node = pgdat->node_id;\n\tstruct page *page;\n\n\tnr_pages = PAGE_ALIGN(sizeof(struct pglist_data)) >> PAGE_SHIFT;\n\tpage = virt_to_page(pgdat);\n\n\tfor (i = 0; i < nr_pages; i++, page++)\n\t\tget_page_bootmem(node, page, NODE_INFO);\n\n\tpfn = pgdat->node_start_pfn;\n\tend_pfn = pgdat_end_pfn(pgdat);\n\n\t/* register section info */\n\tfor (; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\t/*\n\t\t * Some platforms can assign the same pfn to multiple nodes - on\n\t\t * node0 as well as nodeN.  To avoid registering a pfn against\n\t\t * multiple nodes we check that this pfn does not already\n\t\t * reside in some other nodes.\n\t\t */\n\t\tif (pfn_valid(pfn) && (early_pfn_to_nid(pfn) == node))\n\t\t\tregister_page_bootmem_info_section(pfn);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_page_bootmem_info_section",
          "args": [
            "pfn"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "register_page_bootmem_info_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "196-216",
          "snippet": "static void register_page_bootmem_info_section(unsigned long start_pfn)\n{\n\tunsigned long *usemap, mapsize, section_nr, i;\n\tstruct mem_section *ms;\n\tstruct page *page, *memmap;\n\n\tsection_nr = pfn_to_section_nr(start_pfn);\n\tms = __nr_to_section(section_nr);\n\n\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\n\n\tregister_page_bootmem_memmap(section_nr, memmap, PAGES_PER_SECTION);\n\n\tusemap = ms->pageblock_flags;\n\tpage = virt_to_page(usemap);\n\n\tmapsize = PAGE_ALIGN(usemap_size()) >> PAGE_SHIFT;\n\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic void register_page_bootmem_info_section(unsigned long start_pfn)\n{\n\tunsigned long *usemap, mapsize, section_nr, i;\n\tstruct mem_section *ms;\n\tstruct page *page, *memmap;\n\n\tsection_nr = pfn_to_section_nr(start_pfn);\n\tms = __nr_to_section(section_nr);\n\n\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\n\n\tregister_page_bootmem_memmap(section_nr, memmap, PAGES_PER_SECTION);\n\n\tusemap = ms->pageblock_flags;\n\tpage = virt_to_page(usemap);\n\n\tmapsize = PAGE_ALIGN(usemap_size()) >> PAGE_SHIFT;\n\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_pfn_to_nid",
          "args": [
            "pfn"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1292-1304",
          "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_end_pfn",
          "args": [
            "pgdat"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_bootmem",
          "args": [
            "node",
            "page",
            "NODE_INFO"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "134-141",
          "snippet": "void get_page_bootmem(unsigned long info,  struct page *page,\n\t\t      unsigned long type)\n{\n\tpage->freelist = (void *)type;\n\tSetPagePrivate(page);\n\tset_page_private(page, info);\n\tpage_ref_inc(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid get_page_bootmem(unsigned long info,  struct page *page,\n\t\t      unsigned long type)\n{\n\tpage->freelist = (void *)type;\n\tSetPagePrivate(page);\n\tset_page_private(page, info);\n\tpage_ref_inc(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "pgdat"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "sizeof(struct pglist_data)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid __init register_page_bootmem_info_node(struct pglist_data *pgdat)\n{\n\tunsigned long i, pfn, end_pfn, nr_pages;\n\tint node = pgdat->node_id;\n\tstruct page *page;\n\n\tnr_pages = PAGE_ALIGN(sizeof(struct pglist_data)) >> PAGE_SHIFT;\n\tpage = virt_to_page(pgdat);\n\n\tfor (i = 0; i < nr_pages; i++, page++)\n\t\tget_page_bootmem(node, page, NODE_INFO);\n\n\tpfn = pgdat->node_start_pfn;\n\tend_pfn = pgdat_end_pfn(pgdat);\n\n\t/* register section info */\n\tfor (; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\t/*\n\t\t * Some platforms can assign the same pfn to multiple nodes - on\n\t\t * node0 as well as nodeN.  To avoid registering a pfn against\n\t\t * multiple nodes we check that this pfn does not already\n\t\t * reside in some other nodes.\n\t\t */\n\t\tif (pfn_valid(pfn) && (early_pfn_to_nid(pfn) == node))\n\t\t\tregister_page_bootmem_info_section(pfn);\n\t}\n}"
  },
  {
    "function_name": "register_page_bootmem_info_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "196-216",
    "snippet": "static void register_page_bootmem_info_section(unsigned long start_pfn)\n{\n\tunsigned long *usemap, mapsize, section_nr, i;\n\tstruct mem_section *ms;\n\tstruct page *page, *memmap;\n\n\tsection_nr = pfn_to_section_nr(start_pfn);\n\tms = __nr_to_section(section_nr);\n\n\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\n\n\tregister_page_bootmem_memmap(section_nr, memmap, PAGES_PER_SECTION);\n\n\tusemap = ms->pageblock_flags;\n\tpage = virt_to_page(usemap);\n\n\tmapsize = PAGE_ALIGN(usemap_size()) >> PAGE_SHIFT;\n\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page_bootmem",
          "args": [
            "section_nr",
            "page",
            "MIX_SECTION_INFO"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "134-141",
          "snippet": "void get_page_bootmem(unsigned long info,  struct page *page,\n\t\t      unsigned long type)\n{\n\tpage->freelist = (void *)type;\n\tSetPagePrivate(page);\n\tset_page_private(page, info);\n\tpage_ref_inc(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid get_page_bootmem(unsigned long info,  struct page *page,\n\t\t      unsigned long type)\n{\n\tpage->freelist = (void *)type;\n\tSetPagePrivate(page);\n\tset_page_private(page, info);\n\tpage_ref_inc(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "usemap_size()"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usemap_size",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "usemap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "276-279",
          "snippet": "unsigned long usemap_size(void)\n{\n\treturn BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS) * sizeof(unsigned long);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nunsigned long usemap_size(void)\n{\n\treturn BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS) * sizeof(unsigned long);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "usemap"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_page_bootmem_memmap",
          "args": [
            "section_nr",
            "memmap",
            "PAGES_PER_SECTION"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sparse_decode_mem_map",
          "args": [
            "ms->section_mem_map",
            "section_nr"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_decode_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "259-264",
          "snippet": "struct page *sparse_decode_mem_map(unsigned long coded_mem_map, unsigned long pnum)\n{\n\t/* mask off the extra low bits of information */\n\tcoded_mem_map &= SECTION_MAP_MASK;\n\treturn ((struct page *)coded_mem_map) + section_nr_to_pfn(pnum);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct page *sparse_decode_mem_map(unsigned long coded_mem_map, unsigned long pnum)\n{\n\t/* mask off the extra low bits of information */\n\tcoded_mem_map &= SECTION_MAP_MASK;\n\treturn ((struct page *)coded_mem_map) + section_nr_to_pfn(pnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "section_nr"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "start_pfn"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic void register_page_bootmem_info_section(unsigned long start_pfn)\n{\n\tunsigned long *usemap, mapsize, section_nr, i;\n\tstruct mem_section *ms;\n\tstruct page *page, *memmap;\n\n\tsection_nr = pfn_to_section_nr(start_pfn);\n\tms = __nr_to_section(section_nr);\n\n\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\n\n\tregister_page_bootmem_memmap(section_nr, memmap, PAGES_PER_SECTION);\n\n\tusemap = ms->pageblock_flags;\n\tpage = virt_to_page(usemap);\n\n\tmapsize = PAGE_ALIGN(usemap_size()) >> PAGE_SHIFT;\n\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\n}"
  },
  {
    "function_name": "register_page_bootmem_info_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "162-194",
    "snippet": "static void register_page_bootmem_info_section(unsigned long start_pfn)\n{\n\tunsigned long *usemap, mapsize, section_nr, i;\n\tstruct mem_section *ms;\n\tstruct page *page, *memmap;\n\n\tsection_nr = pfn_to_section_nr(start_pfn);\n\tms = __nr_to_section(section_nr);\n\n\t/* Get section's memmap address */\n\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\n\n\t/*\n\t * Get page for the memmap's phys address\n\t * XXX: need more consideration for sparse_vmemmap...\n\t */\n\tpage = virt_to_page(memmap);\n\tmapsize = sizeof(struct page) * PAGES_PER_SECTION;\n\tmapsize = PAGE_ALIGN(mapsize) >> PAGE_SHIFT;\n\n\t/* remember memmap's page */\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, SECTION_INFO);\n\n\tusemap = ms->pageblock_flags;\n\tpage = virt_to_page(usemap);\n\n\tmapsize = PAGE_ALIGN(usemap_size()) >> PAGE_SHIFT;\n\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page_bootmem",
          "args": [
            "section_nr",
            "page",
            "MIX_SECTION_INFO"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "134-141",
          "snippet": "void get_page_bootmem(unsigned long info,  struct page *page,\n\t\t      unsigned long type)\n{\n\tpage->freelist = (void *)type;\n\tSetPagePrivate(page);\n\tset_page_private(page, info);\n\tpage_ref_inc(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid get_page_bootmem(unsigned long info,  struct page *page,\n\t\t      unsigned long type)\n{\n\tpage->freelist = (void *)type;\n\tSetPagePrivate(page);\n\tset_page_private(page, info);\n\tpage_ref_inc(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "usemap_size()"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usemap_size",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "usemap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "276-279",
          "snippet": "unsigned long usemap_size(void)\n{\n\treturn BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS) * sizeof(unsigned long);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nunsigned long usemap_size(void)\n{\n\treturn BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS) * sizeof(unsigned long);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "usemap"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "mapsize"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "memmap"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sparse_decode_mem_map",
          "args": [
            "ms->section_mem_map",
            "section_nr"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_decode_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "259-264",
          "snippet": "struct page *sparse_decode_mem_map(unsigned long coded_mem_map, unsigned long pnum)\n{\n\t/* mask off the extra low bits of information */\n\tcoded_mem_map &= SECTION_MAP_MASK;\n\treturn ((struct page *)coded_mem_map) + section_nr_to_pfn(pnum);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct page *sparse_decode_mem_map(unsigned long coded_mem_map, unsigned long pnum)\n{\n\t/* mask off the extra low bits of information */\n\tcoded_mem_map &= SECTION_MAP_MASK;\n\treturn ((struct page *)coded_mem_map) + section_nr_to_pfn(pnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nr_to_section",
          "args": [
            "section_nr"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_section_nr",
          "args": [
            "start_pfn"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nstatic void register_page_bootmem_info_section(unsigned long start_pfn)\n{\n\tunsigned long *usemap, mapsize, section_nr, i;\n\tstruct mem_section *ms;\n\tstruct page *page, *memmap;\n\n\tsection_nr = pfn_to_section_nr(start_pfn);\n\tms = __nr_to_section(section_nr);\n\n\t/* Get section's memmap address */\n\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\n\n\t/*\n\t * Get page for the memmap's phys address\n\t * XXX: need more consideration for sparse_vmemmap...\n\t */\n\tpage = virt_to_page(memmap);\n\tmapsize = sizeof(struct page) * PAGES_PER_SECTION;\n\tmapsize = PAGE_ALIGN(mapsize) >> PAGE_SHIFT;\n\n\t/* remember memmap's page */\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, SECTION_INFO);\n\n\tusemap = ms->pageblock_flags;\n\tpage = virt_to_page(usemap);\n\n\tmapsize = PAGE_ALIGN(usemap_size()) >> PAGE_SHIFT;\n\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\n\n}"
  },
  {
    "function_name": "put_page_bootmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "143-158",
    "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_reserved_page",
          "args": [
            "page"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&page->lru"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_dec_return",
          "args": [
            "page"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
  },
  {
    "function_name": "get_page_bootmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "134-141",
    "snippet": "void get_page_bootmem(unsigned long info,  struct page *page,\n\t\t      unsigned long type)\n{\n\tpage->freelist = (void *)type;\n\tSetPagePrivate(page);\n\tset_page_private(page, info);\n\tpage_ref_inc(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void generic_online_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_ref_inc",
          "args": [
            "page"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "info"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid get_page_bootmem(unsigned long info,  struct page *page,\n\t\t      unsigned long type)\n{\n\tpage->freelist = (void *)type;\n\tSetPagePrivate(page);\n\tset_page_private(page, info);\n\tpage_ref_inc(page);\n}"
  },
  {
    "function_name": "release_memory_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "124-131",
    "snippet": "static void release_memory_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\trelease_resource(res);\n\tkfree(res);\n\treturn;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "res"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_resource",
          "args": [
            "res"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void release_memory_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\trelease_resource(res);\n\tkfree(res);\n\treturn;\n}"
  },
  {
    "function_name": "register_memory_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "99-122",
    "snippet": "static struct resource *register_memory_resource(u64 start, u64 size)\n{\n\tstruct resource *res, *conflict;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tres->name = \"System RAM\";\n\tres->start = start;\n\tres->end = start + size - 1;\n\tres->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\tconflict =  request_resource_conflict(&iomem_resource, res);\n\tif (conflict) {\n\t\tif (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {\n\t\t\tpr_debug(\"Device unaddressable memory block \"\n\t\t\t\t \"memory hotplug at %#010llx !\\n\",\n\t\t\t\t (unsigned long long)start);\n\t\t}\n\t\tpr_debug(\"System RAM resource %pR cannot be added\\n\", res);\n\t\tkfree(res);\n\t\treturn ERR_PTR(-EEXIST);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EEXIST"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "res"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"System RAM resource %pR cannot be added\\n\"",
            "res"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Device unaddressable memory block \"\n\t\t\t\t \"memory hotplug at %#010llx !\\n\"",
            "(unsigned long long)start"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_resource_conflict",
          "args": [
            "&iomem_resource",
            "res"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct resource)",
            "GFP_KERNEL"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic struct resource *register_memory_resource(u64 start, u64 size)\n{\n\tstruct resource *res, *conflict;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tres->name = \"System RAM\";\n\tres->start = start;\n\tres->end = start + size - 1;\n\tres->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\tconflict =  request_resource_conflict(&iomem_resource, res);\n\tif (conflict) {\n\t\tif (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {\n\t\t\tpr_debug(\"Device unaddressable memory block \"\n\t\t\t\t \"memory hotplug at %#010llx !\\n\",\n\t\t\t\t (unsigned long long)start);\n\t\t}\n\t\tpr_debug(\"System RAM resource %pR cannot be added\\n\", res);\n\t\tkfree(res);\n\t\treturn ERR_PTR(-EEXIST);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "mem_hotplug_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "92-96",
    "snippet": "void mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&mem_hotplug_lock"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "mem_hotplug_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "86-90",
    "snippet": "void mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&mem_hotplug_lock"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}"
  },
  {
    "function_name": "setup_memhp_default_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "75-83",
    "snippet": "static int __init setup_memhp_default_state(char *str)\n{\n\tif (!strcmp(str, \"online\"))\n\t\tmemhp_auto_online = true;\n\telse if (!strcmp(str, \"offline\"))\n\t\tmemhp_auto_online = false;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"offline\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"online\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __init setup_memhp_default_state(char *str)\n{\n\tif (!strcmp(str, \"online\"))\n\t\tmemhp_auto_online = true;\n\telse if (!strcmp(str, \"offline\"))\n\t\tmemhp_auto_online = false;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "put_online_mems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "61-64",
    "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_read",
          "args": [
            "&mem_hotplug_lock"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
  },
  {
    "function_name": "get_online_mems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
    "lines": "56-59",
    "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/compaction.h>",
      "#include <linux/memblock.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/firmware-map.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/suspend.h>",
      "#include <linux/pfn.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/migrate.h>",
      "#include <linux/delay.h>",
      "#include <linux/ioport.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highmem.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/memremap.h>",
      "#include <linux/memory.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_read",
          "args": [
            "&mem_hotplug_lock"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
  }
]