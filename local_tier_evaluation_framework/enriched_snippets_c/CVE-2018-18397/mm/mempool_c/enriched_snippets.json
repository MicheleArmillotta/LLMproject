[
  {
    "function_name": "mempool_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "544-548",
    "snippet": "void mempool_free_pages(void *element, void *pool_data)\n{\n\tint order = (int)(long)pool_data;\n\t__free_pages(element, order);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "element",
            "order"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mempool_free_pages(void *element, void *pool_data)\n{\n\tint order = (int)(long)pool_data;\n\t__free_pages(element, order);\n}"
  },
  {
    "function_name": "mempool_alloc_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "537-541",
    "snippet": "void *mempool_alloc_pages(gfp_t gfp_mask, void *pool_data)\n{\n\tint order = (int)(long)pool_data;\n\treturn alloc_pages(gfp_mask, order);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "gfp_mask",
            "order"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "mempool_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "537-541",
          "snippet": "void *mempool_alloc_pages(gfp_t gfp_mask, void *pool_data)\n{\n\tint order = (int)(long)pool_data;\n\treturn alloc_pages(gfp_mask, order);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *mempool_alloc_pages(gfp_t gfp_mask, void *pool_data)\n{\n\tint order = (int)(long)pool_data;\n\treturn alloc_pages(gfp_mask, order);\n}"
  },
  {
    "function_name": "mempool_kfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "527-530",
    "snippet": "void mempool_kfree(void *element, void *pool_data)\n{\n\tkfree(element);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "element"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mempool_kfree(void *element, void *pool_data)\n{\n\tkfree(element);\n}"
  },
  {
    "function_name": "mempool_kmalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "520-524",
    "snippet": "void *mempool_kmalloc(gfp_t gfp_mask, void *pool_data)\n{\n\tsize_t size = (size_t)pool_data;\n\treturn kmalloc(size, gfp_mask);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "gfp_mask"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "mempool_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "520-524",
          "snippet": "void *mempool_kmalloc(gfp_t gfp_mask, void *pool_data)\n{\n\tsize_t size = (size_t)pool_data;\n\treturn kmalloc(size, gfp_mask);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *mempool_kmalloc(gfp_t gfp_mask, void *pool_data)\n{\n\tsize_t size = (size_t)pool_data;\n\treturn kmalloc(size, gfp_mask);\n}"
  },
  {
    "function_name": "mempool_free_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "509-513",
    "snippet": "void mempool_free_slab(void *element, void *pool_data)\n{\n\tstruct kmem_cache *mem = pool_data;\n\tkmem_cache_free(mem, element);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "mem",
            "element"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mempool_free_slab(void *element, void *pool_data)\n{\n\tstruct kmem_cache *mem = pool_data;\n\tkmem_cache_free(mem, element);\n}"
  },
  {
    "function_name": "mempool_alloc_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "501-506",
    "snippet": "void *mempool_alloc_slab(gfp_t gfp_mask, void *pool_data)\n{\n\tstruct kmem_cache *mem = pool_data;\n\tVM_BUG_ON(mem->ctor);\n\treturn kmem_cache_alloc(mem, gfp_mask);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "mem",
            "gfp_mask"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "mem->ctor"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *mempool_alloc_slab(gfp_t gfp_mask, void *pool_data)\n{\n\tstruct kmem_cache *mem = pool_data;\n\tVM_BUG_ON(mem->ctor);\n\treturn kmem_cache_alloc(mem, gfp_mask);\n}"
  },
  {
    "function_name": "mempool_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "444-495",
    "snippet": "void mempool_free(void *element, mempool_t *pool)\n{\n\tunsigned long flags;\n\n\tif (unlikely(element == NULL))\n\t\treturn;\n\n\t/*\n\t * Paired with the wmb in mempool_alloc().  The preceding read is\n\t * for @element and the following @pool->curr_nr.  This ensures\n\t * that the visible value of @pool->curr_nr is from after the\n\t * allocation of @element.  This is necessary for fringe cases\n\t * where @element was passed to this task without going through\n\t * barriers.\n\t *\n\t * For example, assume @p is %NULL at the beginning and one task\n\t * performs \"p = mempool_alloc(...);\" while another task is doing\n\t * \"while (!p) cpu_relax(); mempool_free(p, ...);\".  This function\n\t * may end up using curr_nr value which is from before allocation\n\t * of @p without the following rmb.\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * For correctness, we need a test which is guaranteed to trigger\n\t * if curr_nr + #allocated == min_nr.  Testing curr_nr < min_nr\n\t * without locking achieves that and refilling as soon as possible\n\t * is desirable.\n\t *\n\t * Because curr_nr visible here is always a value after the\n\t * allocation of @element, any task which decremented curr_nr below\n\t * min_nr is guaranteed to see curr_nr < min_nr unless curr_nr gets\n\t * incremented to min_nr afterwards.  If curr_nr gets incremented\n\t * to min_nr after the allocation of @element, the elements\n\t * allocated after that are subject to the same guarantee.\n\t *\n\t * Waiters happen iff curr_nr is 0 and the above guarantee also\n\t * ensures that there will be frees which return elements to the\n\t * pool waking up the waiters.\n\t */\n\tif (unlikely(pool->curr_nr < pool->min_nr)) {\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (likely(pool->curr_nr < pool->min_nr)) {\n\t\t\tadd_element(pool, element);\n\t\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t\twake_up(&pool->wait);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t}\n\tpool->free(element, pool->pool_data);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pool->free",
          "args": [
            "element",
            "pool->pool_data"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&pool->wait"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_element",
          "args": [
            "pool",
            "element"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "add_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "122-128",
          "snippet": "static __always_inline void add_element(mempool_t *pool, void *element)\n{\n\tBUG_ON(pool->curr_nr >= pool->min_nr);\n\tpoison_element(pool, element);\n\tkasan_poison_element(pool, element);\n\tpool->elements[pool->curr_nr++] = element;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic __always_inline void add_element(mempool_t *pool, void *element)\n{\n\tBUG_ON(pool->curr_nr >= pool->min_nr);\n\tpoison_element(pool, element);\n\tkasan_poison_element(pool, element);\n\tpool->elements[pool->curr_nr++] = element;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pool->curr_nr < pool->min_nr"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pool->curr_nr < pool->min_nr"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "element == NULL"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mempool_free(void *element, mempool_t *pool)\n{\n\tunsigned long flags;\n\n\tif (unlikely(element == NULL))\n\t\treturn;\n\n\t/*\n\t * Paired with the wmb in mempool_alloc().  The preceding read is\n\t * for @element and the following @pool->curr_nr.  This ensures\n\t * that the visible value of @pool->curr_nr is from after the\n\t * allocation of @element.  This is necessary for fringe cases\n\t * where @element was passed to this task without going through\n\t * barriers.\n\t *\n\t * For example, assume @p is %NULL at the beginning and one task\n\t * performs \"p = mempool_alloc(...);\" while another task is doing\n\t * \"while (!p) cpu_relax(); mempool_free(p, ...);\".  This function\n\t * may end up using curr_nr value which is from before allocation\n\t * of @p without the following rmb.\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * For correctness, we need a test which is guaranteed to trigger\n\t * if curr_nr + #allocated == min_nr.  Testing curr_nr < min_nr\n\t * without locking achieves that and refilling as soon as possible\n\t * is desirable.\n\t *\n\t * Because curr_nr visible here is always a value after the\n\t * allocation of @element, any task which decremented curr_nr below\n\t * min_nr is guaranteed to see curr_nr < min_nr unless curr_nr gets\n\t * incremented to min_nr afterwards.  If curr_nr gets incremented\n\t * to min_nr after the allocation of @element, the elements\n\t * allocated after that are subject to the same guarantee.\n\t *\n\t * Waiters happen iff curr_nr is 0 and the above guarantee also\n\t * ensures that there will be frees which return elements to the\n\t * pool waking up the waiters.\n\t */\n\tif (unlikely(pool->curr_nr < pool->min_nr)) {\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (likely(pool->curr_nr < pool->min_nr)) {\n\t\t\tadd_element(pool, element);\n\t\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t\twake_up(&pool->wait);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t}\n\tpool->free(element, pool->pool_data);\n}"
  },
  {
    "function_name": "mempool_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "367-433",
    "snippet": "void *mempool_alloc(mempool_t *pool, gfp_t gfp_mask)\n{\n\tvoid *element;\n\tunsigned long flags;\n\twait_queue_entry_t wait;\n\tgfp_t gfp_temp;\n\n\tVM_WARN_ON_ONCE(gfp_mask & __GFP_ZERO);\n\tmight_sleep_if(gfp_mask & __GFP_DIRECT_RECLAIM);\n\n\tgfp_mask |= __GFP_NOMEMALLOC;\t/* don't allocate emergency reserves */\n\tgfp_mask |= __GFP_NORETRY;\t/* don't loop in __alloc_pages */\n\tgfp_mask |= __GFP_NOWARN;\t/* failures are OK */\n\n\tgfp_temp = gfp_mask & ~(__GFP_DIRECT_RECLAIM|__GFP_IO);\n\nrepeat_alloc:\n\n\telement = pool->alloc(gfp_temp, pool->pool_data);\n\tif (likely(element != NULL))\n\t\treturn element;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tif (likely(pool->curr_nr)) {\n\t\telement = remove_element(pool);\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t/* paired with rmb in mempool_free(), read comment there */\n\t\tsmp_wmb();\n\t\t/*\n\t\t * Update the allocation stack trace as this is more useful\n\t\t * for debugging.\n\t\t */\n\t\tkmemleak_update_trace(element);\n\t\treturn element;\n\t}\n\n\t/*\n\t * We use gfp mask w/o direct reclaim or IO for the first round.  If\n\t * alloc failed with that and @pool was empty, retry immediately.\n\t */\n\tif (gfp_temp != gfp_mask) {\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\tgfp_temp = gfp_mask;\n\t\tgoto repeat_alloc;\n\t}\n\n\t/* We must not sleep if !__GFP_DIRECT_RECLAIM */\n\tif (!(gfp_mask & __GFP_DIRECT_RECLAIM)) {\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\treturn NULL;\n\t}\n\n\t/* Let's wait for someone else to return an element to @pool */\n\tinit_wait(&wait);\n\tprepare_to_wait(&pool->wait, &wait, TASK_UNINTERRUPTIBLE);\n\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\t/*\n\t * FIXME: this should be io_schedule().  The timeout is there as a\n\t * workaround for some DM problems in 2.6.18.\n\t */\n\tio_schedule_timeout(5*HZ);\n\n\tfinish_wait(&pool->wait, &wait);\n\tgoto repeat_alloc;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&pool->wait",
            "&wait"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule_timeout",
          "args": [
            "5*HZ"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&pool->wait",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_wait",
          "args": [
            "&wait"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_update_trace",
          "args": [
            "element"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_update_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1104-1128",
          "snippet": "void __ref kmemleak_update_trace(const void *ptr)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long flags;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (!kmemleak_enabled || IS_ERR_OR_NULL(ptr))\n\t\treturn;\n\n\tobject = find_and_get_object((unsigned long)ptr, 1);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Updating stack trace for unknown object at %p\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->trace_len = __save_stack_trace(object->trace);\n\tspin_unlock_irqrestore(&object->lock, flags);\n\n\tput_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\n\nvoid __ref kmemleak_update_trace(const void *ptr)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long flags;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (!kmemleak_enabled || IS_ERR_OR_NULL(ptr))\n\t\treturn;\n\n\tobject = find_and_get_object((unsigned long)ptr, 1);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Updating stack trace for unknown object at %p\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->trace_len = __save_stack_trace(object->trace);\n\tspin_unlock_irqrestore(&object->lock, flags);\n\n\tput_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_element",
          "args": [
            "pool"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "remove_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "130-138",
          "snippet": "static void *remove_element(mempool_t *pool)\n{\n\tvoid *element = pool->elements[--pool->curr_nr];\n\n\tBUG_ON(pool->curr_nr < 0);\n\tkasan_unpoison_element(pool, element);\n\tcheck_element(pool, element);\n\treturn element;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void *remove_element(mempool_t *pool)\n{\n\tvoid *element = pool->elements[--pool->curr_nr];\n\n\tBUG_ON(pool->curr_nr < 0);\n\tkasan_unpoison_element(pool, element);\n\tcheck_element(pool, element);\n\treturn element;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pool->curr_nr"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "element != NULL"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool->alloc",
          "args": [
            "gfp_temp",
            "pool->pool_data"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep_if",
          "args": [
            "gfp_mask & __GFP_DIRECT_RECLAIM"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON_ONCE",
          "args": [
            "gfp_mask & __GFP_ZERO"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *mempool_alloc(mempool_t *pool, gfp_t gfp_mask)\n{\n\tvoid *element;\n\tunsigned long flags;\n\twait_queue_entry_t wait;\n\tgfp_t gfp_temp;\n\n\tVM_WARN_ON_ONCE(gfp_mask & __GFP_ZERO);\n\tmight_sleep_if(gfp_mask & __GFP_DIRECT_RECLAIM);\n\n\tgfp_mask |= __GFP_NOMEMALLOC;\t/* don't allocate emergency reserves */\n\tgfp_mask |= __GFP_NORETRY;\t/* don't loop in __alloc_pages */\n\tgfp_mask |= __GFP_NOWARN;\t/* failures are OK */\n\n\tgfp_temp = gfp_mask & ~(__GFP_DIRECT_RECLAIM|__GFP_IO);\n\nrepeat_alloc:\n\n\telement = pool->alloc(gfp_temp, pool->pool_data);\n\tif (likely(element != NULL))\n\t\treturn element;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tif (likely(pool->curr_nr)) {\n\t\telement = remove_element(pool);\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t/* paired with rmb in mempool_free(), read comment there */\n\t\tsmp_wmb();\n\t\t/*\n\t\t * Update the allocation stack trace as this is more useful\n\t\t * for debugging.\n\t\t */\n\t\tkmemleak_update_trace(element);\n\t\treturn element;\n\t}\n\n\t/*\n\t * We use gfp mask w/o direct reclaim or IO for the first round.  If\n\t * alloc failed with that and @pool was empty, retry immediately.\n\t */\n\tif (gfp_temp != gfp_mask) {\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\tgfp_temp = gfp_mask;\n\t\tgoto repeat_alloc;\n\t}\n\n\t/* We must not sleep if !__GFP_DIRECT_RECLAIM */\n\tif (!(gfp_mask & __GFP_DIRECT_RECLAIM)) {\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\treturn NULL;\n\t}\n\n\t/* Let's wait for someone else to return an element to @pool */\n\tinit_wait(&wait);\n\tprepare_to_wait(&pool->wait, &wait, TASK_UNINTERRUPTIBLE);\n\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\t/*\n\t * FIXME: this should be io_schedule().  The timeout is there as a\n\t * workaround for some DM problems in 2.6.18.\n\t */\n\tio_schedule_timeout(5*HZ);\n\n\tfinish_wait(&pool->wait, &wait);\n\tgoto repeat_alloc;\n}"
  },
  {
    "function_name": "mempool_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "293-352",
    "snippet": "int mempool_resize(mempool_t *pool, int new_min_nr)\n{\n\tvoid *element;\n\tvoid **new_elements;\n\tunsigned long flags;\n\n\tBUG_ON(new_min_nr <= 0);\n\tmight_sleep();\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tif (new_min_nr <= pool->min_nr) {\n\t\twhile (new_min_nr < pool->curr_nr) {\n\t\t\telement = remove_element(pool);\n\t\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t\tpool->free(element, pool->pool_data);\n\t\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\t}\n\t\tpool->min_nr = new_min_nr;\n\t\tgoto out_unlock;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\t/* Grow the pool */\n\tnew_elements = kmalloc_array(new_min_nr, sizeof(*new_elements),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_elements)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tif (unlikely(new_min_nr <= pool->min_nr)) {\n\t\t/* Raced, other resize will do our work */\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\tkfree(new_elements);\n\t\tgoto out;\n\t}\n\tmemcpy(new_elements, pool->elements,\n\t\t\tpool->curr_nr * sizeof(*new_elements));\n\tkfree(pool->elements);\n\tpool->elements = new_elements;\n\tpool->min_nr = new_min_nr;\n\n\twhile (pool->curr_nr < pool->min_nr) {\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\telement = pool->alloc(GFP_KERNEL, pool->pool_data);\n\t\tif (!element)\n\t\t\tgoto out;\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (pool->curr_nr < pool->min_nr) {\n\t\t\tadd_element(pool, element);\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t\tpool->free(element, pool->pool_data);\t/* Raced */\n\t\t\tgoto out;\n\t\t}\n\t}\nout_unlock:\n\tspin_unlock_irqrestore(&pool->lock, flags);\nout:\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool->free",
          "args": [
            "element",
            "pool->pool_data"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_element",
          "args": [
            "pool",
            "element"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "add_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "122-128",
          "snippet": "static __always_inline void add_element(mempool_t *pool, void *element)\n{\n\tBUG_ON(pool->curr_nr >= pool->min_nr);\n\tpoison_element(pool, element);\n\tkasan_poison_element(pool, element);\n\tpool->elements[pool->curr_nr++] = element;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic __always_inline void add_element(mempool_t *pool, void *element)\n{\n\tBUG_ON(pool->curr_nr >= pool->min_nr);\n\tpoison_element(pool, element);\n\tkasan_poison_element(pool, element);\n\tpool->elements[pool->curr_nr++] = element;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool->alloc",
          "args": [
            "GFP_KERNEL",
            "pool->pool_data"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pool->elements"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_elements",
            "pool->elements",
            "pool->curr_nr * sizeof(*new_elements)"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new_min_nr <= pool->min_nr"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "new_min_nr",
            "sizeof(*new_elements)",
            "GFP_KERNEL"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool->free",
          "args": [
            "element",
            "pool->pool_data"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_element",
          "args": [
            "pool"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "remove_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "130-138",
          "snippet": "static void *remove_element(mempool_t *pool)\n{\n\tvoid *element = pool->elements[--pool->curr_nr];\n\n\tBUG_ON(pool->curr_nr < 0);\n\tkasan_unpoison_element(pool, element);\n\tcheck_element(pool, element);\n\treturn element;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void *remove_element(mempool_t *pool)\n{\n\tvoid *element = pool->elements[--pool->curr_nr];\n\n\tBUG_ON(pool->curr_nr < 0);\n\tkasan_unpoison_element(pool, element);\n\tcheck_element(pool, element);\n\treturn element;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_min_nr <= 0"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint mempool_resize(mempool_t *pool, int new_min_nr)\n{\n\tvoid *element;\n\tvoid **new_elements;\n\tunsigned long flags;\n\n\tBUG_ON(new_min_nr <= 0);\n\tmight_sleep();\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tif (new_min_nr <= pool->min_nr) {\n\t\twhile (new_min_nr < pool->curr_nr) {\n\t\t\telement = remove_element(pool);\n\t\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t\tpool->free(element, pool->pool_data);\n\t\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\t}\n\t\tpool->min_nr = new_min_nr;\n\t\tgoto out_unlock;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\t/* Grow the pool */\n\tnew_elements = kmalloc_array(new_min_nr, sizeof(*new_elements),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_elements)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tif (unlikely(new_min_nr <= pool->min_nr)) {\n\t\t/* Raced, other resize will do our work */\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\tkfree(new_elements);\n\t\tgoto out;\n\t}\n\tmemcpy(new_elements, pool->elements,\n\t\t\tpool->curr_nr * sizeof(*new_elements));\n\tkfree(pool->elements);\n\tpool->elements = new_elements;\n\tpool->min_nr = new_min_nr;\n\n\twhile (pool->curr_nr < pool->min_nr) {\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\telement = pool->alloc(GFP_KERNEL, pool->pool_data);\n\t\tif (!element)\n\t\t\tgoto out;\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (pool->curr_nr < pool->min_nr) {\n\t\t\tadd_element(pool, element);\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t\tpool->free(element, pool->pool_data);\t/* Raced */\n\t\t\tgoto out;\n\t\t}\n\t}\nout_unlock:\n\tspin_unlock_irqrestore(&pool->lock, flags);\nout:\n\treturn 0;\n}"
  },
  {
    "function_name": "mempool_create_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "257-274",
    "snippet": "mempool_t *mempool_create_node(int min_nr, mempool_alloc_t *alloc_fn,\n\t\t\t       mempool_free_t *free_fn, void *pool_data,\n\t\t\t       gfp_t gfp_mask, int node_id)\n{\n\tmempool_t *pool;\n\n\tpool = kzalloc_node(sizeof(*pool), gfp_mask, node_id);\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (mempool_init_node(pool, min_nr, alloc_fn, free_fn, pool_data,\n\t\t\t      gfp_mask, node_id)) {\n\t\tkfree(pool);\n\t\treturn NULL;\n\t}\n\n\treturn pool;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pool"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool_init_node",
          "args": [
            "pool",
            "min_nr",
            "alloc_fn",
            "free_fn",
            "pool_data",
            "gfp_mask",
            "node_id"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "mempool_init_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "180-211",
          "snippet": "int mempool_init_node(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,\n\t\t      mempool_free_t *free_fn, void *pool_data,\n\t\t      gfp_t gfp_mask, int node_id)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->min_nr\t= min_nr;\n\tpool->pool_data = pool_data;\n\tpool->alloc\t= alloc_fn;\n\tpool->free\t= free_fn;\n\tinit_waitqueue_head(&pool->wait);\n\n\tpool->elements = kmalloc_array_node(min_nr, sizeof(void *),\n\t\t\t\t\t    gfp_mask, node_id);\n\tif (!pool->elements)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * First pre-allocate the guaranteed number of buffers.\n\t */\n\twhile (pool->curr_nr < pool->min_nr) {\n\t\tvoid *element;\n\n\t\telement = pool->alloc(gfp_mask, pool->pool_data);\n\t\tif (unlikely(!element)) {\n\t\t\tmempool_exit(pool);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tadd_element(pool, element);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint mempool_init_node(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,\n\t\t      mempool_free_t *free_fn, void *pool_data,\n\t\t      gfp_t gfp_mask, int node_id)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->min_nr\t= min_nr;\n\tpool->pool_data = pool_data;\n\tpool->alloc\t= alloc_fn;\n\tpool->free\t= free_fn;\n\tinit_waitqueue_head(&pool->wait);\n\n\tpool->elements = kmalloc_array_node(min_nr, sizeof(void *),\n\t\t\t\t\t    gfp_mask, node_id);\n\tif (!pool->elements)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * First pre-allocate the guaranteed number of buffers.\n\t */\n\twhile (pool->curr_nr < pool->min_nr) {\n\t\tvoid *element;\n\n\t\telement = pool->alloc(gfp_mask, pool->pool_data);\n\t\tif (unlikely(!element)) {\n\t\t\tmempool_exit(pool);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tadd_element(pool, element);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*pool)",
            "gfp_mask",
            "node_id"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nmempool_t *mempool_create_node(int min_nr, mempool_alloc_t *alloc_fn,\n\t\t\t       mempool_free_t *free_fn, void *pool_data,\n\t\t\t       gfp_t gfp_mask, int node_id)\n{\n\tmempool_t *pool;\n\n\tpool = kzalloc_node(sizeof(*pool), gfp_mask, node_id);\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (mempool_init_node(pool, min_nr, alloc_fn, free_fn, pool_data,\n\t\t\t      gfp_mask, node_id)) {\n\t\tkfree(pool);\n\t\treturn NULL;\n\t}\n\n\treturn pool;\n}"
  },
  {
    "function_name": "mempool_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "249-254",
    "snippet": "mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn,\n\t\t\t\tmempool_free_t *free_fn, void *pool_data)\n{\n\treturn mempool_create_node(min_nr,alloc_fn,free_fn, pool_data,\n\t\t\t\t   GFP_KERNEL, NUMA_NO_NODE);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_create_node",
          "args": [
            "min_nr",
            "alloc_fn",
            "free_fn",
            "pool_data",
            "GFP_KERNEL",
            "NUMA_NO_NODE"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "mempool_create_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "257-274",
          "snippet": "mempool_t *mempool_create_node(int min_nr, mempool_alloc_t *alloc_fn,\n\t\t\t       mempool_free_t *free_fn, void *pool_data,\n\t\t\t       gfp_t gfp_mask, int node_id)\n{\n\tmempool_t *pool;\n\n\tpool = kzalloc_node(sizeof(*pool), gfp_mask, node_id);\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (mempool_init_node(pool, min_nr, alloc_fn, free_fn, pool_data,\n\t\t\t      gfp_mask, node_id)) {\n\t\tkfree(pool);\n\t\treturn NULL;\n\t}\n\n\treturn pool;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nmempool_t *mempool_create_node(int min_nr, mempool_alloc_t *alloc_fn,\n\t\t\t       mempool_free_t *free_fn, void *pool_data,\n\t\t\t       gfp_t gfp_mask, int node_id)\n{\n\tmempool_t *pool;\n\n\tpool = kzalloc_node(sizeof(*pool), gfp_mask, node_id);\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (mempool_init_node(pool, min_nr, alloc_fn, free_fn, pool_data,\n\t\t\t      gfp_mask, node_id)) {\n\t\tkfree(pool);\n\t\treturn NULL;\n\t}\n\n\treturn pool;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nmempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn,\n\t\t\t\tmempool_free_t *free_fn, void *pool_data)\n{\n\treturn mempool_create_node(min_nr,alloc_fn,free_fn, pool_data,\n\t\t\t\t   GFP_KERNEL, NUMA_NO_NODE);\n}"
  },
  {
    "function_name": "mempool_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "226-232",
    "snippet": "int mempool_init(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,\n\t\t mempool_free_t *free_fn, void *pool_data)\n{\n\treturn mempool_init_node(pool, min_nr, alloc_fn, free_fn,\n\t\t\t\t pool_data, GFP_KERNEL, NUMA_NO_NODE);\n\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_init_node",
          "args": [
            "pool",
            "min_nr",
            "alloc_fn",
            "free_fn",
            "pool_data",
            "GFP_KERNEL",
            "NUMA_NO_NODE"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "mempool_init_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "180-211",
          "snippet": "int mempool_init_node(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,\n\t\t      mempool_free_t *free_fn, void *pool_data,\n\t\t      gfp_t gfp_mask, int node_id)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->min_nr\t= min_nr;\n\tpool->pool_data = pool_data;\n\tpool->alloc\t= alloc_fn;\n\tpool->free\t= free_fn;\n\tinit_waitqueue_head(&pool->wait);\n\n\tpool->elements = kmalloc_array_node(min_nr, sizeof(void *),\n\t\t\t\t\t    gfp_mask, node_id);\n\tif (!pool->elements)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * First pre-allocate the guaranteed number of buffers.\n\t */\n\twhile (pool->curr_nr < pool->min_nr) {\n\t\tvoid *element;\n\n\t\telement = pool->alloc(gfp_mask, pool->pool_data);\n\t\tif (unlikely(!element)) {\n\t\t\tmempool_exit(pool);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tadd_element(pool, element);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint mempool_init_node(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,\n\t\t      mempool_free_t *free_fn, void *pool_data,\n\t\t      gfp_t gfp_mask, int node_id)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->min_nr\t= min_nr;\n\tpool->pool_data = pool_data;\n\tpool->alloc\t= alloc_fn;\n\tpool->free\t= free_fn;\n\tinit_waitqueue_head(&pool->wait);\n\n\tpool->elements = kmalloc_array_node(min_nr, sizeof(void *),\n\t\t\t\t\t    gfp_mask, node_id);\n\tif (!pool->elements)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * First pre-allocate the guaranteed number of buffers.\n\t */\n\twhile (pool->curr_nr < pool->min_nr) {\n\t\tvoid *element;\n\n\t\telement = pool->alloc(gfp_mask, pool->pool_data);\n\t\tif (unlikely(!element)) {\n\t\t\tmempool_exit(pool);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tadd_element(pool, element);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint mempool_init(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,\n\t\t mempool_free_t *free_fn, void *pool_data)\n{\n\treturn mempool_init_node(pool, min_nr, alloc_fn, free_fn,\n\t\t\t\t pool_data, GFP_KERNEL, NUMA_NO_NODE);\n\n}"
  },
  {
    "function_name": "mempool_init_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "180-211",
    "snippet": "int mempool_init_node(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,\n\t\t      mempool_free_t *free_fn, void *pool_data,\n\t\t      gfp_t gfp_mask, int node_id)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->min_nr\t= min_nr;\n\tpool->pool_data = pool_data;\n\tpool->alloc\t= alloc_fn;\n\tpool->free\t= free_fn;\n\tinit_waitqueue_head(&pool->wait);\n\n\tpool->elements = kmalloc_array_node(min_nr, sizeof(void *),\n\t\t\t\t\t    gfp_mask, node_id);\n\tif (!pool->elements)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * First pre-allocate the guaranteed number of buffers.\n\t */\n\twhile (pool->curr_nr < pool->min_nr) {\n\t\tvoid *element;\n\n\t\telement = pool->alloc(gfp_mask, pool->pool_data);\n\t\tif (unlikely(!element)) {\n\t\t\tmempool_exit(pool);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tadd_element(pool, element);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_element",
          "args": [
            "pool",
            "element"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "add_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "122-128",
          "snippet": "static __always_inline void add_element(mempool_t *pool, void *element)\n{\n\tBUG_ON(pool->curr_nr >= pool->min_nr);\n\tpoison_element(pool, element);\n\tkasan_poison_element(pool, element);\n\tpool->elements[pool->curr_nr++] = element;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic __always_inline void add_element(mempool_t *pool, void *element)\n{\n\tBUG_ON(pool->curr_nr >= pool->min_nr);\n\tpoison_element(pool, element);\n\tkasan_poison_element(pool, element);\n\tpool->elements[pool->curr_nr++] = element;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool_exit",
          "args": [
            "pool"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "mempool_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "151-159",
          "snippet": "void mempool_exit(mempool_t *pool)\n{\n\twhile (pool->curr_nr) {\n\t\tvoid *element = remove_element(pool);\n\t\tpool->free(element, pool->pool_data);\n\t}\n\tkfree(pool->elements);\n\tpool->elements = NULL;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mempool_exit(mempool_t *pool)\n{\n\twhile (pool->curr_nr) {\n\t\tvoid *element = remove_element(pool);\n\t\tpool->free(element, pool->pool_data);\n\t}\n\tkfree(pool->elements);\n\tpool->elements = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!element"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool->alloc",
          "args": [
            "gfp_mask",
            "pool->pool_data"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array_node",
          "args": [
            "min_nr",
            "sizeof(void *)",
            "gfp_mask",
            "node_id"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&pool->wait"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pool->lock"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint mempool_init_node(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,\n\t\t      mempool_free_t *free_fn, void *pool_data,\n\t\t      gfp_t gfp_mask, int node_id)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->min_nr\t= min_nr;\n\tpool->pool_data = pool_data;\n\tpool->alloc\t= alloc_fn;\n\tpool->free\t= free_fn;\n\tinit_waitqueue_head(&pool->wait);\n\n\tpool->elements = kmalloc_array_node(min_nr, sizeof(void *),\n\t\t\t\t\t    gfp_mask, node_id);\n\tif (!pool->elements)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * First pre-allocate the guaranteed number of buffers.\n\t */\n\twhile (pool->curr_nr < pool->min_nr) {\n\t\tvoid *element;\n\n\t\telement = pool->alloc(gfp_mask, pool->pool_data);\n\t\tif (unlikely(!element)) {\n\t\t\tmempool_exit(pool);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tadd_element(pool, element);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mempool_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "170-177",
    "snippet": "void mempool_destroy(mempool_t *pool)\n{\n\tif (unlikely(!pool))\n\t\treturn;\n\n\tmempool_exit(pool);\n\tkfree(pool);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pool"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool_exit",
          "args": [
            "pool"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "mempool_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "151-159",
          "snippet": "void mempool_exit(mempool_t *pool)\n{\n\twhile (pool->curr_nr) {\n\t\tvoid *element = remove_element(pool);\n\t\tpool->free(element, pool->pool_data);\n\t}\n\tkfree(pool->elements);\n\tpool->elements = NULL;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mempool_exit(mempool_t *pool)\n{\n\twhile (pool->curr_nr) {\n\t\tvoid *element = remove_element(pool);\n\t\tpool->free(element, pool->pool_data);\n\t}\n\tkfree(pool->elements);\n\tpool->elements = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pool"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mempool_destroy(mempool_t *pool)\n{\n\tif (unlikely(!pool))\n\t\treturn;\n\n\tmempool_exit(pool);\n\tkfree(pool);\n}"
  },
  {
    "function_name": "mempool_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "151-159",
    "snippet": "void mempool_exit(mempool_t *pool)\n{\n\twhile (pool->curr_nr) {\n\t\tvoid *element = remove_element(pool);\n\t\tpool->free(element, pool->pool_data);\n\t}\n\tkfree(pool->elements);\n\tpool->elements = NULL;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pool->elements"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pool->free",
          "args": [
            "element",
            "pool->pool_data"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_element",
          "args": [
            "pool"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "remove_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "130-138",
          "snippet": "static void *remove_element(mempool_t *pool)\n{\n\tvoid *element = pool->elements[--pool->curr_nr];\n\n\tBUG_ON(pool->curr_nr < 0);\n\tkasan_unpoison_element(pool, element);\n\tcheck_element(pool, element);\n\treturn element;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void *remove_element(mempool_t *pool)\n{\n\tvoid *element = pool->elements[--pool->curr_nr];\n\n\tBUG_ON(pool->curr_nr < 0);\n\tkasan_unpoison_element(pool, element);\n\tcheck_element(pool, element);\n\treturn element;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mempool_exit(mempool_t *pool)\n{\n\twhile (pool->curr_nr) {\n\t\tvoid *element = remove_element(pool);\n\t\tpool->free(element, pool->pool_data);\n\t}\n\tkfree(pool->elements);\n\tpool->elements = NULL;\n}"
  },
  {
    "function_name": "remove_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "130-138",
    "snippet": "static void *remove_element(mempool_t *pool)\n{\n\tvoid *element = pool->elements[--pool->curr_nr];\n\n\tBUG_ON(pool->curr_nr < 0);\n\tkasan_unpoison_element(pool, element);\n\tcheck_element(pool, element);\n\treturn element;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_element",
          "args": [
            "pool",
            "element"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "check_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "98-100",
          "snippet": "static inline void check_element(mempool_t *pool, void *element)\n{\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_element(mempool_t *pool, void *element)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_unpoison_element",
          "args": [
            "pool",
            "element"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_unpoison_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "114-120",
          "snippet": "static void kasan_unpoison_element(mempool_t *pool, void *element)\n{\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\tkasan_unpoison_slab(element);\n\tif (pool->alloc == mempool_alloc_pages)\n\t\tkasan_alloc_pages(element, (unsigned long)pool->pool_data);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void kasan_unpoison_element(mempool_t *pool, void *element)\n{\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\tkasan_unpoison_slab(element);\n\tif (pool->alloc == mempool_alloc_pages)\n\t\tkasan_alloc_pages(element, (unsigned long)pool->pool_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pool->curr_nr < 0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void *remove_element(mempool_t *pool)\n{\n\tvoid *element = pool->elements[--pool->curr_nr];\n\n\tBUG_ON(pool->curr_nr < 0);\n\tkasan_unpoison_element(pool, element);\n\tcheck_element(pool, element);\n\treturn element;\n}"
  },
  {
    "function_name": "add_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "122-128",
    "snippet": "static __always_inline void add_element(mempool_t *pool, void *element)\n{\n\tBUG_ON(pool->curr_nr >= pool->min_nr);\n\tpoison_element(pool, element);\n\tkasan_poison_element(pool, element);\n\tpool->elements[pool->curr_nr++] = element;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_poison_element",
          "args": [
            "pool",
            "element"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_poison_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "106-112",
          "snippet": "static __always_inline void kasan_poison_element(mempool_t *pool, void *element)\n{\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\tkasan_poison_kfree(element, _RET_IP_);\n\tif (pool->alloc == mempool_alloc_pages)\n\t\tkasan_free_pages(element, (unsigned long)pool->pool_data);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic __always_inline void kasan_poison_element(mempool_t *pool, void *element)\n{\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\tkasan_poison_kfree(element, _RET_IP_);\n\tif (pool->alloc == mempool_alloc_pages)\n\t\tkasan_free_pages(element, (unsigned long)pool->pool_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poison_element",
          "args": [
            "pool",
            "element"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_unpoison_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "114-120",
          "snippet": "static void kasan_unpoison_element(mempool_t *pool, void *element)\n{\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\tkasan_unpoison_slab(element);\n\tif (pool->alloc == mempool_alloc_pages)\n\t\tkasan_alloc_pages(element, (unsigned long)pool->pool_data);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void kasan_unpoison_element(mempool_t *pool, void *element)\n{\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\tkasan_unpoison_slab(element);\n\tif (pool->alloc == mempool_alloc_pages)\n\t\tkasan_alloc_pages(element, (unsigned long)pool->pool_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pool->curr_nr >= pool->min_nr"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic __always_inline void add_element(mempool_t *pool, void *element)\n{\n\tBUG_ON(pool->curr_nr >= pool->min_nr);\n\tpoison_element(pool, element);\n\tkasan_poison_element(pool, element);\n\tpool->elements[pool->curr_nr++] = element;\n}"
  },
  {
    "function_name": "kasan_unpoison_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "114-120",
    "snippet": "static void kasan_unpoison_element(mempool_t *pool, void *element)\n{\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\tkasan_unpoison_slab(element);\n\tif (pool->alloc == mempool_alloc_pages)\n\t\tkasan_alloc_pages(element, (unsigned long)pool->pool_data);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_alloc_pages",
          "args": [
            "element",
            "(unsigned long)pool->pool_data"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "308-312",
          "snippet": "void kasan_alloc_pages(struct page *page, unsigned int order)\n{\n\tif (likely(!PageHighMem(page)))\n\t\tkasan_unpoison_shadow(page_address(page), PAGE_SIZE << order);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_alloc_pages(struct page *page, unsigned int order)\n{\n\tif (likely(!PageHighMem(page)))\n\t\tkasan_unpoison_shadow(page_address(page), PAGE_SIZE << order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_unpoison_slab",
          "args": [
            "element"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void kasan_unpoison_element(mempool_t *pool, void *element)\n{\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\tkasan_unpoison_slab(element);\n\tif (pool->alloc == mempool_alloc_pages)\n\t\tkasan_alloc_pages(element, (unsigned long)pool->pool_data);\n}"
  },
  {
    "function_name": "kasan_poison_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "106-112",
    "snippet": "static __always_inline void kasan_poison_element(mempool_t *pool, void *element)\n{\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\tkasan_poison_kfree(element, _RET_IP_);\n\tif (pool->alloc == mempool_alloc_pages)\n\t\tkasan_free_pages(element, (unsigned long)pool->pool_data);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_free_pages",
          "args": [
            "element",
            "(unsigned long)pool->pool_data"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "314-320",
          "snippet": "void kasan_free_pages(struct page *page, unsigned int order)\n{\n\tif (likely(!PageHighMem(page)))\n\t\tkasan_poison_shadow(page_address(page),\n\t\t\t\tPAGE_SIZE << order,\n\t\t\t\tKASAN_FREE_PAGE);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_free_pages(struct page *page, unsigned int order)\n{\n\tif (likely(!PageHighMem(page)))\n\t\tkasan_poison_shadow(page_address(page),\n\t\t\t\tPAGE_SIZE << order,\n\t\t\t\tKASAN_FREE_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_poison_kfree",
          "args": [
            "element",
            "_RET_IP_"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_poison_kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "594-610",
          "snippet": "void kasan_poison_kfree(void *ptr, unsigned long ip)\n{\n\tstruct page *page;\n\n\tpage = virt_to_head_page(ptr);\n\n\tif (unlikely(!PageSlab(page))) {\n\t\tif (ptr != page_address(page)) {\n\t\t\tkasan_report_invalid_free(ptr, ip);\n\t\t\treturn;\n\t\t}\n\t\tkasan_poison_shadow(ptr, PAGE_SIZE << compound_order(page),\n\t\t\t\tKASAN_FREE_PAGE);\n\t} else {\n\t\t__kasan_slab_free(page->slab_cache, ptr, ip, false);\n\t}\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_poison_kfree(void *ptr, unsigned long ip)\n{\n\tstruct page *page;\n\n\tpage = virt_to_head_page(ptr);\n\n\tif (unlikely(!PageSlab(page))) {\n\t\tif (ptr != page_address(page)) {\n\t\t\tkasan_report_invalid_free(ptr, ip);\n\t\t\treturn;\n\t\t}\n\t\tkasan_poison_shadow(ptr, PAGE_SIZE << compound_order(page),\n\t\t\t\tKASAN_FREE_PAGE);\n\t} else {\n\t\t__kasan_slab_free(page->slab_cache, ptr, ip, false);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic __always_inline void kasan_poison_element(mempool_t *pool, void *element)\n{\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\tkasan_poison_kfree(element, _RET_IP_);\n\tif (pool->alloc == mempool_alloc_pages)\n\t\tkasan_free_pages(element, (unsigned long)pool->pool_data);\n}"
  },
  {
    "function_name": "poison_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "101-103",
    "snippet": "static inline void poison_element(mempool_t *pool, void *element)\n{\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void poison_element(mempool_t *pool, void *element)\n{\n}"
  },
  {
    "function_name": "check_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "98-100",
    "snippet": "static inline void check_element(mempool_t *pool, void *element)\n{\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_element(mempool_t *pool, void *element)\n{\n}"
  },
  {
    "function_name": "poison_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "82-96",
    "snippet": "static void poison_element(mempool_t *pool, void *element)\n{\n\t/* Mempools backed by slab allocator */\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\t__poison_element(element, ksize(element));\n\n\t/* Mempools backed by page allocator */\n\tif (pool->alloc == mempool_alloc_pages) {\n\t\tint order = (int)(long)pool->pool_data;\n\t\tvoid *addr = kmap_atomic((struct page *)element);\n\n\t\t__poison_element(addr, 1UL << (PAGE_SHIFT + order));\n\t\tkunmap_atomic(addr);\n\t}\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__poison_element",
          "args": [
            "addr",
            "1UL << (PAGE_SHIFT + order)"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__poison_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "74-80",
          "snippet": "static void __poison_element(void *element, size_t size)\n{\n\tu8 *obj = element;\n\n\tmemset(obj, POISON_FREE, size - 1);\n\tobj[size - 1] = POISON_END;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __poison_element(void *element, size_t size)\n{\n\tu8 *obj = element;\n\n\tmemset(obj, POISON_FREE, size - 1);\n\tobj[size - 1] = POISON_END;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "(struct page *)element"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksize",
          "args": [
            "element"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4465-4480",
          "snippet": "size_t ksize(const void *objp)\n{\n\tsize_t size;\n\n\tBUG_ON(!objp);\n\tif (unlikely(objp == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsize = virt_to_cache(objp)->object_size;\n\t/* We assume that ksize callers could use the whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(objp, size);\n\n\treturn size;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nsize_t ksize(const void *objp)\n{\n\tsize_t size;\n\n\tBUG_ON(!objp);\n\tif (unlikely(objp == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsize = virt_to_cache(objp)->object_size;\n\t/* We assume that ksize callers could use the whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(objp, size);\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void poison_element(mempool_t *pool, void *element)\n{\n\t/* Mempools backed by slab allocator */\n\tif (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)\n\t\t__poison_element(element, ksize(element));\n\n\t/* Mempools backed by page allocator */\n\tif (pool->alloc == mempool_alloc_pages) {\n\t\tint order = (int)(long)pool->pool_data;\n\t\tvoid *addr = kmap_atomic((struct page *)element);\n\n\t\t__poison_element(addr, 1UL << (PAGE_SHIFT + order));\n\t\tkunmap_atomic(addr);\n\t}\n}"
  },
  {
    "function_name": "__poison_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "74-80",
    "snippet": "static void __poison_element(void *element, size_t size)\n{\n\tu8 *obj = element;\n\n\tmemset(obj, POISON_FREE, size - 1);\n\tobj[size - 1] = POISON_END;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "obj",
            "POISON_FREE",
            "size - 1"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __poison_element(void *element, size_t size)\n{\n\tu8 *obj = element;\n\n\tmemset(obj, POISON_FREE, size - 1);\n\tobj[size - 1] = POISON_END;\n}"
  },
  {
    "function_name": "check_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "58-72",
    "snippet": "static void check_element(mempool_t *pool, void *element)\n{\n\t/* Mempools backed by slab allocator */\n\tif (pool->free == mempool_free_slab || pool->free == mempool_kfree)\n\t\t__check_element(pool, element, ksize(element));\n\n\t/* Mempools backed by page allocator */\n\tif (pool->free == mempool_free_pages) {\n\t\tint order = (int)(long)pool->pool_data;\n\t\tvoid *addr = kmap_atomic((struct page *)element);\n\n\t\t__check_element(pool, addr, 1UL << (PAGE_SHIFT + order));\n\t\tkunmap_atomic(addr);\n\t}\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__check_element",
          "args": [
            "pool",
            "addr",
            "1UL << (PAGE_SHIFT + order)"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "__check_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "42-56",
          "snippet": "static void __check_element(mempool_t *pool, void *element, size_t size)\n{\n\tu8 *obj = element;\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tu8 exp = (i < size - 1) ? POISON_FREE : POISON_END;\n\n\t\tif (obj[i] != exp) {\n\t\t\tpoison_error(pool, element, size, i);\n\t\t\treturn;\n\t\t}\n\t}\n\tmemset(obj, POISON_INUSE, size);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __check_element(mempool_t *pool, void *element, size_t size)\n{\n\tu8 *obj = element;\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tu8 exp = (i < size - 1) ? POISON_FREE : POISON_END;\n\n\t\tif (obj[i] != exp) {\n\t\t\tpoison_error(pool, element, size, i);\n\t\t\treturn;\n\t\t}\n\t}\n\tmemset(obj, POISON_INUSE, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "(struct page *)element"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksize",
          "args": [
            "element"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "ksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4465-4480",
          "snippet": "size_t ksize(const void *objp)\n{\n\tsize_t size;\n\n\tBUG_ON(!objp);\n\tif (unlikely(objp == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsize = virt_to_cache(objp)->object_size;\n\t/* We assume that ksize callers could use the whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(objp, size);\n\n\treturn size;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nsize_t ksize(const void *objp)\n{\n\tsize_t size;\n\n\tBUG_ON(!objp);\n\tif (unlikely(objp == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsize = virt_to_cache(objp)->object_size;\n\t/* We assume that ksize callers could use the whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(objp, size);\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void check_element(mempool_t *pool, void *element)\n{\n\t/* Mempools backed by slab allocator */\n\tif (pool->free == mempool_free_slab || pool->free == mempool_kfree)\n\t\t__check_element(pool, element, ksize(element));\n\n\t/* Mempools backed by page allocator */\n\tif (pool->free == mempool_free_pages) {\n\t\tint order = (int)(long)pool->pool_data;\n\t\tvoid *addr = kmap_atomic((struct page *)element);\n\n\t\t__check_element(pool, addr, 1UL << (PAGE_SHIFT + order));\n\t\tkunmap_atomic(addr);\n\t}\n}"
  },
  {
    "function_name": "__check_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "42-56",
    "snippet": "static void __check_element(mempool_t *pool, void *element, size_t size)\n{\n\tu8 *obj = element;\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tu8 exp = (i < size - 1) ? POISON_FREE : POISON_END;\n\n\t\tif (obj[i] != exp) {\n\t\t\tpoison_error(pool, element, size, i);\n\t\t\treturn;\n\t\t}\n\t}\n\tmemset(obj, POISON_INUSE, size);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "obj",
            "POISON_INUSE",
            "size"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poison_error",
          "args": [
            "pool",
            "element",
            "size",
            "i"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "poison_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
          "lines": "25-40",
          "snippet": "static void poison_error(mempool_t *pool, void *element, size_t size,\n\t\t\t size_t byte)\n{\n\tconst int nr = pool->curr_nr;\n\tconst int start = max_t(int, byte - (BITS_PER_LONG / 8), 0);\n\tconst int end = min_t(int, byte + (BITS_PER_LONG / 8), size);\n\tint i;\n\n\tpr_err(\"BUG: mempool element poison mismatch\\n\");\n\tpr_err(\"Mempool %p size %zu\\n\", pool, size);\n\tpr_err(\" nr=%d @ %p: %s0x\", nr, element, start > 0 ? \"... \" : \"\");\n\tfor (i = start; i < end; i++)\n\t\tpr_cont(\"%x \", *(u8 *)(element + i));\n\tpr_cont(\"%s\\n\", end < size ? \"...\" : \"\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/export.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void poison_error(mempool_t *pool, void *element, size_t size,\n\t\t\t size_t byte)\n{\n\tconst int nr = pool->curr_nr;\n\tconst int start = max_t(int, byte - (BITS_PER_LONG / 8), 0);\n\tconst int end = min_t(int, byte + (BITS_PER_LONG / 8), size);\n\tint i;\n\n\tpr_err(\"BUG: mempool element poison mismatch\\n\");\n\tpr_err(\"Mempool %p size %zu\\n\", pool, size);\n\tpr_err(\" nr=%d @ %p: %s0x\", nr, element, start > 0 ? \"... \" : \"\");\n\tfor (i = start; i < end; i++)\n\t\tpr_cont(\"%x \", *(u8 *)(element + i));\n\tpr_cont(\"%s\\n\", end < size ? \"...\" : \"\");\n\tdump_stack();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __check_element(mempool_t *pool, void *element, size_t size)\n{\n\tu8 *obj = element;\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tu8 exp = (i < size - 1) ? POISON_FREE : POISON_END;\n\n\t\tif (obj[i] != exp) {\n\t\t\tpoison_error(pool, element, size, i);\n\t\t\treturn;\n\t\t}\n\t}\n\tmemset(obj, POISON_INUSE, size);\n}"
  },
  {
    "function_name": "poison_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempool.c",
    "lines": "25-40",
    "snippet": "static void poison_error(mempool_t *pool, void *element, size_t size,\n\t\t\t size_t byte)\n{\n\tconst int nr = pool->curr_nr;\n\tconst int start = max_t(int, byte - (BITS_PER_LONG / 8), 0);\n\tconst int end = min_t(int, byte + (BITS_PER_LONG / 8), size);\n\tint i;\n\n\tpr_err(\"BUG: mempool element poison mismatch\\n\");\n\tpr_err(\"Mempool %p size %zu\\n\", pool, size);\n\tpr_err(\" nr=%d @ %p: %s0x\", nr, element, start > 0 ? \"... \" : \"\");\n\tfor (i = start; i < end; i++)\n\t\tpr_cont(\"%x \", *(u8 *)(element + i));\n\tpr_cont(\"%s\\n\", end < size ? \"...\" : \"\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/export.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s\\n\"",
            "end < size ? \"...\" : \"\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%x \"",
            "*(u8 *)(element + i)"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\" nr=%d @ %p: %s0x\"",
            "nr",
            "element",
            "start > 0 ? \"... \" : \"\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Mempool %p size %zu\\n\"",
            "pool",
            "size"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BUG: mempool element poison mismatch\\n\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "byte + (BITS_PER_LONG / 8)",
            "size"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "int",
            "byte - (BITS_PER_LONG / 8)",
            "0"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void poison_error(mempool_t *pool, void *element, size_t size,\n\t\t\t size_t byte)\n{\n\tconst int nr = pool->curr_nr;\n\tconst int start = max_t(int, byte - (BITS_PER_LONG / 8), 0);\n\tconst int end = min_t(int, byte + (BITS_PER_LONG / 8), size);\n\tint i;\n\n\tpr_err(\"BUG: mempool element poison mismatch\\n\");\n\tpr_err(\"Mempool %p size %zu\\n\", pool, size);\n\tpr_err(\" nr=%d @ %p: %s0x\", nr, element, start > 0 ? \"... \" : \"\");\n\tfor (i = start; i < end; i++)\n\t\tpr_cont(\"%x \", *(u8 *)(element + i));\n\tpr_cont(\"%s\\n\", end < size ? \"...\" : \"\");\n\tdump_stack();\n}"
  }
]