[
  {
    "function_name": "madvise_behavior_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "704-738",
    "snippet": "static bool\nmadvise_behavior_valid(int behavior)\n{\n\tswitch (behavior) {\n\tcase MADV_DOFORK:\n\tcase MADV_DONTFORK:\n\tcase MADV_NORMAL:\n\tcase MADV_SEQUENTIAL:\n\tcase MADV_RANDOM:\n\tcase MADV_REMOVE:\n\tcase MADV_WILLNEED:\n\tcase MADV_DONTNEED:\n\tcase MADV_FREE:\n#ifdef CONFIG_KSM\n\tcase MADV_MERGEABLE:\n\tcase MADV_UNMERGEABLE:\n#endif\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tcase MADV_HUGEPAGE:\n\tcase MADV_NOHUGEPAGE:\n#endif\n\tcase MADV_DONTDUMP:\n\tcase MADV_DODUMP:\n\tcase MADV_WIPEONFORK:\n\tcase MADV_KEEPONFORK:\n#ifdef CONFIG_MEMORY_FAILURE\n\tcase MADV_SOFT_OFFLINE:\n\tcase MADV_HWPOISON:\n#endif\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic bool\nmadvise_behavior_valid(int behavior)\n{\n\tswitch (behavior) {\n\tcase MADV_DOFORK:\n\tcase MADV_DONTFORK:\n\tcase MADV_NORMAL:\n\tcase MADV_SEQUENTIAL:\n\tcase MADV_RANDOM:\n\tcase MADV_REMOVE:\n\tcase MADV_WILLNEED:\n\tcase MADV_DONTNEED:\n\tcase MADV_FREE:\n#ifdef CONFIG_KSM\n\tcase MADV_MERGEABLE:\n\tcase MADV_UNMERGEABLE:\n#endif\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tcase MADV_HUGEPAGE:\n\tcase MADV_NOHUGEPAGE:\n#endif\n\tcase MADV_DONTDUMP:\n\tcase MADV_DODUMP:\n\tcase MADV_WIPEONFORK:\n\tcase MADV_KEEPONFORK:\n#ifdef CONFIG_MEMORY_FAILURE\n\tcase MADV_SOFT_OFFLINE:\n\tcase MADV_HWPOISON:\n#endif\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "madvise_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "687-702",
    "snippet": "static long\nmadvise_vma(struct vm_area_struct *vma, struct vm_area_struct **prev,\n\t\tunsigned long start, unsigned long end, int behavior)\n{\n\tswitch (behavior) {\n\tcase MADV_REMOVE:\n\t\treturn madvise_remove(vma, prev, start, end);\n\tcase MADV_WILLNEED:\n\t\treturn madvise_willneed(vma, prev, start, end);\n\tcase MADV_FREE:\n\tcase MADV_DONTNEED:\n\t\treturn madvise_dontneed_free(vma, prev, start, end, behavior);\n\tdefault:\n\t\treturn madvise_behavior(vma, prev, start, end, behavior);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "madvise_behavior",
          "args": [
            "vma",
            "prev",
            "start",
            "end",
            "behavior"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "madvise_behavior",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
          "lines": "55-190",
          "snippet": "static long madvise_behavior(struct vm_area_struct *vma,\n\t\t     struct vm_area_struct **prev,\n\t\t     unsigned long start, unsigned long end, int behavior)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint error = 0;\n\tpgoff_t pgoff;\n\tunsigned long new_flags = vma->vm_flags;\n\n\tswitch (behavior) {\n\tcase MADV_NORMAL:\n\t\tnew_flags = new_flags & ~VM_RAND_READ & ~VM_SEQ_READ;\n\t\tbreak;\n\tcase MADV_SEQUENTIAL:\n\t\tnew_flags = (new_flags & ~VM_RAND_READ) | VM_SEQ_READ;\n\t\tbreak;\n\tcase MADV_RANDOM:\n\t\tnew_flags = (new_flags & ~VM_SEQ_READ) | VM_RAND_READ;\n\t\tbreak;\n\tcase MADV_DONTFORK:\n\t\tnew_flags |= VM_DONTCOPY;\n\t\tbreak;\n\tcase MADV_DOFORK:\n\t\tif (vma->vm_flags & VM_IO) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags &= ~VM_DONTCOPY;\n\t\tbreak;\n\tcase MADV_WIPEONFORK:\n\t\t/* MADV_WIPEONFORK is only supported on anonymous memory. */\n\t\tif (vma->vm_file || vma->vm_flags & VM_SHARED) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags |= VM_WIPEONFORK;\n\t\tbreak;\n\tcase MADV_KEEPONFORK:\n\t\tnew_flags &= ~VM_WIPEONFORK;\n\t\tbreak;\n\tcase MADV_DONTDUMP:\n\t\tnew_flags |= VM_DONTDUMP;\n\t\tbreak;\n\tcase MADV_DODUMP:\n\t\tif (!is_vm_hugetlb_page(vma) && new_flags & VM_SPECIAL) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags &= ~VM_DONTDUMP;\n\t\tbreak;\n\tcase MADV_MERGEABLE:\n\tcase MADV_UNMERGEABLE:\n\t\terror = ksm_madvise(vma, start, end, behavior, &new_flags);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MADV_HUGEPAGE:\n\tcase MADV_NOHUGEPAGE:\n\t\terror = hugepage_madvise(vma, &new_flags, behavior);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (new_flags == vma->vm_flags) {\n\t\t*prev = vma;\n\t\tgoto out;\n\t}\n\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*prev = vma_merge(mm, *prev, start, end, new_flags, vma->anon_vma,\n\t\t\t  vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t  vma->vm_userfaultfd_ctx);\n\tif (*prev) {\n\t\tvma = *prev;\n\t\tgoto success;\n\t}\n\n\t*prev = vma;\n\n\tif (start != vma->vm_start) {\n\t\tif (unlikely(mm->map_count >= sysctl_max_map_count)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = __split_vma(mm, vma, start, 1);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (end != vma->vm_end) {\n\t\tif (unlikely(mm->map_count >= sysctl_max_map_count)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = __split_vma(mm, vma, end, 0);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nsuccess:\n\t/*\n\t * vm_flags is protected by the mmap_sem held in write mode.\n\t */\n\tvma->vm_flags = new_flags;\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched.h>",
            "#include <linux/falloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic long madvise_behavior(struct vm_area_struct *vma,\n\t\t     struct vm_area_struct **prev,\n\t\t     unsigned long start, unsigned long end, int behavior)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint error = 0;\n\tpgoff_t pgoff;\n\tunsigned long new_flags = vma->vm_flags;\n\n\tswitch (behavior) {\n\tcase MADV_NORMAL:\n\t\tnew_flags = new_flags & ~VM_RAND_READ & ~VM_SEQ_READ;\n\t\tbreak;\n\tcase MADV_SEQUENTIAL:\n\t\tnew_flags = (new_flags & ~VM_RAND_READ) | VM_SEQ_READ;\n\t\tbreak;\n\tcase MADV_RANDOM:\n\t\tnew_flags = (new_flags & ~VM_SEQ_READ) | VM_RAND_READ;\n\t\tbreak;\n\tcase MADV_DONTFORK:\n\t\tnew_flags |= VM_DONTCOPY;\n\t\tbreak;\n\tcase MADV_DOFORK:\n\t\tif (vma->vm_flags & VM_IO) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags &= ~VM_DONTCOPY;\n\t\tbreak;\n\tcase MADV_WIPEONFORK:\n\t\t/* MADV_WIPEONFORK is only supported on anonymous memory. */\n\t\tif (vma->vm_file || vma->vm_flags & VM_SHARED) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags |= VM_WIPEONFORK;\n\t\tbreak;\n\tcase MADV_KEEPONFORK:\n\t\tnew_flags &= ~VM_WIPEONFORK;\n\t\tbreak;\n\tcase MADV_DONTDUMP:\n\t\tnew_flags |= VM_DONTDUMP;\n\t\tbreak;\n\tcase MADV_DODUMP:\n\t\tif (!is_vm_hugetlb_page(vma) && new_flags & VM_SPECIAL) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags &= ~VM_DONTDUMP;\n\t\tbreak;\n\tcase MADV_MERGEABLE:\n\tcase MADV_UNMERGEABLE:\n\t\terror = ksm_madvise(vma, start, end, behavior, &new_flags);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MADV_HUGEPAGE:\n\tcase MADV_NOHUGEPAGE:\n\t\terror = hugepage_madvise(vma, &new_flags, behavior);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (new_flags == vma->vm_flags) {\n\t\t*prev = vma;\n\t\tgoto out;\n\t}\n\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*prev = vma_merge(mm, *prev, start, end, new_flags, vma->anon_vma,\n\t\t\t  vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t  vma->vm_userfaultfd_ctx);\n\tif (*prev) {\n\t\tvma = *prev;\n\t\tgoto success;\n\t}\n\n\t*prev = vma;\n\n\tif (start != vma->vm_start) {\n\t\tif (unlikely(mm->map_count >= sysctl_max_map_count)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = __split_vma(mm, vma, start, 1);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (end != vma->vm_end) {\n\t\tif (unlikely(mm->map_count >= sysctl_max_map_count)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = __split_vma(mm, vma, end, 0);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nsuccess:\n\t/*\n\t * vm_flags is protected by the mmap_sem held in write mode.\n\t */\n\tvma->vm_flags = new_flags;\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "madvise_dontneed_free",
          "args": [
            "vma",
            "prev",
            "start",
            "end",
            "behavior"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "madvise_dontneed_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
          "lines": "514-568",
          "snippet": "static long madvise_dontneed_free(struct vm_area_struct *vma,\n\t\t\t\t  struct vm_area_struct **prev,\n\t\t\t\t  unsigned long start, unsigned long end,\n\t\t\t\t  int behavior)\n{\n\t*prev = vma;\n\tif (!can_madv_dontneed_vma(vma))\n\t\treturn -EINVAL;\n\n\tif (!userfaultfd_remove(vma, start, end)) {\n\t\t*prev = NULL; /* mmap_sem has been dropped, prev is stale */\n\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tvma = find_vma(current->mm, start);\n\t\tif (!vma)\n\t\t\treturn -ENOMEM;\n\t\tif (start < vma->vm_start) {\n\t\t\t/*\n\t\t\t * This \"vma\" under revalidation is the one\n\t\t\t * with the lowest vma->vm_start where start\n\t\t\t * is also < vma->vm_end. If start <\n\t\t\t * vma->vm_start it means an hole materialized\n\t\t\t * in the user address space within the\n\t\t\t * virtual range passed to MADV_DONTNEED\n\t\t\t * or MADV_FREE.\n\t\t\t */\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\treturn -EINVAL;\n\t\tif (end > vma->vm_end) {\n\t\t\t/*\n\t\t\t * Don't fail if end > vma->vm_end. If the old\n\t\t\t * vma was splitted while the mmap_sem was\n\t\t\t * released the effect of the concurrent\n\t\t\t * operation may not cause madvise() to\n\t\t\t * have an undefined result. There may be an\n\t\t\t * adjacent next vma that we'll walk\n\t\t\t * next. userfaultfd_remove() will generate an\n\t\t\t * UFFD_EVENT_REMOVE repetition on the\n\t\t\t * end-vma->vm_end range, but the manager can\n\t\t\t * handle a repetition fine.\n\t\t\t */\n\t\t\tend = vma->vm_end;\n\t\t}\n\t\tVM_WARN_ON(start >= end);\n\t}\n\n\tif (behavior == MADV_DONTNEED)\n\t\treturn madvise_dontneed_single_vma(vma, start, end);\n\telse if (behavior == MADV_FREE)\n\t\treturn madvise_free_single_vma(vma, start, end);\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched.h>",
            "#include <linux/falloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic long madvise_dontneed_free(struct vm_area_struct *vma,\n\t\t\t\t  struct vm_area_struct **prev,\n\t\t\t\t  unsigned long start, unsigned long end,\n\t\t\t\t  int behavior)\n{\n\t*prev = vma;\n\tif (!can_madv_dontneed_vma(vma))\n\t\treturn -EINVAL;\n\n\tif (!userfaultfd_remove(vma, start, end)) {\n\t\t*prev = NULL; /* mmap_sem has been dropped, prev is stale */\n\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tvma = find_vma(current->mm, start);\n\t\tif (!vma)\n\t\t\treturn -ENOMEM;\n\t\tif (start < vma->vm_start) {\n\t\t\t/*\n\t\t\t * This \"vma\" under revalidation is the one\n\t\t\t * with the lowest vma->vm_start where start\n\t\t\t * is also < vma->vm_end. If start <\n\t\t\t * vma->vm_start it means an hole materialized\n\t\t\t * in the user address space within the\n\t\t\t * virtual range passed to MADV_DONTNEED\n\t\t\t * or MADV_FREE.\n\t\t\t */\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\treturn -EINVAL;\n\t\tif (end > vma->vm_end) {\n\t\t\t/*\n\t\t\t * Don't fail if end > vma->vm_end. If the old\n\t\t\t * vma was splitted while the mmap_sem was\n\t\t\t * released the effect of the concurrent\n\t\t\t * operation may not cause madvise() to\n\t\t\t * have an undefined result. There may be an\n\t\t\t * adjacent next vma that we'll walk\n\t\t\t * next. userfaultfd_remove() will generate an\n\t\t\t * UFFD_EVENT_REMOVE repetition on the\n\t\t\t * end-vma->vm_end range, but the manager can\n\t\t\t * handle a repetition fine.\n\t\t\t */\n\t\t\tend = vma->vm_end;\n\t\t}\n\t\tVM_WARN_ON(start >= end);\n\t}\n\n\tif (behavior == MADV_DONTNEED)\n\t\treturn madvise_dontneed_single_vma(vma, start, end);\n\telse if (behavior == MADV_FREE)\n\t\treturn madvise_free_single_vma(vma, start, end);\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "madvise_willneed",
          "args": [
            "vma",
            "prev",
            "start",
            "end"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "madvise_willneed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
          "lines": "273-308",
          "snippet": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n\n\t*prev = vma;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\n\tif (shmem_mapping(file->f_mapping)) {\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\n\tif (IS_DAX(file_inode(file))) {\n\t\t/* no bad return value, but ignore advice */\n\t\treturn 0;\n\t}\n\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched.h>",
            "#include <linux/falloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n\n\t*prev = vma;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\n\tif (shmem_mapping(file->f_mapping)) {\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\n\tif (IS_DAX(file_inode(file))) {\n\t\t/* no bad return value, but ignore advice */\n\t\treturn 0;\n\t}\n\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "madvise_remove",
          "args": [
            "vma",
            "prev",
            "start",
            "end"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "madvise_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
          "lines": "574-616",
          "snippet": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\tstruct file *f;\n\n\t*prev = NULL;\t/* tell sys_madvise we drop mmap_sem */\n\n\tif (vma->vm_flags & VM_LOCKED)\n\t\treturn -EINVAL;\n\n\tf = vma->vm_file;\n\n\tif (!f || !f->f_mapping || !f->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\n\t/*\n\t * Filesystem's fallocate may need to take i_mutex.  We need to\n\t * explicitly grab a reference because the vma (and hence the\n\t * vma's reference to the file) can go away as soon as we drop\n\t * mmap_sem.\n\t */\n\tget_file(f);\n\tif (userfaultfd_remove(vma, start, end)) {\n\t\t/* mmap_sem was not released by userfaultfd_remove() */\n\t\tup_read(&current->mm->mmap_sem);\n\t}\n\terror = vfs_fallocate(f,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tfput(f);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched.h>",
            "#include <linux/falloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\tstruct file *f;\n\n\t*prev = NULL;\t/* tell sys_madvise we drop mmap_sem */\n\n\tif (vma->vm_flags & VM_LOCKED)\n\t\treturn -EINVAL;\n\n\tf = vma->vm_file;\n\n\tif (!f || !f->f_mapping || !f->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\n\t/*\n\t * Filesystem's fallocate may need to take i_mutex.  We need to\n\t * explicitly grab a reference because the vma (and hence the\n\t * vma's reference to the file) can go away as soon as we drop\n\t * mmap_sem.\n\t */\n\tget_file(f);\n\tif (userfaultfd_remove(vma, start, end)) {\n\t\t/* mmap_sem was not released by userfaultfd_remove() */\n\t\tup_read(&current->mm->mmap_sem);\n\t}\n\terror = vfs_fallocate(f,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tfput(f);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic long\nmadvise_vma(struct vm_area_struct *vma, struct vm_area_struct **prev,\n\t\tunsigned long start, unsigned long end, int behavior)\n{\n\tswitch (behavior) {\n\tcase MADV_REMOVE:\n\t\treturn madvise_remove(vma, prev, start, end);\n\tcase MADV_WILLNEED:\n\t\treturn madvise_willneed(vma, prev, start, end);\n\tcase MADV_FREE:\n\tcase MADV_DONTNEED:\n\t\treturn madvise_dontneed_free(vma, prev, start, end, behavior);\n\tdefault:\n\t\treturn madvise_behavior(vma, prev, start, end, behavior);\n\t}\n}"
  },
  {
    "function_name": "madvise_inject_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "622-684",
    "snippet": "static int madvise_inject_error(int behavior,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct page *page;\n\tstruct zone *zone;\n\tunsigned int order;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\n\tfor (; start < end; start += PAGE_SIZE << order) {\n\t\tunsigned long pfn;\n\t\tint ret;\n\n\t\tret = get_user_pages_fast(start, 1, 0, &page);\n\t\tif (ret != 1)\n\t\t\treturn ret;\n\t\tpfn = page_to_pfn(page);\n\n\t\t/*\n\t\t * When soft offlining hugepages, after migrating the page\n\t\t * we dissolve it, therefore in the second loop \"page\" will\n\t\t * no longer be a compound page, and order will be 0.\n\t\t */\n\t\torder = compound_order(compound_head(page));\n\n\t\tif (PageHWPoison(page)) {\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (behavior == MADV_SOFT_OFFLINE) {\n\t\t\tpr_info(\"Soft offlining pfn %#lx at process virtual address %#lx\\n\",\n\t\t\t\t\tpfn, start);\n\n\t\t\tret = soft_offline_page(page, MF_COUNT_INCREASED);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"Injecting memory failure for pfn %#lx at process virtual address %#lx\\n\",\n\t\t\t\tpfn, start);\n\n\t\t/*\n\t\t * Drop the page reference taken by get_user_pages_fast(). In\n\t\t * the absence of MF_COUNT_INCREASED the memory_failure()\n\t\t * routine is responsible for pinning the page to prevent it\n\t\t * from being released back to the page allocator.\n\t\t */\n\t\tput_page(page);\n\t\tret = memory_failure(pfn, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Ensure that all poisoned pages are removed from per-cpu lists */\n\tfor_each_populated_zone(zone)\n\t\tdrain_all_pages(zone);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memory_failure",
          "args": [
            "pfn",
            "0"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "memory_failure_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1455-1473",
          "snippet": "void memory_failure_queue(unsigned long pfn, int flags)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tunsigned long proc_flags;\n\tstruct memory_failure_entry entry = {\n\t\t.pfn =\t\tpfn,\n\t\t.flags =\tflags,\n\t};\n\n\tmf_cpu = &get_cpu_var(memory_failure_cpu);\n\tspin_lock_irqsave(&mf_cpu->lock, proc_flags);\n\tif (kfifo_put(&mf_cpu->fifo, entry))\n\t\tschedule_work_on(smp_processor_id(), &mf_cpu->work);\n\telse\n\t\tpr_err(\"Memory failure: buffer overflow when queuing memory failure at %#lx\\n\",\n\t\t       pfn);\n\tspin_unlock_irqrestore(&mf_cpu->lock, proc_flags);\n\tput_cpu_var(memory_failure_cpu);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);\n\nvoid memory_failure_queue(unsigned long pfn, int flags)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tunsigned long proc_flags;\n\tstruct memory_failure_entry entry = {\n\t\t.pfn =\t\tpfn,\n\t\t.flags =\tflags,\n\t};\n\n\tmf_cpu = &get_cpu_var(memory_failure_cpu);\n\tspin_lock_irqsave(&mf_cpu->lock, proc_flags);\n\tif (kfifo_put(&mf_cpu->fifo, entry))\n\t\tschedule_work_on(smp_processor_id(), &mf_cpu->work);\n\telse\n\t\tpr_err(\"Memory failure: buffer overflow when queuing memory failure at %#lx\\n\",\n\t\t       pfn);\n\tspin_unlock_irqrestore(&mf_cpu->lock, proc_flags);\n\tput_cpu_var(memory_failure_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Injecting memory failure for pfn %#lx at process virtual address %#lx\\n\"",
            "pfn",
            "start"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "soft_offline_page",
          "args": [
            "page",
            "MF_COUNT_INCREASED"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "soft_offline_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1895-1925",
          "snippet": "int soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (is_zone_device_page(page)) {\n\t\tpr_debug_ratelimited(\"soft_offline: %#lx page is device page\\n\",\n\t\t\t\tpfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_page(page);\n\t\treturn -EIO;\n\t}\n\n\tif (PageHWPoison(page)) {\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_hwpoison_page(page);\n\t\treturn -EBUSY;\n\t}\n\n\tget_online_mems();\n\tret = get_any_page(page, pfn, flags);\n\tput_online_mems();\n\n\tif (ret > 0)\n\t\tret = soft_offline_in_use_page(page, flags);\n\telse if (ret == 0)\n\t\tret = soft_offline_free_page(page);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (is_zone_device_page(page)) {\n\t\tpr_debug_ratelimited(\"soft_offline: %#lx page is device page\\n\",\n\t\t\t\tpfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_page(page);\n\t\treturn -EIO;\n\t}\n\n\tif (PageHWPoison(page)) {\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_hwpoison_page(page);\n\t\treturn -EBUSY;\n\t}\n\n\tget_online_mems();\n\tret = get_any_page(page, pfn, flags);\n\tput_online_mems();\n\n\tif (ret > 0)\n\t\tret = soft_offline_in_use_page(page, flags);\n\telse if (ret == 0)\n\t\tret = soft_offline_free_page(page);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Soft offlining pfn %#lx at process virtual address %#lx\\n\"",
            "pfn",
            "start"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "compound_head(page)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages_fast",
          "args": [
            "start",
            "1",
            "0",
            "&page"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_pages_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "329-334",
          "snippet": "int __weak get_user_pages_fast(unsigned long start,\n\t\t\t\tint nr_pages, int write, struct page **pages)\n{\n\treturn get_user_pages_unlocked(start, nr_pages, pages,\n\t\t\t\t       write ? FOLL_WRITE : 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __weak get_user_pages_fast(unsigned long start,\n\t\t\t\tint nr_pages, int write, struct page **pages)\n{\n\treturn get_user_pages_unlocked(start, nr_pages, pages,\n\t\t\t\t       write ? FOLL_WRITE : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic int madvise_inject_error(int behavior,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct page *page;\n\tstruct zone *zone;\n\tunsigned int order;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\n\tfor (; start < end; start += PAGE_SIZE << order) {\n\t\tunsigned long pfn;\n\t\tint ret;\n\n\t\tret = get_user_pages_fast(start, 1, 0, &page);\n\t\tif (ret != 1)\n\t\t\treturn ret;\n\t\tpfn = page_to_pfn(page);\n\n\t\t/*\n\t\t * When soft offlining hugepages, after migrating the page\n\t\t * we dissolve it, therefore in the second loop \"page\" will\n\t\t * no longer be a compound page, and order will be 0.\n\t\t */\n\t\torder = compound_order(compound_head(page));\n\n\t\tif (PageHWPoison(page)) {\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (behavior == MADV_SOFT_OFFLINE) {\n\t\t\tpr_info(\"Soft offlining pfn %#lx at process virtual address %#lx\\n\",\n\t\t\t\t\tpfn, start);\n\n\t\t\tret = soft_offline_page(page, MF_COUNT_INCREASED);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"Injecting memory failure for pfn %#lx at process virtual address %#lx\\n\",\n\t\t\t\tpfn, start);\n\n\t\t/*\n\t\t * Drop the page reference taken by get_user_pages_fast(). In\n\t\t * the absence of MF_COUNT_INCREASED the memory_failure()\n\t\t * routine is responsible for pinning the page to prevent it\n\t\t * from being released back to the page allocator.\n\t\t */\n\t\tput_page(page);\n\t\tret = memory_failure(pfn, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Ensure that all poisoned pages are removed from per-cpu lists */\n\tfor_each_populated_zone(zone)\n\t\tdrain_all_pages(zone);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "madvise_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "574-616",
    "snippet": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\tstruct file *f;\n\n\t*prev = NULL;\t/* tell sys_madvise we drop mmap_sem */\n\n\tif (vma->vm_flags & VM_LOCKED)\n\t\treturn -EINVAL;\n\n\tf = vma->vm_file;\n\n\tif (!f || !f->f_mapping || !f->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\n\t/*\n\t * Filesystem's fallocate may need to take i_mutex.  We need to\n\t * explicitly grab a reference because the vma (and hence the\n\t * vma's reference to the file) can go away as soon as we drop\n\t * mmap_sem.\n\t */\n\tget_file(f);\n\tif (userfaultfd_remove(vma, start, end)) {\n\t\t/* mmap_sem was not released by userfaultfd_remove() */\n\t\tup_read(&current->mm->mmap_sem);\n\t}\n\terror = vfs_fallocate(f,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tfput(f);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_fallocate",
          "args": [
            "f",
            "FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE",
            "offset",
            "end - start"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_remove",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "f"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "start - vma->vm_start"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\tstruct file *f;\n\n\t*prev = NULL;\t/* tell sys_madvise we drop mmap_sem */\n\n\tif (vma->vm_flags & VM_LOCKED)\n\t\treturn -EINVAL;\n\n\tf = vma->vm_file;\n\n\tif (!f || !f->f_mapping || !f->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\n\t/*\n\t * Filesystem's fallocate may need to take i_mutex.  We need to\n\t * explicitly grab a reference because the vma (and hence the\n\t * vma's reference to the file) can go away as soon as we drop\n\t * mmap_sem.\n\t */\n\tget_file(f);\n\tif (userfaultfd_remove(vma, start, end)) {\n\t\t/* mmap_sem was not released by userfaultfd_remove() */\n\t\tup_read(&current->mm->mmap_sem);\n\t}\n\terror = vfs_fallocate(f,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tfput(f);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}"
  },
  {
    "function_name": "madvise_dontneed_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "514-568",
    "snippet": "static long madvise_dontneed_free(struct vm_area_struct *vma,\n\t\t\t\t  struct vm_area_struct **prev,\n\t\t\t\t  unsigned long start, unsigned long end,\n\t\t\t\t  int behavior)\n{\n\t*prev = vma;\n\tif (!can_madv_dontneed_vma(vma))\n\t\treturn -EINVAL;\n\n\tif (!userfaultfd_remove(vma, start, end)) {\n\t\t*prev = NULL; /* mmap_sem has been dropped, prev is stale */\n\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tvma = find_vma(current->mm, start);\n\t\tif (!vma)\n\t\t\treturn -ENOMEM;\n\t\tif (start < vma->vm_start) {\n\t\t\t/*\n\t\t\t * This \"vma\" under revalidation is the one\n\t\t\t * with the lowest vma->vm_start where start\n\t\t\t * is also < vma->vm_end. If start <\n\t\t\t * vma->vm_start it means an hole materialized\n\t\t\t * in the user address space within the\n\t\t\t * virtual range passed to MADV_DONTNEED\n\t\t\t * or MADV_FREE.\n\t\t\t */\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\treturn -EINVAL;\n\t\tif (end > vma->vm_end) {\n\t\t\t/*\n\t\t\t * Don't fail if end > vma->vm_end. If the old\n\t\t\t * vma was splitted while the mmap_sem was\n\t\t\t * released the effect of the concurrent\n\t\t\t * operation may not cause madvise() to\n\t\t\t * have an undefined result. There may be an\n\t\t\t * adjacent next vma that we'll walk\n\t\t\t * next. userfaultfd_remove() will generate an\n\t\t\t * UFFD_EVENT_REMOVE repetition on the\n\t\t\t * end-vma->vm_end range, but the manager can\n\t\t\t * handle a repetition fine.\n\t\t\t */\n\t\t\tend = vma->vm_end;\n\t\t}\n\t\tVM_WARN_ON(start >= end);\n\t}\n\n\tif (behavior == MADV_DONTNEED)\n\t\treturn madvise_dontneed_single_vma(vma, start, end);\n\telse if (behavior == MADV_FREE)\n\t\treturn madvise_free_single_vma(vma, start, end);\n\telse\n\t\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "madvise_free_single_vma",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "madvise_free_single_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
          "lines": "458-486",
          "snippet": "static int madvise_free_single_vma(struct vm_area_struct *vma,\n\t\t\tunsigned long start_addr, unsigned long end_addr)\n{\n\tunsigned long start, end;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\n\t/* MADV_FREE works for only anon vma at the moment */\n\tif (!vma_is_anonymous(vma))\n\t\treturn -EINVAL;\n\n\tstart = max(vma->vm_start, start_addr);\n\tif (start >= vma->vm_end)\n\t\treturn -EINVAL;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn -EINVAL;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\n\tmmu_notifier_invalidate_range_start(mm, start, end);\n\tmadvise_free_page_range(&tlb, vma, start, end);\n\tmmu_notifier_invalidate_range_end(mm, start, end);\n\ttlb_finish_mmu(&tlb, start, end);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched.h>",
            "#include <linux/falloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic int madvise_free_single_vma(struct vm_area_struct *vma,\n\t\t\tunsigned long start_addr, unsigned long end_addr)\n{\n\tunsigned long start, end;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\n\t/* MADV_FREE works for only anon vma at the moment */\n\tif (!vma_is_anonymous(vma))\n\t\treturn -EINVAL;\n\n\tstart = max(vma->vm_start, start_addr);\n\tif (start >= vma->vm_end)\n\t\treturn -EINVAL;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn -EINVAL;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\n\tmmu_notifier_invalidate_range_start(mm, start, end);\n\tmadvise_free_page_range(&tlb, vma, start, end);\n\tmmu_notifier_invalidate_range_end(mm, start, end);\n\ttlb_finish_mmu(&tlb, start, end);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "madvise_dontneed_single_vma",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "madvise_dontneed_single_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
          "lines": "507-512",
          "snippet": "static long madvise_dontneed_single_vma(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long start, unsigned long end)\n{\n\tzap_page_range(vma, start, end - start);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched.h>",
            "#include <linux/falloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic long madvise_dontneed_single_vma(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long start, unsigned long end)\n{\n\tzap_page_range(vma, start, end - start);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "start >= end"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_madv_dontneed_vma",
          "args": [
            "vma"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "can_madv_dontneed_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "46-49",
          "snippet": "static inline bool can_madv_dontneed_vma(struct vm_area_struct *vma)\n{\n\treturn !(vma->vm_flags & (VM_LOCKED|VM_HUGETLB|VM_PFNMAP));\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool can_madv_dontneed_vma(struct vm_area_struct *vma)\n{\n\treturn !(vma->vm_flags & (VM_LOCKED|VM_HUGETLB|VM_PFNMAP));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "current->mm",
            "start"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_remove",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic long madvise_dontneed_free(struct vm_area_struct *vma,\n\t\t\t\t  struct vm_area_struct **prev,\n\t\t\t\t  unsigned long start, unsigned long end,\n\t\t\t\t  int behavior)\n{\n\t*prev = vma;\n\tif (!can_madv_dontneed_vma(vma))\n\t\treturn -EINVAL;\n\n\tif (!userfaultfd_remove(vma, start, end)) {\n\t\t*prev = NULL; /* mmap_sem has been dropped, prev is stale */\n\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tvma = find_vma(current->mm, start);\n\t\tif (!vma)\n\t\t\treturn -ENOMEM;\n\t\tif (start < vma->vm_start) {\n\t\t\t/*\n\t\t\t * This \"vma\" under revalidation is the one\n\t\t\t * with the lowest vma->vm_start where start\n\t\t\t * is also < vma->vm_end. If start <\n\t\t\t * vma->vm_start it means an hole materialized\n\t\t\t * in the user address space within the\n\t\t\t * virtual range passed to MADV_DONTNEED\n\t\t\t * or MADV_FREE.\n\t\t\t */\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\treturn -EINVAL;\n\t\tif (end > vma->vm_end) {\n\t\t\t/*\n\t\t\t * Don't fail if end > vma->vm_end. If the old\n\t\t\t * vma was splitted while the mmap_sem was\n\t\t\t * released the effect of the concurrent\n\t\t\t * operation may not cause madvise() to\n\t\t\t * have an undefined result. There may be an\n\t\t\t * adjacent next vma that we'll walk\n\t\t\t * next. userfaultfd_remove() will generate an\n\t\t\t * UFFD_EVENT_REMOVE repetition on the\n\t\t\t * end-vma->vm_end range, but the manager can\n\t\t\t * handle a repetition fine.\n\t\t\t */\n\t\t\tend = vma->vm_end;\n\t\t}\n\t\tVM_WARN_ON(start >= end);\n\t}\n\n\tif (behavior == MADV_DONTNEED)\n\t\treturn madvise_dontneed_single_vma(vma, start, end);\n\telse if (behavior == MADV_FREE)\n\t\treturn madvise_free_single_vma(vma, start, end);\n\telse\n\t\treturn -EINVAL;\n}"
  },
  {
    "function_name": "madvise_dontneed_single_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "507-512",
    "snippet": "static long madvise_dontneed_single_vma(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long start, unsigned long end)\n{\n\tzap_page_range(vma, start, end - start);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zap_page_range",
          "args": [
            "vma",
            "start",
            "end - start"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "zap_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1351-1366",
          "snippet": "void zap_page_range(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long size)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = start + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, start, end);\n\tfor ( ; vma && vma->vm_start < end; vma = vma->vm_next)\n\t\tunmap_single_vma(&tlb, vma, start, end, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start, end);\n\ttlb_finish_mmu(&tlb, start, end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid zap_page_range(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long size)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = start + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, start, end);\n\tfor ( ; vma && vma->vm_start < end; vma = vma->vm_next)\n\t\tunmap_single_vma(&tlb, vma, start, end, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start, end);\n\ttlb_finish_mmu(&tlb, start, end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic long madvise_dontneed_single_vma(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long start, unsigned long end)\n{\n\tzap_page_range(vma, start, end - start);\n\treturn 0;\n}"
  },
  {
    "function_name": "madvise_free_single_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "458-486",
    "snippet": "static int madvise_free_single_vma(struct vm_area_struct *vma,\n\t\t\tunsigned long start_addr, unsigned long end_addr)\n{\n\tunsigned long start, end;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\n\t/* MADV_FREE works for only anon vma at the moment */\n\tif (!vma_is_anonymous(vma))\n\t\treturn -EINVAL;\n\n\tstart = max(vma->vm_start, start_addr);\n\tif (start >= vma->vm_end)\n\t\treturn -EINVAL;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn -EINVAL;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\n\tmmu_notifier_invalidate_range_start(mm, start, end);\n\tmadvise_free_page_range(&tlb, vma, start, end);\n\tmmu_notifier_invalidate_range_end(mm, start, end);\n\ttlb_finish_mmu(&tlb, start, end);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_finish_mmu",
          "args": [
            "&tlb",
            "start",
            "end"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_finish_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "247-261",
          "snippet": "void tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "start",
            "end"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "madvise_free_page_range",
          "args": [
            "&tlb",
            "vma",
            "start",
            "end"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "madvise_free_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
          "lines": "443-456",
          "snippet": "static void madvise_free_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end)\n{\n\tstruct mm_walk free_walk = {\n\t\t.pmd_entry = madvise_free_pte_range,\n\t\t.mm = vma->vm_mm,\n\t\t.private = tlb,\n\t};\n\n\ttlb_start_vma(tlb, vma);\n\twalk_page_range(addr, end, &free_walk);\n\ttlb_end_vma(tlb, vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched.h>",
            "#include <linux/falloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic void madvise_free_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end)\n{\n\tstruct mm_walk free_walk = {\n\t\t.pmd_entry = madvise_free_pte_range,\n\t\t.mm = vma->vm_mm,\n\t\t.private = tlb,\n\t};\n\n\ttlb_start_vma(tlb, vma);\n\twalk_page_range(addr, end, &free_walk);\n\ttlb_end_vma(tlb, vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "start",
            "end"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_hiwater_rss",
          "args": [
            "mm"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_gather_mmu",
          "args": [
            "&tlb",
            "mm",
            "start",
            "end"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_gather_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "240-245",
          "snippet": "void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "vma->vm_end",
            "end_addr"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "vma->vm_start",
            "start_addr"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vma"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic int madvise_free_single_vma(struct vm_area_struct *vma,\n\t\t\tunsigned long start_addr, unsigned long end_addr)\n{\n\tunsigned long start, end;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\n\t/* MADV_FREE works for only anon vma at the moment */\n\tif (!vma_is_anonymous(vma))\n\t\treturn -EINVAL;\n\n\tstart = max(vma->vm_start, start_addr);\n\tif (start >= vma->vm_end)\n\t\treturn -EINVAL;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn -EINVAL;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\n\tmmu_notifier_invalidate_range_start(mm, start, end);\n\tmadvise_free_page_range(&tlb, vma, start, end);\n\tmmu_notifier_invalidate_range_end(mm, start, end);\n\ttlb_finish_mmu(&tlb, start, end);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "madvise_free_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "443-456",
    "snippet": "static void madvise_free_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end)\n{\n\tstruct mm_walk free_walk = {\n\t\t.pmd_entry = madvise_free_pte_range,\n\t\t.mm = vma->vm_mm,\n\t\t.private = tlb,\n\t};\n\n\ttlb_start_vma(tlb, vma);\n\twalk_page_range(addr, end, &free_walk);\n\ttlb_end_vma(tlb, vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_end_vma",
          "args": [
            "tlb",
            "vma"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "addr",
            "end",
            "&free_walk"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "293-340",
          "snippet": "int walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_start_vma",
          "args": [
            "tlb",
            "vma"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic void madvise_free_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end)\n{\n\tstruct mm_walk free_walk = {\n\t\t.pmd_entry = madvise_free_pte_range,\n\t\t.mm = vma->vm_mm,\n\t\t.private = tlb,\n\t};\n\n\ttlb_start_vma(tlb, vma);\n\twalk_page_range(addr, end, &free_walk);\n\ttlb_end_vma(tlb, vma);\n}"
  },
  {
    "function_name": "madvise_free_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "310-441",
    "snippet": "static int madvise_free_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n\n{\n\tstruct mmu_gather *tlb = walk->private;\n\tstruct mm_struct *mm = tlb->mm;\n\tstruct vm_area_struct *vma = walk->vma;\n\tspinlock_t *ptl;\n\tpte_t *orig_pte, *pte, ptent;\n\tstruct page *page;\n\tint nr_swap = 0;\n\tunsigned long next;\n\n\tnext = pmd_addr_end(addr, end);\n\tif (pmd_trans_huge(*pmd))\n\t\tif (madvise_free_huge_pmd(tlb, vma, pmd, addr, next))\n\t\t\tgoto next;\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\ttlb_remove_check_page_size_change(tlb, PAGE_SIZE);\n\torig_pte = pte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tflush_tlb_batched_pending(mm);\n\tarch_enter_lazy_mmu_mode();\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\n\t\tif (pte_none(ptent))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If the pte has swp_entry, just clear page table to\n\t\t * prevent swap-in which is more expensive rather than\n\t\t * (page allocation + zeroing).\n\t\t */\n\t\tif (!pte_present(ptent)) {\n\t\t\tswp_entry_t entry;\n\n\t\t\tentry = pte_to_swp_entry(ptent);\n\t\t\tif (non_swap_entry(entry))\n\t\t\t\tcontinue;\n\t\t\tnr_swap--;\n\t\t\tfree_swap_and_cache(entry);\n\t\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = _vm_normal_page(vma, addr, ptent, true);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If pmd isn't transhuge but the page is THP and\n\t\t * is owned by only this process, split it and\n\t\t * deactivate all pages.\n\t\t */\n\t\tif (PageTransCompound(page)) {\n\t\t\tif (page_mapcount(page) != 1)\n\t\t\t\tgoto out;\n\t\t\tget_page(page);\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tput_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpte_unmap_unlock(orig_pte, ptl);\n\t\t\tif (split_huge_page(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page);\n\t\t\t\tpte_offset_map_lock(mm, pmd, addr, &ptl);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tpte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\t\t\tpte--;\n\t\t\taddr -= PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\n\t\tif (PageSwapCache(page) || PageDirty(page)) {\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * If page is shared with others, we couldn't clear\n\t\t\t * PG_dirty of the page.\n\t\t\t */\n\t\t\tif (page_mapcount(page) != 1) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (PageSwapCache(page) && !try_to_free_swap(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClearPageDirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tif (pte_young(ptent) || pte_dirty(ptent)) {\n\t\t\t/*\n\t\t\t * Some of architecture(ex, PPC) don't update TLB\n\t\t\t * with set_pte_at and tlb_remove_tlb_entry so for\n\t\t\t * the portability, remap the pte with old|clean\n\t\t\t * after pte clearing.\n\t\t\t */\n\t\t\tptent = ptep_get_and_clear_full(mm, addr, pte,\n\t\t\t\t\t\t\ttlb->fullmm);\n\n\t\t\tptent = pte_mkold(ptent);\n\t\t\tptent = pte_mkclean(ptent);\n\t\t\tset_pte_at(mm, addr, pte, ptent);\n\t\t\ttlb_remove_tlb_entry(tlb, pte, addr);\n\t\t}\n\t\tmark_page_lazyfree(page);\n\t}\nout:\n\tif (nr_swap) {\n\t\tif (current->mm == mm)\n\t\t\tsync_mm_rss(mm);\n\n\t\tadd_mm_counter(mm, MM_SWAPENTS, nr_swap);\n\t}\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(orig_pte, ptl);\n\tcond_resched();\nnext:\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "orig_pte",
            "ptl"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_leave_lazy_mmu_mode",
          "args": [],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "mm",
            "MM_SWAPENTS",
            "nr_swap"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_counter_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "157-165",
          "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_mm_rss",
          "args": [
            "mm"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "sync_mm_rss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "144-155",
          "snippet": "void sync_mm_rss(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tif (current->rss_stat.count[i]) {\n\t\t\tadd_mm_counter(mm, i, current->rss_stat.count[i]);\n\t\t\tcurrent->rss_stat.count[i] = 0;\n\t\t}\n\t}\n\tcurrent->rss_stat.events = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid sync_mm_rss(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tif (current->rss_stat.count[i]) {\n\t\t\tadd_mm_counter(mm, i, current->rss_stat.count[i]);\n\t\t\tcurrent->rss_stat.count[i] = 0;\n\t\t}\n\t}\n\tcurrent->rss_stat.events = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_page_lazyfree",
          "args": [
            "page"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "mark_page_lazyfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "637-648",
          "snippet": "void mark_page_lazyfree(struct page *page)\n{\n\tif (PageLRU(page) && PageAnon(page) && PageSwapBacked(page) &&\n\t    !PageSwapCache(page) && !PageUnevictable(page)) {\n\t\tstruct pagevec *pvec = &get_cpu_var(lru_lazyfree_pvecs);\n\n\t\tget_page(page);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\t\tput_cpu_var(lru_lazyfree_pvecs);\n\t}\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\n\nvoid mark_page_lazyfree(struct page *page)\n{\n\tif (PageLRU(page) && PageAnon(page) && PageSwapBacked(page) &&\n\t    !PageSwapCache(page) && !PageUnevictable(page)) {\n\t\tstruct pagevec *pvec = &get_cpu_var(lru_lazyfree_pvecs);\n\n\t\tget_page(page);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\t\tput_cpu_var(lru_lazyfree_pvecs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_remove_tlb_entry",
          "args": [
            "tlb",
            "pte",
            "addr"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "addr",
            "pte",
            "ptent"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkclean",
          "args": [
            "ptent"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkold",
          "args": [
            "ptent"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_get_and_clear_full",
          "args": [
            "mm",
            "addr",
            "pte",
            "tlb->fullmm"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "ptent"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_young",
          "args": [
            "ptent"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageDirty",
          "args": [
            "page"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_free_swap",
          "args": [
            "page"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1584-1617",
          "snippet": "int try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTransCompound(page)",
            "page"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_page",
          "args": [
            "page"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "orig_pte",
            "ptl"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_vm_normal_page",
          "args": [
            "vma",
            "addr",
            "ptent",
            "true"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "_vm_normal_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "572-648",
          "snippet": "struct page *_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     pte_t pte, bool with_public_device)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_ops && vma->vm_ops->find_special_page)\n\t\t\treturn vma->vm_ops->find_special_page(vma, addr);\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (is_zero_pfn(pfn))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Device public pages are special pages (they are ZONE_DEVICE\n\t\t * pages but different from persistent memory). They behave\n\t\t * allmost like normal pages. The difference is that they are\n\t\t * not on the lru and thus should never be involve with any-\n\t\t * thing that involve lru manipulation (mlock, numa balancing,\n\t\t * ...).\n\t\t *\n\t\t * This is why we still want to return NULL for such page from\n\t\t * vm_normal_page() so that we do not have to special case all\n\t\t * call site of vm_normal_page().\n\t\t */\n\t\tif (likely(pfn <= highest_memmap_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t\tif (is_device_public_page(page)) {\n\t\t\t\tif (with_public_device)\n\t\t\t\t\treturn page;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (pte_devmap(pte))\n\t\t\treturn NULL;\n\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !CONFIG_ARCH_HAS_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     pte_t pte, bool with_public_device)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_ops && vma->vm_ops->find_special_page)\n\t\t\treturn vma->vm_ops->find_special_page(vma, addr);\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (is_zero_pfn(pfn))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Device public pages are special pages (they are ZONE_DEVICE\n\t\t * pages but different from persistent memory). They behave\n\t\t * allmost like normal pages. The difference is that they are\n\t\t * not on the lru and thus should never be involve with any-\n\t\t * thing that involve lru manipulation (mlock, numa balancing,\n\t\t * ...).\n\t\t *\n\t\t * This is why we still want to return NULL for such page from\n\t\t * vm_normal_page() so that we do not have to special case all\n\t\t * call site of vm_normal_page().\n\t\t */\n\t\tif (likely(pfn <= highest_memmap_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t\tif (is_device_public_page(page)) {\n\t\t\t\tif (with_public_device)\n\t\t\t\t\treturn page;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (pte_devmap(pte))\n\t\t\treturn NULL;\n\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !CONFIG_ARCH_HAS_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_clear_not_present_full",
          "args": [
            "mm",
            "addr",
            "pte",
            "tlb->fullmm"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_swap_and_cache",
          "args": [
            "entry"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_and_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1623-1640",
          "snippet": "int free_swap_and_cache(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned char count;\n\n\tif (non_swap_entry(entry))\n\t\treturn 1;\n\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\tcount = __swap_entry_free(p, entry, 1);\n\t\tif (count == SWAP_HAS_CACHE &&\n\t\t    !swap_page_trans_huge_swapped(p, entry))\n\t\t\t__try_to_reclaim_swap(p, swp_offset(entry),\n\t\t\t\t\t      TTRS_UNMAPPED | TTRS_FULL);\n\t}\n\treturn p != NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TTRS_FULL\t\t0x4",
            "#define TTRS_UNMAPPED\t\t0x2"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define TTRS_FULL\t\t0x4\n#define TTRS_UNMAPPED\t\t0x2\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint free_swap_and_cache(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned char count;\n\n\tif (non_swap_entry(entry))\n\t\treturn 1;\n\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\tcount = __swap_entry_free(p, entry, 1);\n\t\tif (count == SWAP_HAS_CACHE &&\n\t\t    !swap_page_trans_huge_swapped(p, entry))\n\t\t\t__try_to_reclaim_swap(p, swp_offset(entry),\n\t\t\t\t\t      TTRS_UNMAPPED | TTRS_FULL);\n\t}\n\treturn p != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "ptent"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "ptent"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "ptent"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_enter_lazy_mmu_mode",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_batched_pending",
          "args": [
            "mm"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tlb_batched_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "509-511",
          "snippet": "static inline void flush_tlb_batched_pending(struct mm_struct *mm)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void flush_tlb_batched_pending(struct mm_struct *mm)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_remove_check_page_size_change",
          "args": [
            "tlb",
            "PAGE_SIZE"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "madvise_free_huge_pmd",
          "args": [
            "tlb",
            "vma",
            "pmd",
            "addr",
            "next"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "madvise_free_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1639-1707",
          "snippet": "bool madvise_free_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tpmd_t *pmd, unsigned long addr, unsigned long next)\n{\n\tspinlock_t *ptl;\n\tpmd_t orig_pmd;\n\tstruct page *page;\n\tstruct mm_struct *mm = tlb->mm;\n\tbool ret = false;\n\n\ttlb_remove_check_page_size_change(tlb, HPAGE_PMD_SIZE);\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\tgoto out_unlocked;\n\n\torig_pmd = *pmd;\n\tif (is_huge_zero_pmd(orig_pmd))\n\t\tgoto out;\n\n\tif (unlikely(!pmd_present(orig_pmd))) {\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(orig_pmd));\n\t\tgoto out;\n\t}\n\n\tpage = pmd_page(orig_pmd);\n\t/*\n\t * If other processes are mapping this page, we couldn't discard\n\t * the page unless they all do MADV_FREE so let's skip the page.\n\t */\n\tif (page_mapcount(page) != 1)\n\t\tgoto out;\n\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\t/*\n\t * If user want to discard part-pages of THP, split it so MADV_FREE\n\t * will deactivate only them.\n\t */\n\tif (next - addr != HPAGE_PMD_SIZE) {\n\t\tget_page(page);\n\t\tspin_unlock(ptl);\n\t\tsplit_huge_page(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto out_unlocked;\n\t}\n\n\tif (PageDirty(page))\n\t\tClearPageDirty(page);\n\tunlock_page(page);\n\n\tif (pmd_young(orig_pmd) || pmd_dirty(orig_pmd)) {\n\t\tpmdp_invalidate(vma, addr, pmd);\n\t\torig_pmd = pmd_mkold(orig_pmd);\n\t\torig_pmd = pmd_mkclean(orig_pmd);\n\n\t\tset_pmd_at(mm, addr, pmd, orig_pmd);\n\t\ttlb_remove_pmd_tlb_entry(tlb, pmd, addr);\n\t}\n\n\tmark_page_lazyfree(page);\n\tret = true;\nout:\n\tspin_unlock(ptl);\nout_unlocked:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nbool madvise_free_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tpmd_t *pmd, unsigned long addr, unsigned long next)\n{\n\tspinlock_t *ptl;\n\tpmd_t orig_pmd;\n\tstruct page *page;\n\tstruct mm_struct *mm = tlb->mm;\n\tbool ret = false;\n\n\ttlb_remove_check_page_size_change(tlb, HPAGE_PMD_SIZE);\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\tgoto out_unlocked;\n\n\torig_pmd = *pmd;\n\tif (is_huge_zero_pmd(orig_pmd))\n\t\tgoto out;\n\n\tif (unlikely(!pmd_present(orig_pmd))) {\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(orig_pmd));\n\t\tgoto out;\n\t}\n\n\tpage = pmd_page(orig_pmd);\n\t/*\n\t * If other processes are mapping this page, we couldn't discard\n\t * the page unless they all do MADV_FREE so let's skip the page.\n\t */\n\tif (page_mapcount(page) != 1)\n\t\tgoto out;\n\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\t/*\n\t * If user want to discard part-pages of THP, split it so MADV_FREE\n\t * will deactivate only them.\n\t */\n\tif (next - addr != HPAGE_PMD_SIZE) {\n\t\tget_page(page);\n\t\tspin_unlock(ptl);\n\t\tsplit_huge_page(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto out_unlocked;\n\t}\n\n\tif (PageDirty(page))\n\t\tClearPageDirty(page);\n\tunlock_page(page);\n\n\tif (pmd_young(orig_pmd) || pmd_dirty(orig_pmd)) {\n\t\tpmdp_invalidate(vma, addr, pmd);\n\t\torig_pmd = pmd_mkold(orig_pmd);\n\t\torig_pmd = pmd_mkclean(orig_pmd);\n\n\t\tset_pmd_at(mm, addr, pmd, orig_pmd);\n\t\ttlb_remove_pmd_tlb_entry(tlb, pmd, addr);\n\t}\n\n\tmark_page_lazyfree(page);\n\tret = true;\nout:\n\tspin_unlock(ptl);\nout_unlocked:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic int madvise_free_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n\n{\n\tstruct mmu_gather *tlb = walk->private;\n\tstruct mm_struct *mm = tlb->mm;\n\tstruct vm_area_struct *vma = walk->vma;\n\tspinlock_t *ptl;\n\tpte_t *orig_pte, *pte, ptent;\n\tstruct page *page;\n\tint nr_swap = 0;\n\tunsigned long next;\n\n\tnext = pmd_addr_end(addr, end);\n\tif (pmd_trans_huge(*pmd))\n\t\tif (madvise_free_huge_pmd(tlb, vma, pmd, addr, next))\n\t\t\tgoto next;\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\ttlb_remove_check_page_size_change(tlb, PAGE_SIZE);\n\torig_pte = pte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tflush_tlb_batched_pending(mm);\n\tarch_enter_lazy_mmu_mode();\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\n\t\tif (pte_none(ptent))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If the pte has swp_entry, just clear page table to\n\t\t * prevent swap-in which is more expensive rather than\n\t\t * (page allocation + zeroing).\n\t\t */\n\t\tif (!pte_present(ptent)) {\n\t\t\tswp_entry_t entry;\n\n\t\t\tentry = pte_to_swp_entry(ptent);\n\t\t\tif (non_swap_entry(entry))\n\t\t\t\tcontinue;\n\t\t\tnr_swap--;\n\t\t\tfree_swap_and_cache(entry);\n\t\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = _vm_normal_page(vma, addr, ptent, true);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If pmd isn't transhuge but the page is THP and\n\t\t * is owned by only this process, split it and\n\t\t * deactivate all pages.\n\t\t */\n\t\tif (PageTransCompound(page)) {\n\t\t\tif (page_mapcount(page) != 1)\n\t\t\t\tgoto out;\n\t\t\tget_page(page);\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tput_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpte_unmap_unlock(orig_pte, ptl);\n\t\t\tif (split_huge_page(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page);\n\t\t\t\tpte_offset_map_lock(mm, pmd, addr, &ptl);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tpte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\t\t\tpte--;\n\t\t\taddr -= PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\n\t\tif (PageSwapCache(page) || PageDirty(page)) {\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * If page is shared with others, we couldn't clear\n\t\t\t * PG_dirty of the page.\n\t\t\t */\n\t\t\tif (page_mapcount(page) != 1) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (PageSwapCache(page) && !try_to_free_swap(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClearPageDirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tif (pte_young(ptent) || pte_dirty(ptent)) {\n\t\t\t/*\n\t\t\t * Some of architecture(ex, PPC) don't update TLB\n\t\t\t * with set_pte_at and tlb_remove_tlb_entry so for\n\t\t\t * the portability, remap the pte with old|clean\n\t\t\t * after pte clearing.\n\t\t\t */\n\t\t\tptent = ptep_get_and_clear_full(mm, addr, pte,\n\t\t\t\t\t\t\ttlb->fullmm);\n\n\t\t\tptent = pte_mkold(ptent);\n\t\t\tptent = pte_mkclean(ptent);\n\t\t\tset_pte_at(mm, addr, pte, ptent);\n\t\t\ttlb_remove_tlb_entry(tlb, pte, addr);\n\t\t}\n\t\tmark_page_lazyfree(page);\n\t}\nout:\n\tif (nr_swap) {\n\t\tif (current->mm == mm)\n\t\t\tsync_mm_rss(mm);\n\n\t\tadd_mm_counter(mm, MM_SWAPENTS, nr_swap);\n\t}\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(orig_pte, ptl);\n\tcond_resched();\nnext:\n\treturn 0;\n}"
  },
  {
    "function_name": "madvise_willneed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "273-308",
    "snippet": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n\n\t*prev = vma;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\n\tif (shmem_mapping(file->f_mapping)) {\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\n\tif (IS_DAX(file_inode(file))) {\n\t\t/* no bad return value, but ignore advice */\n\t\treturn 0;\n\t}\n\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_page_cache_readahead",
          "args": [
            "file->f_mapping",
            "file",
            "start",
            "end - start"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "force_page_cache_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "219-246",
          "snippet": "int force_page_cache_readahead(struct address_space *mapping, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long nr_to_read)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tunsigned long max_pages;\n\n\tif (unlikely(!mapping->a_ops->readpage && !mapping->a_ops->readpages))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tmax_pages = max_t(unsigned long, bdi->io_pages, ra->ra_pages);\n\tnr_to_read = min(nr_to_read, max_pages);\n\twhile (nr_to_read) {\n\t\tunsigned long this_chunk = (2 * 1024 * 1024) / PAGE_SIZE;\n\n\t\tif (this_chunk > nr_to_read)\n\t\t\tthis_chunk = nr_to_read;\n\t\t__do_page_cache_readahead(mapping, filp, offset, this_chunk, 0);\n\n\t\toffset += this_chunk;\n\t\tnr_to_read -= this_chunk;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nint force_page_cache_readahead(struct address_space *mapping, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long nr_to_read)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tunsigned long max_pages;\n\n\tif (unlikely(!mapping->a_ops->readpage && !mapping->a_ops->readpages))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tmax_pages = max_t(unsigned long, bdi->io_pages, ra->ra_pages);\n\tnr_to_read = min(nr_to_read, max_pages);\n\twhile (nr_to_read) {\n\t\tunsigned long this_chunk = (2 * 1024 * 1024) / PAGE_SIZE;\n\n\t\tif (this_chunk > nr_to_read)\n\t\t\tthis_chunk = nr_to_read;\n\t\t__do_page_cache_readahead(mapping, filp, offset, this_chunk, 0);\n\n\t\toffset += this_chunk;\n\t\tnr_to_read -= this_chunk;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "file_inode(file)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_shm_swapin_readahead",
          "args": [
            "vma",
            "start",
            "end",
            "file->f_mapping"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "force_shm_swapin_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
          "lines": "242-267",
          "snippet": "static void force_shm_swapin_readahead(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end,\n\t\tstruct address_space *mapping)\n{\n\tpgoff_t index;\n\tstruct page *page;\n\tswp_entry_t swap;\n\n\tfor (; start < end; start += PAGE_SIZE) {\n\t\tindex = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\t\tpage = find_get_entry(mapping, index);\n\t\tif (!xa_is_value(page)) {\n\t\t\tif (page)\n\t\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\t\tswap = radix_to_swp_entry(page);\n\t\tpage = read_swap_cache_async(swap, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\t\tNULL, 0, false);\n\t\tif (page)\n\t\t\tput_page(page);\n\t}\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched.h>",
            "#include <linux/falloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic void force_shm_swapin_readahead(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end,\n\t\tstruct address_space *mapping)\n{\n\tpgoff_t index;\n\tstruct page *page;\n\tswp_entry_t swap;\n\n\tfor (; start < end; start += PAGE_SIZE) {\n\t\tindex = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\t\tpage = find_get_entry(mapping, index);\n\t\tif (!xa_is_value(page)) {\n\t\t\tif (page)\n\t\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\t\tswap = radix_to_swp_entry(page);\n\t\tpage = read_swap_cache_async(swap, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\t\tNULL, 0, false);\n\t\tif (page)\n\t\t\tput_page(page);\n\t}\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\n}"
        }
      },
      {
        "call_info": {
          "callee": "shmem_mapping",
          "args": [
            "file->f_mapping"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "2195-2198",
          "snippet": "bool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nbool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_swapin_readahead",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "force_swapin_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
          "lines": "228-240",
          "snippet": "static void force_swapin_readahead(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct mm_walk walk = {\n\t\t.mm = vma->vm_mm,\n\t\t.pmd_entry = swapin_walk_pmd_entry,\n\t\t.private = vma,\n\t};\n\n\twalk_page_range(start, end, &walk);\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched.h>",
            "#include <linux/falloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic void force_swapin_readahead(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct mm_walk walk = {\n\t\t.mm = vma->vm_mm,\n\t\t.pmd_entry = swapin_walk_pmd_entry,\n\t\t.private = vma,\n\t};\n\n\twalk_page_range(start, end, &walk);\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n\n\t*prev = vma;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\n\tif (shmem_mapping(file->f_mapping)) {\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\n\tif (IS_DAX(file_inode(file))) {\n\t\t/* no bad return value, but ignore advice */\n\t\treturn 0;\n\t}\n\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}"
  },
  {
    "function_name": "force_shm_swapin_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "242-267",
    "snippet": "static void force_shm_swapin_readahead(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end,\n\t\tstruct address_space *mapping)\n{\n\tpgoff_t index;\n\tstruct page *page;\n\tswp_entry_t swap;\n\n\tfor (; start < end; start += PAGE_SIZE) {\n\t\tindex = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\t\tpage = find_get_entry(mapping, index);\n\t\tif (!xa_is_value(page)) {\n\t\t\tif (page)\n\t\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\t\tswap = radix_to_swp_entry(page);\n\t\tpage = read_swap_cache_async(swap, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\t\tNULL, 0, false);\n\t\tif (page)\n\t\t\tput_page(page);\n\t}\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_swap_cache_async",
          "args": [
            "swap",
            "GFP_HIGHUSER_MOVABLE",
            "NULL",
            "0",
            "false"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "read_swap_cache_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "437-448",
          "snippet": "struct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_to_swp_entry",
          "args": [
            "page"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_entry",
          "args": [
            "mapping",
            "index"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1407-1448",
          "snippet": "struct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic void force_shm_swapin_readahead(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end,\n\t\tstruct address_space *mapping)\n{\n\tpgoff_t index;\n\tstruct page *page;\n\tswp_entry_t swap;\n\n\tfor (; start < end; start += PAGE_SIZE) {\n\t\tindex = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\t\tpage = find_get_entry(mapping, index);\n\t\tif (!xa_is_value(page)) {\n\t\t\tif (page)\n\t\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\t\tswap = radix_to_swp_entry(page);\n\t\tpage = read_swap_cache_async(swap, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\t\tNULL, 0, false);\n\t\tif (page)\n\t\t\tput_page(page);\n\t}\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\n}"
  },
  {
    "function_name": "force_swapin_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "228-240",
    "snippet": "static void force_swapin_readahead(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct mm_walk walk = {\n\t\t.mm = vma->vm_mm,\n\t\t.pmd_entry = swapin_walk_pmd_entry,\n\t\t.private = vma,\n\t};\n\n\twalk_page_range(start, end, &walk);\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "start",
            "end",
            "&walk"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "293-340",
          "snippet": "int walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic void force_swapin_readahead(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct mm_walk walk = {\n\t\t.mm = vma->vm_mm,\n\t\t.pmd_entry = swapin_walk_pmd_entry,\n\t\t.private = vma,\n\t};\n\n\twalk_page_range(start, end, &walk);\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\n}"
  },
  {
    "function_name": "swapin_walk_pmd_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "193-226",
    "snippet": "static int swapin_walk_pmd_entry(pmd_t *pmd, unsigned long start,\n\tunsigned long end, struct mm_walk *walk)\n{\n\tpte_t *orig_pte;\n\tstruct vm_area_struct *vma = walk->private;\n\tunsigned long index;\n\n\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\treturn 0;\n\n\tfor (index = start; index != end; index += PAGE_SIZE) {\n\t\tpte_t pte;\n\t\tswp_entry_t entry;\n\t\tstruct page *page;\n\t\tspinlock_t *ptl;\n\n\t\torig_pte = pte_offset_map_lock(vma->vm_mm, pmd, start, &ptl);\n\t\tpte = *(orig_pte + ((index - start) / PAGE_SIZE));\n\t\tpte_unmap_unlock(orig_pte, ptl);\n\n\t\tif (pte_present(pte) || pte_none(pte))\n\t\t\tcontinue;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (unlikely(non_swap_entry(entry)))\n\t\t\tcontinue;\n\n\t\tpage = read_swap_cache_async(entry, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\t\tvma, index, false);\n\t\tif (page)\n\t\t\tput_page(page);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_swap_cache_async",
          "args": [
            "entry",
            "GFP_HIGHUSER_MOVABLE",
            "vma",
            "index",
            "false"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "read_swap_cache_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "437-448",
          "snippet": "struct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "non_swap_entry(entry)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pte"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pte"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "orig_pte",
            "ptl"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "pmd",
            "start",
            "&ptl"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none_or_trans_huge_or_clear_bad",
          "args": [
            "pmd"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic int swapin_walk_pmd_entry(pmd_t *pmd, unsigned long start,\n\tunsigned long end, struct mm_walk *walk)\n{\n\tpte_t *orig_pte;\n\tstruct vm_area_struct *vma = walk->private;\n\tunsigned long index;\n\n\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\treturn 0;\n\n\tfor (index = start; index != end; index += PAGE_SIZE) {\n\t\tpte_t pte;\n\t\tswp_entry_t entry;\n\t\tstruct page *page;\n\t\tspinlock_t *ptl;\n\n\t\torig_pte = pte_offset_map_lock(vma->vm_mm, pmd, start, &ptl);\n\t\tpte = *(orig_pte + ((index - start) / PAGE_SIZE));\n\t\tpte_unmap_unlock(orig_pte, ptl);\n\n\t\tif (pte_present(pte) || pte_none(pte))\n\t\t\tcontinue;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (unlikely(non_swap_entry(entry)))\n\t\t\tcontinue;\n\n\t\tpage = read_swap_cache_async(entry, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\t\tvma, index, false);\n\t\tif (page)\n\t\t\tput_page(page);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "madvise_behavior",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "55-190",
    "snippet": "static long madvise_behavior(struct vm_area_struct *vma,\n\t\t     struct vm_area_struct **prev,\n\t\t     unsigned long start, unsigned long end, int behavior)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint error = 0;\n\tpgoff_t pgoff;\n\tunsigned long new_flags = vma->vm_flags;\n\n\tswitch (behavior) {\n\tcase MADV_NORMAL:\n\t\tnew_flags = new_flags & ~VM_RAND_READ & ~VM_SEQ_READ;\n\t\tbreak;\n\tcase MADV_SEQUENTIAL:\n\t\tnew_flags = (new_flags & ~VM_RAND_READ) | VM_SEQ_READ;\n\t\tbreak;\n\tcase MADV_RANDOM:\n\t\tnew_flags = (new_flags & ~VM_SEQ_READ) | VM_RAND_READ;\n\t\tbreak;\n\tcase MADV_DONTFORK:\n\t\tnew_flags |= VM_DONTCOPY;\n\t\tbreak;\n\tcase MADV_DOFORK:\n\t\tif (vma->vm_flags & VM_IO) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags &= ~VM_DONTCOPY;\n\t\tbreak;\n\tcase MADV_WIPEONFORK:\n\t\t/* MADV_WIPEONFORK is only supported on anonymous memory. */\n\t\tif (vma->vm_file || vma->vm_flags & VM_SHARED) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags |= VM_WIPEONFORK;\n\t\tbreak;\n\tcase MADV_KEEPONFORK:\n\t\tnew_flags &= ~VM_WIPEONFORK;\n\t\tbreak;\n\tcase MADV_DONTDUMP:\n\t\tnew_flags |= VM_DONTDUMP;\n\t\tbreak;\n\tcase MADV_DODUMP:\n\t\tif (!is_vm_hugetlb_page(vma) && new_flags & VM_SPECIAL) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags &= ~VM_DONTDUMP;\n\t\tbreak;\n\tcase MADV_MERGEABLE:\n\tcase MADV_UNMERGEABLE:\n\t\terror = ksm_madvise(vma, start, end, behavior, &new_flags);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MADV_HUGEPAGE:\n\tcase MADV_NOHUGEPAGE:\n\t\terror = hugepage_madvise(vma, &new_flags, behavior);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (new_flags == vma->vm_flags) {\n\t\t*prev = vma;\n\t\tgoto out;\n\t}\n\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*prev = vma_merge(mm, *prev, start, end, new_flags, vma->anon_vma,\n\t\t\t  vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t  vma->vm_userfaultfd_ctx);\n\tif (*prev) {\n\t\tvma = *prev;\n\t\tgoto success;\n\t}\n\n\t*prev = vma;\n\n\tif (start != vma->vm_start) {\n\t\tif (unlikely(mm->map_count >= sysctl_max_map_count)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = __split_vma(mm, vma, start, 1);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (end != vma->vm_end) {\n\t\tif (unlikely(mm->map_count >= sysctl_max_map_count)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = __split_vma(mm, vma, end, 0);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nsuccess:\n\t/*\n\t * vm_flags is protected by the mmap_sem held in write mode.\n\t */\n\tvma->vm_flags = new_flags;\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__split_vma",
          "args": [
            "mm",
            "vma",
            "end",
            "0"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "__split_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2636-2694",
          "snippet": "int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\n\tif (vma->vm_ops && vma->vm_ops->split) {\n\t\terr = vma->vm_ops->split(vma, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew = vm_area_dup(vma);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\n\t/* Success. */\n\tif (!err)\n\t\treturn 0;\n\n\t/* Clean everything up if vma_adjust failed. */\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tvm_area_free(new);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\n\tif (vma->vm_ops && vma->vm_ops->split) {\n\t\terr = vma->vm_ops->split(vma, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew = vm_area_dup(vma);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\n\t/* Success. */\n\tif (!err)\n\t\treturn 0;\n\n\t/* Clean everything up if vma_adjust failed. */\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tvm_area_free(new);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mm->map_count >= sysctl_max_map_count"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mm->map_count >= sysctl_max_map_count"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_merge",
          "args": [
            "mm",
            "*prev",
            "start",
            "end",
            "new_flags",
            "vma->anon_vma",
            "vma->vm_file",
            "pgoff",
            "vma_policy(vma)",
            "vma->vm_userfaultfd_ctx"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1132-1223",
          "snippet": "struct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstruct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "vma"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "vma_policy_mof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1676-1696",
          "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugepage_madvise",
          "args": [
            "vma",
            "&new_flags",
            "behavior"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_madvise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "306-343",
          "snippet": "int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n#ifdef CONFIG_S390\n\t\t/*\n\t\t * qemu blindly sets MADV_HUGEPAGE on all allocations, but s390\n\t\t * can't handle this properly after s390_enable_sie, so we simply\n\t\t * ignore the madvise to prevent qemu from causing a SIGSEGV.\n\t\t */\n\t\tif (mm_has_pgste(vma->vm_mm))\n\t\t\treturn 0;\n#endif\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\t/*\n\t\t * If the vma become good for khugepaged to scan,\n\t\t * register it here without waiting a page fault that\n\t\t * may not happen any time soon.\n\t\t */\n\t\tif (!(*vm_flags & VM_NO_KHUGEPAGED) &&\n\t\t\t\tkhugepaged_enter_vma_merge(vma, *vm_flags))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\t/*\n\t\t * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning\n\t\t * this vma even if we leave the mm registered in khugepaged if\n\t\t * it got registered before VM_NOHUGEPAGE was set.\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\n#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)\n\nint hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n#ifdef CONFIG_S390\n\t\t/*\n\t\t * qemu blindly sets MADV_HUGEPAGE on all allocations, but s390\n\t\t * can't handle this properly after s390_enable_sie, so we simply\n\t\t * ignore the madvise to prevent qemu from causing a SIGSEGV.\n\t\t */\n\t\tif (mm_has_pgste(vma->vm_mm))\n\t\t\treturn 0;\n#endif\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\t/*\n\t\t * If the vma become good for khugepaged to scan,\n\t\t * register it here without waiting a page fault that\n\t\t * may not happen any time soon.\n\t\t */\n\t\tif (!(*vm_flags & VM_NO_KHUGEPAGED) &&\n\t\t\t\tkhugepaged_enter_vma_merge(vma, *vm_flags))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\t/*\n\t\t * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning\n\t\t * this vma even if we leave the mm registered in khugepaged if\n\t\t * it got registered before VM_NOHUGEPAGE was set.\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksm_madvise",
          "args": [
            "vma",
            "start",
            "end",
            "behavior",
            "&new_flags"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_madvise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2417-2469",
          "snippet": "int ksm_madvise(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long end, int advice, unsigned long *vm_flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\n\tswitch (advice) {\n\tcase MADV_MERGEABLE:\n\t\t/*\n\t\t * Be somewhat over-protective for now!\n\t\t */\n\t\tif (*vm_flags & (VM_MERGEABLE | VM_SHARED  | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP    | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_HUGETLB | VM_MIXEDMAP))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma_is_dax(vma))\n\t\t\treturn 0;\n\n#ifdef VM_SAO\n\t\tif (*vm_flags & VM_SAO)\n\t\t\treturn 0;\n#endif\n#ifdef VM_SPARC_ADI\n\t\tif (*vm_flags & VM_SPARC_ADI)\n\t\t\treturn 0;\n#endif\n\n\t\tif (!test_bit(MMF_VM_MERGEABLE, &mm->flags)) {\n\t\t\terr = __ksm_enter(mm);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags |= VM_MERGEABLE;\n\t\tbreak;\n\n\tcase MADV_UNMERGEABLE:\n\t\tif (!(*vm_flags & VM_MERGEABLE))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma->anon_vma) {\n\t\t\terr = unmerge_ksm_pages(vma, start, end);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags &= ~VM_MERGEABLE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nint ksm_madvise(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long end, int advice, unsigned long *vm_flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\n\tswitch (advice) {\n\tcase MADV_MERGEABLE:\n\t\t/*\n\t\t * Be somewhat over-protective for now!\n\t\t */\n\t\tif (*vm_flags & (VM_MERGEABLE | VM_SHARED  | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP    | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_HUGETLB | VM_MIXEDMAP))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma_is_dax(vma))\n\t\t\treturn 0;\n\n#ifdef VM_SAO\n\t\tif (*vm_flags & VM_SAO)\n\t\t\treturn 0;\n#endif\n#ifdef VM_SPARC_ADI\n\t\tif (*vm_flags & VM_SPARC_ADI)\n\t\t\treturn 0;\n#endif\n\n\t\tif (!test_bit(MMF_VM_MERGEABLE, &mm->flags)) {\n\t\t\terr = __ksm_enter(mm);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags |= VM_MERGEABLE;\n\t\tbreak;\n\n\tcase MADV_UNMERGEABLE:\n\t\tif (!(*vm_flags & VM_MERGEABLE))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma->anon_vma) {\n\t\t\terr = unmerge_ksm_pages(vma, start, end);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags &= ~VM_MERGEABLE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic long madvise_behavior(struct vm_area_struct *vma,\n\t\t     struct vm_area_struct **prev,\n\t\t     unsigned long start, unsigned long end, int behavior)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint error = 0;\n\tpgoff_t pgoff;\n\tunsigned long new_flags = vma->vm_flags;\n\n\tswitch (behavior) {\n\tcase MADV_NORMAL:\n\t\tnew_flags = new_flags & ~VM_RAND_READ & ~VM_SEQ_READ;\n\t\tbreak;\n\tcase MADV_SEQUENTIAL:\n\t\tnew_flags = (new_flags & ~VM_RAND_READ) | VM_SEQ_READ;\n\t\tbreak;\n\tcase MADV_RANDOM:\n\t\tnew_flags = (new_flags & ~VM_SEQ_READ) | VM_RAND_READ;\n\t\tbreak;\n\tcase MADV_DONTFORK:\n\t\tnew_flags |= VM_DONTCOPY;\n\t\tbreak;\n\tcase MADV_DOFORK:\n\t\tif (vma->vm_flags & VM_IO) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags &= ~VM_DONTCOPY;\n\t\tbreak;\n\tcase MADV_WIPEONFORK:\n\t\t/* MADV_WIPEONFORK is only supported on anonymous memory. */\n\t\tif (vma->vm_file || vma->vm_flags & VM_SHARED) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags |= VM_WIPEONFORK;\n\t\tbreak;\n\tcase MADV_KEEPONFORK:\n\t\tnew_flags &= ~VM_WIPEONFORK;\n\t\tbreak;\n\tcase MADV_DONTDUMP:\n\t\tnew_flags |= VM_DONTDUMP;\n\t\tbreak;\n\tcase MADV_DODUMP:\n\t\tif (!is_vm_hugetlb_page(vma) && new_flags & VM_SPECIAL) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_flags &= ~VM_DONTDUMP;\n\t\tbreak;\n\tcase MADV_MERGEABLE:\n\tcase MADV_UNMERGEABLE:\n\t\terror = ksm_madvise(vma, start, end, behavior, &new_flags);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MADV_HUGEPAGE:\n\tcase MADV_NOHUGEPAGE:\n\t\terror = hugepage_madvise(vma, &new_flags, behavior);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (new_flags == vma->vm_flags) {\n\t\t*prev = vma;\n\t\tgoto out;\n\t}\n\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*prev = vma_merge(mm, *prev, start, end, new_flags, vma->anon_vma,\n\t\t\t  vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t  vma->vm_userfaultfd_ctx);\n\tif (*prev) {\n\t\tvma = *prev;\n\t\tgoto success;\n\t}\n\n\t*prev = vma;\n\n\tif (start != vma->vm_start) {\n\t\tif (unlikely(mm->map_count >= sysctl_max_map_count)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = __split_vma(mm, vma, start, 1);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (end != vma->vm_end) {\n\t\tif (unlikely(mm->map_count >= sysctl_max_map_count)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = __split_vma(mm, vma, end, 0);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * madvise() returns EAGAIN if kernel resources, such as\n\t\t\t * slab, are temporarily unavailable.\n\t\t\t */\n\t\t\tif (error == -ENOMEM)\n\t\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nsuccess:\n\t/*\n\t * vm_flags is protected by the mmap_sem held in write mode.\n\t */\n\tvma->vm_flags = new_flags;\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "madvise_need_mmap_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "37-49",
    "snippet": "static int madvise_need_mmap_write(int behavior)\n{\n\tswitch (behavior) {\n\tcase MADV_REMOVE:\n\tcase MADV_WILLNEED:\n\tcase MADV_DONTNEED:\n\tcase MADV_FREE:\n\t\treturn 0;\n\tdefault:\n\t\t/* be safe, default to 1. list exceptions explicitly */\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic int madvise_need_mmap_write(int behavior)\n{\n\tswitch (behavior) {\n\tcase MADV_REMOVE:\n\tcase MADV_WILLNEED:\n\tcase MADV_DONTNEED:\n\tcase MADV_FREE:\n\t\treturn 0;\n\tdefault:\n\t\t/* be safe, default to 1. list exceptions explicitly */\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "madvise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
    "lines": "801-895",
    "snippet": "SYSCALL_DEFINE3(madvise, unsigned long, start, size_t, len_in, int, behavior)\n{\n\tunsigned long end, tmp;\n\tstruct vm_area_struct *vma, *prev;\n\tint unmapped_error = 0;\n\tint error = -EINVAL;\n\tint write;\n\tsize_t len;\n\tstruct blk_plug plug;\n\n\tif (!madvise_behavior_valid(behavior))\n\t\treturn error;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn error;\n\tlen = (len_in + ~PAGE_MASK) & PAGE_MASK;\n\n\t/* Check to see whether len was rounded up from small -ve to zero */\n\tif (len_in && !len)\n\t\treturn error;\n\n\tend = start + len;\n\tif (end < start)\n\t\treturn error;\n\n\terror = 0;\n\tif (end == start)\n\t\treturn error;\n\n#ifdef CONFIG_MEMORY_FAILURE\n\tif (behavior == MADV_HWPOISON || behavior == MADV_SOFT_OFFLINE)\n\t\treturn madvise_inject_error(behavior, start, start + len_in);\n#endif\n\n\twrite = madvise_need_mmap_write(behavior);\n\tif (write) {\n\t\tif (down_write_killable(&current->mm->mmap_sem))\n\t\t\treturn -EINTR;\n\t} else {\n\t\tdown_read(&current->mm->mmap_sem);\n\t}\n\n\t/*\n\t * If the interval [start,end) covers some unmapped address\n\t * ranges, just ignore them, but return -ENOMEM at the end.\n\t * - different from the way of handling in mlock etc.\n\t */\n\tvma = find_vma_prev(current->mm, start, &prev);\n\tif (vma && start > vma->vm_start)\n\t\tprev = vma;\n\n\tblk_start_plug(&plug);\n\tfor (;;) {\n\t\t/* Still start < end. */\n\t\terror = -ENOMEM;\n\t\tif (!vma)\n\t\t\tgoto out;\n\n\t\t/* Here start < (end|vma->vm_end). */\n\t\tif (start < vma->vm_start) {\n\t\t\tunmapped_error = -ENOMEM;\n\t\t\tstart = vma->vm_start;\n\t\t\tif (start >= end)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* Here vma->vm_start <= start < (end|vma->vm_end) */\n\t\ttmp = vma->vm_end;\n\t\tif (end < tmp)\n\t\t\ttmp = end;\n\n\t\t/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */\n\t\terror = madvise_vma(vma, &prev, start, tmp, behavior);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tstart = tmp;\n\t\tif (prev && start < prev->vm_end)\n\t\t\tstart = prev->vm_end;\n\t\terror = unmapped_error;\n\t\tif (start >= end)\n\t\t\tgoto out;\n\t\tif (prev)\n\t\t\tvma = prev->vm_next;\n\t\telse\t/* madvise_remove dropped mmap_sem */\n\t\t\tvma = find_vma(current->mm, start);\n\t}\nout:\n\tblk_finish_plug(&plug);\n\tif (write)\n\t\tup_write(&current->mm->mmap_sem);\n\telse\n\t\tup_read(&current->mm->mmap_sem);\n\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched.h>",
      "#include <linux/falloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nSYSCALL_DEFINE3(madvise, unsigned long, start, size_t, len_in, int, behavior)\n{\n\tunsigned long end, tmp;\n\tstruct vm_area_struct *vma, *prev;\n\tint unmapped_error = 0;\n\tint error = -EINVAL;\n\tint write;\n\tsize_t len;\n\tstruct blk_plug plug;\n\n\tif (!madvise_behavior_valid(behavior))\n\t\treturn error;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn error;\n\tlen = (len_in + ~PAGE_MASK) & PAGE_MASK;\n\n\t/* Check to see whether len was rounded up from small -ve to zero */\n\tif (len_in && !len)\n\t\treturn error;\n\n\tend = start + len;\n\tif (end < start)\n\t\treturn error;\n\n\terror = 0;\n\tif (end == start)\n\t\treturn error;\n\n#ifdef CONFIG_MEMORY_FAILURE\n\tif (behavior == MADV_HWPOISON || behavior == MADV_SOFT_OFFLINE)\n\t\treturn madvise_inject_error(behavior, start, start + len_in);\n#endif\n\n\twrite = madvise_need_mmap_write(behavior);\n\tif (write) {\n\t\tif (down_write_killable(&current->mm->mmap_sem))\n\t\t\treturn -EINTR;\n\t} else {\n\t\tdown_read(&current->mm->mmap_sem);\n\t}\n\n\t/*\n\t * If the interval [start,end) covers some unmapped address\n\t * ranges, just ignore them, but return -ENOMEM at the end.\n\t * - different from the way of handling in mlock etc.\n\t */\n\tvma = find_vma_prev(current->mm, start, &prev);\n\tif (vma && start > vma->vm_start)\n\t\tprev = vma;\n\n\tblk_start_plug(&plug);\n\tfor (;;) {\n\t\t/* Still start < end. */\n\t\terror = -ENOMEM;\n\t\tif (!vma)\n\t\t\tgoto out;\n\n\t\t/* Here start < (end|vma->vm_end). */\n\t\tif (start < vma->vm_start) {\n\t\t\tunmapped_error = -ENOMEM;\n\t\t\tstart = vma->vm_start;\n\t\t\tif (start >= end)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* Here vma->vm_start <= start < (end|vma->vm_end) */\n\t\ttmp = vma->vm_end;\n\t\tif (end < tmp)\n\t\t\ttmp = end;\n\n\t\t/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */\n\t\terror = madvise_vma(vma, &prev, start, tmp, behavior);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tstart = tmp;\n\t\tif (prev && start < prev->vm_end)\n\t\t\tstart = prev->vm_end;\n\t\terror = unmapped_error;\n\t\tif (start >= end)\n\t\t\tgoto out;\n\t\tif (prev)\n\t\t\tvma = prev->vm_next;\n\t\telse\t/* madvise_remove dropped mmap_sem */\n\t\t\tvma = find_vma(current->mm, start);\n\t}\nout:\n\tblk_finish_plug(&plug);\n\tif (write)\n\t\tup_write(&current->mm->mmap_sem);\n\telse\n\t\tup_read(&current->mm->mmap_sem);\n\n\treturn error;\n}"
  }
]